>   Упакованные блоки имеют заголовок:
>
>+0 "HR".
>+2 распакованная длина.
>+4 упакованная длина.
>+6 шесть последних байт блока.
>+12 два байта начала битового потока.
>+13 первый байт блока.
>+14 сами упакованные данные.

1. пакуется весь файл без последних 6 байт, которые вон вверху
2. сначала при распаковке выбирается 16 бит битпотока, потом байт,
который безусловно копируется в выход, потом начинается обычная
работа (выборка битов и байтов по мере необходимости)


обозначение вроде %abcd<byte1>xyz<byte2>
означает, что сначала из битпотока выбираются биты abcd (при необходимости
новые 2 байта засасываются), потом из байт-потока byte1, потом снова биты xyz,
потом byte2

>%1 - получить  байт  из байтового потока и
>поместить куда распаковываем.

%1<byte> - копировать byte в выход


Ссылки отсчитываются от текущего байта: который только предстоит заполнить чем-либо, на
который указывает указатель.

запись вида [abc] - обозначает беззнаковое число, составленное из битов a,b и c,
выровненных вправо.

запись вида ( A | B | C ) - выбор одного из вариантов A, B или C, условия указаны в тексте

смещение задаётся 2-байтовым числом, которое прибавляется к адресу текущего байта:
например смещение FFFF обозначает смещение на 1 байт взад (на последний уже записанный в выход
байт)


>%000,-disp3 - копировать 1 байт со смеще-
>ния -1..8

%000abc, длина 1 байт, смещение FFF8+[abc]

>%001 - копировать C=2 байта. disp кодируе-
> тся так:
> %00-%01: -dispH=#fd-#fe, dispL в битовом
>  потоке;
> %10: -dispH=#ff, далее исходя из байтово-
>  го  потока: числа  <#e0  понимаются  как
>  -dispL  (ссылка  обычная),  >=#e0 хитро:
>  RLCA:XOR C, при  A=-1  расширяется длина
>  ссылки, иначе  SUB 15 и получаем -dispL=
> =#b2-#ee (ссылка со вставным байтом:байт
>  из $-disp, байт из байтового потока,байт
>  из $+2-disp );
> %11,-disp5:обычная ссылка (через %10 та-
>  кие короткие disp описать нельзя);

%00100<dispL>: длина 2 байта, смещение FD00+dispL
%00101<dispL>: длина 2 байта, смещение FE00+dispL

%00110<byte> длина 2 байта
если byte<#e0 то смещение FF00+byte

есди byte>=#e0, то A=byte:RLCA:XOR C - чему равно C?

если после этого A==FF, то расширяется длина ссылки:
что именно делается с D? в выход ничего не идёт?

если A!=FF, то A=A-15, смещение FF00+A (A=#b2..#ee)

в каком случае вставной байт? только если byte>=#e0 и A!=FF ?
первый байт по смещению, другой из байтовго потока ещё один? в каком
порядке?

%00111abcde - длина 2 байта, смещение FFE0 + [abcde]


>%010 - копировать C=3 байта. Здесь и далее
> disp кодируется так:
> %00: -dispH=#fe, -dispL в битовом потоке;
> %01: -dispH=#ff, далее исходя из байтово-
>  го  потока: числа  <#e0 понимаются  как
>  -dispL  (ссылка  обычная), >=#e0  хитро:
>  RLCA:XOR C, при  A=-1  расширяется длина
>  ссылки  (на самом деле не используется),
>  иначе  SUB 15  и получаем -dispL=#b1-#ef
>  (со вставным байтом:байт из $-disp, байт
>  из байтового потока, байт из $+2-disp );
> %10,-disp5;
> %11:расширяющаяся ссылка. -dispH берётся
>  из битового потока, число битов согласно
>  D  (#bf..#fe соответствует  2..8  бит).
>  -dispL  берётся  из  байтового потока. В
>  остальном ссылка как ссылка.

%01000<dispL>: длина 3 байта, смещение FE00+dispL

%01001: вопросы, аналогичные ссылке %00110, вдобавок:
 - почему тут стало dispL b1-ef, а было b2-ee ?
 - изменился ли С
 - вставной байт тут при длине ссылки 3 байта, а раньше - при длине 2 байта?

%01010abcde - длина 3 байта, смещение FFE0+[abcde]

%01011ab<byte> -- %01011abcdefgh<byte>
длина 3 байта
количество выбираемых бит ab -- abcdefgh зависит от содержимого D:
D=#BF - 2 бита (ab)
D=#DF - 3 бита (abc)
D=#EF - 4 бита
...
D=#FE - 8 бит (abcdefgh)

смещение ( FC+[ab] | F8+[abc] | F0+[abcd] | ... | [abcdefgh] )*256 + byte,
в зависимости от кол-ва выбранных битов, зависящего от содержимого D



>%01100 - копировать  C=4  байта  как выше.
> Здесь и далее коды ссылок со вставным ба-
> йтом невыгодны, но есть.
>%01110 - копировать 5.
>%0111100 - копировать 6.
>%0111101 - копировать 7.
>%0111110 - копировать 8.
>%011111100 - копировать 9.
>%011111101 - копировать 10.
>%011111110 - копировать 11.
>%01111111100 - копировать 12
>%01111111101 - копировать 13.
>%01111111110 - копировать 14.
>%01111111111 - копировать 15.

вообще аут.
если так:
префикс %011
длина кодируется
%00, %01, %1100, %1101, %1110, %111100 и тд до %11111111,
то как кодируется дальше смещение? Как ведёт себя вставная ссылка?



> %01101000001111 - конец файла.

%01101000001111 - остановка распаковки

>%0110100,len7 - если len7>15, то len будет
> равно  len7*256+байт_из_байтового_потока.
> В  любом  случае  результат ляжет в BC, а
> далее см. случаи с len=3..15.

%0110100abcdefg<byte> - если [abcdefg]>15, то длина ссылки [abcdefg]*256 + <byte>
смещение видимо опять кодируется как в случае %010xxxxxx ?
Когда выбираются биты смещения - после выборки byte или до?
как дела с вставной ссылкой, как она себя ведёт

>%0110101xxxx - 12-42 (чётное число) байтов
> из байтового потока.

%0110101abcd - копировать из байтового потока [abcd]*2 + 12 байт в выход

>%011011,-disp4: ссылка со вставным байтом:
> байт из $-disp, байт из байтового потока,
> байт из $+2-disp. Сделано из-за того, что
> в %001предусмотрены  только -dispL=#b2..
> #ee, причем чётные, а в %010 только #b1..
> #ef, нечётные.

%011011abcd<byte> ? или как? откуда какие смещения и длины берутся?

