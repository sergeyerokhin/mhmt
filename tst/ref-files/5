; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-depack.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_buf_size
PUBLIC	_buf_ptr
PUBLIC	_buffer
_BSS	SEGMENT
_buf_size DD	01H DUP (?)
_buf_ptr DD	01H DUP (?)
_buffer	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_depack_outbyte
PUBLIC	??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@ ; `string'
PUBLIC	??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@ ; `string'
PUBLIC	_depacker_hrust
PUBLIC	_depacker_hrum
PUBLIC	_checker_hrum
PUBLIC	_depacker_megalz
PUBLIC	_checker_megalz
PUBLIC	_depack
EXTRN	__imp__free:PROC
EXTRN	_emit_file:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__printf:PROC
EXTRN	_wrk:BYTE
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@
; File d:\d\mhmt\src\mhmt-depack.c
CONST	SEGMENT
??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@ DB 'mhmt-'
	DB	'depack.c:depack() cannot allocate memory for depack buffer!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@
CONST	SEGMENT
??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@ DB 'mhm'
	DB	't-depack.c:depack() - format unsupported!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _depack
_TEXT	SEGMENT
tv83 = -232						; size = 4
tv79 = -232						; size = 4
tv69 = -232						; size = 4
_success$ = -32						; size = 4
_depacker$ = -20					; size = 4
_checker$ = -8						; size = 4
_depack	PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 18   : 	ULONG (*checker) (void) = NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _checker$[ebp], 0

; 19   : 	ULONG (*depacker)(void) = NULL;

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _depacker$[ebp], 0

; 20   : 
; 21   : 
; 22   : 	ULONG success=1;

  0002c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 23   : 
; 24   : 
; 25   : 	// some preparations
; 26   : 	//
; 27   : 	if( wrk.packtype==PK_MLZ )

  00033	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  0003a	75 10		 jne	 SHORT $LN8@depack

; 28   : 	{
; 29   : 		checker  = &checker_megalz;

  0003c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _checker$[ebp], OFFSET _checker_megalz

; 30   : 		depacker = &depacker_megalz;

  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _depacker$[ebp], OFFSET _depacker_megalz
  0004a	eb 49		 jmp	 SHORT $LN7@depack
$LN8@depack:

; 31   : 	}
; 32   : 	else if( wrk.packtype==PK_HRM )

  0004c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  00053	75 10		 jne	 SHORT $LN6@depack

; 33   : 	{
; 34   : 		checker  = &checker_hrum;

  00055	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _checker$[ebp], OFFSET _checker_hrum

; 35   : 		depacker = &depacker_hrum;

  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _depacker$[ebp], OFFSET _depacker_hrum
  00063	eb 30		 jmp	 SHORT $LN7@depack
$LN6@depack:

; 36   : 	}
; 37   : 	else if( wrk.packtype==PK_HST )

  00065	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  0006c	75 09		 jne	 SHORT $LN4@depack

; 38   : 	{
; 39   : //		checker  = &checker_hrust;
; 40   : 		depacker = &depacker_hrust;

  0006e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _depacker$[ebp], OFFSET _depacker_hrust

; 41   : 	}
; 42   : 	else

  00075	eb 1e		 jmp	 SHORT $LN7@depack
$LN4@depack:

; 43   : 	{
; 44   : 		printf("mhmt-depack.c:depack() - format unsupported!\n");

  00077	8b f4		 mov	 esi, esp
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00084	83 c4 04	 add	 esp, 4
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 45   : 		return 0;

  0008e	33 c0		 xor	 eax, eax
  00090	e9 23 01 00 00	 jmp	 $LN9@depack
$LN7@depack:

; 46   : 	}
; 47   : 
; 48   : 
; 49   : 
; 50   : 	// allocate buffer used for depacking
; 51   : 	//
; 52   : 	buf_size = ( wrk.maxwin==4352 ) ? 8192 : wrk.maxwin; // provided there are no other non-2^n sizes

  00095	81 3d 1c 00 00
	00 00 11 00 00	 cmp	 DWORD PTR _wrk+28, 4352	; 00001100H
  0009f	75 0c		 jne	 SHORT $LN11@depack
  000a1	c7 85 18 ff ff
	ff 00 20 00 00	 mov	 DWORD PTR tv69[ebp], 8192 ; 00002000H
  000ab	eb 0b		 jmp	 SHORT $LN12@depack
$LN11@depack:
  000ad	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  000b2	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN12@depack:
  000b8	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  000be	89 0d 00 00 00
	00		 mov	 DWORD PTR _buf_size, ecx

; 53   : 
; 54   : 	buffer=(UBYTE*)malloc(buf_size);

  000c4	8b f4		 mov	 esi, esp
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_size
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d2	83 c4 04	 add	 esp, 4
  000d5	3b f4		 cmp	 esi, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	a3 00 00 00 00	 mov	 DWORD PTR _buffer, eax

; 55   : 	if( !buffer )

  000e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _buffer, 0
  000e8	75 1e		 jne	 SHORT $LN2@depack

; 56   : 	{
; 57   : 		printf("mhmt-depack.c:depack() cannot allocate memory for depack buffer!\n");

  000ea	8b f4		 mov	 esi, esp
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000f7	83 c4 04	 add	 esp, 4
  000fa	3b f4		 cmp	 esi, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 58   : 		return 0;

  00101	33 c0		 xor	 eax, eax
  00103	e9 b0 00 00 00	 jmp	 $LN9@depack
$LN2@depack:

; 59   : 	}
; 60   : 
; 61   : 	buf_ptr=0;

  00108	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _buf_ptr, 0

; 62   : 
; 63   : 
; 64   : 	success = success && emit_file(NULL,EMIT_FILE_INIT);

  00112	83 7d e0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00116	74 1c		 je	 SHORT $LN13@depack
  00118	6a ff		 push	 -1
  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 _emit_file
  00121	83 c4 08	 add	 esp, 8
  00124	85 c0		 test	 eax, eax
  00126	74 0c		 je	 SHORT $LN13@depack
  00128	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv79[ebp], 1
  00132	eb 0a		 jmp	 SHORT $LN14@depack
$LN13@depack:
  00134	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN14@depack:
  0013e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  00144	89 45 e0	 mov	 DWORD PTR _success$[ebp], eax

; 65   : 
; 66   : //	success = success && (*checker) ();
; 67   : 
; 68   : //#ifdef DBG
; 69   : //	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
; 70   : //#endif
; 71   : 
; 72   : 
; 73   : 
; 74   : 	success = success && (*depacker)();

  00147	83 7d e0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0014b	74 1c		 je	 SHORT $LN15@depack
  0014d	8b f4		 mov	 esi, esp
  0014f	ff 55 ec	 call	 DWORD PTR _depacker$[ebp]
  00152	3b f4		 cmp	 esi, esp
  00154	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00159	85 c0		 test	 eax, eax
  0015b	74 0c		 je	 SHORT $LN15@depack
  0015d	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv83[ebp], 1
  00167	eb 0a		 jmp	 SHORT $LN16@depack
$LN15@depack:
  00169	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv83[ebp], 0
$LN16@depack:
  00173	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  00179	89 45 e0	 mov	 DWORD PTR _success$[ebp], eax

; 75   : 
; 76   : 	/*success = success && */depack_outbyte( 0, DEPACK_OUTBYTE_FLUSH );

  0017c	6a 01		 push	 1
  0017e	6a 00		 push	 0
  00180	e8 00 00 00 00	 call	 _depack_outbyte
  00185	83 c4 08	 add	 esp, 8

; 77   : 
; 78   : 	/*success = success && */emit_file(NULL,EMIT_FILE_FINISH);

  00188	6a 00		 push	 0
  0018a	6a 00		 push	 0
  0018c	e8 00 00 00 00	 call	 _emit_file
  00191	83 c4 08	 add	 esp, 8

; 79   : 
; 80   : 
; 81   : 
; 82   : 
; 83   : 	if( buffer )

  00194	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _buffer, 0
  0019b	74 18		 je	 SHORT $LN1@depack

; 84   : 		free(buffer);

  0019d	8b f4		 mov	 esi, esp
  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  001ab	83 c4 04	 add	 esp, 4
  001ae	3b f4		 cmp	 esi, esp
  001b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@depack:

; 85   : 
; 86   : 	return success;

  001b5	8b 45 e0	 mov	 eax, DWORD PTR _success$[ebp]
$LN9@depack:

; 87   : }

  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	5b		 pop	 ebx
  001bb	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  001c1	3b ec		 cmp	 ebp, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
_depack	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ ; `string'
PUBLIC	??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ ; `string'
PUBLIC	??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	_depack_getbits
PUBLIC	??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	_depack_getbyte
;	COMDAT ??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
; File d:\d\mhmt\src\mhmt-depack-megalz.c
CONST	SEGMENT
??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ DB 'mh'
	DB	'mt-depack-megalz.c:{} - Wrong LZ code', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
CONST	SEGMENT
??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ DB 'mh'
	DB	'mt-depack-megalz.c:{} - Wrong lookback displacement of %d, gr'
	DB	'eater than maxwin', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _checker_megalz
_TEXT	SEGMENT
tv93 = -292						; size = 4
_success$ = -92						; size = 4
_stop$ = -80						; size = 4
_length$ = -68						; size = 4
_disp$ = -56						; size = 4
_bitlen$ = -44						; size = 4
_bits$ = -32						; size = 4
_byte$ = -20						; size = 4
_check$ = -8						; size = 4
_checker_megalz PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 9    : 	ULONG check;
; 10   : 	ULONG byte,bits,bitlen;
; 11   : 	LONG disp;
; 12   : 	ULONG length;
; 13   : 
; 14   : 	ULONG stop;
; 15   : 
; 16   : 
; 17   : 	ULONG success = 1;

  0001e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 18   : 
; 19   : 
; 20   : 	// rewind input stream
; 21   : 	//
; 22   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _depack_getbyte
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 23   : #ifdef DPK_CHECK
; 24   : 	if( 0xFFFFFFFF == check )

  00032	83 7d f8 ff	 cmp	 DWORD PTR _check$[ebp], -1
  00036	75 1e		 jne	 SHORT $LN36@checker_me

; 25   : 	{
; 26   :  #ifdef DPK_REPERR
; 27   : 		printf("mhmt-depack-megalz.c:{} - Can't rewind input stream!\n");

  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00045	83 c4 04	 add	 esp, 4
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 28   :  #endif
; 29   : 		return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 29 03 00 00	 jmp	 $LN37@checker_me
$LN36@checker_me:

; 30   : 	}
; 31   : #endif
; 32   : 
; 33   : 
; 34   : 	// first byte of input stream goes to the output unchanged
; 35   : 	//
; 36   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00056	6a 01		 push	 1
  00058	e8 00 00 00 00	 call	 _depack_getbyte
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 37   : #ifdef DPK_CHECK
; 38   : 	if( 0xFFFFFFFF == byte )

  00063	83 7d ec ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00067	75 1e		 jne	 SHORT $LN35@checker_me
$NO_BYTE$3924:

; 39   : 	{
; 40   : NO_BYTE:
; 41   :  #ifdef DPK_REPERR
; 42   : 		printf("mhmt-depack-megalz.c:{} - Can't get byte from input stream!\n");

  00069	8b f4		 mov	 esi, esp
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00076	83 c4 04	 add	 esp, 4
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 43   :  #endif
; 44   : 		return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 f8 02 00 00	 jmp	 $LN37@checker_me
$LN35@checker_me:

; 45   : 	}
; 46   : #endif
; 47   : 
; 48   : #ifdef DPK_DEPACK
; 49   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 50   : #endif
; 51   : 
; 52   : 
; 53   : #ifdef DPK_CHECK
; 54   :  #ifdef DPK_REPERR
; 55   :  #endif
; 56   : #endif
; 57   : 	// next is byte to the bitstream
; 58   : 	//
; 59   : 	check = depack_getbits(8,DEPACK_GETBITS_FORCE);

  00087	6a 01		 push	 1
  00089	6a 08		 push	 8
  0008b	e8 00 00 00 00	 call	 _depack_getbits
  00090	83 c4 08	 add	 esp, 8
  00093	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 60   : #ifdef DPK_CHECK
; 61   : 	if( 0xFFFFFFFF == check )

  00096	83 7d f8 ff	 cmp	 DWORD PTR _check$[ebp], -1
  0009a	75 1e		 jne	 SHORT $LN34@checker_me
$NO_BITS$3927:

; 62   : 	{
; 63   : NO_BITS:
; 64   :  #ifdef DPK_REPERR
; 65   : 		printf("mhmt-depack-megalz.c:{} - Can't get bits from input stream!\n");

  0009c	8b f4		 mov	 esi, esp
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000a9	83 c4 04	 add	 esp, 4
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   :  #endif
; 67   : 		return 0;

  000b3	33 c0		 xor	 eax, eax
  000b5	e9 c5 02 00 00	 jmp	 $LN37@checker_me
$LN34@checker_me:

; 68   : 	}
; 69   : #endif
; 70   : 
; 71   : 
; 72   : 
; 73   : 	// now normal depacking loop
; 74   : 	//
; 75   : 	stop = 0;

  000ba	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 0
$LN33@checker_me:

; 76   : 	while( (!stop) && success )

  000c1	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  000c5	0f 85 b1 02 00
	00		 jne	 $LN32@checker_me
  000cb	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  000cf	0f 84 a7 02 00
	00		 je	 $LN32@checker_me

; 77   :  	{
; 78   : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  000d5	6a 02		 push	 2
  000d7	6a 01		 push	 1
  000d9	e8 00 00 00 00	 call	 _depack_getbits
  000de	83 c4 08	 add	 esp, 8
  000e1	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 79   : #ifdef DPK_CHECK
; 80   : 		if( 0xFFFFFFFF == bits ) goto NO_BITS;

  000e4	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  000e8	75 02		 jne	 SHORT $LN31@checker_me
  000ea	eb b0		 jmp	 SHORT $NO_BITS$3927
$LN31@checker_me:

; 81   : #endif
; 82   : 
; 83   : 		if( 1&bits ) // %1<byte>

  000ec	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  000ef	83 e0 01	 and	 eax, 1
  000f2	74 1d		 je	 SHORT $LN30@checker_me

; 84   : 		{
; 85   : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000f4	6a 01		 push	 1
  000f6	e8 00 00 00 00	 call	 _depack_getbyte
  000fb	83 c4 04	 add	 esp, 4
  000fe	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  00101	83 7d ec ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00105	75 05		 jne	 SHORT $LN29@checker_me
  00107	e9 5d ff ff ff	 jmp	 $NO_BYTE$3924
$LN29@checker_me:

; 88   : #endif
; 89   : 
; 90   : #ifdef DPK_DEPACK
; 91   : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 92   : #endif
; 93   : 		}
; 94   : 		else // %0xx

  0010c	e9 66 02 00 00	 jmp	 $LN28@checker_me
$LN30@checker_me:

; 95   : 		{
; 96   : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00111	6a 02		 push	 2
  00113	6a 02		 push	 2
  00115	e8 00 00 00 00	 call	 _depack_getbits
  0011a	83 c4 08	 add	 esp, 8
  0011d	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 97   : #ifdef DPK_CHECK
; 98   : 			if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00120	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00124	75 05		 jne	 SHORT $LN27@checker_me
  00126	e9 71 ff ff ff	 jmp	 $NO_BITS$3927
$LN27@checker_me:

; 99   : #endif
; 100  : 
; 101  : 			switch( 0x03 & bits )

  0012b	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  0012e	83 e0 03	 and	 eax, 3
  00131	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  00137	83 bd dc fe ff
	ff 03		 cmp	 DWORD PTR tv93[ebp], 3
  0013e	0f 87 33 02 00
	00		 ja	 $LN28@checker_me
  00144	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  0014a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN39@checker_me[ecx*4]
$LN24@checker_me:

; 102  : 			{
; 103  : 			case 0x00: // %000xxx
; 104  : 
; 105  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  00151	6a 02		 push	 2
  00153	6a 03		 push	 3
  00155	e8 00 00 00 00	 call	 _depack_getbits
  0015a	83 c4 08	 add	 esp, 8
  0015d	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 106  : #ifdef DPK_CHECK
; 107  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00160	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00164	75 05		 jne	 SHORT $LN23@checker_me
  00166	e9 31 ff ff ff	 jmp	 $NO_BITS$3927
$LN23@checker_me:

; 108  : #endif
; 109  : 
; 110  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0016b	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  0016e	83 e0 07	 and	 eax, 7
  00171	83 c8 f8	 or	 eax, -8			; fffffff8H
  00174	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 111  : #ifdef DPK_CHECK
; 112  : 				if( (ULONG)(-disp) > wrk.maxwin )

  00177	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  0017a	f7 d8		 neg	 eax
  0017c	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00182	76 24		 jbe	 SHORT $LN22@checker_me
$WRONG_DISP$3945:

; 113  : 				{
; 114  : WRONG_DISP:
; 115  :  #ifdef DPK_REPERR
; 116  : 					printf("mhmt-depack-megalz.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );

  00184	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00187	f7 d8		 neg	 eax
  00189	8b f4		 mov	 esi, esp
  0018b	50		 push	 eax
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00197	83 c4 08	 add	 esp, 8
  0019a	3b f4		 cmp	 esi, esp
  0019c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 117  :  #endif
; 118  : 					return 0;

  001a1	33 c0		 xor	 eax, eax
  001a3	e9 d7 01 00 00	 jmp	 $LN37@checker_me
$LN22@checker_me:

; 119  : 				}
; 120  : #endif
; 121  : 
; 122  : #ifdef DPK_DEPACK
; 123  : 				success = success && depack_repeat(disp,1);
; 124  : #endif
; 125  : 				break;

  001a8	e9 ca 01 00 00	 jmp	 $LN28@checker_me
$LN21@checker_me:

; 126  : 
; 127  : 
; 128  : 			case 0x01: // %001
; 129  : 
; 130  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  001ad	6a 01		 push	 1
  001af	e8 00 00 00 00	 call	 _depack_getbyte
  001b4	83 c4 04	 add	 esp, 4
  001b7	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 131  : #ifdef DPK_CHECK
; 132  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  001ba	83 7d ec ff	 cmp	 DWORD PTR _byte$[ebp], -1
  001be	75 05		 jne	 SHORT $LN20@checker_me
  001c0	e9 a4 fe ff ff	 jmp	 $NO_BYTE$3924
$LN20@checker_me:

; 133  : #endif
; 134  : 
; 135  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  001c5	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  001c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001cd	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  001d2	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 136  : #ifdef DPK_CHECK
; 137  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;

  001d5	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  001d8	f7 d8		 neg	 eax
  001da	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  001e0	76 02		 jbe	 SHORT $LN19@checker_me
  001e2	eb a0		 jmp	 SHORT $WRONG_DISP$3945
$LN19@checker_me:

; 138  : #endif
; 139  : 
; 140  : #ifdef DPK_DEPACK
; 141  : 				success = success && depack_repeat(disp,2);
; 142  : #endif
; 143  : 				break;

  001e4	e9 8e 01 00 00	 jmp	 $LN28@checker_me
$LN18@checker_me:

; 144  : 
; 145  : 
; 146  : 			case 0x02: // %010
; 147  : 
; 148  : 				length = 3;

  001e9	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _length$[ebp], 3
$FAR_DISP$3952:

; 149  : FAR_DISP:
; 150  : 				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  001f0	6a 02		 push	 2
  001f2	6a 01		 push	 1
  001f4	e8 00 00 00 00	 call	 _depack_getbits
  001f9	83 c4 08	 add	 esp, 8
  001fc	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 151  : #ifdef DPK_CHECK
; 152  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  001ff	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00203	75 05		 jne	 SHORT $LN17@checker_me
  00205	e9 92 fe ff ff	 jmp	 $NO_BITS$3927
$LN17@checker_me:

; 153  : #endif
; 154  : 				if( !(1&bits) ) // -1..-256

  0020a	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  0020d	83 e0 01	 and	 eax, 1
  00210	75 3c		 jne	 SHORT $LN16@checker_me

; 155  : 				{
; 156  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00212	6a 01		 push	 1
  00214	e8 00 00 00 00	 call	 _depack_getbyte
  00219	83 c4 04	 add	 esp, 4
  0021c	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 157  : #ifdef DPK_CHECK
; 158  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  0021f	83 7d ec ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00223	75 05		 jne	 SHORT $LN15@checker_me
  00225	e9 3f fe ff ff	 jmp	 $NO_BYTE$3924
$LN15@checker_me:

; 159  : #endif
; 160  : 					disp = (-256) | (0x00FF&byte); // -1..-256

  0022a	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  0022d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00232	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00237	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 161  : #ifdef DPK_CHECK
; 162  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;

  0023a	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  0023d	f7 d8		 neg	 eax
  0023f	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00245	76 05		 jbe	 SHORT $LN14@checker_me
  00247	e9 38 ff ff ff	 jmp	 $WRONG_DISP$3945
$LN14@checker_me:

; 163  : #endif
; 164  : 
; 165  : #ifdef DPK_DEPACK
; 166  : 					success = success && depack_repeat(disp,length);
; 167  : #endif
; 168  : 				}
; 169  : 				else // -257..-4352

  0024c	eb 59		 jmp	 SHORT $LN13@checker_me
$LN16@checker_me:

; 170  : 				{
; 171  : 					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  0024e	6a 02		 push	 2
  00250	6a 04		 push	 4
  00252	e8 00 00 00 00	 call	 _depack_getbits
  00257	83 c4 08	 add	 esp, 8
  0025a	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 172  : #ifdef DPK_CHECK
; 173  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;

  0025d	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00261	75 05		 jne	 SHORT $LN12@checker_me
  00263	e9 34 fe ff ff	 jmp	 $NO_BITS$3927
$LN12@checker_me:

; 174  : #endif
; 175  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00268	6a 01		 push	 1
  0026a	e8 00 00 00 00	 call	 _depack_getbyte
  0026f	83 c4 04	 add	 esp, 4
  00272	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 176  : #ifdef DPK_CHECK
; 177  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  00275	83 7d ec ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00279	75 05		 jne	 SHORT $LN11@checker_me
  0027b	e9 e9 fd ff ff	 jmp	 $NO_BYTE$3924
$LN11@checker_me:

; 178  : #endif
; 179  : 					disp = ( ((-16)|(15&bits)) - 1 )*0x100 + byte;

  00280	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  00283	83 e0 0f	 and	 eax, 15			; 0000000fH
  00286	83 c8 f0	 or	 eax, -16		; fffffff0H
  00289	83 e8 01	 sub	 eax, 1
  0028c	c1 e0 08	 shl	 eax, 8
  0028f	03 45 ec	 add	 eax, DWORD PTR _byte$[ebp]
  00292	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 180  : #ifdef DPK_CHECK
; 181  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;

  00295	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00298	f7 d8		 neg	 eax
  0029a	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  002a0	76 05		 jbe	 SHORT $LN13@checker_me
  002a2	e9 dd fe ff ff	 jmp	 $WRONG_DISP$3945
$LN13@checker_me:

; 182  : #endif
; 183  : 
; 184  : #ifdef DPK_DEPACK
; 185  : 					success = success && depack_repeat(disp,length);
; 186  : #endif
; 187  : 				}
; 188  : 
; 189  : 				break;

  002a7	e9 cb 00 00 00	 jmp	 $LN28@checker_me
$LN9@checker_me:

; 190  : 
; 191  : 
; 192  : 			case 0x03: // %011 - variable length
; 193  : 
; 194  : 				bitlen = 0;

  002ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bitlen$[ebp], 0
$LN8@checker_me:

; 195  : 				do
; 196  : 				{
; 197  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  002b3	6a 02		 push	 2
  002b5	6a 01		 push	 1
  002b7	e8 00 00 00 00	 call	 _depack_getbits
  002bc	83 c4 08	 add	 esp, 8
  002bf	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 198  : #ifdef DPK_CHECK
; 199  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;

  002c2	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  002c6	75 05		 jne	 SHORT $LN5@checker_me
  002c8	e9 cf fd ff ff	 jmp	 $NO_BITS$3927
$LN5@checker_me:

; 200  : #endif
; 201  : 					bitlen++;

  002cd	8b 45 d4	 mov	 eax, DWORD PTR _bitlen$[ebp]
  002d0	83 c0 01	 add	 eax, 1
  002d3	89 45 d4	 mov	 DWORD PTR _bitlen$[ebp], eax

; 202  : 
; 203  : 				} while ( !(1&bits) );

  002d6	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  002d9	83 e0 01	 and	 eax, 1
  002dc	74 d5		 je	 SHORT $LN8@checker_me

; 204  : 
; 205  : 				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!

  002de	83 7d d4 09	 cmp	 DWORD PTR _bitlen$[ebp], 9
  002e2	75 0c		 jne	 SHORT $LN4@checker_me

; 206  : 				{
; 207  : 					stop = 1;

  002e4	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 1

; 208  : 					break; // exit switch(){}

  002eb	e9 87 00 00 00	 jmp	 $LN28@checker_me
$LN4@checker_me:

; 209  : 				}
; 210  : #ifdef DPK_CHECK
; 211  : 				if( bitlen>7 )

  002f0	83 7d d4 07	 cmp	 DWORD PTR _bitlen$[ebp], 7
  002f4	76 1b		 jbe	 SHORT $LN3@checker_me

; 212  : 				{
; 213  :  #ifdef DPK_REPERR
; 214  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");

  002f6	8b f4		 mov	 esi, esp
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00303	83 c4 04	 add	 esp, 4
  00306	3b f4		 cmp	 esi, esp
  00308	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 215  :  #endif
; 216  : 					return 0;

  0030d	33 c0		 xor	 eax, eax
  0030f	eb 6e		 jmp	 SHORT $LN37@checker_me
$LN3@checker_me:

; 217  : 				}
; 218  : #endif
; 219  : 				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);

  00311	6a 02		 push	 2
  00313	8b 45 d4	 mov	 eax, DWORD PTR _bitlen$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 _depack_getbits
  0031c	83 c4 08	 add	 esp, 8
  0031f	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 220  : #ifdef DPK_CHECK
; 221  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00322	83 7d e0 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00326	75 05		 jne	 SHORT $LN2@checker_me
  00328	e9 6f fd ff ff	 jmp	 $NO_BITS$3927
$LN2@checker_me:

; 222  : #endif
; 223  : 				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );

  0032d	b8 01 00 00 00	 mov	 eax, 1
  00332	8b 4d d4	 mov	 ecx, DWORD PTR _bitlen$[ebp]
  00335	d3 e0		 shl	 eax, cl
  00337	ba 01 00 00 00	 mov	 edx, 1
  0033c	8b 4d d4	 mov	 ecx, DWORD PTR _bitlen$[ebp]
  0033f	d3 e2		 shl	 edx, cl
  00341	83 ea 01	 sub	 edx, 1
  00344	23 55 e0	 and	 edx, DWORD PTR _bits$[ebp]
  00347	8d 44 10 02	 lea	 eax, DWORD PTR [eax+edx+2]
  0034b	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 224  : #ifdef DPK_CHECK
; 225  : 				if( length>255 )

  0034e	81 7d bc ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  00355	76 1b		 jbe	 SHORT $LN1@checker_me

; 226  : 				{
; 227  :  #ifdef DPK_REPERR
; 228  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");

  00357	8b f4		 mov	 esi, esp
  00359	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00364	83 c4 04	 add	 esp, 4
  00367	3b f4		 cmp	 esi, esp
  00369	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 229  :  #endif
; 230  : 					return 0;

  0036e	33 c0		 xor	 eax, eax
  00370	eb 0d		 jmp	 SHORT $LN37@checker_me
$LN1@checker_me:

; 231  : 				}
; 232  : #endif
; 233  : 				goto FAR_DISP;

  00372	e9 79 fe ff ff	 jmp	 $FAR_DISP$3952
$LN28@checker_me:

; 234  : 
; 235  : 				break;
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	}

  00377	e9 45 fd ff ff	 jmp	 $LN33@checker_me
$LN32@checker_me:

; 240  : 
; 241  : 	return success;

  0037c	8b 45 a4	 mov	 eax, DWORD PTR _success$[ebp]
$LN37@checker_me:

; 242  : }

  0037f	5f		 pop	 edi
  00380	5e		 pop	 esi
  00381	5b		 pop	 ebx
  00382	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00388	3b ec		 cmp	 ebp, esp
  0038a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0038f	8b e5		 mov	 esp, ebp
  00391	5d		 pop	 ebp
  00392	c3		 ret	 0
  00393	90		 npad	 1
$LN39@checker_me:
  00394	00 00 00 00	 DD	 $LN24@checker_me
  00398	00 00 00 00	 DD	 $LN21@checker_me
  0039c	00 00 00 00	 DD	 $LN18@checker_me
  003a0	00 00 00 00	 DD	 $LN9@checker_me
_checker_megalz ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@ ; `string'
PUBLIC	??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ ; `string'
PUBLIC	??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ ; `string'
PUBLIC	??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@ ; `string'
PUBLIC	??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@ ; `string'
;	COMDAT ??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@
; File d:\d\mhmt\src\mhmt-depack-hrum.c
CONST	SEGMENT
??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@ DB 'mh'
	DB	'mt-depack-hrum.c:{} - Wrong lookback displacement of %d, grea'
	DB	'ter than maxwin', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
CONST	SEGMENT
??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
CONST	SEGMENT
??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@
CONST	SEGMENT
??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@ DB 'mh'
	DB	'mt-depack-hrum.c:{} - Wrong ZX-header!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@
CONST	SEGMENT
??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _checker_hrum
_TEXT	SEGMENT
tv138 = -292						; size = 4
_success$ = -92						; size = 4
_stop$ = -80						; size = 4
_length$ = -68						; size = 4
_disp$ = -56						; size = 4
_bits$ = -44						; size = 4
_byte$ = -32						; size = 4
_check$ = -20						; size = 4
_i$ = -8						; size = 4
_checker_hrum PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 	LONG  disp;
; 14   : 	ULONG length;
; 15   : 
; 16   : 	ULONG stop;
; 17   : 
; 18   : 
; 19   : 	ULONG success = 1;

  0001e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 20   : 
; 21   : 
; 22   : 	// rewind input stream
; 23   : 	//
; 24   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _depack_getbyte
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 25   : #ifdef DPK_CHECK
; 26   : 	if( 0xFFFFFFFF == check )

  00032	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  00036	75 1e		 jne	 SHORT $LN70@checker_hr

; 27   : 	{
; 28   :  #ifdef DPK_REPERR
; 29   : 		printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");

  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00045	83 c4 04	 add	 esp, 4
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 30   :  #endif
; 31   : 		return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 55 04 00 00	 jmp	 $LN71@checker_hr
$LN70@checker_hr:

; 32   : 	}
; 33   : #endif
; 34   : 
; 35   : 
; 36   : 	// manage zx header if needed
; 37   : 	if( wrk.zxheader )

  00056	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  0005d	0f 84 85 00 00
	00		 je	 $LN69@checker_hr

; 38   : 	{
; 39   : 		// skip 5 bytes (they will go to the end of output file)
; 40   : 		for(i=0;i<5;i++)

  00063	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006a	eb 09		 jmp	 SHORT $LN68@checker_hr
$LN67@checker_hr:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN68@checker_hr:
  00075	83 7d f8 05	 cmp	 DWORD PTR _i$[ebp], 5
  00079	7d 1a		 jge	 SHORT $LN66@checker_hr

; 41   : 		{
; 42   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0007b	6a 01		 push	 1
  0007d	e8 00 00 00 00	 call	 _depack_getbyte
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 43   : #ifdef DPK_CHECK
; 44   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;

  00088	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  0008c	75 05		 jne	 SHORT $LN65@checker_hr
  0008e	e9 9b 00 00 00	 jmp	 $NO_BYTE_HRM$3991
$LN65@checker_hr:

; 45   : #endif
; 46   : 		}

  00093	eb d7		 jmp	 SHORT $LN67@checker_hr
$LN66@checker_hr:

; 47   : 
; 48   : 		// next 2 bytes must be 0x10
; 49   : 		for(i=0;i<2;i++)

  00095	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009c	eb 09		 jmp	 SHORT $LN64@checker_hr
$LN63@checker_hr:
  0009e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN64@checker_hr:
  000a7	83 7d f8 02	 cmp	 DWORD PTR _i$[ebp], 2
  000ab	7d 3b		 jge	 SHORT $LN69@checker_hr

; 50   : 		{
; 51   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000ad	6a 01		 push	 1
  000af	e8 00 00 00 00	 call	 _depack_getbyte
  000b4	83 c4 04	 add	 esp, 4
  000b7	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 52   : #ifdef DPK_CHECK
; 53   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;

  000ba	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  000be	75 02		 jne	 SHORT $LN61@checker_hr
  000c0	eb 6c		 jmp	 SHORT $NO_BYTE_HRM$3991
$LN61@checker_hr:

; 54   : 			if( check != 0x0010 )

  000c2	83 7d ec 10	 cmp	 DWORD PTR _check$[ebp], 16 ; 00000010H
  000c6	74 1e		 je	 SHORT $LN60@checker_hr

; 55   : 			{
; 56   :  #ifdef DPK_REPERR
; 57   : 				printf("mhmt-depack-hrum.c:{} - Wrong ZX-header!\n");

  000c8	8b f4		 mov	 esi, esp
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000d5	83 c4 04	 add	 esp, 4
  000d8	3b f4		 cmp	 esi, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 58   :  #endif
; 59   : 				return 0;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 c5 03 00 00	 jmp	 $LN71@checker_hr
$LN60@checker_hr:

; 60   : 			}
; 61   : #endif
; 62   : 		}

  000e6	eb b6		 jmp	 SHORT $LN63@checker_hr
$LN69@checker_hr:

; 63   : 	}
; 64   : 
; 65   : 
; 66   : 
; 67   : 	// initialize bitstream first
; 68   : 	//
; 69   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  000e8	6a 01		 push	 1
  000ea	6a 10		 push	 16			; 00000010H
  000ec	e8 00 00 00 00	 call	 _depack_getbits
  000f1	83 c4 08	 add	 esp, 8
  000f4	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 70   : #ifdef DPK_CHECK
; 71   : 	if( 0xFFFFFFFF == check )

  000f7	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  000fb	75 1e		 jne	 SHORT $LN59@checker_hr
$NO_BITS_HRM$3999:

; 72   : 	{
; 73   : NO_BITS_HRM:
; 74   :  #ifdef DPK_REPERR
; 75   : 		printf("mhmt-depack-hrum.c:{} - Can't get bits from input stream!\n");

  000fd	8b f4		 mov	 esi, esp
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0010a	83 c4 04	 add	 esp, 4
  0010d	3b f4		 cmp	 esi, esp
  0010f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   :  #endif
; 77   : 		return 0;

  00114	33 c0		 xor	 eax, eax
  00116	e9 90 03 00 00	 jmp	 $LN71@checker_hr
$LN59@checker_hr:

; 78   : 	}
; 79   : #endif
; 80   : 
; 81   : 
; 82   : 
; 83   : 	// then byte of input stream goes to the output unchanged
; 84   : 	//
; 85   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0011b	6a 01		 push	 1
  0011d	e8 00 00 00 00	 call	 _depack_getbyte
  00122	83 c4 04	 add	 esp, 4
  00125	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 86   : #ifdef DPK_CHECK
; 87   : 	if( 0xFFFFFFFF == byte )

  00128	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  0012c	75 1e		 jne	 SHORT $LN58@checker_hr
$NO_BYTE_HRM$3991:

; 88   : 	{
; 89   : NO_BYTE_HRM:
; 90   :  #ifdef DPK_REPERR
; 91   : 		printf("mhmt-depack-hrum.c:{} - Can't get byte from input stream!\n");

  0012e	8b f4		 mov	 esi, esp
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0013b	83 c4 04	 add	 esp, 4
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 92   :  #endif
; 93   : 		return 0;

  00145	33 c0		 xor	 eax, eax
  00147	e9 5f 03 00 00	 jmp	 $LN71@checker_hr
$LN58@checker_hr:

; 94   : 	}
; 95   : #endif
; 96   : 
; 97   : #ifdef DPK_DEPACK
; 98   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 99   : #endif
; 100  : 
; 101  : 
; 102  : 
; 103  : 	// now normal depacking loop
; 104  : 	//
; 105  : 	stop = 0;

  0014c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 0
$LN57@checker_hr:

; 106  : 	while( (!stop) && success )

  00153	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  00157	0f 85 4b 03 00
	00		 jne	 $LN56@checker_hr
  0015d	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00161	0f 84 41 03 00
	00		 je	 $LN56@checker_hr

; 107  :  	{
; 108  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00167	6a 02		 push	 2
  00169	6a 01		 push	 1
  0016b	e8 00 00 00 00	 call	 _depack_getbits
  00170	83 c4 08	 add	 esp, 8
  00173	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 109  : #ifdef DPK_CHECK
; 110  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00176	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0017a	75 05		 jne	 SHORT $LN55@checker_hr
  0017c	e9 7c ff ff ff	 jmp	 $NO_BITS_HRM$3999
$LN55@checker_hr:

; 111  : #endif
; 112  : 
; 113  : 		if( 1&bits ) // %1<byte>

  00181	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00184	83 e0 01	 and	 eax, 1
  00187	74 1a		 je	 SHORT $LN54@checker_hr

; 114  : 		{
; 115  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00189	6a 01		 push	 1
  0018b	e8 00 00 00 00	 call	 _depack_getbyte
  00190	83 c4 04	 add	 esp, 4
  00193	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 116  : #ifdef DPK_CHECK
; 117  : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00196	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  0019a	75 02		 jne	 SHORT $LN53@checker_hr
  0019c	eb 90		 jmp	 SHORT $NO_BYTE_HRM$3991
$LN53@checker_hr:

; 118  : #endif
; 119  : 
; 120  : #ifdef DPK_DEPACK
; 121  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 122  : #endif
; 123  : 		}
; 124  : 		else // %0xx

  0019e	e9 00 03 00 00	 jmp	 $LN52@checker_hr
$LN54@checker_hr:

; 125  : 		{
; 126  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  001a3	6a 02		 push	 2
  001a5	6a 02		 push	 2
  001a7	e8 00 00 00 00	 call	 _depack_getbits
  001ac	83 c4 08	 add	 esp, 8
  001af	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 127  : #ifdef DPK_CHECK
; 128  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  001b2	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  001b6	75 05		 jne	 SHORT $LN51@checker_hr
  001b8	e9 40 ff ff ff	 jmp	 $NO_BITS_HRM$3999
$LN51@checker_hr:

; 129  : #endif
; 130  : 
; 131  : 			switch( 0x03 & bits )

  001bd	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  001c0	83 e0 03	 and	 eax, 3
  001c3	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  001c9	74 0e		 je	 SHORT $LN48@checker_hr
  001cb	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR tv138[ebp], 1
  001d2	74 61		 je	 SHORT $LN45@checker_hr
  001d4	e9 98 00 00 00	 jmp	 $LN42@checker_hr
$LN48@checker_hr:

; 132  : 			{
; 133  : 			case 0x00: // %000xxx
; 134  : 
; 135  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  001d9	6a 02		 push	 2
  001db	6a 03		 push	 3
  001dd	e8 00 00 00 00	 call	 _depack_getbits
  001e2	83 c4 08	 add	 esp, 8
  001e5	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 136  : #ifdef DPK_CHECK
; 137  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  001e8	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  001ec	75 05		 jne	 SHORT $LN47@checker_hr
  001ee	e9 0a ff ff ff	 jmp	 $NO_BITS_HRM$3999
$LN47@checker_hr:

; 138  : #endif
; 139  : 
; 140  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  001f3	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  001f6	83 e0 07	 and	 eax, 7
  001f9	83 c8 f8	 or	 eax, -8			; fffffff8H
  001fc	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 141  : #ifdef DPK_CHECK
; 142  : 				if( (ULONG)(-disp) > wrk.maxwin )

  001ff	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00202	f7 d8		 neg	 eax
  00204	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  0020a	76 24		 jbe	 SHORT $LN46@checker_hr
$WRONG_DISP_HRM$4019:

; 143  : 				{
; 144  : WRONG_DISP_HRM:
; 145  :  #ifdef DPK_REPERR
; 146  : 					printf("mhmt-depack-hrum.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );

  0020c	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  0020f	f7 d8		 neg	 eax
  00211	8b f4		 mov	 esi, esp
  00213	50		 push	 eax
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0021f	83 c4 08	 add	 esp, 8
  00222	3b f4		 cmp	 esi, esp
  00224	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 147  :  #endif
; 148  : 					return 0;

  00229	33 c0		 xor	 eax, eax
  0022b	e9 7b 02 00 00	 jmp	 $LN71@checker_hr
$LN46@checker_hr:

; 149  : 				}
; 150  : #endif
; 151  : 
; 152  : #ifdef DPK_DEPACK
; 153  : 				success = success && depack_repeat(disp,1);
; 154  : #endif
; 155  : 				break;

  00230	e9 6e 02 00 00	 jmp	 $LN52@checker_hr
$LN45@checker_hr:

; 156  : 
; 157  : 
; 158  : 			case 0x01: // %001
; 159  : 
; 160  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00235	6a 01		 push	 1
  00237	e8 00 00 00 00	 call	 _depack_getbyte
  0023c	83 c4 04	 add	 esp, 4
  0023f	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 161  : #ifdef DPK_CHECK
; 162  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00242	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00246	75 05		 jne	 SHORT $LN44@checker_hr
  00248	e9 e1 fe ff ff	 jmp	 $NO_BYTE_HRM$3991
$LN44@checker_hr:

; 163  : #endif
; 164  : 
; 165  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  0024d	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00250	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00255	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0025a	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 166  : #ifdef DPK_CHECK
; 167  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;

  0025d	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00260	f7 d8		 neg	 eax
  00262	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00268	76 02		 jbe	 SHORT $LN43@checker_hr
  0026a	eb a0		 jmp	 SHORT $WRONG_DISP_HRM$4019
$LN43@checker_hr:

; 168  : #endif
; 169  : 
; 170  : #ifdef DPK_DEPACK
; 171  : 				success = success && depack_repeat(disp,2);
; 172  : #endif
; 173  : 				break;

  0026c	e9 32 02 00 00	 jmp	 $LN52@checker_hr
$LN42@checker_hr:

; 174  : 
; 175  : 			default: // %010 or %011
; 176  : 
; 177  : 				if( (bits&3)==2 ) // %010 - 3 bytes

  00271	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00274	83 e0 03	 and	 eax, 3
  00277	83 f8 02	 cmp	 eax, 2
  0027a	75 0c		 jne	 SHORT $LN41@checker_hr

; 178  : 				{
; 179  : 					length = 3;

  0027c	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _length$[ebp], 3

; 180  : 				}
; 181  : 				else // %011 - varlen

  00283	e9 53 01 00 00	 jmp	 $LN40@checker_hr
$LN41@checker_hr:

; 182  : 				{
; 183  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00288	6a 02		 push	 2
  0028a	6a 02		 push	 2
  0028c	e8 00 00 00 00	 call	 _depack_getbits
  00291	83 c4 08	 add	 esp, 8
  00294	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 184  : #ifdef DPK_CHECK
; 185  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00297	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0029b	75 05		 jne	 SHORT $LN39@checker_hr
  0029d	e9 5b fe ff ff	 jmp	 $NO_BITS_HRM$3999
$LN39@checker_hr:

; 186  : #endif
; 187  : 					//  fetch len
; 188  : 					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop

  002a2	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  002a6	75 2a		 jne	 SHORT $LN38@checker_hr

; 189  : 					{
; 190  : 						length = depack_getbyte(DEPACK_GETBYTE_NEXT);

  002a8	6a 01		 push	 1
  002aa	e8 00 00 00 00	 call	 _depack_getbyte
  002af	83 c4 04	 add	 esp, 4
  002b2	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 191  : #ifdef DPK_CHECK
; 192  : 						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;

  002b5	83 7d bc ff	 cmp	 DWORD PTR _length$[ebp], -1
  002b9	75 05		 jne	 SHORT $LN37@checker_hr
  002bb	e9 6e fe ff ff	 jmp	 $NO_BYTE_HRM$3991
$LN37@checker_hr:

; 193  : #endif
; 194  : 						if( length == 0 )

  002c0	83 7d bc 00	 cmp	 DWORD PTR _length$[ebp], 0
  002c4	75 07		 jne	 SHORT $LN36@checker_hr

; 195  : 							stop = 1;

  002c6	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 1
$LN36@checker_hr:

; 196  : 					}
; 197  : 					else if( bits == 0x01 ) // %01101 - len=4

  002cd	e9 09 01 00 00	 jmp	 $LN40@checker_hr
$LN38@checker_hr:
  002d2	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  002d6	75 0c		 jne	 SHORT $LN34@checker_hr

; 198  : 					{
; 199  : 						length = 4;

  002d8	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _length$[ebp], 4
  002df	e9 f7 00 00 00	 jmp	 $LN40@checker_hr
$LN34@checker_hr:

; 200  : 					}
; 201  : 					else if( bits == 0x02 ) // %01110 - len=5

  002e4	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  002e8	75 0c		 jne	 SHORT $LN32@checker_hr

; 202  : 					{
; 203  : 						length = 5;

  002ea	c7 45 bc 05 00
	00 00		 mov	 DWORD PTR _length$[ebp], 5

; 204  : 					}
; 205  : 					else // %01111

  002f1	e9 e5 00 00 00	 jmp	 $LN40@checker_hr
$LN32@checker_hr:

; 206  : 					{
; 207  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  002f6	6a 02		 push	 2
  002f8	6a 02		 push	 2
  002fa	e8 00 00 00 00	 call	 _depack_getbits
  002ff	83 c4 08	 add	 esp, 8
  00302	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 208  : #ifdef DPK_CHECK
; 209  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00305	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00309	75 05		 jne	 SHORT $LN30@checker_hr
  0030b	e9 ed fd ff ff	 jmp	 $NO_BITS_HRM$3999
$LN30@checker_hr:

; 210  : #endif
; 211  : 						if( bits == 0x00 ) // %0111100

  00310	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00314	75 0c		 jne	 SHORT $LN29@checker_hr

; 212  : 						{
; 213  : 							length = 6;

  00316	c7 45 bc 06 00
	00 00		 mov	 DWORD PTR _length$[ebp], 6
  0031d	e9 b9 00 00 00	 jmp	 $LN40@checker_hr
$LN29@checker_hr:

; 214  : 						}
; 215  : 						else if( bits == 0x01 ) // %0111101

  00322	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  00326	75 0c		 jne	 SHORT $LN27@checker_hr

; 216  : 						{
; 217  : 							length = 7;

  00328	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR _length$[ebp], 7
  0032f	e9 a7 00 00 00	 jmp	 $LN40@checker_hr
$LN27@checker_hr:

; 218  : 						}
; 219  : 						else if( bits == 0x02 ) // %0111110

  00334	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  00338	75 0c		 jne	 SHORT $LN25@checker_hr

; 220  : 						{
; 221  : 							length = 8;

  0033a	c7 45 bc 08 00
	00 00		 mov	 DWORD PTR _length$[ebp], 8

; 222  : 						}
; 223  : 						else // %0111111

  00341	e9 95 00 00 00	 jmp	 $LN40@checker_hr
$LN25@checker_hr:

; 224  : 						{
; 225  : 							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00346	6a 02		 push	 2
  00348	6a 02		 push	 2
  0034a	e8 00 00 00 00	 call	 _depack_getbits
  0034f	83 c4 08	 add	 esp, 8
  00352	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 226  : #ifdef DPK_CHECK
; 227  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00355	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00359	75 05		 jne	 SHORT $LN23@checker_hr
  0035b	e9 9d fd ff ff	 jmp	 $NO_BITS_HRM$3999
$LN23@checker_hr:

; 228  : #endif
; 229  : 							if( bits == 0x00 ) // %011111100

  00360	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00364	75 09		 jne	 SHORT $LN22@checker_hr

; 230  : 							{
; 231  : 								length = 9;

  00366	c7 45 bc 09 00
	00 00		 mov	 DWORD PTR _length$[ebp], 9
  0036d	eb 6c		 jmp	 SHORT $LN40@checker_hr
$LN22@checker_hr:

; 232  : 							}
; 233  : 							else if( bits == 0x01 ) // %011111101

  0036f	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  00373	75 09		 jne	 SHORT $LN20@checker_hr

; 234  : 							{
; 235  : 								length = 10;

  00375	c7 45 bc 0a 00
	00 00		 mov	 DWORD PTR _length$[ebp], 10 ; 0000000aH
  0037c	eb 5d		 jmp	 SHORT $LN40@checker_hr
$LN20@checker_hr:

; 236  : 							}
; 237  : 							else if( bits == 0x02 ) // %011111110

  0037e	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  00382	75 09		 jne	 SHORT $LN18@checker_hr

; 238  : 							{
; 239  : 								length = 11;

  00384	c7 45 bc 0b 00
	00 00		 mov	 DWORD PTR _length$[ebp], 11 ; 0000000bH

; 240  : 							}
; 241  : 							else // %011111111

  0038b	eb 4e		 jmp	 SHORT $LN40@checker_hr
$LN18@checker_hr:

; 242  : 							{
; 243  : 								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0038d	6a 02		 push	 2
  0038f	6a 02		 push	 2
  00391	e8 00 00 00 00	 call	 _depack_getbits
  00396	83 c4 08	 add	 esp, 8
  00399	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 244  : #ifdef DPK_CHECK
; 245  : 								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  0039c	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  003a0	75 05		 jne	 SHORT $LN16@checker_hr
  003a2	e9 56 fd ff ff	 jmp	 $NO_BITS_HRM$3999
$LN16@checker_hr:

; 246  : #endif
; 247  : 								if( bits == 0x00 ) // %01111111100

  003a7	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  003ab	75 09		 jne	 SHORT $LN15@checker_hr

; 248  : 								{
; 249  : 									length = 12;

  003ad	c7 45 bc 0c 00
	00 00		 mov	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  003b4	eb 25		 jmp	 SHORT $LN40@checker_hr
$LN15@checker_hr:

; 250  : 								}
; 251  : 								else if( bits == 0x01 ) // %01111111101

  003b6	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  003ba	75 09		 jne	 SHORT $LN13@checker_hr

; 252  : 								{
; 253  : 									length = 13;

  003bc	c7 45 bc 0d 00
	00 00		 mov	 DWORD PTR _length$[ebp], 13 ; 0000000dH
  003c3	eb 16		 jmp	 SHORT $LN40@checker_hr
$LN13@checker_hr:

; 254  : 								}
; 255  : 								else if( bits == 0x02 ) // %01111111110

  003c5	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  003c9	75 09		 jne	 SHORT $LN11@checker_hr

; 256  : 								{
; 257  : 									length = 14;

  003cb	c7 45 bc 0e 00
	00 00		 mov	 DWORD PTR _length$[ebp], 14 ; 0000000eH

; 258  : 								}
; 259  : 								else // %01111111111

  003d2	eb 07		 jmp	 SHORT $LN40@checker_hr
$LN11@checker_hr:

; 260  : 								{
; 261  : 									length = 15;

  003d4	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _length$[ebp], 15 ; 0000000fH
$LN40@checker_hr:

; 262  : 								}
; 263  : 							}
; 264  : 						}
; 265  : 					}
; 266  : 				}
; 267  : 
; 268  : 
; 269  : 				// fetch disp and depack
; 270  : 				if( !stop )

  003db	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  003df	0f 85 be 00 00
	00		 jne	 $LN52@checker_hr

; 271  : 				{
; 272  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  003e5	6a 02		 push	 2
  003e7	6a 01		 push	 1
  003e9	e8 00 00 00 00	 call	 _depack_getbits
  003ee	83 c4 08	 add	 esp, 8
  003f1	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 273  : #ifdef DPK_CHECK
; 274  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  003f4	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  003f8	75 05		 jne	 SHORT $LN8@checker_hr
  003fa	e9 fe fc ff ff	 jmp	 $NO_BITS_HRM$3999
$LN8@checker_hr:

; 275  : #endif
; 276  : 					if( bits == 0x00 ) // %0<disp>

  003ff	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00403	75 3c		 jne	 SHORT $LN7@checker_hr

; 277  : 					{
; 278  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00405	6a 01		 push	 1
  00407	e8 00 00 00 00	 call	 _depack_getbyte
  0040c	83 c4 04	 add	 esp, 4
  0040f	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 279  : #ifdef DPK_CHECK
; 280  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00412	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00416	75 05		 jne	 SHORT $LN6@checker_hr
  00418	e9 11 fd ff ff	 jmp	 $NO_BYTE_HRM$3991
$LN6@checker_hr:

; 281  : #endif
; 282  : 						disp = (-256) | (0x00FF&byte); // -1..-256

  0041d	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00420	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00425	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0042a	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 283  : #ifdef DPK_CHECK
; 284  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;

  0042d	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00430	f7 d8		 neg	 eax
  00432	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00438	76 05		 jbe	 SHORT $LN5@checker_hr
  0043a	e9 cd fd ff ff	 jmp	 $WRONG_DISP_HRM$4019
$LN5@checker_hr:

; 285  : #endif
; 286  : #ifdef DPK_DEPACK
; 287  : 						success = success && depack_repeat(disp,length);
; 288  : #endif
; 289  : 					}
; 290  : 					else // %1abcd<disp>

  0043f	eb 62		 jmp	 SHORT $LN52@checker_hr
$LN7@checker_hr:

; 291  : 					{
; 292  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  00441	6a 02		 push	 2
  00443	6a 04		 push	 4
  00445	e8 00 00 00 00	 call	 _depack_getbits
  0044a	83 c4 08	 add	 esp, 8
  0044d	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 293  : #ifdef DPK_CHECK
; 294  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00450	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00454	75 05		 jne	 SHORT $LN3@checker_hr
  00456	e9 a2 fc ff ff	 jmp	 $NO_BITS_HRM$3999
$LN3@checker_hr:

; 295  : #endif
; 296  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0045b	6a 01		 push	 1
  0045d	e8 00 00 00 00	 call	 _depack_getbyte
  00462	83 c4 04	 add	 esp, 4
  00465	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 297  : #ifdef DPK_CHECK
; 298  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00468	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  0046c	75 05		 jne	 SHORT $LN2@checker_hr
  0046e	e9 bb fc ff ff	 jmp	 $NO_BYTE_HRM$3991
$LN2@checker_hr:

; 299  : #endif
; 300  : 						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096

  00473	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00476	c1 e0 08	 shl	 eax, 8
  00479	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  0047e	0d 00 f0 ff ff	 or	 eax, -4096		; fffff000H
  00483	8b 4d e0	 mov	 ecx, DWORD PTR _byte$[ebp]
  00486	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0048c	0b c1		 or	 eax, ecx
  0048e	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 301  : #ifdef DPK_CHECK
; 302  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;

  00491	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00494	f7 d8		 neg	 eax
  00496	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  0049c	76 05		 jbe	 SHORT $LN52@checker_hr
  0049e	e9 69 fd ff ff	 jmp	 $WRONG_DISP_HRM$4019
$LN52@checker_hr:

; 303  : #endif
; 304  : #ifdef DPK_DEPACK
; 305  : 						success = success && depack_repeat(disp,length);
; 306  : #endif
; 307  : 					}
; 308  : 				}
; 309  : 
; 310  : 				break;
; 311  : 			}
; 312  : 		}
; 313  : 	}

  004a3	e9 ab fc ff ff	 jmp	 $LN57@checker_hr
$LN56@checker_hr:

; 314  : 
; 315  : 	//manage zxheader again (copy to the end of output)
; 316  : #ifdef DPK_DEPACK
; 317  : 	if( wrk.zxheader )
; 318  : 	{
; 319  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);
; 320  :  #ifdef DPK_CHECK
; 321  : 		if( 0xFFFFFFFF == check )
; 322  : 		{
; 323  :   #ifdef DPK_REPERR
; 324  : 			printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 325  :   #endif
; 326  : 			return 0;
; 327  : 		}
; 328  :  #endif
; 329  : 
; 330  : 		// place 5 bytes of header to the end
; 331  : 		for(i=0;i<5;i++)
; 332  : 		{
; 333  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 334  :  #ifdef DPK_CHECK
; 335  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
; 336  :  #endif
; 337  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 338  : 		}
; 339  : 	}
; 340  : #endif
; 341  : 
; 342  : 	return success;

  004a8	8b 45 a4	 mov	 eax, DWORD PTR _success$[ebp]
$LN71@checker_hr:

; 343  : }

  004ab	5f		 pop	 edi
  004ac	5e		 pop	 esi
  004ad	5b		 pop	 ebx
  004ae	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  004b4	3b ec		 cmp	 ebp, esp
  004b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004bb	8b e5		 mov	 esp, ebp
  004bd	5d		 pop	 ebp
  004be	c3		 ret	 0
_checker_hrum ENDP
_TEXT	ENDS
PUBLIC	_depack_repeat
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\d\mhmt\src\mhmt-depack-megalz.c
;	COMDAT _depacker_megalz
_TEXT	SEGMENT
tv184 = -292						; size = 4
tv168 = -292						; size = 4
tv153 = -292						; size = 4
tv143 = -292						; size = 4
tv132 = -292						; size = 4
tv95 = -292						; size = 4
tv75 = -292						; size = 4
_success$ = -92						; size = 4
_stop$ = -80						; size = 4
_length$ = -68						; size = 4
_disp$ = -56						; size = 4
_bitlen$ = -44						; size = 4
_bits$ = -32						; size = 4
_byte$ = -20						; size = 4
_check$ = -8						; size = 4
_depacker_megalz PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 9    : 	ULONG check;
; 10   : 	ULONG byte,bits,bitlen;
; 11   : 	LONG disp;
; 12   : 	ULONG length;
; 13   : 
; 14   : 	ULONG stop;
; 15   : 
; 16   : 
; 17   : 	ULONG success = 1;

  0001e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 18   : 
; 19   : 
; 20   : 	// rewind input stream
; 21   : 	//
; 22   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _depack_getbyte
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 23   : #ifdef DPK_CHECK
; 24   : 	if( 0xFFFFFFFF == check )
; 25   : 	{
; 26   :  #ifdef DPK_REPERR
; 27   : 		printf("mhmt-depack-megalz.c:{} - Can't rewind input stream!\n");
; 28   :  #endif
; 29   : 		return 0;
; 30   : 	}
; 31   : #endif
; 32   : 
; 33   : 
; 34   : 	// first byte of input stream goes to the output unchanged
; 35   : 	//
; 36   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00032	6a 01		 push	 1
  00034	e8 00 00 00 00	 call	 _depack_getbyte
  00039	83 c4 04	 add	 esp, 4
  0003c	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 37   : #ifdef DPK_CHECK
; 38   : 	if( 0xFFFFFFFF == byte )
; 39   : 	{
; 40   : NO_BYTE:
; 41   :  #ifdef DPK_REPERR
; 42   : 		printf("mhmt-depack-megalz.c:{} - Can't get byte from input stream!\n");
; 43   :  #endif
; 44   : 		return 0;
; 45   : 	}
; 46   : #endif
; 47   : 
; 48   : #ifdef DPK_DEPACK
; 49   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0003f	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00043	74 23		 je	 SHORT $LN19@depacker_m
  00045	6a 02		 push	 2
  00047	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _depack_outbyte
  00055	83 c4 08	 add	 esp, 8
  00058	85 c0		 test	 eax, eax
  0005a	74 0c		 je	 SHORT $LN19@depacker_m
  0005c	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
  00066	eb 0a		 jmp	 SHORT $LN20@depacker_m
$LN19@depacker_m:
  00068	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
$LN20@depacker_m:
  00072	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00078	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 50   : #endif
; 51   : 
; 52   : 
; 53   : #ifdef DPK_CHECK
; 54   :  #ifdef DPK_REPERR
; 55   :  #endif
; 56   : #endif
; 57   : 	// next is byte to the bitstream
; 58   : 	//
; 59   : 	check = depack_getbits(8,DEPACK_GETBITS_FORCE);

  0007b	6a 01		 push	 1
  0007d	6a 08		 push	 8
  0007f	e8 00 00 00 00	 call	 _depack_getbits
  00084	83 c4 08	 add	 esp, 8
  00087	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 60   : #ifdef DPK_CHECK
; 61   : 	if( 0xFFFFFFFF == check )
; 62   : 	{
; 63   : NO_BITS:
; 64   :  #ifdef DPK_REPERR
; 65   : 		printf("mhmt-depack-megalz.c:{} - Can't get bits from input stream!\n");
; 66   :  #endif
; 67   : 		return 0;
; 68   : 	}
; 69   : #endif
; 70   : 
; 71   : 
; 72   : 
; 73   : 	// now normal depacking loop
; 74   : 	//
; 75   : 	stop = 0;

  0008a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 0
$LN16@depacker_m:

; 76   : 	while( (!stop) && success )

  00091	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  00095	0f 85 a8 02 00
	00		 jne	 $LN15@depacker_m
  0009b	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0009f	0f 84 9e 02 00
	00		 je	 $LN15@depacker_m

; 77   :  	{
; 78   : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  000a5	6a 02		 push	 2
  000a7	6a 01		 push	 1
  000a9	e8 00 00 00 00	 call	 _depack_getbits
  000ae	83 c4 08	 add	 esp, 8
  000b1	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 79   : #ifdef DPK_CHECK
; 80   : 		if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 81   : #endif
; 82   : 
; 83   : 		if( 1&bits ) // %1<byte>

  000b4	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  000b7	83 e0 01	 and	 eax, 1
  000ba	74 4e		 je	 SHORT $LN14@depacker_m

; 84   : 		{
; 85   : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000bc	6a 01		 push	 1
  000be	e8 00 00 00 00	 call	 _depack_getbyte
  000c3	83 c4 04	 add	 esp, 4
  000c6	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 88   : #endif
; 89   : 
; 90   : #ifdef DPK_DEPACK
; 91   : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  000c9	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  000cd	74 23		 je	 SHORT $LN21@depacker_m
  000cf	6a 02		 push	 2
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  000d4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _depack_outbyte
  000df	83 c4 08	 add	 esp, 8
  000e2	85 c0		 test	 eax, eax
  000e4	74 0c		 je	 SHORT $LN21@depacker_m
  000e6	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv95[ebp], 1
  000f0	eb 0a		 jmp	 SHORT $LN22@depacker_m
$LN21@depacker_m:
  000f2	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp], 0
$LN22@depacker_m:
  000fc	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv95[ebp]
  00102	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 92   : #endif
; 93   : 		}
; 94   : 		else // %0xx

  00105	e9 34 02 00 00	 jmp	 $LN13@depacker_m
$LN14@depacker_m:

; 95   : 		{
; 96   : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0010a	6a 02		 push	 2
  0010c	6a 02		 push	 2
  0010e	e8 00 00 00 00	 call	 _depack_getbits
  00113	83 c4 08	 add	 esp, 8
  00116	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 97   : #ifdef DPK_CHECK
; 98   : 			if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 99   : #endif
; 100  : 
; 101  : 			switch( 0x03 & bits )

  00119	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  0011c	83 e0 03	 and	 eax, 3
  0011f	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv132[ebp], eax
  00125	83 bd dc fe ff
	ff 03		 cmp	 DWORD PTR tv132[ebp], 3
  0012c	0f 87 0c 02 00
	00		 ja	 $LN13@depacker_m
  00132	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv132[ebp]
  00138	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN31@depacker_m[ecx*4]
$LN10@depacker_m:

; 102  : 			{
; 103  : 			case 0x00: // %000xxx
; 104  : 
; 105  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  0013f	6a 02		 push	 2
  00141	6a 03		 push	 3
  00143	e8 00 00 00 00	 call	 _depack_getbits
  00148	83 c4 08	 add	 esp, 8
  0014b	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 106  : #ifdef DPK_CHECK
; 107  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 108  : #endif
; 109  : 
; 110  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0014e	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  00151	83 e0 07	 and	 eax, 7
  00154	83 c8 f8	 or	 eax, -8			; fffffff8H
  00157	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 111  : #ifdef DPK_CHECK
; 112  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 113  : 				{
; 114  : WRONG_DISP:
; 115  :  #ifdef DPK_REPERR
; 116  : 					printf("mhmt-depack-megalz.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 117  :  #endif
; 118  : 					return 0;
; 119  : 				}
; 120  : #endif
; 121  : 
; 122  : #ifdef DPK_DEPACK
; 123  : 				success = success && depack_repeat(disp,1);

  0015a	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0015e	74 1e		 je	 SHORT $LN23@depacker_m
  00160	6a 01		 push	 1
  00162	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _depack_repeat
  0016b	83 c4 08	 add	 esp, 8
  0016e	85 c0		 test	 eax, eax
  00170	74 0c		 je	 SHORT $LN23@depacker_m
  00172	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv143[ebp], 1
  0017c	eb 0a		 jmp	 SHORT $LN24@depacker_m
$LN23@depacker_m:
  0017e	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv143[ebp], 0
$LN24@depacker_m:
  00188	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv143[ebp]
  0018e	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 124  : #endif
; 125  : 				break;

  00191	e9 a8 01 00 00	 jmp	 $LN13@depacker_m
$LN9@depacker_m:

; 126  : 
; 127  : 
; 128  : 			case 0x01: // %001
; 129  : 
; 130  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00196	6a 01		 push	 1
  00198	e8 00 00 00 00	 call	 _depack_getbyte
  0019d	83 c4 04	 add	 esp, 4
  001a0	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 131  : #ifdef DPK_CHECK
; 132  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 133  : #endif
; 134  : 
; 135  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  001a3	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  001a6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ab	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  001b0	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 136  : #ifdef DPK_CHECK
; 137  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 138  : #endif
; 139  : 
; 140  : #ifdef DPK_DEPACK
; 141  : 				success = success && depack_repeat(disp,2);

  001b3	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  001b7	74 1e		 je	 SHORT $LN25@depacker_m
  001b9	6a 02		 push	 2
  001bb	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _depack_repeat
  001c4	83 c4 08	 add	 esp, 8
  001c7	85 c0		 test	 eax, eax
  001c9	74 0c		 je	 SHORT $LN25@depacker_m
  001cb	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  001d5	eb 0a		 jmp	 SHORT $LN26@depacker_m
$LN25@depacker_m:
  001d7	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN26@depacker_m:
  001e1	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv153[ebp]
  001e7	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 142  : #endif
; 143  : 				break;

  001ea	e9 4f 01 00 00	 jmp	 $LN13@depacker_m
$LN8@depacker_m:

; 144  : 
; 145  : 
; 146  : 			case 0x02: // %010
; 147  : 
; 148  : 				length = 3;

  001ef	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _length$[ebp], 3
$FAR_DISP$4093:

; 149  : FAR_DISP:
; 150  : 				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  001f6	6a 02		 push	 2
  001f8	6a 01		 push	 1
  001fa	e8 00 00 00 00	 call	 _depack_getbits
  001ff	83 c4 08	 add	 esp, 8
  00202	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 151  : #ifdef DPK_CHECK
; 152  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 153  : #endif
; 154  : 				if( !(1&bits) ) // -1..-256

  00205	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  00208	83 e0 01	 and	 eax, 1
  0020b	75 58		 jne	 SHORT $LN7@depacker_m

; 155  : 				{
; 156  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0020d	6a 01		 push	 1
  0020f	e8 00 00 00 00	 call	 _depack_getbyte
  00214	83 c4 04	 add	 esp, 4
  00217	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 157  : #ifdef DPK_CHECK
; 158  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 159  : #endif
; 160  : 					disp = (-256) | (0x00FF&byte); // -1..-256

  0021a	8b 45 ec	 mov	 eax, DWORD PTR _byte$[ebp]
  0021d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00222	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00227	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 161  : #ifdef DPK_CHECK
; 162  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 163  : #endif
; 164  : 
; 165  : #ifdef DPK_DEPACK
; 166  : 					success = success && depack_repeat(disp,length);

  0022a	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0022e	74 20		 je	 SHORT $LN27@depacker_m
  00230	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  00233	50		 push	 eax
  00234	8b 4d c8	 mov	 ecx, DWORD PTR _disp$[ebp]
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 _depack_repeat
  0023d	83 c4 08	 add	 esp, 8
  00240	85 c0		 test	 eax, eax
  00242	74 0c		 je	 SHORT $LN27@depacker_m
  00244	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv168[ebp], 1
  0024e	eb 0a		 jmp	 SHORT $LN28@depacker_m
$LN27@depacker_m:
  00250	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv168[ebp], 0
$LN28@depacker_m:
  0025a	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv168[ebp]
  00260	89 55 a4	 mov	 DWORD PTR _success$[ebp], edx

; 167  : #endif
; 168  : 				}
; 169  : 				else // -257..-4352

  00263	eb 6a		 jmp	 SHORT $LN6@depacker_m
$LN7@depacker_m:

; 170  : 				{
; 171  : 					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  00265	6a 02		 push	 2
  00267	6a 04		 push	 4
  00269	e8 00 00 00 00	 call	 _depack_getbits
  0026e	83 c4 08	 add	 esp, 8
  00271	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 172  : #ifdef DPK_CHECK
; 173  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 174  : #endif
; 175  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00274	6a 01		 push	 1
  00276	e8 00 00 00 00	 call	 _depack_getbyte
  0027b	83 c4 04	 add	 esp, 4
  0027e	89 45 ec	 mov	 DWORD PTR _byte$[ebp], eax

; 176  : #ifdef DPK_CHECK
; 177  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 178  : #endif
; 179  : 					disp = ( ((-16)|(15&bits)) - 1 )*0x100 + byte;

  00281	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  00284	83 e0 0f	 and	 eax, 15			; 0000000fH
  00287	83 c8 f0	 or	 eax, -16		; fffffff0H
  0028a	83 e8 01	 sub	 eax, 1
  0028d	c1 e0 08	 shl	 eax, 8
  00290	03 45 ec	 add	 eax, DWORD PTR _byte$[ebp]
  00293	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 180  : #ifdef DPK_CHECK
; 181  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 182  : #endif
; 183  : 
; 184  : #ifdef DPK_DEPACK
; 185  : 					success = success && depack_repeat(disp,length);

  00296	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0029a	74 20		 je	 SHORT $LN29@depacker_m
  0029c	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  0029f	50		 push	 eax
  002a0	8b 4d c8	 mov	 ecx, DWORD PTR _disp$[ebp]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 _depack_repeat
  002a9	83 c4 08	 add	 esp, 8
  002ac	85 c0		 test	 eax, eax
  002ae	74 0c		 je	 SHORT $LN29@depacker_m
  002b0	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv184[ebp], 1
  002ba	eb 0a		 jmp	 SHORT $LN30@depacker_m
$LN29@depacker_m:
  002bc	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv184[ebp], 0
$LN30@depacker_m:
  002c6	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv184[ebp]
  002cc	89 55 a4	 mov	 DWORD PTR _success$[ebp], edx
$LN6@depacker_m:

; 186  : #endif
; 187  : 				}
; 188  : 
; 189  : 				break;

  002cf	eb 6d		 jmp	 SHORT $LN13@depacker_m
$LN5@depacker_m:

; 190  : 
; 191  : 
; 192  : 			case 0x03: // %011 - variable length
; 193  : 
; 194  : 				bitlen = 0;

  002d1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bitlen$[ebp], 0
$LN4@depacker_m:

; 195  : 				do
; 196  : 				{
; 197  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  002d8	6a 02		 push	 2
  002da	6a 01		 push	 1
  002dc	e8 00 00 00 00	 call	 _depack_getbits
  002e1	83 c4 08	 add	 esp, 8
  002e4	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 198  : #ifdef DPK_CHECK
; 199  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 200  : #endif
; 201  : 					bitlen++;

  002e7	8b 45 d4	 mov	 eax, DWORD PTR _bitlen$[ebp]
  002ea	83 c0 01	 add	 eax, 1
  002ed	89 45 d4	 mov	 DWORD PTR _bitlen$[ebp], eax

; 202  : 
; 203  : 				} while ( !(1&bits) );

  002f0	8b 45 e0	 mov	 eax, DWORD PTR _bits$[ebp]
  002f3	83 e0 01	 and	 eax, 1
  002f6	74 e0		 je	 SHORT $LN4@depacker_m

; 204  : 
; 205  : 				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!

  002f8	83 7d d4 09	 cmp	 DWORD PTR _bitlen$[ebp], 9
  002fc	75 09		 jne	 SHORT $LN1@depacker_m

; 206  : 				{
; 207  : 					stop = 1;

  002fe	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 1

; 208  : 					break; // exit switch(){}

  00305	eb 37		 jmp	 SHORT $LN13@depacker_m
$LN1@depacker_m:

; 209  : 				}
; 210  : #ifdef DPK_CHECK
; 211  : 				if( bitlen>7 )
; 212  : 				{
; 213  :  #ifdef DPK_REPERR
; 214  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
; 215  :  #endif
; 216  : 					return 0;
; 217  : 				}
; 218  : #endif
; 219  : 				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);

  00307	6a 02		 push	 2
  00309	8b 45 d4	 mov	 eax, DWORD PTR _bitlen$[ebp]
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 _depack_getbits
  00312	83 c4 08	 add	 esp, 8
  00315	89 45 e0	 mov	 DWORD PTR _bits$[ebp], eax

; 220  : #ifdef DPK_CHECK
; 221  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 222  : #endif
; 223  : 				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );

  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	8b 4d d4	 mov	 ecx, DWORD PTR _bitlen$[ebp]
  00320	d3 e0		 shl	 eax, cl
  00322	ba 01 00 00 00	 mov	 edx, 1
  00327	8b 4d d4	 mov	 ecx, DWORD PTR _bitlen$[ebp]
  0032a	d3 e2		 shl	 edx, cl
  0032c	83 ea 01	 sub	 edx, 1
  0032f	23 55 e0	 and	 edx, DWORD PTR _bits$[ebp]
  00332	8d 44 10 02	 lea	 eax, DWORD PTR [eax+edx+2]
  00336	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 224  : #ifdef DPK_CHECK
; 225  : 				if( length>255 )
; 226  : 				{
; 227  :  #ifdef DPK_REPERR
; 228  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
; 229  :  #endif
; 230  : 					return 0;
; 231  : 				}
; 232  : #endif
; 233  : 				goto FAR_DISP;

  00339	e9 b8 fe ff ff	 jmp	 $FAR_DISP$4093
$LN13@depacker_m:

; 234  : 
; 235  : 				break;
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	}

  0033e	e9 4e fd ff ff	 jmp	 $LN16@depacker_m
$LN15@depacker_m:

; 240  : 
; 241  : 	return success;

  00343	8b 45 a4	 mov	 eax, DWORD PTR _success$[ebp]

; 242  : }

  00346	5f		 pop	 edi
  00347	5e		 pop	 esi
  00348	5b		 pop	 ebx
  00349	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  0034f	3b ec		 cmp	 ebp, esp
  00351	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00356	8b e5		 mov	 esp, ebp
  00358	5d		 pop	 ebp
  00359	c3		 ret	 0
  0035a	8b ff		 npad	 2
$LN31@depacker_m:
  0035c	00 00 00 00	 DD	 $LN10@depacker_m
  00360	00 00 00 00	 DD	 $LN9@depacker_m
  00364	00 00 00 00	 DD	 $LN8@depacker_m
  00368	00 00 00 00	 DD	 $LN5@depacker_m
_depacker_megalz ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\d\mhmt\src\mhmt-depack-hrum.c
_TEXT	ENDS
;	COMDAT _depacker_hrum
_TEXT	SEGMENT
tv239 = -292						; size = 4
tv222 = -292						; size = 4
tv206 = -292						; size = 4
tv162 = -292						; size = 4
tv152 = -292						; size = 4
tv141 = -292						; size = 4
tv136 = -292						; size = 4
tv87 = -292						; size = 4
_success$ = -92						; size = 4
_stop$ = -80						; size = 4
_length$ = -68						; size = 4
_disp$ = -56						; size = 4
_bits$ = -44						; size = 4
_byte$ = -32						; size = 4
_check$ = -20						; size = 4
_i$ = -8						; size = 4
_depacker_hrum PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 	LONG  disp;
; 14   : 	ULONG length;
; 15   : 
; 16   : 	ULONG stop;
; 17   : 
; 18   : 
; 19   : 	ULONG success = 1;

  0001e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 20   : 
; 21   : 
; 22   : 	// rewind input stream
; 23   : 	//
; 24   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _depack_getbyte
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 25   : #ifdef DPK_CHECK
; 26   : 	if( 0xFFFFFFFF == check )
; 27   : 	{
; 28   :  #ifdef DPK_REPERR
; 29   : 		printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 30   :  #endif
; 31   : 		return 0;
; 32   : 	}
; 33   : #endif
; 34   : 
; 35   : 
; 36   : 	// manage zx header if needed
; 37   : 	if( wrk.zxheader )

  00032	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00039	74 4e		 je	 SHORT $LN50@depacker_h

; 38   : 	{
; 39   : 		// skip 5 bytes (they will go to the end of output file)
; 40   : 		for(i=0;i<5;i++)

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN49@depacker_h
$LN48@depacker_h:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN49@depacker_h:
  0004d	83 7d f8 05	 cmp	 DWORD PTR _i$[ebp], 5
  00051	7d 0f		 jge	 SHORT $LN47@depacker_h

; 41   : 		{
; 42   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00053	6a 01		 push	 1
  00055	e8 00 00 00 00	 call	 _depack_getbyte
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 43   : #ifdef DPK_CHECK
; 44   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
; 45   : #endif
; 46   : 		}

  00060	eb e2		 jmp	 SHORT $LN48@depacker_h
$LN47@depacker_h:

; 47   : 
; 48   : 		// next 2 bytes must be 0x10
; 49   : 		for(i=0;i<2;i++)

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00069	eb 09		 jmp	 SHORT $LN46@depacker_h
$LN45@depacker_h:
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN46@depacker_h:
  00074	83 7d f8 02	 cmp	 DWORD PTR _i$[ebp], 2
  00078	7d 0f		 jge	 SHORT $LN50@depacker_h

; 50   : 		{
; 51   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0007a	6a 01		 push	 1
  0007c	e8 00 00 00 00	 call	 _depack_getbyte
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 52   : #ifdef DPK_CHECK
; 53   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
; 54   : 			if( check != 0x0010 )
; 55   : 			{
; 56   :  #ifdef DPK_REPERR
; 57   : 				printf("mhmt-depack-hrum.c:{} - Wrong ZX-header!\n");
; 58   :  #endif
; 59   : 				return 0;
; 60   : 			}
; 61   : #endif
; 62   : 		}

  00087	eb e2		 jmp	 SHORT $LN45@depacker_h
$LN50@depacker_h:

; 63   : 	}
; 64   : 
; 65   : 
; 66   : 
; 67   : 	// initialize bitstream first
; 68   : 	//
; 69   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  00089	6a 01		 push	 1
  0008b	6a 10		 push	 16			; 00000010H
  0008d	e8 00 00 00 00	 call	 _depack_getbits
  00092	83 c4 08	 add	 esp, 8
  00095	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 70   : #ifdef DPK_CHECK
; 71   : 	if( 0xFFFFFFFF == check )
; 72   : 	{
; 73   : NO_BITS_HRM:
; 74   :  #ifdef DPK_REPERR
; 75   : 		printf("mhmt-depack-hrum.c:{} - Can't get bits from input stream!\n");
; 76   :  #endif
; 77   : 		return 0;
; 78   : 	}
; 79   : #endif
; 80   : 
; 81   : 
; 82   : 
; 83   : 	// then byte of input stream goes to the output unchanged
; 84   : 	//
; 85   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00098	6a 01		 push	 1
  0009a	e8 00 00 00 00	 call	 _depack_getbyte
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 86   : #ifdef DPK_CHECK
; 87   : 	if( 0xFFFFFFFF == byte )
; 88   : 	{
; 89   : NO_BYTE_HRM:
; 90   :  #ifdef DPK_REPERR
; 91   : 		printf("mhmt-depack-hrum.c:{} - Can't get byte from input stream!\n");
; 92   :  #endif
; 93   : 		return 0;
; 94   : 	}
; 95   : #endif
; 96   : 
; 97   : #ifdef DPK_DEPACK
; 98   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  000a5	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  000a9	74 23		 je	 SHORT $LN53@depacker_h
  000ab	6a 02		 push	 2
  000ad	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  000b0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _depack_outbyte
  000bb	83 c4 08	 add	 esp, 8
  000be	85 c0		 test	 eax, eax
  000c0	74 0c		 je	 SHORT $LN53@depacker_h
  000c2	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv87[ebp], 1
  000cc	eb 0a		 jmp	 SHORT $LN54@depacker_h
$LN53@depacker_h:
  000ce	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
$LN54@depacker_h:
  000d8	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  000de	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 99   : #endif
; 100  : 
; 101  : 
; 102  : 
; 103  : 	// now normal depacking loop
; 104  : 	//
; 105  : 	stop = 0;

  000e1	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 0
$LN43@depacker_h:

; 106  : 	while( (!stop) && success )

  000e8	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  000ec	0f 85 69 03 00
	00		 jne	 $LN42@depacker_h
  000f2	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  000f6	0f 84 5f 03 00
	00		 je	 $LN42@depacker_h

; 107  :  	{
; 108  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  000fc	6a 02		 push	 2
  000fe	6a 01		 push	 1
  00100	e8 00 00 00 00	 call	 _depack_getbits
  00105	83 c4 08	 add	 esp, 8
  00108	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 109  : #ifdef DPK_CHECK
; 110  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 111  : #endif
; 112  : 
; 113  : 		if( 1&bits ) // %1<byte>

  0010b	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  0010e	83 e0 01	 and	 eax, 1
  00111	74 4e		 je	 SHORT $LN41@depacker_h

; 114  : 		{
; 115  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00113	6a 01		 push	 1
  00115	e8 00 00 00 00	 call	 _depack_getbyte
  0011a	83 c4 04	 add	 esp, 4
  0011d	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 116  : #ifdef DPK_CHECK
; 117  : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 118  : #endif
; 119  : 
; 120  : #ifdef DPK_DEPACK
; 121  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00120	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00124	74 23		 je	 SHORT $LN55@depacker_h
  00126	6a 02		 push	 2
  00128	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  0012b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _depack_outbyte
  00136	83 c4 08	 add	 esp, 8
  00139	85 c0		 test	 eax, eax
  0013b	74 0c		 je	 SHORT $LN55@depacker_h
  0013d	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
  00147	eb 0a		 jmp	 SHORT $LN56@depacker_h
$LN55@depacker_h:
  00149	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN56@depacker_h:
  00153	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv136[ebp]
  00159	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 122  : #endif
; 123  : 		}
; 124  : 		else // %0xx

  0015c	e9 f5 02 00 00	 jmp	 $LN40@depacker_h
$LN41@depacker_h:

; 125  : 		{
; 126  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00161	6a 02		 push	 2
  00163	6a 02		 push	 2
  00165	e8 00 00 00 00	 call	 _depack_getbits
  0016a	83 c4 08	 add	 esp, 8
  0016d	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 127  : #ifdef DPK_CHECK
; 128  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 129  : #endif
; 130  : 
; 131  : 			switch( 0x03 & bits )

  00170	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00173	83 e0 03	 and	 eax, 3
  00176	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  0017c	74 0e		 je	 SHORT $LN37@depacker_h
  0017e	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR tv141[ebp], 1
  00185	74 5c		 je	 SHORT $LN36@depacker_h
  00187	e9 b0 00 00 00	 jmp	 $LN35@depacker_h
$LN37@depacker_h:

; 132  : 			{
; 133  : 			case 0x00: // %000xxx
; 134  : 
; 135  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  0018c	6a 02		 push	 2
  0018e	6a 03		 push	 3
  00190	e8 00 00 00 00	 call	 _depack_getbits
  00195	83 c4 08	 add	 esp, 8
  00198	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 136  : #ifdef DPK_CHECK
; 137  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 138  : #endif
; 139  : 
; 140  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0019b	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  0019e	83 e0 07	 and	 eax, 7
  001a1	83 c8 f8	 or	 eax, -8			; fffffff8H
  001a4	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 141  : #ifdef DPK_CHECK
; 142  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 143  : 				{
; 144  : WRONG_DISP_HRM:
; 145  :  #ifdef DPK_REPERR
; 146  : 					printf("mhmt-depack-hrum.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 147  :  #endif
; 148  : 					return 0;
; 149  : 				}
; 150  : #endif
; 151  : 
; 152  : #ifdef DPK_DEPACK
; 153  : 				success = success && depack_repeat(disp,1);

  001a7	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  001ab	74 1e		 je	 SHORT $LN57@depacker_h
  001ad	6a 01		 push	 1
  001af	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 _depack_repeat
  001b8	83 c4 08	 add	 esp, 8
  001bb	85 c0		 test	 eax, eax
  001bd	74 0c		 je	 SHORT $LN57@depacker_h
  001bf	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv152[ebp], 1
  001c9	eb 0a		 jmp	 SHORT $LN58@depacker_h
$LN57@depacker_h:
  001cb	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
$LN58@depacker_h:
  001d5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv152[ebp]
  001db	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 154  : #endif
; 155  : 				break;

  001de	e9 73 02 00 00	 jmp	 $LN40@depacker_h
$LN36@depacker_h:

; 156  : 
; 157  : 
; 158  : 			case 0x01: // %001
; 159  : 
; 160  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  001e3	6a 01		 push	 1
  001e5	e8 00 00 00 00	 call	 _depack_getbyte
  001ea	83 c4 04	 add	 esp, 4
  001ed	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 161  : #ifdef DPK_CHECK
; 162  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 163  : #endif
; 164  : 
; 165  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  001f0	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  001f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001f8	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  001fd	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 166  : #ifdef DPK_CHECK
; 167  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 168  : #endif
; 169  : 
; 170  : #ifdef DPK_DEPACK
; 171  : 				success = success && depack_repeat(disp,2);

  00200	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00204	74 1e		 je	 SHORT $LN59@depacker_h
  00206	6a 02		 push	 2
  00208	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 _depack_repeat
  00211	83 c4 08	 add	 esp, 8
  00214	85 c0		 test	 eax, eax
  00216	74 0c		 je	 SHORT $LN59@depacker_h
  00218	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv162[ebp], 1
  00222	eb 0a		 jmp	 SHORT $LN60@depacker_h
$LN59@depacker_h:
  00224	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv162[ebp], 0
$LN60@depacker_h:
  0022e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv162[ebp]
  00234	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 172  : #endif
; 173  : 				break;

  00237	e9 1a 02 00 00	 jmp	 $LN40@depacker_h
$LN35@depacker_h:

; 174  : 
; 175  : 			default: // %010 or %011
; 176  : 
; 177  : 				if( (bits&3)==2 ) // %010 - 3 bytes

  0023c	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  0023f	83 e0 03	 and	 eax, 3
  00242	83 f8 02	 cmp	 eax, 2
  00245	75 0c		 jne	 SHORT $LN34@depacker_h

; 178  : 				{
; 179  : 					length = 3;

  00247	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _length$[ebp], 3

; 180  : 				}
; 181  : 				else // %011 - varlen

  0024e	e9 19 01 00 00	 jmp	 $LN33@depacker_h
$LN34@depacker_h:

; 182  : 				{
; 183  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00253	6a 02		 push	 2
  00255	6a 02		 push	 2
  00257	e8 00 00 00 00	 call	 _depack_getbits
  0025c	83 c4 08	 add	 esp, 8
  0025f	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 184  : #ifdef DPK_CHECK
; 185  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 186  : #endif
; 187  : 					//  fetch len
; 188  : 					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop

  00262	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00266	75 1f		 jne	 SHORT $LN32@depacker_h

; 189  : 					{
; 190  : 						length = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00268	6a 01		 push	 1
  0026a	e8 00 00 00 00	 call	 _depack_getbyte
  0026f	83 c4 04	 add	 esp, 4
  00272	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 191  : #ifdef DPK_CHECK
; 192  : 						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;
; 193  : #endif
; 194  : 						if( length == 0 )

  00275	83 7d bc 00	 cmp	 DWORD PTR _length$[ebp], 0
  00279	75 07		 jne	 SHORT $LN31@depacker_h

; 195  : 							stop = 1;

  0027b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 1
$LN31@depacker_h:

; 196  : 					}
; 197  : 					else if( bits == 0x01 ) // %01101 - len=4

  00282	e9 e5 00 00 00	 jmp	 $LN33@depacker_h
$LN32@depacker_h:
  00287	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  0028b	75 0c		 jne	 SHORT $LN29@depacker_h

; 198  : 					{
; 199  : 						length = 4;

  0028d	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _length$[ebp], 4
  00294	e9 d3 00 00 00	 jmp	 $LN33@depacker_h
$LN29@depacker_h:

; 200  : 					}
; 201  : 					else if( bits == 0x02 ) // %01110 - len=5

  00299	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  0029d	75 0c		 jne	 SHORT $LN27@depacker_h

; 202  : 					{
; 203  : 						length = 5;

  0029f	c7 45 bc 05 00
	00 00		 mov	 DWORD PTR _length$[ebp], 5

; 204  : 					}
; 205  : 					else // %01111

  002a6	e9 c1 00 00 00	 jmp	 $LN33@depacker_h
$LN27@depacker_h:

; 206  : 					{
; 207  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  002ab	6a 02		 push	 2
  002ad	6a 02		 push	 2
  002af	e8 00 00 00 00	 call	 _depack_getbits
  002b4	83 c4 08	 add	 esp, 8
  002b7	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 208  : #ifdef DPK_CHECK
; 209  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 210  : #endif
; 211  : 						if( bits == 0x00 ) // %0111100

  002ba	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  002be	75 0c		 jne	 SHORT $LN25@depacker_h

; 212  : 						{
; 213  : 							length = 6;

  002c0	c7 45 bc 06 00
	00 00		 mov	 DWORD PTR _length$[ebp], 6
  002c7	e9 a0 00 00 00	 jmp	 $LN33@depacker_h
$LN25@depacker_h:

; 214  : 						}
; 215  : 						else if( bits == 0x01 ) // %0111101

  002cc	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  002d0	75 0c		 jne	 SHORT $LN23@depacker_h

; 216  : 						{
; 217  : 							length = 7;

  002d2	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR _length$[ebp], 7
  002d9	e9 8e 00 00 00	 jmp	 $LN33@depacker_h
$LN23@depacker_h:

; 218  : 						}
; 219  : 						else if( bits == 0x02 ) // %0111110

  002de	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  002e2	75 09		 jne	 SHORT $LN21@depacker_h

; 220  : 						{
; 221  : 							length = 8;

  002e4	c7 45 bc 08 00
	00 00		 mov	 DWORD PTR _length$[ebp], 8

; 222  : 						}
; 223  : 						else // %0111111

  002eb	eb 7f		 jmp	 SHORT $LN33@depacker_h
$LN21@depacker_h:

; 224  : 						{
; 225  : 							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  002ed	6a 02		 push	 2
  002ef	6a 02		 push	 2
  002f1	e8 00 00 00 00	 call	 _depack_getbits
  002f6	83 c4 08	 add	 esp, 8
  002f9	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 226  : #ifdef DPK_CHECK
; 227  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 228  : #endif
; 229  : 							if( bits == 0x00 ) // %011111100

  002fc	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00300	75 09		 jne	 SHORT $LN19@depacker_h

; 230  : 							{
; 231  : 								length = 9;

  00302	c7 45 bc 09 00
	00 00		 mov	 DWORD PTR _length$[ebp], 9
  00309	eb 61		 jmp	 SHORT $LN33@depacker_h
$LN19@depacker_h:

; 232  : 							}
; 233  : 							else if( bits == 0x01 ) // %011111101

  0030b	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  0030f	75 09		 jne	 SHORT $LN17@depacker_h

; 234  : 							{
; 235  : 								length = 10;

  00311	c7 45 bc 0a 00
	00 00		 mov	 DWORD PTR _length$[ebp], 10 ; 0000000aH
  00318	eb 52		 jmp	 SHORT $LN33@depacker_h
$LN17@depacker_h:

; 236  : 							}
; 237  : 							else if( bits == 0x02 ) // %011111110

  0031a	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  0031e	75 09		 jne	 SHORT $LN15@depacker_h

; 238  : 							{
; 239  : 								length = 11;

  00320	c7 45 bc 0b 00
	00 00		 mov	 DWORD PTR _length$[ebp], 11 ; 0000000bH

; 240  : 							}
; 241  : 							else // %011111111

  00327	eb 43		 jmp	 SHORT $LN33@depacker_h
$LN15@depacker_h:

; 242  : 							{
; 243  : 								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00329	6a 02		 push	 2
  0032b	6a 02		 push	 2
  0032d	e8 00 00 00 00	 call	 _depack_getbits
  00332	83 c4 08	 add	 esp, 8
  00335	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 244  : #ifdef DPK_CHECK
; 245  : 								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 246  : #endif
; 247  : 								if( bits == 0x00 ) // %01111111100

  00338	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  0033c	75 09		 jne	 SHORT $LN13@depacker_h

; 248  : 								{
; 249  : 									length = 12;

  0033e	c7 45 bc 0c 00
	00 00		 mov	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  00345	eb 25		 jmp	 SHORT $LN33@depacker_h
$LN13@depacker_h:

; 250  : 								}
; 251  : 								else if( bits == 0x01 ) // %01111111101

  00347	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  0034b	75 09		 jne	 SHORT $LN11@depacker_h

; 252  : 								{
; 253  : 									length = 13;

  0034d	c7 45 bc 0d 00
	00 00		 mov	 DWORD PTR _length$[ebp], 13 ; 0000000dH
  00354	eb 16		 jmp	 SHORT $LN33@depacker_h
$LN11@depacker_h:

; 254  : 								}
; 255  : 								else if( bits == 0x02 ) // %01111111110

  00356	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  0035a	75 09		 jne	 SHORT $LN9@depacker_h

; 256  : 								{
; 257  : 									length = 14;

  0035c	c7 45 bc 0e 00
	00 00		 mov	 DWORD PTR _length$[ebp], 14 ; 0000000eH

; 258  : 								}
; 259  : 								else // %01111111111

  00363	eb 07		 jmp	 SHORT $LN33@depacker_h
$LN9@depacker_h:

; 260  : 								{
; 261  : 									length = 15;

  00365	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _length$[ebp], 15 ; 0000000fH
$LN33@depacker_h:

; 262  : 								}
; 263  : 							}
; 264  : 						}
; 265  : 					}
; 266  : 				}
; 267  : 
; 268  : 
; 269  : 				// fetch disp and depack
; 270  : 				if( !stop )

  0036c	83 7d b0 00	 cmp	 DWORD PTR _stop$[ebp], 0
  00370	0f 85 e0 00 00
	00		 jne	 $LN40@depacker_h

; 271  : 				{
; 272  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00376	6a 02		 push	 2
  00378	6a 01		 push	 1
  0037a	e8 00 00 00 00	 call	 _depack_getbits
  0037f	83 c4 08	 add	 esp, 8
  00382	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 273  : #ifdef DPK_CHECK
; 274  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 275  : #endif
; 276  : 					if( bits == 0x00 ) // %0<disp>

  00385	83 7d d4 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00389	75 58		 jne	 SHORT $LN6@depacker_h

; 277  : 					{
; 278  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0038b	6a 01		 push	 1
  0038d	e8 00 00 00 00	 call	 _depack_getbyte
  00392	83 c4 04	 add	 esp, 4
  00395	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 279  : #ifdef DPK_CHECK
; 280  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 281  : #endif
; 282  : 						disp = (-256) | (0x00FF&byte); // -1..-256

  00398	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  0039b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a0	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  003a5	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 283  : #ifdef DPK_CHECK
; 284  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 285  : #endif
; 286  : #ifdef DPK_DEPACK
; 287  : 						success = success && depack_repeat(disp,length);

  003a8	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  003ac	74 20		 je	 SHORT $LN61@depacker_h
  003ae	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  003b1	50		 push	 eax
  003b2	8b 4d c8	 mov	 ecx, DWORD PTR _disp$[ebp]
  003b5	51		 push	 ecx
  003b6	e8 00 00 00 00	 call	 _depack_repeat
  003bb	83 c4 08	 add	 esp, 8
  003be	85 c0		 test	 eax, eax
  003c0	74 0c		 je	 SHORT $LN61@depacker_h
  003c2	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv206[ebp], 1
  003cc	eb 0a		 jmp	 SHORT $LN62@depacker_h
$LN61@depacker_h:
  003ce	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv206[ebp], 0
$LN62@depacker_h:
  003d8	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv206[ebp]
  003de	89 55 a4	 mov	 DWORD PTR _success$[ebp], edx

; 288  : #endif
; 289  : 					}
; 290  : 					else // %1abcd<disp>

  003e1	eb 73		 jmp	 SHORT $LN40@depacker_h
$LN6@depacker_h:

; 291  : 					{
; 292  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  003e3	6a 02		 push	 2
  003e5	6a 04		 push	 4
  003e7	e8 00 00 00 00	 call	 _depack_getbits
  003ec	83 c4 08	 add	 esp, 8
  003ef	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 293  : #ifdef DPK_CHECK
; 294  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 295  : #endif
; 296  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  003f2	6a 01		 push	 1
  003f4	e8 00 00 00 00	 call	 _depack_getbyte
  003f9	83 c4 04	 add	 esp, 4
  003fc	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 297  : #ifdef DPK_CHECK
; 298  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 299  : #endif
; 300  : 						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096

  003ff	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00402	c1 e0 08	 shl	 eax, 8
  00405	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  0040a	0d 00 f0 ff ff	 or	 eax, -4096		; fffff000H
  0040f	8b 4d e0	 mov	 ecx, DWORD PTR _byte$[ebp]
  00412	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00418	0b c1		 or	 eax, ecx
  0041a	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 301  : #ifdef DPK_CHECK
; 302  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 303  : #endif
; 304  : #ifdef DPK_DEPACK
; 305  : 						success = success && depack_repeat(disp,length);

  0041d	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00421	74 20		 je	 SHORT $LN63@depacker_h
  00423	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  00426	50		 push	 eax
  00427	8b 4d c8	 mov	 ecx, DWORD PTR _disp$[ebp]
  0042a	51		 push	 ecx
  0042b	e8 00 00 00 00	 call	 _depack_repeat
  00430	83 c4 08	 add	 esp, 8
  00433	85 c0		 test	 eax, eax
  00435	74 0c		 je	 SHORT $LN63@depacker_h
  00437	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv222[ebp], 1
  00441	eb 0a		 jmp	 SHORT $LN64@depacker_h
$LN63@depacker_h:
  00443	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
$LN64@depacker_h:
  0044d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv222[ebp]
  00453	89 55 a4	 mov	 DWORD PTR _success$[ebp], edx
$LN40@depacker_h:

; 306  : #endif
; 307  : 					}
; 308  : 				}
; 309  : 
; 310  : 				break;
; 311  : 			}
; 312  : 		}
; 313  : 	}

  00456	e9 8d fc ff ff	 jmp	 $LN43@depacker_h
$LN42@depacker_h:

; 314  : 
; 315  : 	//manage zxheader again (copy to the end of output)
; 316  : #ifdef DPK_DEPACK
; 317  : 	if( wrk.zxheader )

  0045b	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00462	74 70		 je	 SHORT $LN4@depacker_h

; 318  : 	{
; 319  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00464	6a 00		 push	 0
  00466	e8 00 00 00 00	 call	 _depack_getbyte
  0046b	83 c4 04	 add	 esp, 4
  0046e	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 320  :  #ifdef DPK_CHECK
; 321  : 		if( 0xFFFFFFFF == check )
; 322  : 		{
; 323  :   #ifdef DPK_REPERR
; 324  : 			printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 325  :   #endif
; 326  : 			return 0;
; 327  : 		}
; 328  :  #endif
; 329  : 
; 330  : 		// place 5 bytes of header to the end
; 331  : 		for(i=0;i<5;i++)

  00471	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00478	eb 09		 jmp	 SHORT $LN3@depacker_h
$LN2@depacker_h:
  0047a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0047d	83 c0 01	 add	 eax, 1
  00480	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@depacker_h:
  00483	83 7d f8 05	 cmp	 DWORD PTR _i$[ebp], 5
  00487	7d 4b		 jge	 SHORT $LN4@depacker_h

; 332  : 		{
; 333  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00489	6a 01		 push	 1
  0048b	e8 00 00 00 00	 call	 _depack_getbyte
  00490	83 c4 04	 add	 esp, 4
  00493	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 334  :  #ifdef DPK_CHECK
; 335  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
; 336  :  #endif
; 337  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00496	83 7d a4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0049a	74 23		 je	 SHORT $LN65@depacker_h
  0049c	6a 02		 push	 2
  0049e	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  004a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004a6	50		 push	 eax
  004a7	e8 00 00 00 00	 call	 _depack_outbyte
  004ac	83 c4 08	 add	 esp, 8
  004af	85 c0		 test	 eax, eax
  004b1	74 0c		 je	 SHORT $LN65@depacker_h
  004b3	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv239[ebp], 1
  004bd	eb 0a		 jmp	 SHORT $LN66@depacker_h
$LN65@depacker_h:
  004bf	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv239[ebp], 0
$LN66@depacker_h:
  004c9	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv239[ebp]
  004cf	89 4d a4	 mov	 DWORD PTR _success$[ebp], ecx

; 338  : 		}

  004d2	eb a6		 jmp	 SHORT $LN2@depacker_h
$LN4@depacker_h:

; 339  : 	}
; 340  : #endif
; 341  : 
; 342  : 	return success;

  004d4	8b 45 a4	 mov	 eax, DWORD PTR _success$[ebp]

; 343  : }

  004d7	5f		 pop	 edi
  004d8	5e		 pop	 esi
  004d9	5b		 pop	 ebx
  004da	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  004e0	3b ec		 cmp	 ebp, esp
  004e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004e7	8b e5		 mov	 esp, ebp
  004e9	5d		 pop	 ebp
  004ea	c3		 ret	 0
_depacker_hrum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@ ; `string'
PUBLIC	??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@ ; `string'
PUBLIC	??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@ ; `string'
PUBLIC	??_C@_0L@KFHJGGOL@expansion?6?$AA@		; `string'
PUBLIC	??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ ; `string'
PUBLIC	??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ ; `string'
PUBLIC	??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@ ; `string'
PUBLIC	??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@ ; `string'
EXTRN	__RTC_UninitUse:PROC
;	COMDAT ??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
; File d:\d\mhmt\src\mhmt-depack-hrust.c
CONST	SEGMENT
??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ DB 'i'
	DB	'nsert-match.len=%d,disp=%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ DB 'match.le'
	DB	'n=%d,disp=%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@ DB 'copy.len=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@
CONST	SEGMENT
??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - Wrong lookback displacement of %d, gre'
	DB	'ater than maxwin', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@
CONST	SEGMENT
??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - Wrong displacement in disptype!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@
CONST	SEGMENT
??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - bitlen of expandable displacement expa'
	DB	'nded more than 16 bits!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KFHJGGOL@expansion?6?$AA@
CONST	SEGMENT
??_C@_0L@KFHJGGOL@expansion?6?$AA@ DB 'expansion', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
CONST	SEGMENT
??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
CONST	SEGMENT
??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@
CONST	SEGMENT
??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Bad zx-header!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@
CONST	SEGMENT
??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _depacker_hrust
_TEXT	SEGMENT
tv379 = -376						; size = 4
tv356 = -376						; size = 4
tv350 = -376						; size = 4
tv342 = -376						; size = 4
tv329 = -376						; size = 4
tv316 = -376						; size = 4
tv240 = -376						; size = 4
tv189 = -376						; size = 4
tv158 = -376						; size = 4
tv146 = -376						; size = 4
tv132 = -376						; size = 4
$T4524 = -365						; size = 1
$T4525 = -353						; size = 1
_success$ = -152					; size = 4
_stop$ = -140						; size = 4
_expbitlen$ = -128					; size = 4
_docopy$ = -116						; size = 4
_disptype$ = -104					; size = 4
_skiplen$ = -92						; size = 4
_skipdisp$ = -80					; size = 4
_length$ = -68						; size = 4
_disp$ = -56						; size = 4
_bits$ = -44						; size = 4
_byte$ = -32						; size = 4
_check$ = -20						; size = 4
_i$ = -8						; size = 4
_depacker_hrust PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 93 fe ff
	ff 00		 mov	 BYTE PTR $T4524[ebp], 0
  00025	c6 85 9f fe ff
	ff 00		 mov	 BYTE PTR $T4525[ebp], 0

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 
; 14   : 	LONG   disp;
; 15   : 	LONG length; // if -3 - insertion match, if 0 - nothing to do
; 16   : 
; 17   : 	ULONG skipdisp,skiplen;
; 18   : 
; 19   : 	ULONG disptype;
; 20   : // fetch byte and add to existing disp
; 21   : #define DISP_PLUSBYTE 0
; 22   : // fetch 5 bits to disp
; 23   : #define DISP_ABCDE    1
; 24   : // common disp for 3+ lengthes
; 25   : #define DISP_COMMON   2
; 26   : 
; 27   : 	ULONG docopy; // do copy from input instead of repeating
; 28   : 
; 29   : 	ULONG expbitlen = 2; // expandable displacement

  0002c	c7 45 80 02 00
	00 00		 mov	 DWORD PTR _expbitlen$[ebp], 2

; 30   : 
; 31   : 
; 32   : 	ULONG stop;
; 33   : 
; 34   : 
; 35   : 	ULONG success = 1;

  00033	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _success$[ebp], 1

; 36   : 
; 37   : 
; 38   : 
; 39   : 
; 40   : 
; 41   : 	// rewind input stream
; 42   : 	//
; 43   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  0003d	6a 00		 push	 0
  0003f	e8 00 00 00 00	 call	 _depack_getbyte
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 44   : #ifdef DPK_CHECK
; 45   : 	if( 0xFFFFFFFF == check )

  0004a	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  0004e	75 1e		 jne	 SHORT $LN109@depacker_h@2

; 46   : 	{
; 47   :  #ifdef DPK_REPERR
; 48   : 		printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");

  00050	8b f4		 mov	 esi, esp
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0005d	83 c4 04	 add	 esp, 4
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 49   :  #endif
; 50   : 		return 0;

  00067	33 c0		 xor	 eax, eax
  00069	e9 70 0d 00 00	 jmp	 $LN110@depacker_h@2
$LN109@depacker_h@2:

; 51   : 	}
; 52   : #endif
; 53   : 
; 54   : 
; 55   : 	// manage zx header if needed
; 56   : 	if( wrk.zxheader )

  0006e	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00075	0f 84 a7 00 00
	00		 je	 $LN108@depacker_h@2

; 57   : 	{
; 58   : 		// check for "HR" in beginning
; 59   : 		check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0007b	6a 01		 push	 1
  0007d	e8 00 00 00 00	 call	 _depack_getbyte
  00082	83 c4 04	 add	 esp, 4
  00085	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 60   : #ifdef DPK_CHECK
; 61   : 		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00088	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  0008c	75 05		 jne	 SHORT $LN107@depacker_h@2
  0008e	e9 d5 00 00 00	 jmp	 $NO_BYTE_HST$4187
$LN107@depacker_h@2:

; 62   : 		if( check != 'H' )

  00093	83 7d ec 48	 cmp	 DWORD PTR _check$[ebp], 72 ; 00000048H
  00097	74 1e		 je	 SHORT $LN106@depacker_h@2

; 63   : 		{
; 64   :  #ifdef DPK_REPERR
; 65   : 			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");

  00099	8b f4		 mov	 esi, esp
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000a6	83 c4 04	 add	 esp, 4
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   :  #endif
; 67   : 			return 0;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 27 0d 00 00	 jmp	 $LN110@depacker_h@2
$LN106@depacker_h@2:

; 68   : 		}
; 69   : #endif
; 70   : 		check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000b7	6a 01		 push	 1
  000b9	e8 00 00 00 00	 call	 _depack_getbyte
  000be	83 c4 04	 add	 esp, 4
  000c1	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 71   : #ifdef DPK_CHECK
; 72   : 		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  000c4	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  000c8	75 05		 jne	 SHORT $LN105@depacker_h@2
  000ca	e9 99 00 00 00	 jmp	 $NO_BYTE_HST$4187
$LN105@depacker_h@2:

; 73   : 		if( check != 'R' )

  000cf	83 7d ec 52	 cmp	 DWORD PTR _check$[ebp], 82 ; 00000052H
  000d3	74 1e		 je	 SHORT $LN104@depacker_h@2

; 74   : 		{
; 75   :  #ifdef DPK_REPERR
; 76   : 			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");

  000d5	8b f4		 mov	 esi, esp
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000e2	83 c4 04	 add	 esp, 4
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   :  #endif
; 78   : 			return 0;

  000ec	33 c0		 xor	 eax, eax
  000ee	e9 eb 0c 00 00	 jmp	 $LN110@depacker_h@2
$LN104@depacker_h@2:

; 79   : 		}
; 80   : #endif
; 81   : 
; 82   : 		// skip 10 bytes
; 83   : 		for(i=0;i<10;i++)

  000f3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000fa	eb 09		 jmp	 SHORT $LN103@depacker_h@2
$LN102@depacker_h@2:
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ff	83 c0 01	 add	 eax, 1
  00102	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN103@depacker_h@2:
  00105	83 7d f8 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00109	7d 17		 jge	 SHORT $LN108@depacker_h@2

; 84   : 		{
; 85   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0010b	6a 01		 push	 1
  0010d	e8 00 00 00 00	 call	 _depack_getbyte
  00112	83 c4 04	 add	 esp, 4
  00115	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00118	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  0011c	75 02		 jne	 SHORT $LN100@depacker_h@2
  0011e	eb 48		 jmp	 SHORT $NO_BYTE_HST$4187
$LN100@depacker_h@2:

; 88   : #endif
; 89   : 		}

  00120	eb da		 jmp	 SHORT $LN102@depacker_h@2
$LN108@depacker_h@2:

; 90   : 	}
; 91   : 
; 92   : 
; 93   : 
; 94   : 	// initialize bitstream first
; 95   : 	//
; 96   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  00122	6a 01		 push	 1
  00124	6a 10		 push	 16			; 00000010H
  00126	e8 00 00 00 00	 call	 _depack_getbits
  0012b	83 c4 08	 add	 esp, 8
  0012e	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 97   : #ifdef DPK_CHECK
; 98   : 	if( 0xFFFFFFFF == check )

  00131	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  00135	75 1e		 jne	 SHORT $LN99@depacker_h@2
$NO_BITS_HST$4197:

; 99   : 	{
; 100  : NO_BITS_HST:
; 101  :  #ifdef DPK_REPERR
; 102  : 		printf("mhmt-depack-hrust.c:{} - Can't get bits from input stream!\n");

  00137	8b f4		 mov	 esi, esp
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00144	83 c4 04	 add	 esp, 4
  00147	3b f4		 cmp	 esi, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 103  :  #endif
; 104  : 		return 0;

  0014e	33 c0		 xor	 eax, eax
  00150	e9 89 0c 00 00	 jmp	 $LN110@depacker_h@2
$LN99@depacker_h@2:

; 105  : 	}
; 106  : #endif
; 107  : 
; 108  : 
; 109  : 
; 110  : 	// then byte of input stream goes to the output unchanged
; 111  : 	//
; 112  : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00155	6a 01		 push	 1
  00157	e8 00 00 00 00	 call	 _depack_getbyte
  0015c	83 c4 04	 add	 esp, 4
  0015f	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 113  : #ifdef DPK_CHECK
; 114  : 	if( 0xFFFFFFFF == byte )

  00162	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00166	75 1e		 jne	 SHORT $LN98@depacker_h@2
$NO_BYTE_HST$4187:

; 115  : 	{
; 116  : NO_BYTE_HST:
; 117  :  #ifdef DPK_REPERR
; 118  : 		printf("mhmt-depack-hrust.c:{} - Can't get byte from input stream!\n");

  00168	8b f4		 mov	 esi, esp
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00175	83 c4 04	 add	 esp, 4
  00178	3b f4		 cmp	 esi, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 119  :  #endif
; 120  : 		return 0;

  0017f	33 c0		 xor	 eax, eax
  00181	e9 58 0c 00 00	 jmp	 $LN110@depacker_h@2
$LN98@depacker_h@2:

; 121  : 	}
; 122  : #endif
; 123  : 
; 124  : #ifdef DPK_DEPACK
; 125  : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00186	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  0018d	74 23		 je	 SHORT $LN112@depacker_h@2
  0018f	6a 02		 push	 2
  00191	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00194	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _depack_outbyte
  0019f	83 c4 08	 add	 esp, 8
  001a2	85 c0		 test	 eax, eax
  001a4	74 0c		 je	 SHORT $LN112@depacker_h@2
  001a6	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv132[ebp], 1
  001b0	eb 0a		 jmp	 SHORT $LN113@depacker_h@2
$LN112@depacker_h@2:
  001b2	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv132[ebp], 0
$LN113@depacker_h@2:
  001bc	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv132[ebp]
  001c2	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx

; 126  : #endif
; 127  : 
; 128  : 
; 129  : 
; 130  : 	// now normal depacking loop
; 131  : 	//
; 132  :   	stop = 0;

  001c8	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _stop$[ebp], 0
$LN97@depacker_h@2:

; 133  : 	while( (!stop) && success )

  001d2	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  001d9	0f 85 15 0b 00
	00		 jne	 $LN96@depacker_h@2
  001df	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  001e6	0f 84 08 0b 00
	00		 je	 $LN96@depacker_h@2

; 134  :  	{
; 135  : 		skiplen  = 0;

  001ec	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _skiplen$[ebp], 0

; 136  : 		skipdisp = 0;

  001f3	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _skipdisp$[ebp], 0

; 137  : 		disptype = DISP_PLUSBYTE;

  001fa	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 0

; 138  : 		docopy = 0;

  00201	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _docopy$[ebp], 0

; 139  : 
; 140  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00208	6a 02		 push	 2
  0020a	6a 01		 push	 1
  0020c	e8 00 00 00 00	 call	 _depack_getbits
  00211	83 c4 08	 add	 esp, 8
  00214	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 141  : #ifdef DPK_CHECK
; 142  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00217	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0021b	75 05		 jne	 SHORT $LN95@depacker_h@2
  0021d	e9 15 ff ff ff	 jmp	 $NO_BITS_HST$4197
$LN95@depacker_h@2:

; 143  : #endif
; 144  : 
; 145  : 		if( 1&bits ) // %1<byte>

  00222	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00225	83 e0 01	 and	 eax, 1
  00228	74 1a		 je	 SHORT $LN94@depacker_h@2

; 146  : 		{
; 147  : 			docopy = 1;

  0022a	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _docopy$[ebp], 1

; 148  : 			length = 1;

  00231	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00238	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _length$[ebp], 1

; 149  : 		}
; 150  : 		else // %0xx

  0023f	e9 29 02 00 00	 jmp	 $LN93@depacker_h@2
$LN94@depacker_h@2:

; 151  : 		{
; 152  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00244	6a 02		 push	 2
  00246	6a 02		 push	 2
  00248	e8 00 00 00 00	 call	 _depack_getbits
  0024d	83 c4 08	 add	 esp, 8
  00250	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 153  : #ifdef DPK_CHECK
; 154  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00253	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00257	75 05		 jne	 SHORT $LN92@depacker_h@2
  00259	e9 d9 fe ff ff	 jmp	 $NO_BITS_HST$4197
$LN92@depacker_h@2:

; 155  : #endif
; 156  : 
; 157  : 			switch( bits&3 )

  0025e	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00261	83 e0 03	 and	 eax, 3
  00264	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv146[ebp], eax
  0026a	83 bd 88 fe ff
	ff 03		 cmp	 DWORD PTR tv146[ebp], 3
  00271	0f 87 f6 01 00
	00		 ja	 $LN93@depacker_h@2
  00277	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv146[ebp]
  0027d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN149@depacker_h@2[ecx*4]
$LN89@depacker_h@2:

; 158  : 			{
; 159  : 			case 0: // %000xxx
; 160  : 
; 161  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  00284	6a 02		 push	 2
  00286	6a 03		 push	 3
  00288	e8 00 00 00 00	 call	 _depack_getbits
  0028d	83 c4 08	 add	 esp, 8
  00290	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 162  : #ifdef DPK_CHECK
; 163  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00293	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00297	75 05		 jne	 SHORT $LN88@depacker_h@2
  00299	e9 99 fe ff ff	 jmp	 $NO_BITS_HST$4197
$LN88@depacker_h@2:

; 164  : #endif
; 165  : 
; 166  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0029e	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  002a1	83 e0 07	 and	 eax, 7
  002a4	83 c8 f8	 or	 eax, -8			; fffffff8H
  002a7	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  002ae	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 167  : 				length = 1;

  002b1	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  002b8	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _length$[ebp], 1

; 168  : 
; 169  : 				skiplen  = 1;

  002bf	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _skiplen$[ebp], 1

; 170  : 				skipdisp = 1;

  002c6	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _skipdisp$[ebp], 1

; 171  : 
; 172  : 				break;

  002cd	e9 9b 01 00 00	 jmp	 $LN93@depacker_h@2
$LN87@depacker_h@2:

; 173  : 
; 174  : 
; 175  : 
; 176  : 
; 177  : 
; 178  : 
; 179  : 			case 1: // %001 - 2 bytes or insertion match part 1
; 180  : 
; 181  : 				length = 2;

  002d2	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  002d9	c7 45 bc 02 00
	00 00		 mov	 DWORD PTR _length$[ebp], 2

; 182  : 				skiplen = 1;

  002e0	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _skiplen$[ebp], 1

; 183  : 
; 184  : 				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  002e7	6a 02		 push	 2
  002e9	6a 02		 push	 2
  002eb	e8 00 00 00 00	 call	 _depack_getbits
  002f0	83 c4 08	 add	 esp, 8
  002f3	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 185  : #ifdef DPK_CHECK
; 186  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  002f6	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  002fa	75 05		 jne	 SHORT $LN86@depacker_h@2
  002fc	e9 36 fe ff ff	 jmp	 $NO_BITS_HST$4197
$LN86@depacker_h@2:

; 187  : #endif
; 188  : 
; 189  : 				switch( bits&3 )

  00301	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00304	83 e0 03	 and	 eax, 3
  00307	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv158[ebp], eax
  0030d	83 bd 88 fe ff
	ff 03		 cmp	 DWORD PTR tv158[ebp], 3
  00314	0f 87 2c 01 00
	00		 ja	 $LN84@depacker_h@2
  0031a	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv158[ebp]
  00320	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN150@depacker_h@2[ecx*4]
$LN83@depacker_h@2:

; 190  : 				{
; 191  : 				case 0: // %001 00 - disp FDxx
; 192  : 					//disptype = DISP_PLUSBYTE; // default value
; 193  : 					disp = (-768);

  00327	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  0032e	c7 45 c8 00 fd
	ff ff		 mov	 DWORD PTR _disp$[ebp], -768 ; fffffd00H

; 194  : 
; 195  : 					break;

  00335	e9 0c 01 00 00	 jmp	 $LN84@depacker_h@2
$LN82@depacker_h@2:

; 196  : 
; 197  : 				case 1: // %001 01 - disp FExx
; 198  : 					//disptype = DISP_PLUSBYTE; // default value
; 199  : 					disp = (-512);

  0033a	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00341	c7 45 c8 00 fe
	ff ff		 mov	 DWORD PTR _disp$[ebp], -512 ; fffffe00H

; 200  : 
; 201  : 					break;

  00348	e9 f9 00 00 00	 jmp	 $LN84@depacker_h@2
$LN81@depacker_h@2:

; 202  : 
; 203  : 				case 2: // %001 10 - ff00..ffdf or insertion match
; 204  : 
; 205  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0034d	6a 01		 push	 1
  0034f	e8 00 00 00 00	 call	 _depack_getbyte
  00354	83 c4 04	 add	 esp, 4
  00357	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 206  : #ifdef DPK_CHECK
; 207  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  0035a	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  0035e	75 05		 jne	 SHORT $LN80@depacker_h@2
  00360	e9 03 fe ff ff	 jmp	 $NO_BYTE_HST$4187
$LN80@depacker_h@2:

; 208  : #endif
; 209  : 					skipdisp = 1;

  00365	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _skipdisp$[ebp], 1

; 210  : 
; 211  : 					if( byte<0x00E0 ) // ff00..ffdf

  0036c	81 7d e0 e0 00
	00 00		 cmp	 DWORD PTR _byte$[ebp], 224 ; 000000e0H
  00373	73 1c		 jae	 SHORT $LN79@depacker_h@2

; 212  : 					{
; 213  : 						disp = (-256) | (byte&0x00FF);

  00375	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00378	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0037d	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00382	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00389	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax
  0038c	e9 ac 00 00 00	 jmp	 $LN78@depacker_h@2
$LN79@depacker_h@2:

; 214  : 					}
; 215  : 					else if( byte==0x00FE ) // expand bitlen of expandable displacement

  00391	81 7d e0 fe 00
	00 00		 cmp	 DWORD PTR _byte$[ebp], 254 ; 000000feH
  00398	75 54		 jne	 SHORT $LN77@depacker_h@2

; 216  : 					{
; 217  : 						#ifdef DBG
; 218  : 							printf("expansion\n");

  0039a	8b f4		 mov	 esi, esp
  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KFHJGGOL@expansion?6?$AA@
  003a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003a7	83 c4 04	 add	 esp, 4
  003aa	3b f4		 cmp	 esi, esp
  003ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 219  : 						#endif
; 220  : 
; 221  : 						length = 0; // nothing to do

  003b1	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  003b8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 222  : 						expbitlen++;

  003bf	8b 45 80	 mov	 eax, DWORD PTR _expbitlen$[ebp]
  003c2	83 c0 01	 add	 eax, 1
  003c5	89 45 80	 mov	 DWORD PTR _expbitlen$[ebp], eax

; 223  : #ifdef DPK_CHECK
; 224  : 						if( expbitlen>8 )

  003c8	83 7d 80 08	 cmp	 DWORD PTR _expbitlen$[ebp], 8
  003cc	76 1e		 jbe	 SHORT $LN76@depacker_h@2

; 225  : 						{
; 226  :  #ifdef DPK_REPERR
; 227  : 							printf("mhmt-depack-hrust.c:{} - bitlen of expandable displacement expanded more than 16 bits!\n");

  003ce	8b f4		 mov	 esi, esp
  003d0	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003db	83 c4 04	 add	 esp, 4
  003de	3b f4		 cmp	 esi, esp
  003e0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 228  :  #endif
; 229  : 							return 0;

  003e5	33 c0		 xor	 eax, eax
  003e7	e9 f2 09 00 00	 jmp	 $LN110@depacker_h@2
$LN76@depacker_h@2:

; 230  : 						}
; 231  : #endif
; 232  : 					}
; 233  : 					else // insertion match - xor 2

  003ec	eb 4f		 jmp	 SHORT $LN78@depacker_h@2
$LN77@depacker_h@2:

; 234  : 					{
; 235  : 						length = (-3); // mark insertion match

  003ee	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  003f5	c7 45 bc fd ff
	ff ff		 mov	 DWORD PTR _length$[ebp], -3 ; fffffffdH

; 236  : 
; 237  : 						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1

  003fc	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  003ff	d1 e0		 shl	 eax, 1
  00401	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00406	8b 4d e0	 mov	 ecx, DWORD PTR _byte$[ebp]
  00409	c1 e9 07	 shr	 ecx, 7
  0040c	83 e1 01	 and	 ecx, 1
  0040f	0b c1		 or	 eax, ecx
  00411	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 238  : 						byte ^= 0x02;

  00414	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00417	83 f0 02	 xor	 eax, 2
  0041a	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 239  : 						byte -= 15;

  0041d	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00420	83 e8 0f	 sub	 eax, 15			; 0000000fH
  00423	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 240  : 
; 241  : 						disp = (-256) | (byte&0x00FF);

  00426	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00429	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0042e	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00433	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  0043a	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax
$LN78@depacker_h@2:

; 242  : 					}
; 243  : 					break;

  0043d	eb 07		 jmp	 SHORT $LN84@depacker_h@2
$LN74@depacker_h@2:

; 244  : 
; 245  : 				case 3: // %001 11 - disp FFE0+[abcde]
; 246  : 
; 247  : 					disptype = DISP_ABCDE;

  0043f	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 1
$LN84@depacker_h@2:

; 248  : 
; 249  : 					break;
; 250  : 				}
; 251  : 
; 252  : 				break;

  00446	eb 25		 jmp	 SHORT $LN93@depacker_h@2
$LN73@depacker_h@2:

; 253  : 
; 254  : 
; 255  : 
; 256  : 			case 2: // %010 - 3 bytes or something
; 257  : 
; 258  : 				length = 3;

  00448	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  0044f	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _length$[ebp], 3

; 259  : 				skiplen = 1;

  00456	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _skiplen$[ebp], 1

; 260  : 				disptype = DISP_COMMON;

  0045d	c7 45 98 02 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 2

; 261  : 
; 262  : 				break;

  00464	eb 07		 jmp	 SHORT $LN93@depacker_h@2
$LN72@depacker_h@2:

; 263  : 
; 264  : 
; 265  : 			case 3: // %011 - varlen
; 266  : 
; 267  : 				disptype = DISP_COMMON;

  00466	c7 45 98 02 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 2
$LN93@depacker_h@2:

; 268  : 
; 269  : 				break;
; 270  : 			}
; 271  : 		}
; 272  : 
; 273  : 			if( (!stop) && (!skiplen) && (!docopy) )

  0046d	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  00474	0f 85 3b 02 00
	00		 jne	 $LN71@depacker_h@2
  0047a	83 7d a4 00	 cmp	 DWORD PTR _skiplen$[ebp], 0
  0047e	0f 85 31 02 00
	00		 jne	 $LN71@depacker_h@2
  00484	83 7d 8c 00	 cmp	 DWORD PTR _docopy$[ebp], 0
  00488	0f 85 27 02 00
	00		 jne	 $LN71@depacker_h@2

; 274  : 			{
; 275  : 				// read variable length
; 276  : 				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0048e	6a 02		 push	 2
  00490	6a 02		 push	 2
  00492	e8 00 00 00 00	 call	 _depack_getbits
  00497	83 c4 08	 add	 esp, 8
  0049a	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 277  : #ifdef DPK_CHECK
; 278  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  0049d	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  004a1	75 05		 jne	 SHORT $LN70@depacker_h@2
  004a3	e9 8f fc ff ff	 jmp	 $NO_BITS_HST$4197
$LN70@depacker_h@2:

; 279  : #endif                                                                                  i
; 280  : 				switch( bits&3 )

  004a8	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  004ab	83 e0 03	 and	 eax, 3
  004ae	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  004b4	83 bd 88 fe ff
	ff 03		 cmp	 DWORD PTR tv189[ebp], 3
  004bb	0f 87 f4 01 00
	00		 ja	 $LN71@depacker_h@2
  004c1	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv189[ebp]
  004c7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN151@depacker_h@2[ecx*4]
$LN67@depacker_h@2:

; 281  : 				{
; 282  : 				case 0: // special cases
; 283  : 
; 284  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  004ce	6a 02		 push	 2
  004d0	6a 01		 push	 1
  004d2	e8 00 00 00 00	 call	 _depack_getbits
  004d7	83 c4 08	 add	 esp, 8
  004da	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 285  : #ifdef DPK_CHECK
; 286  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  004dd	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  004e1	75 05		 jne	 SHORT $LN66@depacker_h@2
  004e3	e9 4f fc ff ff	 jmp	 $NO_BITS_HST$4197
$LN66@depacker_h@2:

; 287  : #endif
; 288  : 					if( bits&1 ) // %011 001abcd<byte> - insertion match, displacements -1..-16

  004e8	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  004eb	83 e0 01	 and	 eax, 1
  004ee	74 47		 je	 SHORT $LN65@depacker_h@2

; 289  : 					{
; 290  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  004f0	6a 02		 push	 2
  004f2	6a 04		 push	 4
  004f4	e8 00 00 00 00	 call	 _depack_getbits
  004f9	83 c4 08	 add	 esp, 8
  004fc	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 291  : #ifdef DPK_CHECK
; 292  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  004ff	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00503	75 05		 jne	 SHORT $LN64@depacker_h@2
  00505	e9 2d fc ff ff	 jmp	 $NO_BITS_HST$4197
$LN64@depacker_h@2:

; 293  : #endif
; 294  : 						length = (-3); // mark insertion match

  0050a	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00511	c7 45 bc fd ff
	ff ff		 mov	 DWORD PTR _length$[ebp], -3 ; fffffffdH

; 295  : 
; 296  : 						skipdisp = 1; // prepare displacement

  00518	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _skipdisp$[ebp], 1

; 297  : 						disp = (-16) | (bits&15);

  0051f	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00522	83 e0 0f	 and	 eax, 15			; 0000000fH
  00525	83 c8 f0	 or	 eax, -16		; fffffff0H
  00528	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  0052f	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 298  : 					}
; 299  : 					else

  00532	e9 dd 00 00 00	 jmp	 $LN63@depacker_h@2
$LN65@depacker_h@2:

; 300  : 					{
; 301  : 						bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00537	6a 02		 push	 2
  00539	6a 01		 push	 1
  0053b	e8 00 00 00 00	 call	 _depack_getbits
  00540	83 c4 08	 add	 esp, 8
  00543	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 302  : #ifdef DPK_CHECK
; 303  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00546	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0054a	75 05		 jne	 SHORT $LN62@depacker_h@2
  0054c	e9 e6 fb ff ff	 jmp	 $NO_BITS_HST$4197
$LN62@depacker_h@2:

; 304  : #endif
; 305  : 						if( bits&1 ) // %011 0001abcd - copy-many-bytes

  00551	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00554	83 e0 01	 and	 eax, 1
  00557	74 3e		 je	 SHORT $LN61@depacker_h@2

; 306  : 						{
; 307  : 							bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  00559	6a 02		 push	 2
  0055b	6a 04		 push	 4
  0055d	e8 00 00 00 00	 call	 _depack_getbits
  00562	83 c4 08	 add	 esp, 8
  00565	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 308  : #ifdef DPK_CHECK
; 309  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00568	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0056c	75 05		 jne	 SHORT $LN60@depacker_h@2
  0056e	e9 c4 fb ff ff	 jmp	 $NO_BITS_HST$4197
$LN60@depacker_h@2:

; 310  : #endif
; 311  : 							length = ((bits&15)+6)<<1;

  00573	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00576	83 e0 0f	 and	 eax, 15			; 0000000fH
  00579	8d 4c 00 0c	 lea	 ecx, DWORD PTR [eax+eax+12]
  0057d	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00584	89 4d bc	 mov	 DWORD PTR _length$[ebp], ecx

; 312  : 							skipdisp = 1;

  00587	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _skipdisp$[ebp], 1

; 313  : 							docopy = 1;

  0058e	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _docopy$[ebp], 1

; 314  : 						}
; 315  : 						else // %011 0000abcdefg[<byte>] - longer lengthes

  00595	eb 7d		 jmp	 SHORT $LN63@depacker_h@2
$LN61@depacker_h@2:

; 316  : 						{
; 317  : 							bits = depack_getbits(7,DEPACK_GETBITS_NEXT);

  00597	6a 02		 push	 2
  00599	6a 07		 push	 7
  0059b	e8 00 00 00 00	 call	 _depack_getbits
  005a0	83 c4 08	 add	 esp, 8
  005a3	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 318  : #ifdef DPK_CHECK
; 319  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  005a6	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  005aa	75 05		 jne	 SHORT $LN58@depacker_h@2
  005ac	e9 86 fb ff ff	 jmp	 $NO_BITS_HST$4197
$LN58@depacker_h@2:

; 320  : #endif
; 321  : 							bits &= 127;

  005b1	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  005b4	83 e0 7f	 and	 eax, 127		; 0000007fH
  005b7	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 322  : 
; 323  : 							if( bits==15 ) // stop depack

  005ba	83 7d d4 0f	 cmp	 DWORD PTR _bits$[ebp], 15 ; 0000000fH
  005be	75 0c		 jne	 SHORT $LN57@depacker_h@2

; 324  : 							{
; 325  : 								stop=1;

  005c0	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _stop$[ebp], 1
  005ca	eb 48		 jmp	 SHORT $LN63@depacker_h@2
$LN57@depacker_h@2:

; 326  : 							}
; 327  : 							else if( bits>15 ) // 16..127

  005cc	83 7d d4 0f	 cmp	 DWORD PTR _bits$[ebp], 15 ; 0000000fH
  005d0	76 0f		 jbe	 SHORT $LN55@depacker_h@2

; 328  : 							{
; 329  : 								length = bits;

  005d2	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  005d9	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  005dc	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 330  : 							}
; 331  : 							else // 0..14: longer lengthes

  005df	eb 33		 jmp	 SHORT $LN63@depacker_h@2
$LN55@depacker_h@2:

; 332  : 							{
; 333  : 								byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  005e1	6a 01		 push	 1
  005e3	e8 00 00 00 00	 call	 _depack_getbyte
  005e8	83 c4 04	 add	 esp, 4
  005eb	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 334  : #ifdef DPK_CHECK
; 335  : 								if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  005ee	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  005f2	75 05		 jne	 SHORT $LN53@depacker_h@2
  005f4	e9 6f fb ff ff	 jmp	 $NO_BYTE_HST$4187
$LN53@depacker_h@2:

; 336  : #endif
; 337  : 								length = (bits<<8) + (byte&0x00FF);

  005f9	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  005fc	c1 e0 08	 shl	 eax, 8
  005ff	8b 4d e0	 mov	 ecx, DWORD PTR _byte$[ebp]
  00602	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00608	03 c1		 add	 eax, ecx
  0060a	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00611	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax
$LN63@depacker_h@2:

; 338  : 							}
; 339  : 						}
; 340  : 					}
; 341  : 					break;

  00614	e9 9c 00 00 00	 jmp	 $LN71@depacker_h@2
$LN52@depacker_h@2:

; 342  : 				case 1: // %01101
; 343  : 					length = 4;

  00619	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00620	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _length$[ebp], 4

; 344  : 					break;

  00627	e9 89 00 00 00	 jmp	 $LN71@depacker_h@2
$LN51@depacker_h@2:

; 345  : 				case 2: // %01110
; 346  : 					length = 5;

  0062c	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00633	c7 45 bc 05 00
	00 00		 mov	 DWORD PTR _length$[ebp], 5

; 347  : 					break;

  0063a	eb 79		 jmp	 SHORT $LN71@depacker_h@2
$LN50@depacker_h@2:

; 348  : 				case 3: // variable length (6-15), %01111...
; 349  : 
; 350  : 					length = 6;

  0063c	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00643	c7 45 bc 06 00
	00 00		 mov	 DWORD PTR _length$[ebp], 6
$LN49@depacker_h@2:

; 351  : 					do
; 352  : 					{
; 353  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0064a	6a 02		 push	 2
  0064c	6a 02		 push	 2
  0064e	e8 00 00 00 00	 call	 _depack_getbits
  00653	83 c4 08	 add	 esp, 8
  00656	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 354  : #ifdef DPK_CHECK
; 355  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00659	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0065d	75 05		 jne	 SHORT $LN46@depacker_h@2
  0065f	e9 d3 fa ff ff	 jmp	 $NO_BITS_HST$4197
$LN46@depacker_h@2:

; 356  : #endif                                                                                  i
; 357  : 						bits &= 3;

  00664	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00667	83 e0 03	 and	 eax, 3
  0066a	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 358  : 						length += bits;

  0066d	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00674	75 0d		 jne	 SHORT $LN126@depacker_h@2
  00676	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  0067b	e8 00 00 00 00	 call	 __RTC_UninitUse
  00680	83 c4 04	 add	 esp, 4
$LN126@depacker_h@2:
  00683	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  00686	03 45 d4	 add	 eax, DWORD PTR _bits$[ebp]
  00689	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  00690	89 45 bc	 mov	 DWORD PTR _length$[ebp], eax

; 359  : 
; 360  : 					} while( (bits==3) && (length<15) );

  00693	83 7d d4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00697	75 1c		 jne	 SHORT $LN71@depacker_h@2
  00699	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  006a0	75 0d		 jne	 SHORT $LN128@depacker_h@2
  006a2	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  006a7	e8 00 00 00 00	 call	 __RTC_UninitUse
  006ac	83 c4 04	 add	 esp, 4
$LN128@depacker_h@2:
  006af	83 7d bc 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  006b3	7c 95		 jl	 SHORT $LN49@depacker_h@2
$LN71@depacker_h@2:

; 361  : 					break;
; 362  : 				}
; 363  : 			}
; 364  : 
; 365  : 			if( (!stop) && (!skipdisp) && (!docopy) )

  006b5	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  006bc	0f 85 81 02 00
	00		 jne	 $LN44@depacker_h@2
  006c2	83 7d b0 00	 cmp	 DWORD PTR _skipdisp$[ebp], 0
  006c6	0f 85 77 02 00
	00		 jne	 $LN44@depacker_h@2
  006cc	83 7d 8c 00	 cmp	 DWORD PTR _docopy$[ebp], 0
  006d0	0f 85 6d 02 00
	00		 jne	 $LN44@depacker_h@2

; 366  : 			{
; 367  : 				// extract displacement
; 368  : 
; 369  : 				switch( disptype )

  006d6	8b 45 98	 mov	 eax, DWORD PTR _disptype$[ebp]
  006d9	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
  006df	83 bd 88 fe ff
	ff 00		 cmp	 DWORD PTR tv240[ebp], 0
  006e6	0f 84 4c 01 00
	00		 je	 $LN31@depacker_h@2
  006ec	83 bd 88 fe ff
	ff 01		 cmp	 DWORD PTR tv240[ebp], 1
  006f3	0f 84 fd 01 00
	00		 je	 $LN25@depacker_h@2
  006f9	83 bd 88 fe ff
	ff 02		 cmp	 DWORD PTR tv240[ebp], 2
  00700	74 05		 je	 SHORT $LN41@depacker_h@2
  00702	e9 1e 02 00 00	 jmp	 $LN23@depacker_h@2
$LN41@depacker_h@2:

; 370  : 				{
; 371  : 				case DISP_COMMON:
; 372  : 
; 373  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00707	6a 02		 push	 2
  00709	6a 02		 push	 2
  0070b	e8 00 00 00 00	 call	 _depack_getbits
  00710	83 c4 08	 add	 esp, 8
  00713	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 374  : #ifdef DPK_CHECK
; 375  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00716	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  0071a	75 05		 jne	 SHORT $LN40@depacker_h@2
  0071c	e9 16 fa ff ff	 jmp	 $NO_BITS_HST$4197
$LN40@depacker_h@2:

; 376  : #endif                                                                                  i
; 377  : 					bits &= 3;

  00721	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00724	83 e0 03	 and	 eax, 3
  00727	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 378  : 					if( !bits ) // %00<byte> - fe00..feff

  0072a	75 1a		 jne	 SHORT $LN39@depacker_h@2

; 379  : 					{
; 380  : 						disp = (-512);

  0072c	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00733	c7 45 c8 00 fe
	ff ff		 mov	 DWORD PTR _disp$[ebp], -512 ; fffffe00H

; 381  : 						disptype=DISP_PLUSBYTE; // we fall in next section and there is check

  0073a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 0
  00741	e9 f2 00 00 00	 jmp	 $LN31@depacker_h@2
$LN39@depacker_h@2:

; 382  : 						// NO break!
; 383  : 					}
; 384  : 					else if( bits==1 ) // %01<byte> - ff00..ffdf

  00746	83 7d d4 01	 cmp	 DWORD PTR _bits$[ebp], 1
  0074a	75 13		 jne	 SHORT $LN37@depacker_h@2

; 385  : 					{
; 386  : 						disp = (-256);

  0074c	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00753	c7 45 c8 00 ff
	ff ff		 mov	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  0075a	e9 d9 00 00 00	 jmp	 $LN31@depacker_h@2
$LN37@depacker_h@2:

; 387  : 						// NO break!
; 388  : 						// no check for byte in range e0..ff here - but in next switch section!
; 389  : 					}
; 390  : 					else if( bits==2 ) // %10abcde - ffe0..ffff

  0075f	83 7d d4 02	 cmp	 DWORD PTR _bits$[ebp], 2
  00763	75 37		 jne	 SHORT $LN35@depacker_h@2

; 391  : 					{
; 392  : 						bits = depack_getbits(5,DEPACK_GETBITS_NEXT);

  00765	6a 02		 push	 2
  00767	6a 05		 push	 5
  00769	e8 00 00 00 00	 call	 _depack_getbits
  0076e	83 c4 08	 add	 esp, 8
  00771	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 393  : #ifdef DPK_CHECK
; 394  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00774	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00778	75 05		 jne	 SHORT $LN34@depacker_h@2
  0077a	e9 b8 f9 ff ff	 jmp	 $NO_BITS_HST$4197
$LN34@depacker_h@2:

; 395  : #endif                                                                                  i
; 396  : 						disp = (-32) | (bits&31);

  0077f	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00782	83 e0 1f	 and	 eax, 31			; 0000001fH
  00785	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00788	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  0078f	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 397  : 
; 398  : 						break;

  00792	e9 ac 01 00 00	 jmp	 $LN44@depacker_h@2

; 399  : 					}
; 400  : 					else // %11... - expanding displacement

  00797	e9 9c 00 00 00	 jmp	 $LN31@depacker_h@2
$LN35@depacker_h@2:

; 401  : 					{
; 402  : 						bits = depack_getbits(expbitlen,DEPACK_GETBITS_NEXT);

  0079c	6a 02		 push	 2
  0079e	8b 45 80	 mov	 eax, DWORD PTR _expbitlen$[ebp]
  007a1	50		 push	 eax
  007a2	e8 00 00 00 00	 call	 _depack_getbits
  007a7	83 c4 08	 add	 esp, 8
  007aa	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 403  : #ifdef DPK_CHECK
; 404  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  007ad	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  007b1	75 05		 jne	 SHORT $LN32@depacker_h@2
  007b3	e9 7f f9 ff ff	 jmp	 $NO_BITS_HST$4197
$LN32@depacker_h@2:

; 405  : #endif                                                                                  i
; 406  : 						disp = (-1)<<expbitlen;

  007b8	83 c8 ff	 or	 eax, -1
  007bb	8b 4d 80	 mov	 ecx, DWORD PTR _expbitlen$[ebp]
  007be	d3 e0		 shl	 eax, cl
  007c0	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  007c7	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 407  : 						disp |= (bits&(~disp));

  007ca	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  007d1	75 0d		 jne	 SHORT $LN129@depacker_h@2
  007d3	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  007d8	e8 00 00 00 00	 call	 __RTC_UninitUse
  007dd	83 c4 04	 add	 esp, 4
$LN129@depacker_h@2:
  007e0	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  007e7	75 0d		 jne	 SHORT $LN131@depacker_h@2
  007e9	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  007ee	e8 00 00 00 00	 call	 __RTC_UninitUse
  007f3	83 c4 04	 add	 esp, 4
$LN131@depacker_h@2:
  007f6	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  007f9	f7 d0		 not	 eax
  007fb	23 45 d4	 and	 eax, DWORD PTR _bits$[ebp]
  007fe	0b 45 c8	 or	 eax, DWORD PTR _disp$[ebp]
  00801	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00808	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 408  : 
; 409  : 						disp <<= 8;

  0080b	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00812	75 0d		 jne	 SHORT $LN132@depacker_h@2
  00814	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00819	e8 00 00 00 00	 call	 __RTC_UninitUse
  0081e	83 c4 04	 add	 esp, 4
$LN132@depacker_h@2:
  00821	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00824	c1 e0 08	 shl	 eax, 8
  00827	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  0082e	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 410  : 
; 411  : 						disptype = DISP_PLUSBYTE;

  00831	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _disptype$[ebp], 0
$LN31@depacker_h@2:

; 412  : 						// NO break!
; 413  : 					}
; 414  : 
; 415  : 				case DISP_PLUSBYTE:
; 416  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00838	6a 01		 push	 1
  0083a	e8 00 00 00 00	 call	 _depack_getbyte
  0083f	83 c4 04	 add	 esp, 4
  00842	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 417  : #ifdef DPK_CHECK
; 418  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00845	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00849	75 05		 jne	 SHORT $LN30@depacker_h@2
  0084b	e9 18 f9 ff ff	 jmp	 $NO_BYTE_HST$4187
$LN30@depacker_h@2:

; 419  : #endif
; 420  : 					if( disptype==DISP_COMMON ) // if we here from previous section of switch()

  00850	83 7d 98 02	 cmp	 DWORD PTR _disptype$[ebp], 2
  00854	75 73		 jne	 SHORT $LN29@depacker_h@2

; 421  : 					{                           // we must check for insertion match!
; 422  : 
; 423  : 						if( byte<0x00E0 ) // ff00..ffdf

  00856	81 7d e0 e0 00
	00 00		 cmp	 DWORD PTR _byte$[ebp], 224 ; 000000e0H
  0085d	73 19		 jae	 SHORT $LN28@depacker_h@2

; 424  : 						{
; 425  : 							disp = (-256) | (byte&0x00FF);

  0085f	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00862	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00867	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0086c	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00873	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 426  : 						}
; 427  : 						else // insertion match - xor 3

  00876	eb 4f		 jmp	 SHORT $LN27@depacker_h@2
$LN28@depacker_h@2:

; 428  : 						{
; 429  : 							length = (-3); // mark insertion match

  00878	c6 85 93 fe ff
	ff 01		 mov	 BYTE PTR $T4524[ebp], 1
  0087f	c7 45 bc fd ff
	ff ff		 mov	 DWORD PTR _length$[ebp], -3 ; fffffffdH

; 430  : 
; 431  : 							byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1

  00886	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00889	d1 e0		 shl	 eax, 1
  0088b	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00890	8b 4d e0	 mov	 ecx, DWORD PTR _byte$[ebp]
  00893	c1 e9 07	 shr	 ecx, 7
  00896	83 e1 01	 and	 ecx, 1
  00899	0b c1		 or	 eax, ecx
  0089b	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 432  : 							byte ^= 0x03;

  0089e	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  008a1	83 f0 03	 xor	 eax, 3
  008a4	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 433  : 							byte -= 15;

  008a7	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  008aa	83 e8 0f	 sub	 eax, 15			; 0000000fH
  008ad	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 434  : 
; 435  : 							disp = (-256) | (byte&0x00FF);

  008b0	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  008b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008b8	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  008bd	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  008c4	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax
$LN27@depacker_h@2:

; 436  : 						}
; 437  : 					}
; 438  : 					else

  008c7	eb 2b		 jmp	 SHORT $LN26@depacker_h@2
$LN29@depacker_h@2:

; 439  : 					{
; 440  :  						disp = disp + (byte&0x00FF);

  008c9	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  008d0	75 0d		 jne	 SHORT $LN133@depacker_h@2
  008d2	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  008d7	e8 00 00 00 00	 call	 __RTC_UninitUse
  008dc	83 c4 04	 add	 esp, 4
$LN133@depacker_h@2:
  008df	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  008e2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008e7	03 45 c8	 add	 eax, DWORD PTR _disp$[ebp]
  008ea	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  008f1	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax
$LN26@depacker_h@2:

; 441  : 					}
; 442  : 
; 443  : 					break;

  008f4	eb 4d		 jmp	 SHORT $LN44@depacker_h@2
$LN25@depacker_h@2:

; 444  : 
; 445  : 				case DISP_ABCDE:
; 446  : 					bits = depack_getbits(5,DEPACK_GETBITS_NEXT);

  008f6	6a 02		 push	 2
  008f8	6a 05		 push	 5
  008fa	e8 00 00 00 00	 call	 _depack_getbits
  008ff	83 c4 08	 add	 esp, 8
  00902	89 45 d4	 mov	 DWORD PTR _bits$[ebp], eax

; 447  : #ifdef DPK_CHECK
; 448  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00905	83 7d d4 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00909	75 05		 jne	 SHORT $LN24@depacker_h@2
  0090b	e9 27 f8 ff ff	 jmp	 $NO_BITS_HST$4197
$LN24@depacker_h@2:

; 449  : #endif
; 450  : 					disp = (-32) | (bits&31);

  00910	8b 45 d4	 mov	 eax, DWORD PTR _bits$[ebp]
  00913	83 e0 1f	 and	 eax, 31			; 0000001fH
  00916	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00919	c6 85 9f fe ff
	ff 01		 mov	 BYTE PTR $T4525[ebp], 1
  00920	89 45 c8	 mov	 DWORD PTR _disp$[ebp], eax

; 451  : 
; 452  : 					break;

  00923	eb 1e		 jmp	 SHORT $LN44@depacker_h@2
$LN23@depacker_h@2:

; 453  : 
; 454  : 				default:
; 455  : #ifdef DPK_CHECK
; 456  :  #ifdef DPK_REPERR
; 457  : 					printf("mhmt-depack-hrust.c:{} - Wrong displacement in disptype!\n");

  00925	8b f4		 mov	 esi, esp
  00927	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@
  0092c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00932	83 c4 04	 add	 esp, 4
  00935	3b f4		 cmp	 esi, esp
  00937	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  :  #endif
; 459  : 					return 0;

  0093c	33 c0		 xor	 eax, eax
  0093e	e9 9b 04 00 00	 jmp	 $LN110@depacker_h@2
$LN44@depacker_h@2:

; 460  : #endif
; 461  : 					break;
; 462  : 				}
; 463  : 			}
; 464  : 
; 465  : 
; 466  : #ifdef DPK_CHECK
; 467  : 			if( success && (!docopy) && (!stop) && ((ULONG)(-disp)>wrk.maxwin) )

  00943	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  0094a	74 6c		 je	 SHORT $LN22@depacker_h@2
  0094c	83 7d 8c 00	 cmp	 DWORD PTR _docopy$[ebp], 0
  00950	75 66		 jne	 SHORT $LN22@depacker_h@2
  00952	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  00959	75 5d		 jne	 SHORT $LN22@depacker_h@2
  0095b	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00962	75 0d		 jne	 SHORT $LN134@depacker_h@2
  00964	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00969	e8 00 00 00 00	 call	 __RTC_UninitUse
  0096e	83 c4 04	 add	 esp, 4
$LN134@depacker_h@2:
  00971	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00974	f7 d8		 neg	 eax
  00976	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  0097c	76 3a		 jbe	 SHORT $LN22@depacker_h@2
$WRONG_DISP_HST$4291:

; 468  : 			{
; 469  : WRONG_DISP_HST:
; 470  :  #ifdef DPK_REPERR
; 471  : 				printf("mhmt-depack-hrust.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );

  0097e	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00985	75 0d		 jne	 SHORT $LN135@depacker_h@2
  00987	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  0098c	e8 00 00 00 00	 call	 __RTC_UninitUse
  00991	83 c4 04	 add	 esp, 4
$LN135@depacker_h@2:
  00994	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00997	f7 d8		 neg	 eax
  00999	8b f4		 mov	 esi, esp
  0099b	50		 push	 eax
  0099c	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@
  009a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  009a7	83 c4 08	 add	 esp, 8
  009aa	3b f4		 cmp	 esi, esp
  009ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 472  :  #endif
; 473  : 				return 0;

  009b1	33 c0		 xor	 eax, eax
  009b3	e9 26 04 00 00	 jmp	 $LN110@depacker_h@2
$LN22@depacker_h@2:

; 474  : 			}
; 475  : #endif
; 476  : 
; 477  : 
; 478  : 			if( docopy && (!stop) )

  009b8	83 7d 8c 00	 cmp	 DWORD PTR _docopy$[ebp], 0
  009bc	0f 84 d2 00 00
	00		 je	 $LN21@depacker_h@2
  009c2	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  009c9	0f 85 c5 00 00
	00		 jne	 $LN21@depacker_h@2

; 479  : 			{
; 480  : 				#ifdef DBG
; 481  : 					printf("copy.len=%d\n",length);

  009cf	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  009d6	75 0d		 jne	 SHORT $LN136@depacker_h@2
  009d8	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  009dd	e8 00 00 00 00	 call	 __RTC_UninitUse
  009e2	83 c4 04	 add	 esp, 4
$LN136@depacker_h@2:
  009e5	8b f4		 mov	 esi, esp
  009e7	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  009ea	50		 push	 eax
  009eb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@
  009f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  009f6	83 c4 08	 add	 esp, 8
  009f9	3b f4		 cmp	 esi, esp
  009fb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 482  : 				#endif
; 483  : 				for(i=0;i<length;i++)

  00a00	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00a07	eb 09		 jmp	 SHORT $LN20@depacker_h@2
$LN19@depacker_h@2:
  00a09	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a0c	83 c0 01	 add	 eax, 1
  00a0f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN20@depacker_h@2:
  00a12	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00a19	75 0d		 jne	 SHORT $LN137@depacker_h@2
  00a1b	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00a20	e8 00 00 00 00	 call	 __RTC_UninitUse
  00a25	83 c4 04	 add	 esp, 4
$LN137@depacker_h@2:
  00a28	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a2b	3b 45 bc	 cmp	 eax, DWORD PTR _length$[ebp]
  00a2e	7d 5f		 jge	 SHORT $LN18@depacker_h@2

; 484  : 				{
; 485  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00a30	6a 01		 push	 1
  00a32	e8 00 00 00 00	 call	 _depack_getbyte
  00a37	83 c4 04	 add	 esp, 4
  00a3a	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 486  : #ifdef DPK_CHECK
; 487  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00a3d	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00a41	75 05		 jne	 SHORT $LN17@depacker_h@2
  00a43	e9 20 f7 ff ff	 jmp	 $NO_BYTE_HST$4187
$LN17@depacker_h@2:

; 488  : #endif
; 489  : 
; 490  : 
; 491  : #ifdef DPK_DEPACK
; 492  : 					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00a48	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00a4f	74 23		 je	 SHORT $LN114@depacker_h@2
  00a51	6a 02		 push	 2
  00a53	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00a56	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a5b	50		 push	 eax
  00a5c	e8 00 00 00 00	 call	 _depack_outbyte
  00a61	83 c4 08	 add	 esp, 8
  00a64	85 c0		 test	 eax, eax
  00a66	74 0c		 je	 SHORT $LN114@depacker_h@2
  00a68	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv316[ebp], 1
  00a72	eb 0a		 jmp	 SHORT $LN115@depacker_h@2
$LN114@depacker_h@2:
  00a74	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv316[ebp], 0
$LN115@depacker_h@2:
  00a7e	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv316[ebp]
  00a84	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx

; 493  : #endif
; 494  : 				}

  00a8a	e9 7a ff ff ff	 jmp	 $LN19@depacker_h@2
$LN18@depacker_h@2:

; 495  : 			}
; 496  : 			else if( (!docopy) && (!stop) )// not do-copy

  00a8f	e9 5b 02 00 00	 jmp	 $LN16@depacker_h@2
$LN21@depacker_h@2:
  00a94	83 7d 8c 00	 cmp	 DWORD PTR _docopy$[ebp], 0
  00a98	0f 85 51 02 00
	00		 jne	 $LN16@depacker_h@2
  00a9e	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _stop$[ebp], 0
  00aa5	0f 85 44 02 00
	00		 jne	 $LN16@depacker_h@2

; 497  : 			{
; 498  : 				if( length!=(-3) )

  00aab	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00ab2	75 0d		 jne	 SHORT $LN138@depacker_h@2
  00ab4	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00ab9	e8 00 00 00 00	 call	 __RTC_UninitUse
  00abe	83 c4 04	 add	 esp, 4
$LN138@depacker_h@2:
  00ac1	83 7d bc fd	 cmp	 DWORD PTR _length$[ebp], -3 ; fffffffdH
  00ac5	0f 84 d7 00 00
	00		 je	 $LN14@depacker_h@2

; 499  : 				{
; 500  : 					#ifdef DBG
; 501  : 						printf("match.len=%d,disp=%d\n",length,disp);

  00acb	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00ad2	75 0d		 jne	 SHORT $LN139@depacker_h@2
  00ad4	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00ad9	e8 00 00 00 00	 call	 __RTC_UninitUse
  00ade	83 c4 04	 add	 esp, 4
$LN139@depacker_h@2:
  00ae1	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00ae8	75 0d		 jne	 SHORT $LN140@depacker_h@2
  00aea	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00aef	e8 00 00 00 00	 call	 __RTC_UninitUse
  00af4	83 c4 04	 add	 esp, 4
$LN140@depacker_h@2:
  00af7	8b f4		 mov	 esi, esp
  00af9	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00afc	50		 push	 eax
  00afd	8b 4d bc	 mov	 ecx, DWORD PTR _length$[ebp]
  00b00	51		 push	 ecx
  00b01	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
  00b06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00b0c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b0f	3b f4		 cmp	 esi, esp
  00b11	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 502  : 					#endif
; 503  : 
; 504  : #ifdef DPK_DEPACK
; 505  : 					if( length )

  00b16	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00b1d	75 0d		 jne	 SHORT $LN141@depacker_h@2
  00b1f	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00b24	e8 00 00 00 00	 call	 __RTC_UninitUse
  00b29	83 c4 04	 add	 esp, 4
$LN141@depacker_h@2:
  00b2c	83 7d bc 00	 cmp	 DWORD PTR _length$[ebp], 0
  00b30	74 6b		 je	 SHORT $LN13@depacker_h@2

; 506  : 						success = success && depack_repeat(disp,length);

  00b32	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00b39	74 4c		 je	 SHORT $LN116@depacker_h@2
  00b3b	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00b42	75 0d		 jne	 SHORT $LN142@depacker_h@2
  00b44	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00b49	e8 00 00 00 00	 call	 __RTC_UninitUse
  00b4e	83 c4 04	 add	 esp, 4
$LN142@depacker_h@2:
  00b51	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00b58	75 0d		 jne	 SHORT $LN143@depacker_h@2
  00b5a	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00b5f	e8 00 00 00 00	 call	 __RTC_UninitUse
  00b64	83 c4 04	 add	 esp, 4
$LN143@depacker_h@2:
  00b67	8b 45 bc	 mov	 eax, DWORD PTR _length$[ebp]
  00b6a	50		 push	 eax
  00b6b	8b 4d c8	 mov	 ecx, DWORD PTR _disp$[ebp]
  00b6e	51		 push	 ecx
  00b6f	e8 00 00 00 00	 call	 _depack_repeat
  00b74	83 c4 08	 add	 esp, 8
  00b77	85 c0		 test	 eax, eax
  00b79	74 0c		 je	 SHORT $LN116@depacker_h@2
  00b7b	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv329[ebp], 1
  00b85	eb 0a		 jmp	 SHORT $LN117@depacker_h@2
$LN116@depacker_h@2:
  00b87	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv329[ebp], 0
$LN117@depacker_h@2:
  00b91	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv329[ebp]
  00b97	89 95 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], edx
$LN13@depacker_h@2:

; 507  : #endif
; 508  : 				}
; 509  : 				else // (-3)

  00b9d	e9 4d 01 00 00	 jmp	 $LN16@depacker_h@2
$LN14@depacker_h@2:

; 510  : 				{
; 511  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00ba2	6a 01		 push	 1
  00ba4	e8 00 00 00 00	 call	 _depack_getbyte
  00ba9	83 c4 04	 add	 esp, 4
  00bac	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 512  : #ifdef DPK_CHECK
; 513  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00baf	83 7d e0 ff	 cmp	 DWORD PTR _byte$[ebp], -1
  00bb3	75 05		 jne	 SHORT $LN11@depacker_h@2
  00bb5	e9 ae f5 ff ff	 jmp	 $NO_BYTE_HST$4187
$LN11@depacker_h@2:

; 514  : #endif
; 515  : 					#ifdef DBG
; 516  : 						printf("insert-match.len=%d,disp=%d\n",(-length),disp);

  00bba	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00bc1	75 0d		 jne	 SHORT $LN144@depacker_h@2
  00bc3	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00bc8	e8 00 00 00 00	 call	 __RTC_UninitUse
  00bcd	83 c4 04	 add	 esp, 4
$LN144@depacker_h@2:
  00bd0	80 bd 93 fe ff
	ff 00		 cmp	 BYTE PTR $T4524[ebp], 0
  00bd7	75 0d		 jne	 SHORT $LN145@depacker_h@2
  00bd9	68 00 00 00 00	 push	 OFFSET $LN127@depacker_h@2
  00bde	e8 00 00 00 00	 call	 __RTC_UninitUse
  00be3	83 c4 04	 add	 esp, 4
$LN145@depacker_h@2:
  00be6	8b f4		 mov	 esi, esp
  00be8	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00beb	50		 push	 eax
  00bec	8b 4d bc	 mov	 ecx, DWORD PTR _length$[ebp]
  00bef	f7 d9		 neg	 ecx
  00bf1	51		 push	 ecx
  00bf2	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
  00bf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00bfd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c00	3b f4		 cmp	 esi, esp
  00c02	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 517  : 					#endif
; 518  : 
; 519  : 
; 520  : #ifdef DPK_DEPACK
; 521  : 					success = success && depack_repeat(disp,1);

  00c07	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00c0e	74 34		 je	 SHORT $LN118@depacker_h@2
  00c10	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00c17	75 0d		 jne	 SHORT $LN146@depacker_h@2
  00c19	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00c1e	e8 00 00 00 00	 call	 __RTC_UninitUse
  00c23	83 c4 04	 add	 esp, 4
$LN146@depacker_h@2:
  00c26	6a 01		 push	 1
  00c28	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00c2b	50		 push	 eax
  00c2c	e8 00 00 00 00	 call	 _depack_repeat
  00c31	83 c4 08	 add	 esp, 8
  00c34	85 c0		 test	 eax, eax
  00c36	74 0c		 je	 SHORT $LN118@depacker_h@2
  00c38	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv342[ebp], 1
  00c42	eb 0a		 jmp	 SHORT $LN119@depacker_h@2
$LN118@depacker_h@2:
  00c44	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv342[ebp], 0
$LN119@depacker_h@2:
  00c4e	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv342[ebp]
  00c54	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx

; 522  : 					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00c5a	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00c61	74 23		 je	 SHORT $LN120@depacker_h@2
  00c63	6a 02		 push	 2
  00c65	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00c68	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c6d	50		 push	 eax
  00c6e	e8 00 00 00 00	 call	 _depack_outbyte
  00c73	83 c4 08	 add	 esp, 8
  00c76	85 c0		 test	 eax, eax
  00c78	74 0c		 je	 SHORT $LN120@depacker_h@2
  00c7a	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv350[ebp], 1
  00c84	eb 0a		 jmp	 SHORT $LN121@depacker_h@2
$LN120@depacker_h@2:
  00c86	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv350[ebp], 0
$LN121@depacker_h@2:
  00c90	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv350[ebp]
  00c96	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx

; 523  : 					success = success && depack_repeat(disp,1);

  00c9c	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00ca3	74 34		 je	 SHORT $LN122@depacker_h@2
  00ca5	80 bd 9f fe ff
	ff 00		 cmp	 BYTE PTR $T4525[ebp], 0
  00cac	75 0d		 jne	 SHORT $LN147@depacker_h@2
  00cae	68 00 00 00 00	 push	 OFFSET $LN130@depacker_h@2
  00cb3	e8 00 00 00 00	 call	 __RTC_UninitUse
  00cb8	83 c4 04	 add	 esp, 4
$LN147@depacker_h@2:
  00cbb	6a 01		 push	 1
  00cbd	8b 45 c8	 mov	 eax, DWORD PTR _disp$[ebp]
  00cc0	50		 push	 eax
  00cc1	e8 00 00 00 00	 call	 _depack_repeat
  00cc6	83 c4 08	 add	 esp, 8
  00cc9	85 c0		 test	 eax, eax
  00ccb	74 0c		 je	 SHORT $LN122@depacker_h@2
  00ccd	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv356[ebp], 1
  00cd7	eb 0a		 jmp	 SHORT $LN123@depacker_h@2
$LN122@depacker_h@2:
  00cd9	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv356[ebp], 0
$LN123@depacker_h@2:
  00ce3	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv356[ebp]
  00ce9	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx
$LN16@depacker_h@2:

; 524  : #endif
; 525  : 				}
; 526  : 
; 527  : 			}
; 528  : 	}

  00cef	e9 de f4 ff ff	 jmp	 $LN97@depacker_h@2
$LN96@depacker_h@2:

; 529  : 
; 530  : 	//manage zxheader again (copy to the end of output)
; 531  : #ifdef DPK_DEPACK
; 532  : 	if( wrk.zxheader )

  00cf4	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00cfb	0f 84 d7 00 00
	00		 je	 $LN10@depacker_h@2

; 533  : 	{
; 534  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00d01	6a 00		 push	 0
  00d03	e8 00 00 00 00	 call	 _depack_getbyte
  00d08	83 c4 04	 add	 esp, 4
  00d0b	89 45 ec	 mov	 DWORD PTR _check$[ebp], eax

; 535  :  #ifdef DPK_CHECK
; 536  : 		if( 0xFFFFFFFF == check )

  00d0e	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  00d12	75 1e		 jne	 SHORT $LN9@depacker_h@2

; 537  : 		{
; 538  :   #ifdef DPK_REPERR
; 539  : 			printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");

  00d14	8b f4		 mov	 esi, esp
  00d16	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@
  00d1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00d21	83 c4 04	 add	 esp, 4
  00d24	3b f4		 cmp	 esi, esp
  00d26	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 540  :   #endif
; 541  : 			return 0;

  00d2b	33 c0		 xor	 eax, eax
  00d2d	e9 ac 00 00 00	 jmp	 $LN110@depacker_h@2
$LN9@depacker_h@2:

; 542  : 		}
; 543  :  #endif
; 544  : 
; 545  : 		for(i=0;i<6;i++) // skip bytes

  00d32	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d39	eb 09		 jmp	 SHORT $LN8@depacker_h@2
$LN7@depacker_h@2:
  00d3b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d3e	83 c0 01	 add	 eax, 1
  00d41	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@depacker_h@2:
  00d44	83 7d f8 06	 cmp	 DWORD PTR _i$[ebp], 6
  00d48	7d 1a		 jge	 SHORT $LN6@depacker_h@2

; 546  : 		{
; 547  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00d4a	6a 01		 push	 1
  00d4c	e8 00 00 00 00	 call	 _depack_getbyte
  00d51	83 c4 04	 add	 esp, 4
  00d54	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 548  :  #ifdef DPK_CHECK
; 549  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00d57	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  00d5b	75 05		 jne	 SHORT $LN5@depacker_h@2
  00d5d	e9 06 f4 ff ff	 jmp	 $NO_BYTE_HST$4187
$LN5@depacker_h@2:

; 550  :  #endif
; 551  : 		}

  00d62	eb d7		 jmp	 SHORT $LN7@depacker_h@2
$LN6@depacker_h@2:

; 552  : 		// place 6 bytes of header to the end
; 553  : 		for(i=0;i<6;i++)

  00d64	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d6b	eb 09		 jmp	 SHORT $LN4@depacker_h@2
$LN3@depacker_h@2:
  00d6d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d70	83 c0 01	 add	 eax, 1
  00d73	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@depacker_h@2:
  00d76	83 7d f8 06	 cmp	 DWORD PTR _i$[ebp], 6
  00d7a	7d 5c		 jge	 SHORT $LN10@depacker_h@2

; 554  : 		{
; 555  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00d7c	6a 01		 push	 1
  00d7e	e8 00 00 00 00	 call	 _depack_getbyte
  00d83	83 c4 04	 add	 esp, 4
  00d86	89 45 e0	 mov	 DWORD PTR _byte$[ebp], eax

; 556  :  #ifdef DPK_CHECK
; 557  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00d89	83 7d ec ff	 cmp	 DWORD PTR _check$[ebp], -1
  00d8d	75 05		 jne	 SHORT $LN1@depacker_h@2
  00d8f	e9 d4 f3 ff ff	 jmp	 $NO_BYTE_HST$4187
$LN1@depacker_h@2:

; 558  :  #endif
; 559  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00d94	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _success$[ebp], 0
  00d9b	74 23		 je	 SHORT $LN124@depacker_h@2
  00d9d	6a 02		 push	 2
  00d9f	8b 45 e0	 mov	 eax, DWORD PTR _byte$[ebp]
  00da2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00da7	50		 push	 eax
  00da8	e8 00 00 00 00	 call	 _depack_outbyte
  00dad	83 c4 08	 add	 esp, 8
  00db0	85 c0		 test	 eax, eax
  00db2	74 0c		 je	 SHORT $LN124@depacker_h@2
  00db4	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv379[ebp], 1
  00dbe	eb 0a		 jmp	 SHORT $LN125@depacker_h@2
$LN124@depacker_h@2:
  00dc0	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv379[ebp], 0
$LN125@depacker_h@2:
  00dca	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv379[ebp]
  00dd0	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _success$[ebp], ecx

; 560  : 		}

  00dd6	eb 95		 jmp	 SHORT $LN3@depacker_h@2
$LN10@depacker_h@2:

; 561  : 	}
; 562  : #endif
; 563  : 
; 564  : 	return success;

  00dd8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _success$[ebp]
$LN110@depacker_h@2:

; 565  : }

  00dde	5f		 pop	 edi
  00ddf	5e		 pop	 esi
  00de0	5b		 pop	 ebx
  00de1	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  00de7	3b ec		 cmp	 ebp, esp
  00de9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00dee	8b e5		 mov	 esp, ebp
  00df0	5d		 pop	 ebp
  00df1	c3		 ret	 0
$LN148@depacker_h@2:
$LN130@depacker_h@2:
  00df2	64		 DB	 100			; 00000064H
  00df3	69		 DB	 105			; 00000069H
  00df4	73		 DB	 115			; 00000073H
  00df5	70		 DB	 112			; 00000070H
  00df6	00		 DB	 0
$LN127@depacker_h@2:
  00df7	6c		 DB	 108			; 0000006cH
  00df8	65		 DB	 101			; 00000065H
  00df9	6e		 DB	 110			; 0000006eH
  00dfa	67		 DB	 103			; 00000067H
  00dfb	74		 DB	 116			; 00000074H
  00dfc	68		 DB	 104			; 00000068H
  00dfd	00		 DB	 0
  00dfe	8b ff		 npad	 2
$LN149@depacker_h@2:
  00e00	00 00 00 00	 DD	 $LN89@depacker_h@2
  00e04	00 00 00 00	 DD	 $LN87@depacker_h@2
  00e08	00 00 00 00	 DD	 $LN73@depacker_h@2
  00e0c	00 00 00 00	 DD	 $LN72@depacker_h@2
$LN150@depacker_h@2:
  00e10	00 00 00 00	 DD	 $LN83@depacker_h@2
  00e14	00 00 00 00	 DD	 $LN82@depacker_h@2
  00e18	00 00 00 00	 DD	 $LN81@depacker_h@2
  00e1c	00 00 00 00	 DD	 $LN74@depacker_h@2
$LN151@depacker_h@2:
  00e20	00 00 00 00	 DD	 $LN67@depacker_h@2
  00e24	00 00 00 00	 DD	 $LN52@depacker_h@2
  00e28	00 00 00 00	 DD	 $LN51@depacker_h@2
  00e2c	00 00 00 00	 DD	 $LN50@depacker_h@2
_depacker_hrust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@ ; `string'
_BSS	SEGMENT
?position@?1??depack_getbyte@@9@9 DD 01H DUP (?)	; `depack_getbyte'::`2'::position
_BSS	ENDS
;	COMDAT ??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@
; File d:\d\mhmt\src\mhmt-depack.c
CONST	SEGMENT
??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@ DB 'mhmt'
	DB	'-depack.c:depack_get() - wrong operation code', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _depack_getbyte
_TEXT	SEGMENT
tv70 = -196						; size = 4
_operation$ = 8						; size = 4
_depack_getbyte PROC					; COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 125  : 	static ULONG position;
; 126  : 
; 127  : 	if( operation==DEPACK_GETBYTE_REWIND )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _operation$[ebp], 0
  00022	75 10		 jne	 SHORT $LN5@depack_get

; 128  : 	{
; 129  : 		position=0;

  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, 0

; 130  : 		return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 5c		 jmp	 SHORT $LN6@depack_get
  00032	eb 57		 jmp	 SHORT $LN4@depack_get
$LN5@depack_get:

; 131  : 	}
; 132  : 	else if( operation==DEPACK_GETBYTE_NEXT )

  00034	83 7d 08 01	 cmp	 DWORD PTR _operation$[ebp], 1
  00038	75 3a		 jne	 SHORT $LN3@depack_get

; 133  : 	{
; 134  : 		if( position < wrk.inlen )

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??depack_getbyte@@9@9
  0003f	3b 05 34 00 00
	00		 cmp	 eax, DWORD PTR _wrk+52
  00045	73 2b		 jae	 SHORT $LN2@depack_get

; 135  : 		{
; 136  : //#ifdef DBG
; 137  : //			printf("<%02x>", wrk.indata[position]);
; 138  : //#endif
; 139  : 			return (ULONG)wrk.indata[position++];

  00047	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0004c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?position@?1??depack_getbyte@@9@9
  00052	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00055	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
  0005b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?position@?1??depack_getbyte@@9@9
  00061	83 c2 01	 add	 edx, 1
  00064	89 15 00 00 00
	00		 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, edx
  0006a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00070	eb 1c		 jmp	 SHORT $LN6@depack_get
$LN2@depack_get:

; 140  : 		}
; 141  : 	}
; 142  : 	else // should never happen in a correct program

  00072	eb 17		 jmp	 SHORT $LN4@depack_get
$LN3@depack_get:

; 143  : 		printf("mhmt-depack.c:depack_get() - wrong operation code\n");

  00074	8b f4		 mov	 esi, esp
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@depack_get:

; 144  : 
; 145  : 	return 0xFFFFFFFF;

  0008b	83 c8 ff	 or	 eax, -1
$LN6@depack_get:

; 146  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_depack_getbyte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ ; `string'
PUBLIC	??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ ; `string'
PUBLIC	_depack_getbits_word
_BSS	SEGMENT
?num_bits_left@?1??depack_getbits@@9@9 DD 01H DUP (?)	; `depack_getbits'::`2'::num_bits_left
?bits@?1??depack_getbits@@9@9 DD 01H DUP (?)		; `depack_getbits'::`2'::bits
_BSS	ENDS
;	COMDAT ??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_getbits() - wrong operation code', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_getbits() - too many (>31) or zero bits reque'
	DB	'sted', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _depack_getbits
_TEXT	SEGMENT
_fetched_bits$ = -8					; size = 4
_numbits$ = 8						; size = 4
_operation$ = 12					; size = 4
_depack_getbits PROC					; COMDAT

; 153  : {	static ULONG bits;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 154  : 
; 155  : 	static ULONG num_bits_left;
; 156  : 
; 157  : 	ULONG fetched_bits;
; 158  : 
; 159  : 
; 160  : 	if( operation==DEPACK_GETBITS_FORCE ) // force word retrieval (for start of stream)

  0001e	83 7d 0c 01	 cmp	 DWORD PTR _operation$[ebp], 1
  00022	75 3f		 jne	 SHORT $LN16@depack_get@2

; 161  : 	{
; 162  : 		bits = depack_getbits_word();

  00024	e8 00 00 00 00	 call	 _depack_getbits_word
  00029	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 163  : 		if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  0002e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?bits@?1??depack_getbits@@9@9, -1
  00035	75 08		 jne	 SHORT $LN15@depack_get@2
  00037	83 c8 ff	 or	 eax, -1
  0003a	e9 46 01 00 00	 jmp	 $LN17@depack_get@2
$LN15@depack_get@2:

; 164  : 		num_bits_left = wrk.wordbit ? 16 : 8;

  0003f	33 c0		 xor	 eax, eax
  00041	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  00048	0f 95 c0	 setne	 al
  0004b	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax

; 165  : 		return 0;

  00057	33 c0		 xor	 eax, eax
  00059	e9 27 01 00 00	 jmp	 $LN17@depack_get@2
  0005e	e9 22 01 00 00	 jmp	 $LN17@depack_get@2
$LN16@depack_get@2:

; 166  : 	}
; 167  : 	else if( operation==DEPACK_GETBITS_NEXT ) // return bits and fetch new as needed (wrk.fullbits accounted for)

  00063	83 7d 0c 02	 cmp	 DWORD PTR _operation$[ebp], 2
  00067	0f 85 fe 00 00
	00		 jne	 $LN13@depack_get@2

; 168  : 	{
; 169  : 		if( (numbits==0) || (numbits>31) )

  0006d	83 7d 08 00	 cmp	 DWORD PTR _numbits$[ebp], 0
  00071	74 06		 je	 SHORT $LN11@depack_get@2
  00073	83 7d 08 1f	 cmp	 DWORD PTR _numbits$[ebp], 31 ; 0000001fH
  00077	76 1f		 jbe	 SHORT $LN12@depack_get@2
$LN11@depack_get@2:

; 170  : 		{
; 171  : 			printf("mhmt-depack.c:depack_getbits() - too many (>31) or zero bits requested\n");

  00079	8b f4		 mov	 esi, esp
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00086	83 c4 04	 add	 esp, 4
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  : 			return 0xFFFFFFFF;

  00090	83 c8 ff	 or	 eax, -1
  00093	e9 ed 00 00 00	 jmp	 $LN17@depack_get@2
$LN12@depack_get@2:

; 173  : 		}
; 174  : 
; 175  : 		fetched_bits = 0;

  00098	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fetched_bits$[ebp], 0
$LN10@depack_get@2:

; 176  : 		do
; 177  : 		{
; 178  : 			if( !wrk.fullbits ) // empty bits

  0009f	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  000a6	75 3c		 jne	 SHORT $LN7@depack_get@2

; 179  : 			{
; 180  : 				if( !num_bits_left )

  000a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, 0
  000af	75 33		 jne	 SHORT $LN7@depack_get@2

; 181  : 				{
; 182  : 					bits = depack_getbits_word();

  000b1	e8 00 00 00 00	 call	 _depack_getbits_word
  000b6	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 183  : 					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  000bb	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?bits@?1??depack_getbits@@9@9, -1
  000c2	75 08		 jne	 SHORT $LN5@depack_get@2
  000c4	83 c8 ff	 or	 eax, -1
  000c7	e9 b9 00 00 00	 jmp	 $LN17@depack_get@2
$LN5@depack_get@2:

; 184  : 					num_bits_left = wrk.wordbit ? 16 : 8;

  000cc	33 c0		 xor	 eax, eax
  000ce	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  000d5	0f 95 c0	 setne	 al
  000d8	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  000df	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax
$LN7@depack_get@2:

; 185  : 				}
; 186  : 			}
; 187  : 
; 188  : //#ifdef DBG
; 189  : //			printf("%d",bits>>31);
; 190  : //#endif
; 191  : 			fetched_bits = ( fetched_bits<<1 ) | ( 1&(bits>>31) );

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _fetched_bits$[ebp]
  000e7	d1 e0		 shl	 eax, 1
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bits@?1??depack_getbits@@9@9
  000ef	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000f2	83 e1 01	 and	 ecx, 1
  000f5	0b c1		 or	 eax, ecx
  000f7	89 45 f8	 mov	 DWORD PTR _fetched_bits$[ebp], eax

; 192  : 			bits <<= 1;

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bits@?1??depack_getbits@@9@9
  000ff	d1 e0		 shl	 eax, 1
  00101	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 193  : 			num_bits_left--;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9
  0010b	83 e8 01	 sub	 eax, 1
  0010e	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax

; 194  : 
; 195  : 			if( wrk.fullbits )

  00113	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  0011a	74 39		 je	 SHORT $LN9@depack_get@2

; 196  : 			{
; 197  : 				if( !num_bits_left )

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, 0
  00123	75 30		 jne	 SHORT $LN9@depack_get@2

; 198  : 				{
; 199  : 					bits = depack_getbits_word();

  00125	e8 00 00 00 00	 call	 _depack_getbits_word
  0012a	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 200  : 					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  0012f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?bits@?1??depack_getbits@@9@9, -1
  00136	75 05		 jne	 SHORT $LN2@depack_get@2
  00138	83 c8 ff	 or	 eax, -1
  0013b	eb 48		 jmp	 SHORT $LN17@depack_get@2
$LN2@depack_get@2:

; 201  : 					num_bits_left = wrk.wordbit ? 16 : 8;

  0013d	33 c0		 xor	 eax, eax
  0013f	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  00146	0f 95 c0	 setne	 al
  00149	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  00150	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax
$LN9@depack_get@2:

; 202  : 				}
; 203  : 			}
; 204  : 
; 205  : 		} while( --numbits );

  00155	8b 45 08	 mov	 eax, DWORD PTR _numbits$[ebp]
  00158	83 e8 01	 sub	 eax, 1
  0015b	89 45 08	 mov	 DWORD PTR _numbits$[ebp], eax
  0015e	0f 85 3b ff ff
	ff		 jne	 $LN10@depack_get@2

; 206  : 
; 207  : 		return fetched_bits;

  00164	8b 45 f8	 mov	 eax, DWORD PTR _fetched_bits$[ebp]
  00167	eb 1c		 jmp	 SHORT $LN17@depack_get@2

; 208  : 	}
; 209  : 	else

  00169	eb 1a		 jmp	 SHORT $LN17@depack_get@2
$LN13@depack_get@2:

; 210  : 	{
; 211  : 		printf("mhmt-depack.c:depack_getbits() - wrong operation code\n");

  0016b	8b f4		 mov	 esi, esp
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00178	83 c4 04	 add	 esp, 4
  0017b	3b f4		 cmp	 esi, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 212  : 		return 0xFFFFFFFF;

  00182	83 c8 ff	 or	 eax, -1
$LN17@depack_get@2:

; 213  : 	}
; 214  : }

  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx
  00188	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0018e	3b ec		 cmp	 ebp, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
_depack_getbits ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _depack_getbits_word
_TEXT	SEGMENT
_bits2$ = -20						; size = 4
_bits$ = -8						; size = 4
_depack_getbits_word PROC				; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 221  : 	ULONG bits,bits2;
; 222  : 
; 223  : 	if( wrk.wordbit ) // 16bits

  0001e	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  00025	0f 84 87 00 00
	00		 je	 $LN9@depack_get@3

; 224  : 	{
; 225  : 		if( wrk.bigend )

  0002b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _wrk+20, 0
  00032	74 35		 je	 SHORT $LN8@depack_get@3

; 226  : 		{
; 227  : 			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00034	6a 01		 push	 1
  00036	e8 00 00 00 00	 call	 _depack_getbyte
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR _bits$[ebp], eax

; 228  : 			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;

  00041	83 7d f8 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00045	75 08		 jne	 SHORT $LN7@depack_get@3
  00047	83 c8 ff	 or	 eax, -1
  0004a	e9 82 00 00 00	 jmp	 $LN10@depack_get@3
$LN7@depack_get@3:

; 229  : 			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0004f	6a 01		 push	 1
  00051	e8 00 00 00 00	 call	 _depack_getbyte
  00056	83 c4 04	 add	 esp, 4
  00059	89 45 ec	 mov	 DWORD PTR _bits2$[ebp], eax

; 230  : 			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;

  0005c	83 7d ec ff	 cmp	 DWORD PTR _bits2$[ebp], -1
  00060	75 05		 jne	 SHORT $LN6@depack_get@3
  00062	83 c8 ff	 or	 eax, -1
  00065	eb 6a		 jmp	 SHORT $LN10@depack_get@3
$LN6@depack_get@3:

; 231  : 		}
; 232  : 		else

  00067	eb 30		 jmp	 SHORT $LN5@depack_get@3
$LN8@depack_get@3:

; 233  : 		{
; 234  : 			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00069	6a 01		 push	 1
  0006b	e8 00 00 00 00	 call	 _depack_getbyte
  00070	83 c4 04	 add	 esp, 4
  00073	89 45 ec	 mov	 DWORD PTR _bits2$[ebp], eax

; 235  : 			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;

  00076	83 7d ec ff	 cmp	 DWORD PTR _bits2$[ebp], -1
  0007a	75 05		 jne	 SHORT $LN4@depack_get@3
  0007c	83 c8 ff	 or	 eax, -1
  0007f	eb 50		 jmp	 SHORT $LN10@depack_get@3
$LN4@depack_get@3:

; 236  : 			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00081	6a 01		 push	 1
  00083	e8 00 00 00 00	 call	 _depack_getbyte
  00088	83 c4 04	 add	 esp, 4
  0008b	89 45 f8	 mov	 DWORD PTR _bits$[ebp], eax

; 237  : 			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;

  0008e	83 7d f8 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  00092	75 05		 jne	 SHORT $LN5@depack_get@3
  00094	83 c8 ff	 or	 eax, -1
  00097	eb 38		 jmp	 SHORT $LN10@depack_get@3
$LN5@depack_get@3:

; 238  : 		}
; 239  : 
; 240  : 		bits = (bits<<24) | ( 0x00FF0000&(bits2<<16) );

  00099	8b 45 f8	 mov	 eax, DWORD PTR _bits$[ebp]
  0009c	c1 e0 18	 shl	 eax, 24			; 00000018H
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _bits2$[ebp]
  000a2	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a5	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  000ab	0b c1		 or	 eax, ecx
  000ad	89 45 f8	 mov	 DWORD PTR _bits$[ebp], eax

; 241  : 	}
; 242  : 	else // 8bits

  000b0	eb 1c		 jmp	 SHORT $LN2@depack_get@3
$LN9@depack_get@3:

; 243  : 	{
; 244  : 		bits=depack_getbyte(DEPACK_GETBYTE_NEXT);

  000b2	6a 01		 push	 1
  000b4	e8 00 00 00 00	 call	 _depack_getbyte
  000b9	83 c4 04	 add	 esp, 4
  000bc	89 45 f8	 mov	 DWORD PTR _bits$[ebp], eax

; 245  : 		if( bits!=0xFFFFFFFF)

  000bf	83 7d f8 ff	 cmp	 DWORD PTR _bits$[ebp], -1
  000c3	74 09		 je	 SHORT $LN2@depack_get@3

; 246  : 			bits <<= 24;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _bits$[ebp]
  000c8	c1 e0 18	 shl	 eax, 24			; 00000018H
  000cb	89 45 f8	 mov	 DWORD PTR _bits$[ebp], eax
$LN2@depack_get@3:

; 247  : 	}
; 248  : 
; 249  : 	return bits;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _bits$[ebp]
$LN10@depack_get@3:

; 250  : }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000da	3b ec		 cmp	 ebp, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_depack_getbits_word ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@ ; `string'
;	COMDAT ??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_outbyte() - bad operation requested', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _depack_outbyte
_TEXT	SEGMENT
_byte$ = 8						; size = 1
_operation$ = 12					; size = 4
_depack_outbyte PROC					; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 259  : 	if( operation==DEPACK_OUTBYTE_ADD )

  0001e	83 7d 0c 02	 cmp	 DWORD PTR _operation$[ebp], 2
  00022	75 56		 jne	 SHORT $LN7@depack_out

; 260  : 	{
; 261  : 		buffer[buf_ptr++] = byte;

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  00029	03 05 00 00 00
	00		 add	 eax, DWORD PTR _buf_ptr
  0002f	8a 4d 08	 mov	 cl, BYTE PTR _byte$[ebp]
  00032	88 08		 mov	 BYTE PTR [eax], cl
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _buf_ptr
  0003a	83 c2 01	 add	 edx, 1
  0003d	89 15 00 00 00
	00		 mov	 DWORD PTR _buf_ptr, edx

; 262  : 
; 263  : 
; 264  : 		if( buf_ptr>0x51d )
; 265  : 		{
; 266  : //			printf("\n");
; 267  : 		}
; 268  : 
; 269  : 
; 270  : 		if( buf_ptr >= buf_size )

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_ptr
  00048	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _buf_size
  0004e	72 21		 jb	 SHORT $LN5@depack_out

; 271  : 		{
; 272  : 			buf_ptr=0;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _buf_ptr, 0

; 273  : 			return emit_file( buffer, buf_size );

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_size
  0005f	50		 push	 eax
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buffer
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _emit_file
  0006c	83 c4 08	 add	 esp, 8
  0006f	eb 51		 jmp	 SHORT $LN8@depack_out
$LN5@depack_out:

; 274  : 		}
; 275  : 
; 276  : 		return 1;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	eb 4a		 jmp	 SHORT $LN8@depack_out
  00078	eb 48		 jmp	 SHORT $LN8@depack_out
$LN7@depack_out:

; 277  : 	}
; 278  : 	else if( operation==DEPACK_OUTBYTE_FLUSH )

  0007a	83 7d 0c 01	 cmp	 DWORD PTR _operation$[ebp], 1
  0007e	75 29		 jne	 SHORT $LN3@depack_out

; 279  : 	{
; 280  : 		if( buf_ptr ) return emit_file( buffer, buf_ptr );

  00080	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _buf_ptr, 0
  00087	74 17		 je	 SHORT $LN2@depack_out
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_ptr
  0008e	50		 push	 eax
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buffer
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _emit_file
  0009b	83 c4 08	 add	 esp, 8
  0009e	eb 22		 jmp	 SHORT $LN8@depack_out
$LN2@depack_out:

; 281  : 		return 1;

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	eb 1b		 jmp	 SHORT $LN8@depack_out

; 282  : 	}
; 283  : 	else

  000a7	eb 19		 jmp	 SHORT $LN8@depack_out
$LN3@depack_out:

; 284  : 	{
; 285  : 		printf("mhmt-depack.c:depack_outbyte() - bad operation requested\n");

  000a9	8b f4		 mov	 esi, esp
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000b6	83 c4 04	 add	 esp, 4
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 286  : 		return 0;

  000c0	33 c0		 xor	 eax, eax
$LN8@depack_out:

; 287  : 	}
; 288  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_depack_outbyte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
PUBLIC	??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
PUBLIC	??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
;	COMDAT ??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - displacement greater than buffer '
	DB	'size!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - non-negative displacement!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - zero length!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _depack_repeat
_TEXT	SEGMENT
tv80 = -220						; size = 4
_success$ = -20						; size = 4
_back_ptr$ = -8						; size = 4
_disp$ = 8						; size = 4
_length$ = 12						; size = 4
_depack_repeat PROC					; COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 296  : 	ULONG back_ptr;
; 297  : 	ULONG success=1;

  0001e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 298  : 
; 299  : //#ifdef DBG
; 300  : //	printf("\n");
; 301  : //#endif
; 302  : 
; 303  : 
; 304  : 	// in a self-consistent system, these three errors should never appear, since there is input stream check before actual depacking
; 305  : 	if( !length )

  00025	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  00029	75 23		 jne	 SHORT $LN9@depack_rep

; 306  : 	{
; 307  : 		printf("mhmt-depack.c:depack_repeat() - zero length!\n");

  0002b	8b f4		 mov	 esi, esp
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 308  : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	e9 d0 00 00 00	 jmp	 $LN10@depack_rep
  00049	e9 c8 00 00 00	 jmp	 $LN8@depack_rep
$LN9@depack_rep:

; 309  : 	}
; 310  : 	else if( disp>=0 )

  0004e	83 7d 08 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00052	7c 23		 jl	 SHORT $LN7@depack_rep

; 311  : 	{
; 312  : 		printf("mhmt-depack.c:depack_repeat() - non-negative displacement!\n");

  00054	8b f4		 mov	 esi, esp
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00061	83 c4 04	 add	 esp, 4
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 313  : 		return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 a7 00 00 00	 jmp	 $LN10@depack_rep
  00072	e9 9f 00 00 00	 jmp	 $LN8@depack_rep
$LN7@depack_rep:

; 314  : 	}
; 315  : 	else if( (ULONG)(-disp)>buf_size )

  00077	8b 45 08	 mov	 eax, DWORD PTR _disp$[ebp]
  0007a	f7 d8		 neg	 eax
  0007c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _buf_size
  00082	76 1d		 jbe	 SHORT $LN5@depack_rep

; 316  : 	{
; 317  : 		printf("mhmt-depack.c:depack_repeat() - displacement greater than buffer size!\n");

  00084	8b f4		 mov	 esi, esp
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 318  : 		return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	eb 7a		 jmp	 SHORT $LN10@depack_rep

; 319  : 	}
; 320  : 	else

  0009f	eb 75		 jmp	 SHORT $LN8@depack_rep
$LN5@depack_rep:

; 321  : 	{
; 322  : 		back_ptr = (disp+buf_ptr) & (buf_size-1); // buf_size MUST BE 2^N!

  000a1	8b 45 08	 mov	 eax, DWORD PTR _disp$[ebp]
  000a4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _buf_ptr
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buf_size
  000b0	83 e9 01	 sub	 ecx, 1
  000b3	23 c1		 and	 eax, ecx
  000b5	89 45 f8	 mov	 DWORD PTR _back_ptr$[ebp], eax
$LN3@depack_rep:

; 323  : 
; 324  : 		do
; 325  : 		{
; 326  : 			success = success && depack_outbyte( buffer[back_ptr], DEPACK_OUTBYTE_ADD ); // also increases buf_ptr

  000b8	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  000bc	74 26		 je	 SHORT $LN12@depack_rep
  000be	6a 02		 push	 2
  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  000c5	03 45 f8	 add	 eax, DWORD PTR _back_ptr$[ebp]
  000c8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _depack_outbyte
  000d1	83 c4 08	 add	 esp, 8
  000d4	85 c0		 test	 eax, eax
  000d6	74 0c		 je	 SHORT $LN12@depack_rep
  000d8	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv80[ebp], 1
  000e2	eb 0a		 jmp	 SHORT $LN13@depack_rep
$LN12@depack_rep:
  000e4	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$LN13@depack_rep:
  000ee	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  000f4	89 55 ec	 mov	 DWORD PTR _success$[ebp], edx

; 327  : 
; 328  : 			back_ptr = (back_ptr+1) & (buf_size-1); // buf_size MUST BE 2^N!

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _back_ptr$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buf_size
  00103	83 e9 01	 sub	 ecx, 1
  00106	23 c1		 and	 eax, ecx
  00108	89 45 f8	 mov	 DWORD PTR _back_ptr$[ebp], eax

; 329  : 
; 330  : 		} while( --length );

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0010e	83 e8 01	 sub	 eax, 1
  00111	89 45 0c	 mov	 DWORD PTR _length$[ebp], eax
  00114	75 a2		 jne	 SHORT $LN3@depack_rep
$LN8@depack_rep:

; 331  : 	}
; 332  : 
; 333  : 	return success;

  00116	8b 45 ec	 mov	 eax, DWORD PTR _success$[ebp]
$LN10@depack_rep:

; 334  : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00122	3b ec		 cmp	 ebp, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_depack_repeat ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-emit.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@ ; `string'
PUBLIC	??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@ ; `string'
PUBLIC	??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@ ; `string'
PUBLIC	_emit_bits
PUBLIC	_emit_byte
PUBLIC	_emit_file
PUBLIC	??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@ ; `string'
PUBLIC	_emit_megalz
EXTRN	_wrk:BYTE
EXTRN	__imp__printf:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
; File d:\d\mhmt\src\mhmt-emit.c
CONST	SEGMENT
??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@ DB 'Maximum displ'
	DB	'acement actually used is %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@
CONST	SEGMENT
??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - invalid code: length=%d, displacement'
	DB	'=%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@
CONST	SEGMENT
??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - encountered stop-code in optimal chai'
	DB	'n before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@
CONST	SEGMENT
??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - NULL passed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _emit_megalz
_TEXT	SEGMENT
tv283 = -280						; size = 4
tv277 = -280						; size = 4
tv271 = -280						; size = 4
tv260 = -280						; size = 4
tv252 = -280						; size = 4
tv243 = -280						; size = 4
tv234 = -280						; size = 4
tv226 = -280						; size = 4
tv218 = -280						; size = 4
tv210 = -280						; size = 4
tv194 = -280						; size = 4
tv188 = -280						; size = 4
tv178 = -280						; size = 4
tv170 = -280						; size = 4
tv160 = -280						; size = 4
tv153 = -280						; size = 4
tv145 = -280						; size = 4
tv138 = -280						; size = 4
tv89 = -280						; size = 4
tv83 = -280						; size = 4
tv77 = -280						; size = 4
tv71 = -280						; size = 4
_success$ = -80						; size = 4
_varlen$ = -68						; size = 4
_varbits$ = -56						; size = 4
_max_disp$ = -44					; size = 4
_disp$ = -32						; size = 4
_length$ = -20						; size = 4
_position$ = -8						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_megalz PROC					; COMDAT

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 14   : 	ULONG position;
; 15   : 	LONG length;
; 16   : 	LONG disp;
; 17   : 
; 18   : 	LONG max_disp; // maximum encountered displacement
; 19   : 
; 20   : 
; 21   : 	ULONG varbits,varlen;
; 22   : 
; 23   : 	ULONG success = 1;

  0001e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 24   : 
; 25   : 	max_disp = 0;

  00025	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _max_disp$[ebp], 0

; 26   : 
; 27   : 
; 28   : 	// some checks
; 29   : 	if( !optch )

  0002c	83 7d 08 00	 cmp	 DWORD PTR _optch$[ebp], 0
  00030	75 1e		 jne	 SHORT $LN30@emit_megal

; 30   : 	{
; 31   : 		printf("mhmt-emit.c:emit_megalz() - NULL passed!\n");

  00032	8b f4		 mov	 esi, esp
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 32   : 		return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 e8 06 00 00	 jmp	 $LN31@emit_megal
$LN30@emit_megal:

; 33   : 	}
; 34   : 
; 35   : 	// initialize
; 36   : 	success = success && emit_file(NULL, EMIT_FILE_INIT);

  00050	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00054	74 1c		 je	 SHORT $LN33@emit_megal
  00056	6a ff		 push	 -1
  00058	6a 00		 push	 0
  0005a	e8 00 00 00 00	 call	 _emit_file
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	74 0c		 je	 SHORT $LN33@emit_megal
  00066	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  00070	eb 0a		 jmp	 SHORT $LN34@emit_megal
$LN33@emit_megal:
  00072	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN34@emit_megal:
  0007c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00082	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 37   : 
; 38   : 	success = success && emit_byte(0, EMIT_BYTE_INIT);

  00085	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00089	74 1c		 je	 SHORT $LN35@emit_megal
  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 _emit_byte
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	74 0c		 je	 SHORT $LN35@emit_megal
  0009b	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
  000a5	eb 0a		 jmp	 SHORT $LN36@emit_megal
$LN35@emit_megal:
  000a7	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN36@emit_megal:
  000b1	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  000b7	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 39   : 
; 40   : 	success = success && emit_bits(0, EMIT_BITS_INIT);

  000ba	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  000be	74 1c		 je	 SHORT $LN37@emit_megal
  000c0	6a ff		 push	 -1
  000c2	6a 00		 push	 0
  000c4	e8 00 00 00 00	 call	 _emit_bits
  000c9	83 c4 08	 add	 esp, 8
  000cc	85 c0		 test	 eax, eax
  000ce	74 0c		 je	 SHORT $LN37@emit_megal
  000d0	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv83[ebp], 1
  000da	eb 0a		 jmp	 SHORT $LN38@emit_megal
$LN37@emit_megal:
  000dc	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv83[ebp], 0
$LN38@emit_megal:
  000e6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  000ec	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 41   : 
; 42   : 
; 43   : 	// copy first byte as-is
; 44   : 	success = success && emit_file( wrk.indata, 1);

  000ef	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  000f3	74 20		 je	 SHORT $LN39@emit_megal
  000f5	6a 01		 push	 1
  000f7	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _emit_file
  00102	83 c4 08	 add	 esp, 8
  00105	85 c0		 test	 eax, eax
  00107	74 0c		 je	 SHORT $LN39@emit_megal
  00109	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv89[ebp], 1
  00113	eb 0a		 jmp	 SHORT $LN40@emit_megal
$LN39@emit_megal:
  00115	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
$LN40@emit_megal:
  0011f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp]
  00125	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 45   : 
; 46   : 	// go emitting codes
; 47   : 	position = 1;

  00128	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _position$[ebp], 1
$LN29@emit_megal:

; 48   : 
; 49   : 	while( (position<actual_len) && success )

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00132	3b 45 0c	 cmp	 eax, DWORD PTR _actual_len$[ebp]
  00135	0f 83 35 05 00
	00		 jae	 $LN28@emit_megal
  0013b	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0013f	0f 84 2b 05 00
	00		 je	 $LN28@emit_megal

; 50   : 	{
; 51   : 		length = optch[position].code.length;

  00145	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00148	c1 e0 04	 shl	 eax, 4
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  0014e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00151	89 55 ec	 mov	 DWORD PTR _length$[ebp], edx

; 52   : 		disp   = optch[position].code.disp;

  00154	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00157	c1 e0 04	 shl	 eax, 4
  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  0015d	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00161	89 55 e0	 mov	 DWORD PTR _disp$[ebp], edx

; 53   : 
; 54   : 		if( length==0 )

  00164	83 7d ec 00	 cmp	 DWORD PTR _length$[ebp], 0
  00168	75 23		 jne	 SHORT $LN27@emit_megal

; 55   : 		{
; 56   : 			printf("mhmt-emit.c:emit_megalz() - encountered stop-code in optimal chain before emitting all data!\n");

  0016a	8b f4		 mov	 esi, esp
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00177	83 c4 04	 add	 esp, 4
  0017a	3b f4		 cmp	 esi, esp
  0017c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 57   : 			return 0;

  00181	33 c0		 xor	 eax, eax
  00183	e9 b0 05 00 00	 jmp	 $LN31@emit_megal
  00188	e9 d5 04 00 00	 jmp	 $LN26@emit_megal
$LN27@emit_megal:

; 58   : 		}
; 59   : 		else if( length==1 ) // either copy-byte or len=1 code

  0018d	83 7d ec 01	 cmp	 DWORD PTR _length$[ebp], 1
  00191	0f 85 1b 01 00
	00		 jne	 $LN25@emit_megal

; 60   : 		{
; 61   : 			if( disp==0 ) // copy-byte (%1<byte>)

  00197	83 7d e0 00	 cmp	 DWORD PTR _disp$[ebp], 0
  0019b	75 7c		 jne	 SHORT $LN24@emit_megal

; 62   : 			{
; 63   : 				success = success && emit_bits( 0x80000000, 1 );

  0019d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  001a1	74 1f		 je	 SHORT $LN41@emit_megal
  001a3	6a 01		 push	 1
  001a5	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001aa	e8 00 00 00 00	 call	 _emit_bits
  001af	83 c4 08	 add	 esp, 8
  001b2	85 c0		 test	 eax, eax
  001b4	74 0c		 je	 SHORT $LN41@emit_megal
  001b6	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv138[ebp], 1
  001c0	eb 0a		 jmp	 SHORT $LN42@emit_megal
$LN41@emit_megal:
  001c2	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp], 0
$LN42@emit_megal:
  001cc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv138[ebp]
  001d2	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 64   : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  001d5	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  001d9	74 26		 je	 SHORT $LN43@emit_megal
  001db	6a 02		 push	 2
  001dd	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001e2	03 45 f8	 add	 eax, DWORD PTR _position$[ebp]
  001e5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 _emit_byte
  001ee	83 c4 08	 add	 esp, 8
  001f1	85 c0		 test	 eax, eax
  001f3	74 0c		 je	 SHORT $LN43@emit_megal
  001f5	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv145[ebp], 1
  001ff	eb 0a		 jmp	 SHORT $LN44@emit_megal
$LN43@emit_megal:
  00201	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv145[ebp], 0
$LN44@emit_megal:
  0020b	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv145[ebp]
  00211	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx
  00214	e9 94 00 00 00	 jmp	 $LN23@emit_megal
$LN24@emit_megal:

; 65   : 			}
; 66   : 			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)

  00219	83 7d e0 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  0021d	0f 8c 85 00 00
	00		 jl	 $LN22@emit_megal
  00223	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00227	7f 7f		 jg	 SHORT $LN22@emit_megal

; 67   : 			{
; 68   : 				success = success && emit_bits( 0x00000000,   3 );

  00229	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0022d	74 1c		 je	 SHORT $LN45@emit_megal
  0022f	6a 03		 push	 3
  00231	6a 00		 push	 0
  00233	e8 00 00 00 00	 call	 _emit_bits
  00238	83 c4 08	 add	 esp, 8
  0023b	85 c0		 test	 eax, eax
  0023d	74 0c		 je	 SHORT $LN45@emit_megal
  0023f	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  00249	eb 0a		 jmp	 SHORT $LN46@emit_megal
$LN45@emit_megal:
  0024b	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN46@emit_megal:
  00255	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  0025b	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 69   : 				success = success && emit_bits( disp<<(32-3), 3 );

  0025e	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00262	74 21		 je	 SHORT $LN47@emit_megal
  00264	6a 03		 push	 3
  00266	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00269	c1 e0 1d	 shl	 eax, 29			; 0000001dH
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _emit_bits
  00272	83 c4 08	 add	 esp, 8
  00275	85 c0		 test	 eax, eax
  00277	74 0c		 je	 SHORT $LN47@emit_megal
  00279	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv160[ebp], 1
  00283	eb 0a		 jmp	 SHORT $LN48@emit_megal
$LN47@emit_megal:
  00285	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN48@emit_megal:
  0028f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv160[ebp]
  00295	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 70   : 
; 71   : 				if( max_disp > disp ) max_disp = disp;

  00298	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0029b	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  0029e	7e 06		 jle	 SHORT $LN21@emit_megal
  002a0	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  002a3	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN21@emit_megal:

; 72   : 			}
; 73   : 			else

  002a6	eb 05		 jmp	 SHORT $LN23@emit_megal
$LN22@emit_megal:

; 74   : 				goto INVALID_CODE_MEGALZ;

  002a8	e9 8f 03 00 00	 jmp	 $INVALID_CODE_MEGALZ$2631
$LN23@emit_megal:

; 75   : 		}
; 76   : 		else if( length==2 )

  002ad	e9 b0 03 00 00	 jmp	 $LN26@emit_megal
$LN25@emit_megal:
  002b2	83 7d ec 02	 cmp	 DWORD PTR _length$[ebp], 2
  002b6	0f 85 a5 00 00
	00		 jne	 $LN18@emit_megal

; 77   : 		{
; 78   : 			if( (-256)<=disp && disp<=(-1) ) // %001<byte>

  002bc	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  002c3	0f 8c 8e 00 00
	00		 jl	 $LN17@emit_megal
  002c9	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  002cd	0f 8f 84 00 00
	00		 jg	 $LN17@emit_megal

; 79   : 			{
; 80   : 				success = success && emit_bits( 0x20000000, 3 );

  002d3	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  002d7	74 1f		 je	 SHORT $LN49@emit_megal
  002d9	6a 03		 push	 3
  002db	68 00 00 00 20	 push	 536870912		; 20000000H
  002e0	e8 00 00 00 00	 call	 _emit_bits
  002e5	83 c4 08	 add	 esp, 8
  002e8	85 c0		 test	 eax, eax
  002ea	74 0c		 je	 SHORT $LN49@emit_megal
  002ec	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv170[ebp], 1
  002f6	eb 0a		 jmp	 SHORT $LN50@emit_megal
$LN49@emit_megal:
  002f8	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv170[ebp], 0
$LN50@emit_megal:
  00302	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv170[ebp]
  00308	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 81   : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  0030b	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0030f	74 23		 je	 SHORT $LN51@emit_megal
  00311	6a 02		 push	 2
  00313	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00316	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0031b	50		 push	 eax
  0031c	e8 00 00 00 00	 call	 _emit_byte
  00321	83 c4 08	 add	 esp, 8
  00324	85 c0		 test	 eax, eax
  00326	74 0c		 je	 SHORT $LN51@emit_megal
  00328	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv178[ebp], 1
  00332	eb 0a		 jmp	 SHORT $LN52@emit_megal
$LN51@emit_megal:
  00334	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv178[ebp], 0
$LN52@emit_megal:
  0033e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv178[ebp]
  00344	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 82   : 
; 83   : 				if( max_disp > disp ) max_disp = disp;

  00347	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0034a	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  0034d	7e 06		 jle	 SHORT $LN16@emit_megal
  0034f	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00352	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN16@emit_megal:

; 84   : 			}
; 85   : 			else

  00355	eb 05		 jmp	 SHORT $LN15@emit_megal
$LN17@emit_megal:

; 86   : 				goto INVALID_CODE_MEGALZ;

  00357	e9 e0 02 00 00	 jmp	 $INVALID_CODE_MEGALZ$2631
$LN15@emit_megal:

; 87   : 		}
; 88   : 		else if( 3<=length && length<=255 )

  0035c	e9 01 03 00 00	 jmp	 $LN26@emit_megal
$LN18@emit_megal:
  00361	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  00365	0f 8c d1 02 00
	00		 jl	 $INVALID_CODE_MEGALZ$2631
  0036b	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  00372	0f 8f c4 02 00
	00		 jg	 $INVALID_CODE_MEGALZ$2631

; 89   : 		{
; 90   : 			// length coding
; 91   : 			if( length==3 ) // %010

  00378	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  0037c	75 3d		 jne	 SHORT $LN12@emit_megal

; 92   : 			{
; 93   : 				success = success && emit_bits( 0x40000000, 3 );

  0037e	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00382	74 1f		 je	 SHORT $LN53@emit_megal
  00384	6a 03		 push	 3
  00386	68 00 00 00 40	 push	 1073741824		; 40000000H
  0038b	e8 00 00 00 00	 call	 _emit_bits
  00390	83 c4 08	 add	 esp, 8
  00393	85 c0		 test	 eax, eax
  00395	74 0c		 je	 SHORT $LN53@emit_megal
  00397	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv188[ebp], 1
  003a1	eb 0a		 jmp	 SHORT $LN54@emit_megal
$LN53@emit_megal:
  003a3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv188[ebp], 0
$LN54@emit_megal:
  003ad	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  003b3	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 94   : 			}
; 95   : 			else // length==4..255, %011

  003b6	e9 00 01 00 00	 jmp	 $LN11@emit_megal
$LN12@emit_megal:

; 96   : 			{
; 97   : 				success = success && emit_bits( 0x60000000, 3 );

  003bb	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  003bf	74 1f		 je	 SHORT $LN55@emit_megal
  003c1	6a 03		 push	 3
  003c3	68 00 00 00 60	 push	 1610612736		; 60000000H
  003c8	e8 00 00 00 00	 call	 _emit_bits
  003cd	83 c4 08	 add	 esp, 8
  003d0	85 c0		 test	 eax, eax
  003d2	74 0c		 je	 SHORT $LN55@emit_megal
  003d4	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv194[ebp], 1
  003de	eb 0a		 jmp	 SHORT $LN56@emit_megal
$LN55@emit_megal:
  003e0	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv194[ebp], 0
$LN56@emit_megal:
  003ea	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv194[ebp]
  003f0	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 98   : 
; 99   : 				// calculate size of variable bits
; 100  : 				varlen = 0;

  003f3	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 0

; 101  : 				varbits = (length-2)>>1;

  003fa	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  003fd	83 e8 02	 sub	 eax, 2
  00400	d1 f8		 sar	 eax, 1
  00402	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax
$LN10@emit_megal:

; 102  : 				while( varbits )

  00405	83 7d c8 00	 cmp	 DWORD PTR _varbits$[ebp], 0
  00409	74 13		 je	 SHORT $LN9@emit_megal

; 103  : 				{
; 104  : 					varbits >>= 1;

  0040b	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  0040e	d1 e8		 shr	 eax, 1
  00410	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 105  : 					varlen++;

  00413	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00416	83 c0 01	 add	 eax, 1
  00419	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax

; 106  : 				}

  0041c	eb e7		 jmp	 SHORT $LN10@emit_megal
$LN9@emit_megal:

; 107  : 
; 108  : 				varbits = length-2-(1<<varlen); // prepare length coding

  0041e	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00421	83 e8 02	 sub	 eax, 2
  00424	ba 01 00 00 00	 mov	 edx, 1
  00429	8b 4d bc	 mov	 ecx, DWORD PTR _varlen$[ebp]
  0042c	d3 e2		 shl	 edx, cl
  0042e	2b c2		 sub	 eax, edx
  00430	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 109  : 
; 110  : 				success = success && emit_bits(       1<<(32-varlen), varlen );

  00433	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00437	74 2c		 je	 SHORT $LN57@emit_megal
  00439	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  0043c	50		 push	 eax
  0043d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00442	2b 4d bc	 sub	 ecx, DWORD PTR _varlen$[ebp]
  00445	ba 01 00 00 00	 mov	 edx, 1
  0044a	d3 e2		 shl	 edx, cl
  0044c	52		 push	 edx
  0044d	e8 00 00 00 00	 call	 _emit_bits
  00452	83 c4 08	 add	 esp, 8
  00455	85 c0		 test	 eax, eax
  00457	74 0c		 je	 SHORT $LN57@emit_megal
  00459	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv210[ebp], 1
  00463	eb 0a		 jmp	 SHORT $LN58@emit_megal
$LN57@emit_megal:
  00465	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv210[ebp], 0
$LN58@emit_megal:
  0046f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv210[ebp]
  00475	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 111  : 				success = success && emit_bits( varbits<<(32-varlen), varlen );

  00478	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0047c	74 2a		 je	 SHORT $LN59@emit_megal
  0047e	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00481	50		 push	 eax
  00482	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00487	2b 4d bc	 sub	 ecx, DWORD PTR _varlen$[ebp]
  0048a	8b 55 c8	 mov	 edx, DWORD PTR _varbits$[ebp]
  0048d	d3 e2		 shl	 edx, cl
  0048f	52		 push	 edx
  00490	e8 00 00 00 00	 call	 _emit_bits
  00495	83 c4 08	 add	 esp, 8
  00498	85 c0		 test	 eax, eax
  0049a	74 0c		 je	 SHORT $LN59@emit_megal
  0049c	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv218[ebp], 1
  004a6	eb 0a		 jmp	 SHORT $LN60@emit_megal
$LN59@emit_megal:
  004a8	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv218[ebp], 0
$LN60@emit_megal:
  004b2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv218[ebp]
  004b8	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax
$LN11@emit_megal:

; 112  : 			}
; 113  : 
; 114  : 			// displacement coding
; 115  : 			if( (-256)<=disp && disp<=(-1) )

  004bb	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  004c2	0f 8c 8e 00 00
	00		 jl	 $LN8@emit_megal
  004c8	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  004cc	0f 8f 84 00 00
	00		 jg	 $LN8@emit_megal

; 116  : 			{
; 117  : 				success = success && emit_bits( 0, 1 );

  004d2	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  004d6	74 1c		 je	 SHORT $LN61@emit_megal
  004d8	6a 01		 push	 1
  004da	6a 00		 push	 0
  004dc	e8 00 00 00 00	 call	 _emit_bits
  004e1	83 c4 08	 add	 esp, 8
  004e4	85 c0		 test	 eax, eax
  004e6	74 0c		 je	 SHORT $LN61@emit_megal
  004e8	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv226[ebp], 1
  004f2	eb 0a		 jmp	 SHORT $LN62@emit_megal
$LN61@emit_megal:
  004f4	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv226[ebp], 0
$LN62@emit_megal:
  004fe	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv226[ebp]
  00504	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 118  : 				success = success && emit_byte( (UBYTE)(0x00ff & disp), EMIT_BYTE_ADD );

  00507	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0050b	74 23		 je	 SHORT $LN63@emit_megal
  0050d	6a 02		 push	 2
  0050f	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00512	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 _emit_byte
  0051d	83 c4 08	 add	 esp, 8
  00520	85 c0		 test	 eax, eax
  00522	74 0c		 je	 SHORT $LN63@emit_megal
  00524	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv234[ebp], 1
  0052e	eb 0a		 jmp	 SHORT $LN64@emit_megal
$LN63@emit_megal:
  00530	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv234[ebp], 0
$LN64@emit_megal:
  0053a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv234[ebp]
  00540	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 119  : 
; 120  : 				if( max_disp > disp ) max_disp = disp;

  00543	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  00546	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  00549	7e 06		 jle	 SHORT $LN7@emit_megal
  0054b	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  0054e	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN7@emit_megal:

; 121  : 			}
; 122  : 			else if( (-4352)<=disp && disp<(-256) )

  00551	e9 e4 00 00 00	 jmp	 $LN6@emit_megal
$LN8@emit_megal:
  00556	81 7d e0 00 ef
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -4352 ; ffffef00H
  0055d	0f 8c d5 00 00
	00		 jl	 $LN5@emit_megal
  00563	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  0056a	0f 8d c8 00 00
	00		 jge	 $LN5@emit_megal

; 123  : 			{
; 124  : 				success = success && emit_bits( 0x80000000, 1 );

  00570	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00574	74 1f		 je	 SHORT $LN65@emit_megal
  00576	6a 01		 push	 1
  00578	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0057d	e8 00 00 00 00	 call	 _emit_bits
  00582	83 c4 08	 add	 esp, 8
  00585	85 c0		 test	 eax, eax
  00587	74 0c		 je	 SHORT $LN65@emit_megal
  00589	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv243[ebp], 1
  00593	eb 0a		 jmp	 SHORT $LN66@emit_megal
$LN65@emit_megal:
  00595	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv243[ebp], 0
$LN66@emit_megal:
  0059f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv243[ebp]
  005a5	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 125  : 
; 126  : 				success = success && emit_bits( (0x0F00&(disp+0x0100))<<20, 4 );

  005a8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  005ac	74 2b		 je	 SHORT $LN67@emit_megal
  005ae	6a 04		 push	 4
  005b0	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  005b3	05 00 01 00 00	 add	 eax, 256		; 00000100H
  005b8	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  005bd	c1 e0 14	 shl	 eax, 20			; 00000014H
  005c0	50		 push	 eax
  005c1	e8 00 00 00 00	 call	 _emit_bits
  005c6	83 c4 08	 add	 esp, 8
  005c9	85 c0		 test	 eax, eax
  005cb	74 0c		 je	 SHORT $LN67@emit_megal
  005cd	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv252[ebp], 1
  005d7	eb 0a		 jmp	 SHORT $LN68@emit_megal
$LN67@emit_megal:
  005d9	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv252[ebp], 0
$LN68@emit_megal:
  005e3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv252[ebp]
  005e9	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 127  : 
; 128  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  005ec	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  005f0	74 23		 je	 SHORT $LN69@emit_megal
  005f2	6a 02		 push	 2
  005f4	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  005f7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005fc	50		 push	 eax
  005fd	e8 00 00 00 00	 call	 _emit_byte
  00602	83 c4 08	 add	 esp, 8
  00605	85 c0		 test	 eax, eax
  00607	74 0c		 je	 SHORT $LN69@emit_megal
  00609	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv260[ebp], 1
  00613	eb 0a		 jmp	 SHORT $LN70@emit_megal
$LN69@emit_megal:
  00615	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv260[ebp], 0
$LN70@emit_megal:
  0061f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv260[ebp]
  00625	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 129  : 
; 130  : 				if( max_disp > disp ) max_disp = disp;

  00628	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0062b	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  0062e	7e 06		 jle	 SHORT $LN4@emit_megal
  00630	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00633	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN4@emit_megal:

; 131  : 			}
; 132  : 			else

  00636	eb 02		 jmp	 SHORT $LN6@emit_megal
$LN5@emit_megal:

; 133  : 				goto INVALID_CODE_MEGALZ;

  00638	eb 02		 jmp	 SHORT $INVALID_CODE_MEGALZ$2631
$LN6@emit_megal:

; 134  : 		}
; 135  : 		else

  0063a	eb 26		 jmp	 SHORT $LN26@emit_megal
$INVALID_CODE_MEGALZ$2631:

; 136  : 		{
; 137  : INVALID_CODE_MEGALZ:
; 138  : 			printf("mhmt-emit.c:emit_megalz() - invalid code: length=%d, displacement=%d\n",length,disp);

  0063c	8b f4		 mov	 esi, esp
  0063e	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00641	50		 push	 eax
  00642	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00645	51		 push	 ecx
  00646	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@
  0064b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00651	83 c4 0c	 add	 esp, 12			; 0000000cH
  00654	3b f4		 cmp	 esi, esp
  00656	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 139  : 			return 0;

  0065b	33 c0		 xor	 eax, eax
  0065d	e9 d6 00 00 00	 jmp	 $LN31@emit_megal
$LN26@emit_megal:

; 140  : 		}
; 141  : 
; 142  : 		position += length;

  00662	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00665	03 45 ec	 add	 eax, DWORD PTR _length$[ebp]
  00668	89 45 f8	 mov	 DWORD PTR _position$[ebp], eax

; 143  : 	}

  0066b	e9 bf fa ff ff	 jmp	 $LN29@emit_megal
$LN28@emit_megal:

; 144  : 
; 145  : 	// stop-code
; 146  : 	success = success && emit_bits( 0x60100000, 12 );

  00670	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00674	74 1f		 je	 SHORT $LN71@emit_megal
  00676	6a 0c		 push	 12			; 0000000cH
  00678	68 00 00 10 60	 push	 1611661312		; 60100000H
  0067d	e8 00 00 00 00	 call	 _emit_bits
  00682	83 c4 08	 add	 esp, 8
  00685	85 c0		 test	 eax, eax
  00687	74 0c		 je	 SHORT $LN71@emit_megal
  00689	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv271[ebp], 1
  00693	eb 0a		 jmp	 SHORT $LN72@emit_megal
$LN71@emit_megal:
  00695	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv271[ebp], 0
$LN72@emit_megal:
  0069f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv271[ebp]
  006a5	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 147  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  006a8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006ac	74 1c		 je	 SHORT $LN73@emit_megal
  006ae	6a 00		 push	 0
  006b0	6a 00		 push	 0
  006b2	e8 00 00 00 00	 call	 _emit_bits
  006b7	83 c4 08	 add	 esp, 8
  006ba	85 c0		 test	 eax, eax
  006bc	74 0c		 je	 SHORT $LN73@emit_megal
  006be	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv277[ebp], 1
  006c8	eb 0a		 jmp	 SHORT $LN74@emit_megal
$LN73@emit_megal:
  006ca	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv277[ebp], 0
$LN74@emit_megal:
  006d4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv277[ebp]
  006da	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 148  : 
; 149  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  006dd	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006e1	74 1c		 je	 SHORT $LN75@emit_megal
  006e3	6a 00		 push	 0
  006e5	6a 00		 push	 0
  006e7	e8 00 00 00 00	 call	 _emit_file
  006ec	83 c4 08	 add	 esp, 8
  006ef	85 c0		 test	 eax, eax
  006f1	74 0c		 je	 SHORT $LN75@emit_megal
  006f3	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv283[ebp], 1
  006fd	eb 0a		 jmp	 SHORT $LN76@emit_megal
$LN75@emit_megal:
  006ff	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv283[ebp], 0
$LN76@emit_megal:
  00709	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv283[ebp]
  0070f	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 150  : 
; 151  : 	if( success )

  00712	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00716	74 1d		 je	 SHORT $LN1@emit_megal

; 152  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  00718	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0071b	f7 d8		 neg	 eax
  0071d	8b f4		 mov	 esi, esp
  0071f	50		 push	 eax
  00720	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  00725	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0072b	83 c4 08	 add	 esp, 8
  0072e	3b f4		 cmp	 esi, esp
  00730	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@emit_megal:

; 153  : 
; 154  : 	return success;

  00735	8b 45 b0	 mov	 eax, DWORD PTR _success$[ebp]
$LN31@emit_megal:

; 155  : }

  00738	5f		 pop	 edi
  00739	5e		 pop	 esi
  0073a	5b		 pop	 ebx
  0073b	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00741	3b ec		 cmp	 ebp, esp
  00743	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00748	8b e5		 mov	 esp, ebp
  0074a	5d		 pop	 ebp
  0074b	c3		 ret	 0
_emit_megalz ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@ ; `string'
PUBLIC	??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@ ; `string'
PUBLIC	??_C@_02FGFKJHMM@?$BA?$BA?$AA@			; `string'
PUBLIC	??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@ ; `string'
PUBLIC	_emit_hrum
;	COMDAT ??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@
CONST	SEGMENT
??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@ DB 'mhmt'
	DB	'-emit.c:emit_hrum() - invalid code: length=%d, displacement=%'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@
CONST	SEGMENT
??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@ DB 'mhmt'
	DB	'-emit.c:emit_hrum() - encountered stop-code in optimal chain '
	DB	'before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGFKJHMM@?$BA?$BA?$AA@
CONST	SEGMENT
??_C@_02FGFKJHMM@?$BA?$BA?$AA@ DB 010H, 010H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@
CONST	SEGMENT
??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@ DB 'mhm'
	DB	't-emit.c:emit_hrum() - NULL passed!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _emit_hrum
_TEXT	SEGMENT
tv315 = -280						; size = 4
tv309 = -280						; size = 4
tv303 = -280						; size = 4
tv297 = -280						; size = 4
tv286 = -280						; size = 4
tv278 = -280						; size = 4
tv270 = -280						; size = 4
tv261 = -280						; size = 4
tv253 = -280						; size = 4
tv245 = -280						; size = 4
tv237 = -280						; size = 4
tv231 = -280						; size = 4
tv225 = -280						; size = 4
tv203 = -280						; size = 4
tv193 = -280						; size = 4
tv185 = -280						; size = 4
tv175 = -280						; size = 4
tv168 = -280						; size = 4
tv160 = -280						; size = 4
tv153 = -280						; size = 4
tv136 = -280						; size = 4
tv130 = -280						; size = 4
tv92 = -280						; size = 4
tv83 = -280						; size = 4
tv77 = -280						; size = 4
tv71 = -280						; size = 4
_success$ = -80						; size = 4
_varlen$ = -68						; size = 4
_varbits$ = -56						; size = 4
_max_disp$ = -44					; size = 4
_disp$ = -32						; size = 4
_length$ = -20						; size = 4
_position$ = -8						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_hrum PROC						; COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 175  : 	ULONG position;
; 176  : 	LONG length;
; 177  : 	LONG disp;
; 178  : 
; 179  : 	LONG max_disp; // maximum encountered displacement
; 180  : 
; 181  : 
; 182  : 	ULONG varbits,varlen;
; 183  : 
; 184  : 	ULONG success = 1;

  0001e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 185  : 
; 186  : 	max_disp = 0;

  00025	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _max_disp$[ebp], 0

; 187  : 
; 188  : 
; 189  : 	// some checks
; 190  : 	if( !optch )

  0002c	83 7d 08 00	 cmp	 DWORD PTR _optch$[ebp], 0
  00030	75 1e		 jne	 SHORT $LN35@emit_hrum

; 191  : 	{
; 192  : 		printf("mhmt-emit.c:emit_hrum() - NULL passed!\n");

  00032	8b f4		 mov	 esi, esp
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 193  : 		return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 0c 08 00 00	 jmp	 $LN36@emit_hrum
$LN35@emit_hrum:

; 194  : 	}
; 195  : 
; 196  : 	// initialize
; 197  : 	success = success && emit_file(NULL, EMIT_FILE_INIT);

  00050	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00054	74 1c		 je	 SHORT $LN38@emit_hrum
  00056	6a ff		 push	 -1
  00058	6a 00		 push	 0
  0005a	e8 00 00 00 00	 call	 _emit_file
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	74 0c		 je	 SHORT $LN38@emit_hrum
  00066	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  00070	eb 0a		 jmp	 SHORT $LN39@emit_hrum
$LN38@emit_hrum:
  00072	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN39@emit_hrum:
  0007c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00082	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 198  : 
; 199  : 	success = success && emit_byte(0, EMIT_BYTE_INIT);

  00085	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00089	74 1c		 je	 SHORT $LN40@emit_hrum
  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 _emit_byte
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	74 0c		 je	 SHORT $LN40@emit_hrum
  0009b	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
  000a5	eb 0a		 jmp	 SHORT $LN41@emit_hrum
$LN40@emit_hrum:
  000a7	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN41@emit_hrum:
  000b1	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  000b7	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 200  : 
; 201  : 	success = success && emit_bits(0, EMIT_BITS_INIT);

  000ba	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  000be	74 1c		 je	 SHORT $LN42@emit_hrum
  000c0	6a ff		 push	 -1
  000c2	6a 00		 push	 0
  000c4	e8 00 00 00 00	 call	 _emit_bits
  000c9	83 c4 08	 add	 esp, 8
  000cc	85 c0		 test	 eax, eax
  000ce	74 0c		 je	 SHORT $LN42@emit_hrum
  000d0	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv83[ebp], 1
  000da	eb 0a		 jmp	 SHORT $LN43@emit_hrum
$LN42@emit_hrum:
  000dc	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv83[ebp], 0
$LN43@emit_hrum:
  000e6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  000ec	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 202  : 
; 203  : 
; 204  : 	// manage zx header info
; 205  : 	if( wrk.zxheader )

  000ef	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  000f6	74 7b		 je	 SHORT $LN34@emit_hrum

; 206  : 	{
; 207  :         success = success && emit_file( &wrk.indata[wrk.inlen-5], 5);

  000f8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  000fc	74 2a		 je	 SHORT $LN44@emit_hrum
  000fe	6a 05		 push	 5
  00100	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  00105	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  0010b	8d 54 01 fb	 lea	 edx, DWORD PTR [ecx+eax-5]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _emit_file
  00115	83 c4 08	 add	 esp, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0c		 je	 SHORT $LN44@emit_hrum
  0011c	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv92[ebp], 1
  00126	eb 0a		 jmp	 SHORT $LN45@emit_hrum
$LN44@emit_hrum:
  00128	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN45@emit_hrum:
  00132	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv92[ebp]
  00138	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 208  : 		success = success && emit_file( (UBYTE*)"\020\020", 2); // 0x10, 0x10

  0013b	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0013f	74 1f		 je	 SHORT $LN46@emit_hrum
  00141	6a 02		 push	 2
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_02FGFKJHMM@?$BA?$BA?$AA@
  00148	e8 00 00 00 00	 call	 _emit_file
  0014d	83 c4 08	 add	 esp, 8
  00150	85 c0		 test	 eax, eax
  00152	74 0c		 je	 SHORT $LN46@emit_hrum
  00154	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv130[ebp], 1
  0015e	eb 0a		 jmp	 SHORT $LN47@emit_hrum
$LN46@emit_hrum:
  00160	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
$LN47@emit_hrum:
  0016a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  00170	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax
$LN34@emit_hrum:

; 209  : 	}
; 210  : 
; 211  : 	// schedule first byte to be placed just after first bitstream word
; 212  : 	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

  00173	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00177	74 23		 je	 SHORT $LN48@emit_hrum
  00179	6a 02		 push	 2
  0017b	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00180	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 _emit_byte
  00189	83 c4 08	 add	 esp, 8
  0018c	85 c0		 test	 eax, eax
  0018e	74 0c		 je	 SHORT $LN48@emit_hrum
  00190	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
  0019a	eb 0a		 jmp	 SHORT $LN49@emit_hrum
$LN48@emit_hrum:
  0019c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN49@emit_hrum:
  001a6	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv136[ebp]
  001ac	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx

; 213  : 
; 214  : 	// go emitting codes
; 215  : 	position = 1;

  001af	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _position$[ebp], 1
$LN33@emit_hrum:

; 216  : 
; 217  : 	while( (position<actual_len) && success )

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  001b9	3b 45 0c	 cmp	 eax, DWORD PTR _actual_len$[ebp]
  001bc	0f 83 9d 05 00
	00		 jae	 $LN32@emit_hrum
  001c2	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  001c6	0f 84 93 05 00
	00		 je	 $LN32@emit_hrum

; 218  : 	{
; 219  : 		length = optch[position].code.length;

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  001cf	c1 e0 04	 shl	 eax, 4
  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  001d5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001d8	89 55 ec	 mov	 DWORD PTR _length$[ebp], edx

; 220  : 		disp   = optch[position].code.disp;

  001db	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  001de	c1 e0 04	 shl	 eax, 4
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  001e4	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001e8	89 55 e0	 mov	 DWORD PTR _disp$[ebp], edx

; 221  : 
; 222  : 		if( length==0 )

  001eb	83 7d ec 00	 cmp	 DWORD PTR _length$[ebp], 0
  001ef	75 23		 jne	 SHORT $LN31@emit_hrum

; 223  : 		{
; 224  : 			printf("mhmt-emit.c:emit_hrum() - encountered stop-code in optimal chain before emitting all data!\n");

  001f1	8b f4		 mov	 esi, esp
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001fe	83 c4 04	 add	 esp, 4
  00201	3b f4		 cmp	 esi, esp
  00203	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 225  : 			return 0;

  00208	33 c0		 xor	 eax, eax
  0020a	e9 4d 06 00 00	 jmp	 $LN36@emit_hrum
  0020f	e9 3d 05 00 00	 jmp	 $LN30@emit_hrum
$LN31@emit_hrum:

; 226  : 		}
; 227  : 		else if( length==1 ) // either copy-byte or len=1 code

  00214	83 7d ec 01	 cmp	 DWORD PTR _length$[ebp], 1
  00218	0f 85 1b 01 00
	00		 jne	 $LN29@emit_hrum

; 228  : 		{
; 229  : 			if( disp==0 ) // copy-byte (%1<byte>)

  0021e	83 7d e0 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00222	75 7c		 jne	 SHORT $LN28@emit_hrum

; 230  : 			{
; 231  : 				success = success && emit_bits( 0x80000000, 1 );

  00224	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00228	74 1f		 je	 SHORT $LN50@emit_hrum
  0022a	6a 01		 push	 1
  0022c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00231	e8 00 00 00 00	 call	 _emit_bits
  00236	83 c4 08	 add	 esp, 8
  00239	85 c0		 test	 eax, eax
  0023b	74 0c		 je	 SHORT $LN50@emit_hrum
  0023d	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  00247	eb 0a		 jmp	 SHORT $LN51@emit_hrum
$LN50@emit_hrum:
  00249	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN51@emit_hrum:
  00253	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  00259	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 232  : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  0025c	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00260	74 26		 je	 SHORT $LN52@emit_hrum
  00262	6a 02		 push	 2
  00264	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00269	03 45 f8	 add	 eax, DWORD PTR _position$[ebp]
  0026c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 _emit_byte
  00275	83 c4 08	 add	 esp, 8
  00278	85 c0		 test	 eax, eax
  0027a	74 0c		 je	 SHORT $LN52@emit_hrum
  0027c	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv160[ebp], 1
  00286	eb 0a		 jmp	 SHORT $LN53@emit_hrum
$LN52@emit_hrum:
  00288	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN53@emit_hrum:
  00292	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv160[ebp]
  00298	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx
  0029b	e9 94 00 00 00	 jmp	 $LN27@emit_hrum
$LN28@emit_hrum:

; 233  : 			}
; 234  : 			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)

  002a0	83 7d e0 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  002a4	0f 8c 85 00 00
	00		 jl	 $LN26@emit_hrum
  002aa	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  002ae	7f 7f		 jg	 SHORT $LN26@emit_hrum

; 235  : 			{
; 236  : 				success = success && emit_bits( 0x00000000,   3 );

  002b0	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  002b4	74 1c		 je	 SHORT $LN54@emit_hrum
  002b6	6a 03		 push	 3
  002b8	6a 00		 push	 0
  002ba	e8 00 00 00 00	 call	 _emit_bits
  002bf	83 c4 08	 add	 esp, 8
  002c2	85 c0		 test	 eax, eax
  002c4	74 0c		 je	 SHORT $LN54@emit_hrum
  002c6	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv168[ebp], 1
  002d0	eb 0a		 jmp	 SHORT $LN55@emit_hrum
$LN54@emit_hrum:
  002d2	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv168[ebp], 0
$LN55@emit_hrum:
  002dc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv168[ebp]
  002e2	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 237  : 				success = success && emit_bits( disp<<(32-3), 3 );

  002e5	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  002e9	74 21		 je	 SHORT $LN56@emit_hrum
  002eb	6a 03		 push	 3
  002ed	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  002f0	c1 e0 1d	 shl	 eax, 29			; 0000001dH
  002f3	50		 push	 eax
  002f4	e8 00 00 00 00	 call	 _emit_bits
  002f9	83 c4 08	 add	 esp, 8
  002fc	85 c0		 test	 eax, eax
  002fe	74 0c		 je	 SHORT $LN56@emit_hrum
  00300	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv175[ebp], 1
  0030a	eb 0a		 jmp	 SHORT $LN57@emit_hrum
$LN56@emit_hrum:
  0030c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv175[ebp], 0
$LN57@emit_hrum:
  00316	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv175[ebp]
  0031c	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 238  : 
; 239  : 				if( max_disp > disp ) max_disp = disp;

  0031f	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  00322	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  00325	7e 06		 jle	 SHORT $LN25@emit_hrum
  00327	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  0032a	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN25@emit_hrum:

; 240  : 			}
; 241  : 			else

  0032d	eb 05		 jmp	 SHORT $LN27@emit_hrum
$LN26@emit_hrum:

; 242  : 				goto INVALID_CODE_HRUM;

  0032f	e9 f7 03 00 00	 jmp	 $INVALID_CODE_HRUM$2688
$LN27@emit_hrum:

; 243  : 		}
; 244  : 		else if( length==2 )

  00334	e9 18 04 00 00	 jmp	 $LN30@emit_hrum
$LN29@emit_hrum:
  00339	83 7d ec 02	 cmp	 DWORD PTR _length$[ebp], 2
  0033d	0f 85 a5 00 00
	00		 jne	 $LN22@emit_hrum

; 245  : 		{
; 246  : 			if( (-256)<=disp && disp<=(-1) ) // %001<byte>

  00343	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  0034a	0f 8c 8e 00 00
	00		 jl	 $LN21@emit_hrum
  00350	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00354	0f 8f 84 00 00
	00		 jg	 $LN21@emit_hrum

; 247  : 			{
; 248  : 				success = success && emit_bits( 0x20000000, 3 );

  0035a	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0035e	74 1f		 je	 SHORT $LN58@emit_hrum
  00360	6a 03		 push	 3
  00362	68 00 00 00 20	 push	 536870912		; 20000000H
  00367	e8 00 00 00 00	 call	 _emit_bits
  0036c	83 c4 08	 add	 esp, 8
  0036f	85 c0		 test	 eax, eax
  00371	74 0c		 je	 SHORT $LN58@emit_hrum
  00373	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv185[ebp], 1
  0037d	eb 0a		 jmp	 SHORT $LN59@emit_hrum
$LN58@emit_hrum:
  0037f	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv185[ebp], 0
$LN59@emit_hrum:
  00389	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv185[ebp]
  0038f	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 249  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00392	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00396	74 23		 je	 SHORT $LN60@emit_hrum
  00398	6a 02		 push	 2
  0039a	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  0039d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 _emit_byte
  003a8	83 c4 08	 add	 esp, 8
  003ab	85 c0		 test	 eax, eax
  003ad	74 0c		 je	 SHORT $LN60@emit_hrum
  003af	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv193[ebp], 1
  003b9	eb 0a		 jmp	 SHORT $LN61@emit_hrum
$LN60@emit_hrum:
  003bb	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
$LN61@emit_hrum:
  003c5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv193[ebp]
  003cb	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 250  : 
; 251  : 				if( max_disp > disp ) max_disp = disp;

  003ce	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  003d1	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  003d4	7e 06		 jle	 SHORT $LN20@emit_hrum
  003d6	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  003d9	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN20@emit_hrum:

; 252  : 			}
; 253  : 			else

  003dc	eb 05		 jmp	 SHORT $LN19@emit_hrum
$LN21@emit_hrum:

; 254  : 				goto INVALID_CODE_HRUM;

  003de	e9 48 03 00 00	 jmp	 $INVALID_CODE_HRUM$2688
$LN19@emit_hrum:

; 255  : 		}
; 256  : 		else if( 3<=length && length<=255 )

  003e3	e9 69 03 00 00	 jmp	 $LN30@emit_hrum
$LN22@emit_hrum:
  003e8	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  003ec	0f 8c 39 03 00
	00		 jl	 $INVALID_CODE_HRUM$2688
  003f2	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  003f9	0f 8f 2c 03 00
	00		 jg	 $INVALID_CODE_HRUM$2688

; 257  : 		{
; 258  : 			// length coding
; 259  : 			if( length==3 )

  003ff	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  00403	75 3d		 jne	 SHORT $LN16@emit_hrum

; 260  : 			{
; 261  : 				success = success && emit_bits( 0x40000000, 3 );

  00405	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00409	74 1f		 je	 SHORT $LN62@emit_hrum
  0040b	6a 03		 push	 3
  0040d	68 00 00 00 40	 push	 1073741824		; 40000000H
  00412	e8 00 00 00 00	 call	 _emit_bits
  00417	83 c4 08	 add	 esp, 8
  0041a	85 c0		 test	 eax, eax
  0041c	74 0c		 je	 SHORT $LN62@emit_hrum
  0041e	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv203[ebp], 1
  00428	eb 0a		 jmp	 SHORT $LN63@emit_hrum
$LN62@emit_hrum:
  0042a	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
$LN63@emit_hrum:
  00434	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv203[ebp]
  0043a	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax
  0043d	e9 6d 01 00 00	 jmp	 $LN15@emit_hrum
$LN16@emit_hrum:

; 262  : 			}
; 263  : 			else if( length<=15 )

  00442	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00446	0f 8f ef 00 00
	00		 jg	 $LN14@emit_hrum

; 264  : 			{
; 265  : 				varlen=2;

  0044c	c7 45 bc 02 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 2

; 266  : 
; 267  : 				varbits = (length % 3)<<30; // low 2 bits (except for length==15)

  00453	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00456	99		 cdq
  00457	b9 03 00 00 00	 mov	 ecx, 3
  0045c	f7 f9		 idiv	 ecx
  0045e	c1 e2 1e	 shl	 edx, 30			; 0000001eH
  00461	89 55 c8	 mov	 DWORD PTR _varbits$[ebp], edx

; 268  : 				if( length==15 ) varbits = 0xC0000000;

  00464	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00468	75 07		 jne	 SHORT $LN13@emit_hrum
  0046a	c7 45 c8 00 00
	00 c0		 mov	 DWORD PTR _varbits$[ebp], -1073741824 ; c0000000H
$LN13@emit_hrum:

; 269  : 
; 270  : 				if( length>=6 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  00471	83 7d ec 06	 cmp	 DWORD PTR _length$[ebp], 6
  00475	7c 17		 jl	 SHORT $LN12@emit_hrum
  00477	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  0047a	c1 e8 02	 shr	 eax, 2
  0047d	0d 00 00 00 c0	 or	 eax, -1073741824	; c0000000H
  00482	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax
  00485	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00488	83 c0 02	 add	 eax, 2
  0048b	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax
$LN12@emit_hrum:

; 271  : 				if( length>=9 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  0048e	83 7d ec 09	 cmp	 DWORD PTR _length$[ebp], 9
  00492	7c 17		 jl	 SHORT $LN11@emit_hrum
  00494	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00497	c1 e8 02	 shr	 eax, 2
  0049a	0d 00 00 00 c0	 or	 eax, -1073741824	; c0000000H
  0049f	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax
  004a2	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  004a5	83 c0 02	 add	 eax, 2
  004a8	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax
$LN11@emit_hrum:

; 272  : 				if( length>=12) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  004ab	83 7d ec 0c	 cmp	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  004af	7c 17		 jl	 SHORT $LN10@emit_hrum
  004b1	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  004b4	c1 e8 02	 shr	 eax, 2
  004b7	0d 00 00 00 c0	 or	 eax, -1073741824	; c0000000H
  004bc	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax
  004bf	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  004c2	83 c0 02	 add	 eax, 2
  004c5	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax
$LN10@emit_hrum:

; 273  : 
; 274  : 				success = success && emit_bits( 0x60000000, 3 );

  004c8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  004cc	74 1f		 je	 SHORT $LN64@emit_hrum
  004ce	6a 03		 push	 3
  004d0	68 00 00 00 60	 push	 1610612736		; 60000000H
  004d5	e8 00 00 00 00	 call	 _emit_bits
  004da	83 c4 08	 add	 esp, 8
  004dd	85 c0		 test	 eax, eax
  004df	74 0c		 je	 SHORT $LN64@emit_hrum
  004e1	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv225[ebp], 1
  004eb	eb 0a		 jmp	 SHORT $LN65@emit_hrum
$LN64@emit_hrum:
  004ed	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv225[ebp], 0
$LN65@emit_hrum:
  004f7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv225[ebp]
  004fd	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 275  : 				success = success && emit_bits( varbits, varlen );

  00500	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00504	74 20		 je	 SHORT $LN66@emit_hrum
  00506	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00509	50		 push	 eax
  0050a	8b 4d c8	 mov	 ecx, DWORD PTR _varbits$[ebp]
  0050d	51		 push	 ecx
  0050e	e8 00 00 00 00	 call	 _emit_bits
  00513	83 c4 08	 add	 esp, 8
  00516	85 c0		 test	 eax, eax
  00518	74 0c		 je	 SHORT $LN66@emit_hrum
  0051a	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv231[ebp], 1
  00524	eb 0a		 jmp	 SHORT $LN67@emit_hrum
$LN66@emit_hrum:
  00526	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv231[ebp], 0
$LN67@emit_hrum:
  00530	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv231[ebp]
  00536	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx

; 276  : 			}
; 277  : 			else // 15<length<=255: %01100<len>

  00539	eb 74		 jmp	 SHORT $LN15@emit_hrum
$LN14@emit_hrum:

; 278  : 			{
; 279  : 				success = success && emit_bits( 0x60000000, 5 );

  0053b	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0053f	74 1f		 je	 SHORT $LN68@emit_hrum
  00541	6a 05		 push	 5
  00543	68 00 00 00 60	 push	 1610612736		; 60000000H
  00548	e8 00 00 00 00	 call	 _emit_bits
  0054d	83 c4 08	 add	 esp, 8
  00550	85 c0		 test	 eax, eax
  00552	74 0c		 je	 SHORT $LN68@emit_hrum
  00554	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv237[ebp], 1
  0055e	eb 0a		 jmp	 SHORT $LN69@emit_hrum
$LN68@emit_hrum:
  00560	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv237[ebp], 0
$LN69@emit_hrum:
  0056a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv237[ebp]
  00570	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 280  : 				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );

  00573	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00577	74 23		 je	 SHORT $LN70@emit_hrum
  00579	6a 02		 push	 2
  0057b	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  0057e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00583	50		 push	 eax
  00584	e8 00 00 00 00	 call	 _emit_byte
  00589	83 c4 08	 add	 esp, 8
  0058c	85 c0		 test	 eax, eax
  0058e	74 0c		 je	 SHORT $LN70@emit_hrum
  00590	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv245[ebp], 1
  0059a	eb 0a		 jmp	 SHORT $LN71@emit_hrum
$LN70@emit_hrum:
  0059c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv245[ebp], 0
$LN71@emit_hrum:
  005a6	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  005ac	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
$LN15@emit_hrum:

; 281  : 			}
; 282  : 
; 283  : 			// displacement coding
; 284  : 			if( (-256)<=disp && disp<=(-1) ) // %0<disp>

  005af	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  005b6	0f 8c 8e 00 00
	00		 jl	 $LN8@emit_hrum
  005bc	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  005c0	0f 8f 84 00 00
	00		 jg	 $LN8@emit_hrum

; 285  : 			{
; 286  : 				success = success && emit_bits( 0x00000000, 1 );

  005c6	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  005ca	74 1c		 je	 SHORT $LN72@emit_hrum
  005cc	6a 01		 push	 1
  005ce	6a 00		 push	 0
  005d0	e8 00 00 00 00	 call	 _emit_bits
  005d5	83 c4 08	 add	 esp, 8
  005d8	85 c0		 test	 eax, eax
  005da	74 0c		 je	 SHORT $LN72@emit_hrum
  005dc	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv253[ebp], 1
  005e6	eb 0a		 jmp	 SHORT $LN73@emit_hrum
$LN72@emit_hrum:
  005e8	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv253[ebp], 0
$LN73@emit_hrum:
  005f2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv253[ebp]
  005f8	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 287  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  005fb	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  005ff	74 23		 je	 SHORT $LN74@emit_hrum
  00601	6a 02		 push	 2
  00603	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00606	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0060b	50		 push	 eax
  0060c	e8 00 00 00 00	 call	 _emit_byte
  00611	83 c4 08	 add	 esp, 8
  00614	85 c0		 test	 eax, eax
  00616	74 0c		 je	 SHORT $LN74@emit_hrum
  00618	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv261[ebp], 1
  00622	eb 0a		 jmp	 SHORT $LN75@emit_hrum
$LN74@emit_hrum:
  00624	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv261[ebp], 0
$LN75@emit_hrum:
  0062e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv261[ebp]
  00634	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 288  : 
; 289  : 				if( max_disp > disp ) max_disp = disp;

  00637	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0063a	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  0063d	7e 06		 jle	 SHORT $LN7@emit_hrum
  0063f	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00642	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN7@emit_hrum:

; 290  : 			}
; 291  : 			else if( (-4096)<=disp && disp<(-256) ) //%1abcd<disp>

  00645	e9 df 00 00 00	 jmp	 $LN6@emit_hrum
$LN8@emit_hrum:
  0064a	81 7d e0 00 f0
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -4096 ; fffff000H
  00651	0f 8c d0 00 00
	00		 jl	 $LN5@emit_hrum
  00657	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  0065e	0f 8d c3 00 00
	00		 jge	 $LN5@emit_hrum

; 292  : 			{
; 293  : 				success = success && emit_bits( 0x80000000, 1 );

  00664	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00668	74 1f		 je	 SHORT $LN76@emit_hrum
  0066a	6a 01		 push	 1
  0066c	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00671	e8 00 00 00 00	 call	 _emit_bits
  00676	83 c4 08	 add	 esp, 8
  00679	85 c0		 test	 eax, eax
  0067b	74 0c		 je	 SHORT $LN76@emit_hrum
  0067d	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv270[ebp], 1
  00687	eb 0a		 jmp	 SHORT $LN77@emit_hrum
$LN76@emit_hrum:
  00689	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv270[ebp], 0
$LN77@emit_hrum:
  00693	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv270[ebp]
  00699	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 294  : 				success = success && emit_bits( (0x0F00&disp)<<20, 4 );

  0069c	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006a0	74 26		 je	 SHORT $LN78@emit_hrum
  006a2	6a 04		 push	 4
  006a4	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  006a7	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  006ac	c1 e0 14	 shl	 eax, 20			; 00000014H
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 _emit_bits
  006b5	83 c4 08	 add	 esp, 8
  006b8	85 c0		 test	 eax, eax
  006ba	74 0c		 je	 SHORT $LN78@emit_hrum
  006bc	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv278[ebp], 1
  006c6	eb 0a		 jmp	 SHORT $LN79@emit_hrum
$LN78@emit_hrum:
  006c8	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv278[ebp], 0
$LN79@emit_hrum:
  006d2	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv278[ebp]
  006d8	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 295  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  006db	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006df	74 23		 je	 SHORT $LN80@emit_hrum
  006e1	6a 02		 push	 2
  006e3	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  006e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006eb	50		 push	 eax
  006ec	e8 00 00 00 00	 call	 _emit_byte
  006f1	83 c4 08	 add	 esp, 8
  006f4	85 c0		 test	 eax, eax
  006f6	74 0c		 je	 SHORT $LN80@emit_hrum
  006f8	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv286[ebp], 1
  00702	eb 0a		 jmp	 SHORT $LN81@emit_hrum
$LN80@emit_hrum:
  00704	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv286[ebp], 0
$LN81@emit_hrum:
  0070e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv286[ebp]
  00714	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 296  : 
; 297  : 				if( max_disp > disp ) max_disp = disp;

  00717	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0071a	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  0071d	7e 06		 jle	 SHORT $LN4@emit_hrum
  0071f	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00722	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN4@emit_hrum:

; 298  : 			}
; 299  : 			else

  00725	eb 02		 jmp	 SHORT $LN6@emit_hrum
$LN5@emit_hrum:

; 300  : 				goto INVALID_CODE_HRUM;

  00727	eb 02		 jmp	 SHORT $INVALID_CODE_HRUM$2688
$LN6@emit_hrum:

; 301  : 		}
; 302  : 		else

  00729	eb 26		 jmp	 SHORT $LN30@emit_hrum
$INVALID_CODE_HRUM$2688:

; 303  : 		{
; 304  : INVALID_CODE_HRUM:
; 305  : 			printf("mhmt-emit.c:emit_hrum() - invalid code: length=%d, displacement=%d\n",length,disp);

  0072b	8b f4		 mov	 esi, esp
  0072d	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00730	50		 push	 eax
  00731	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00734	51		 push	 ecx
  00735	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@
  0073a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00740	83 c4 0c	 add	 esp, 12			; 0000000cH
  00743	3b f4		 cmp	 esi, esp
  00745	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 306  : 			return 0;

  0074a	33 c0		 xor	 eax, eax
  0074c	e9 0b 01 00 00	 jmp	 $LN36@emit_hrum
$LN30@emit_hrum:

; 307  : 		}
; 308  : 
; 309  : 		position += length;

  00751	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00754	03 45 ec	 add	 eax, DWORD PTR _length$[ebp]
  00757	89 45 f8	 mov	 DWORD PTR _position$[ebp], eax

; 310  : 	}

  0075a	e9 57 fa ff ff	 jmp	 $LN33@emit_hrum
$LN32@emit_hrum:

; 311  : 
; 312  : 	// stop-code: %01100<0>
; 313  : 	success = success && emit_bits( 0x60000000, 5 );

  0075f	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00763	74 1f		 je	 SHORT $LN82@emit_hrum
  00765	6a 05		 push	 5
  00767	68 00 00 00 60	 push	 1610612736		; 60000000H
  0076c	e8 00 00 00 00	 call	 _emit_bits
  00771	83 c4 08	 add	 esp, 8
  00774	85 c0		 test	 eax, eax
  00776	74 0c		 je	 SHORT $LN82@emit_hrum
  00778	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  00782	eb 0a		 jmp	 SHORT $LN83@emit_hrum
$LN82@emit_hrum:
  00784	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN83@emit_hrum:
  0078e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv297[ebp]
  00794	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 314  : 	success = success && emit_byte( 0x00, EMIT_BYTE_ADD );

  00797	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0079b	74 1c		 je	 SHORT $LN84@emit_hrum
  0079d	6a 02		 push	 2
  0079f	6a 00		 push	 0
  007a1	e8 00 00 00 00	 call	 _emit_byte
  007a6	83 c4 08	 add	 esp, 8
  007a9	85 c0		 test	 eax, eax
  007ab	74 0c		 je	 SHORT $LN84@emit_hrum
  007ad	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv303[ebp], 1
  007b7	eb 0a		 jmp	 SHORT $LN85@emit_hrum
$LN84@emit_hrum:
  007b9	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv303[ebp], 0
$LN85@emit_hrum:
  007c3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv303[ebp]
  007c9	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 315  : 
; 316  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  007cc	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  007d0	74 1c		 je	 SHORT $LN86@emit_hrum
  007d2	6a 00		 push	 0
  007d4	6a 00		 push	 0
  007d6	e8 00 00 00 00	 call	 _emit_bits
  007db	83 c4 08	 add	 esp, 8
  007de	85 c0		 test	 eax, eax
  007e0	74 0c		 je	 SHORT $LN86@emit_hrum
  007e2	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv309[ebp], 1
  007ec	eb 0a		 jmp	 SHORT $LN87@emit_hrum
$LN86@emit_hrum:
  007ee	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv309[ebp], 0
$LN87@emit_hrum:
  007f8	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv309[ebp]
  007fe	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 317  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  00801	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00805	74 1c		 je	 SHORT $LN88@emit_hrum
  00807	6a 00		 push	 0
  00809	6a 00		 push	 0
  0080b	e8 00 00 00 00	 call	 _emit_file
  00810	83 c4 08	 add	 esp, 8
  00813	85 c0		 test	 eax, eax
  00815	74 0c		 je	 SHORT $LN88@emit_hrum
  00817	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv315[ebp], 1
  00821	eb 0a		 jmp	 SHORT $LN89@emit_hrum
$LN88@emit_hrum:
  00823	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
$LN89@emit_hrum:
  0082d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv315[ebp]
  00833	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 318  : 
; 319  : 	if( success )

  00836	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0083a	74 1d		 je	 SHORT $LN1@emit_hrum

; 320  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  0083c	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  0083f	f7 d8		 neg	 eax
  00841	8b f4		 mov	 esi, esp
  00843	50		 push	 eax
  00844	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  00849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0084f	83 c4 08	 add	 esp, 8
  00852	3b f4		 cmp	 esi, esp
  00854	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@emit_hrum:

; 321  : 
; 322  : 	return success;

  00859	8b 45 b0	 mov	 eax, DWORD PTR _success$[ebp]
$LN36@emit_hrum:

; 323  : }

  0085c	5f		 pop	 edi
  0085d	5e		 pop	 esi
  0085e	5b		 pop	 ebx
  0085f	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00865	3b ec		 cmp	 ebp, esp
  00867	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0086c	8b e5		 mov	 esp, ebp
  0086e	5d		 pop	 ebp
  0086f	c3		 ret	 0
_emit_hrum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@ ; `string'
PUBLIC	??_C@_0L@KFHJGGOL@expansion?6?$AA@		; `string'
PUBLIC	??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@ ; `string'
PUBLIC	??_C@_05LIHPPKDI@?$CF04x?3?$AA@			; `string'
PUBLIC	??_C@_02PGLKMFED@HR?$AA@			; `string'
PUBLIC	??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@ ; `string'
PUBLIC	_emit_hrust
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT ??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ DB 'match.le'
	DB	'n=%d,disp=%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@ DB 'copy.len=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@ DB 'i'
	DB	'nsert-match.len=%d,disp=%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@
CONST	SEGMENT
??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@ DB 'mhmt'
	DB	'-emit.c:emit_hrust() - invalid code: length=%d, displacement='
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KFHJGGOL@expansion?6?$AA@
CONST	SEGMENT
??_C@_0L@KFHJGGOL@expansion?6?$AA@ DB 'expansion', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@
CONST	SEGMENT
??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@ DB 'mhmt'
	DB	'-emit.c:emit_hrust() - encountered stop-code in optimal chain'
	DB	' before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LIHPPKDI@?$CF04x?3?$AA@
CONST	SEGMENT
??_C@_05LIHPPKDI@?$CF04x?3?$AA@ DB '%04x:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PGLKMFED@HR?$AA@
CONST	SEGMENT
??_C@_02PGLKMFED@HR?$AA@ DB 'HR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@
CONST	SEGMENT
??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@ DB 'mhm'
	DB	't-emit.c:emit_hrust() - NULL passed!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _emit_hrust
_TEXT	SEGMENT
tv553 = -304						; size = 4
tv547 = -304						; size = 4
tv541 = -304						; size = 4
tv517 = -304						; size = 4
tv509 = -304						; size = 4
tv501 = -304						; size = 4
tv495 = -304						; size = 4
tv487 = -304						; size = 4
tv480 = -304						; size = 4
tv472 = -304						; size = 4
tv465 = -304						; size = 4
tv458 = -304						; size = 4
tv451 = -304						; size = 4
tv443 = -304						; size = 4
tv436 = -304						; size = 4
tv430 = -304						; size = 4
tv423 = -304						; size = 4
tv416 = -304						; size = 4
tv408 = -304						; size = 4
tv399 = -304						; size = 4
tv392 = -304						; size = 4
tv383 = -304						; size = 4
tv377 = -304						; size = 4
tv361 = -304						; size = 4
tv353 = -304						; size = 4
tv345 = -304						; size = 4
tv337 = -304						; size = 4
tv329 = -304						; size = 4
tv321 = -304						; size = 4
tv313 = -304						; size = 4
tv306 = -304						; size = 4
tv297 = -304						; size = 4
tv290 = -304						; size = 4
tv281 = -304						; size = 4
tv273 = -304						; size = 4
tv257 = -304						; size = 4
tv251 = -304						; size = 4
tv235 = -304						; size = 4
tv225 = -304						; size = 4
tv218 = -304						; size = 4
tv208 = -304						; size = 4
tv198 = -304						; size = 4
tv192 = -304						; size = 4
tv180 = -304						; size = 4
tv173 = -304						; size = 4
tv154 = -304						; size = 4
tv148 = -304						; size = 4
tv140 = -304						; size = 4
tv134 = -304						; size = 4
tv90 = -304						; size = 4
tv83 = -304						; size = 4
tv77 = -304						; size = 4
tv71 = -304						; size = 4
_expbitlen$ = -104					; size = 4
_wrlen$ = -92						; size = 2
_success$ = -80						; size = 4
_varlen$ = -68						; size = 4
_varbits$ = -56						; size = 4
_max_disp$ = -44					; size = 4
_disp$ = -32						; size = 4
_length$ = -20						; size = 4
_position$ = -8						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_hrust PROC					; COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 342  : 	ULONG position;
; 343  : 	LONG length;
; 344  : 	LONG disp;
; 345  : 
; 346  : 	LONG max_disp; // maximum encountered displacement
; 347  : 
; 348  : 	ULONG varbits,varlen;
; 349  : 	ULONG success = 1;

  0001e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 350  : 
; 351  : 	UBYTE wrlen[2];
; 352  : 
; 353  : 	ULONG expbitlen = 2; // expandable match: bitlength of displacement

  00025	c7 45 98 02 00
	00 00		 mov	 DWORD PTR _expbitlen$[ebp], 2

; 354  : 
; 355  : 
; 356  : 	max_disp = 0;

  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _max_disp$[ebp], 0

; 357  : 
; 358  : 
; 359  : 	// some checks
; 360  : 	if( !optch )

  00033	83 7d 08 00	 cmp	 DWORD PTR _optch$[ebp], 0
  00037	75 1e		 jne	 SHORT $LN64@emit_hrust

; 361  : 	{
; 362  : 		printf("mhmt-emit.c:emit_hrust() - NULL passed!\n");

  00039	8b f4		 mov	 esi, esp
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00046	83 c4 04	 add	 esp, 4
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 363  : 		return 0;

  00050	33 c0		 xor	 eax, eax
  00052	e9 29 10 00 00	 jmp	 $LN65@emit_hrust
$LN64@emit_hrust:

; 364  : 	}
; 365  : 
; 366  : 	// initialize
; 367  : 	success = success && emit_file(NULL, EMIT_FILE_INIT);

  00057	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0005b	74 1c		 je	 SHORT $LN67@emit_hrust
  0005d	6a ff		 push	 -1
  0005f	6a 00		 push	 0
  00061	e8 00 00 00 00	 call	 _emit_file
  00066	83 c4 08	 add	 esp, 8
  00069	85 c0		 test	 eax, eax
  0006b	74 0c		 je	 SHORT $LN67@emit_hrust
  0006d	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  00077	eb 0a		 jmp	 SHORT $LN68@emit_hrust
$LN67@emit_hrust:
  00079	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN68@emit_hrust:
  00083	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00089	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 368  : 
; 369  : 	success = success && emit_byte(0, EMIT_BYTE_INIT);

  0008c	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00090	74 1c		 je	 SHORT $LN69@emit_hrust
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 _emit_byte
  0009b	83 c4 08	 add	 esp, 8
  0009e	85 c0		 test	 eax, eax
  000a0	74 0c		 je	 SHORT $LN69@emit_hrust
  000a2	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
  000ac	eb 0a		 jmp	 SHORT $LN70@emit_hrust
$LN69@emit_hrust:
  000ae	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN70@emit_hrust:
  000b8	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  000be	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 370  : 
; 371  : 	success = success && emit_bits(0, EMIT_BITS_INIT);

  000c1	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  000c5	74 1c		 je	 SHORT $LN71@emit_hrust
  000c7	6a ff		 push	 -1
  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 _emit_bits
  000d0	83 c4 08	 add	 esp, 8
  000d3	85 c0		 test	 eax, eax
  000d5	74 0c		 je	 SHORT $LN71@emit_hrust
  000d7	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv83[ebp], 1
  000e1	eb 0a		 jmp	 SHORT $LN72@emit_hrust
$LN71@emit_hrust:
  000e3	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv83[ebp], 0
$LN72@emit_hrust:
  000ed	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  000f3	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 372  : 
; 373  : 
; 374  : 	// manage zx header info
; 375  : 	if( wrk.zxheader )

  000f6	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  000fd	0f 84 06 01 00
	00		 je	 $LN63@emit_hrust

; 376  : 	{
; 377  : 		success = success && emit_file( (UBYTE*)"HR", 2);

  00103	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00107	74 1f		 je	 SHORT $LN73@emit_hrust
  00109	6a 02		 push	 2
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_02PGLKMFED@HR?$AA@
  00110	e8 00 00 00 00	 call	 _emit_file
  00115	83 c4 08	 add	 esp, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0c		 je	 SHORT $LN73@emit_hrust
  0011c	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv90[ebp], 1
  00126	eb 0a		 jmp	 SHORT $LN74@emit_hrust
$LN73@emit_hrust:
  00128	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$LN74@emit_hrust:
  00132	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
  00138	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 378  : 
; 379  : 		wrlen[0] = wrk.inlen&0x00FF;

  0013b	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  00140	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00145	88 45 a4	 mov	 BYTE PTR _wrlen$[ebp], al

; 380  : 		wrlen[1] = (wrk.inlen>>8)&0x00FF;

  00148	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  0014d	c1 e8 08	 shr	 eax, 8
  00150	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00155	88 45 a5	 mov	 BYTE PTR _wrlen$[ebp+1], al

; 381  : 		success = success && emit_file( wrlen, 2); // unpacked length mod 65536

  00158	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0015c	74 1e		 je	 SHORT $LN75@emit_hrust
  0015e	6a 02		 push	 2
  00160	8d 45 a4	 lea	 eax, DWORD PTR _wrlen$[ebp]
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 _emit_file
  00169	83 c4 08	 add	 esp, 8
  0016c	85 c0		 test	 eax, eax
  0016e	74 0c		 je	 SHORT $LN75@emit_hrust
  00170	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv134[ebp], 1
  0017a	eb 0a		 jmp	 SHORT $LN76@emit_hrust
$LN75@emit_hrust:
  0017c	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
$LN76@emit_hrust:
  00186	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  0018c	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 382  : 
; 383  : 		success = success && emit_file( wrlen, 2); // packed length - !to be filled later!

  0018f	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00193	74 1e		 je	 SHORT $LN77@emit_hrust
  00195	6a 02		 push	 2
  00197	8d 45 a4	 lea	 eax, DWORD PTR _wrlen$[ebp]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _emit_file
  001a0	83 c4 08	 add	 esp, 8
  001a3	85 c0		 test	 eax, eax
  001a5	74 0c		 je	 SHORT $LN77@emit_hrust
  001a7	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv140[ebp], 1
  001b1	eb 0a		 jmp	 SHORT $LN78@emit_hrust
$LN77@emit_hrust:
  001b3	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN78@emit_hrust:
  001bd	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv140[ebp]
  001c3	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 384  : 
; 385  :         success = success && emit_file( &wrk.indata[wrk.inlen-6], 6); // last bytes

  001c6	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  001ca	74 2a		 je	 SHORT $LN79@emit_hrust
  001cc	6a 06		 push	 6
  001ce	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  001d3	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  001d9	8d 54 01 fa	 lea	 edx, DWORD PTR [ecx+eax-6]
  001dd	52		 push	 edx
  001de	e8 00 00 00 00	 call	 _emit_file
  001e3	83 c4 08	 add	 esp, 8
  001e6	85 c0		 test	 eax, eax
  001e8	74 0c		 je	 SHORT $LN79@emit_hrust
  001ea	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
  001f4	eb 0a		 jmp	 SHORT $LN80@emit_hrust
$LN79@emit_hrust:
  001f6	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
$LN80@emit_hrust:
  00200	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  00206	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax
$LN63@emit_hrust:

; 386  : 	}
; 387  : 
; 388  : 	// schedule first byte to be placed just after first bitstream word
; 389  : 	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

  00209	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0020d	74 23		 je	 SHORT $LN81@emit_hrust
  0020f	6a 02		 push	 2
  00211	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00216	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 _emit_byte
  0021f	83 c4 08	 add	 esp, 8
  00222	85 c0		 test	 eax, eax
  00224	74 0c		 je	 SHORT $LN81@emit_hrust
  00226	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv154[ebp], 1
  00230	eb 0a		 jmp	 SHORT $LN82@emit_hrust
$LN81@emit_hrust:
  00232	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv154[ebp], 0
$LN82@emit_hrust:
  0023c	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  00242	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx

; 390  : 
; 391  : 	// go emitting codes
; 392  : 	position = 1;

  00245	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _position$[ebp], 1
$LN62@emit_hrust:

; 393  : 
; 394  : 	while( (position<actual_len) && success )

  0024c	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  0024f	3b 45 0c	 cmp	 eax, DWORD PTR _actual_len$[ebp]
  00252	0f 83 60 0d 00
	00		 jae	 $LN61@emit_hrust
  00258	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0025c	0f 84 56 0d 00
	00		 je	 $LN61@emit_hrust

; 395  : 	{
; 396  : 		#ifdef DBG
; 397  : 			printf("%04x:",position);

  00262	8b f4		 mov	 esi, esp
  00264	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00267	50		 push	 eax
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_05LIHPPKDI@?$CF04x?3?$AA@
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00273	83 c4 08	 add	 esp, 8
  00276	3b f4		 cmp	 esi, esp
  00278	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 398  : 		#endif
; 399  : 
; 400  : 		length = optch[position].code.length;

  0027d	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00280	c1 e0 04	 shl	 eax, 4
  00283	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  00286	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00289	89 55 ec	 mov	 DWORD PTR _length$[ebp], edx

; 401  : 		disp   = optch[position].code.disp;

  0028c	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  0028f	c1 e0 04	 shl	 eax, 4
  00292	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  00295	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00299	89 55 e0	 mov	 DWORD PTR _disp$[ebp], edx

; 402  : 
; 403  : 		if( length==0 )

  0029c	83 7d ec 00	 cmp	 DWORD PTR _length$[ebp], 0
  002a0	75 23		 jne	 SHORT $LN60@emit_hrust

; 404  : 		{
; 405  : 			printf("mhmt-emit.c:emit_hrust() - encountered stop-code in optimal chain before emitting all data!\n");

  002a2	8b f4		 mov	 esi, esp
  002a4	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002af	83 c4 04	 add	 esp, 4
  002b2	3b f4		 cmp	 esi, esp
  002b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 406  : 			return 0;

  002b9	33 c0		 xor	 eax, eax
  002bb	e9 c0 0d 00 00	 jmp	 $LN65@emit_hrust
  002c0	e9 5b 0c 00 00	 jmp	 $LN59@emit_hrust
$LN60@emit_hrust:

; 407  : 		}
; 408  : 		else if( disp==0 ) // copy-bytes

  002c5	83 7d e0 00	 cmp	 DWORD PTR _disp$[ebp], 0
  002c9	0f 85 8d 01 00
	00		 jne	 $LN58@emit_hrust

; 409  : 		{
; 410  : 			if( length==1 ) // 1 byte: %1<byte>

  002cf	83 7d ec 01	 cmp	 DWORD PTR _length$[ebp], 1
  002d3	75 7c		 jne	 SHORT $LN57@emit_hrust

; 411  : 			{
; 412  : 				success = success && emit_bits( 0x80000000, 1 );

  002d5	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  002d9	74 1f		 je	 SHORT $LN83@emit_hrust
  002db	6a 01		 push	 1
  002dd	68 00 00 00 80	 push	 -2147483648		; 80000000H
  002e2	e8 00 00 00 00	 call	 _emit_bits
  002e7	83 c4 08	 add	 esp, 8
  002ea	85 c0		 test	 eax, eax
  002ec	74 0c		 je	 SHORT $LN83@emit_hrust
  002ee	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv173[ebp], 1
  002f8	eb 0a		 jmp	 SHORT $LN84@emit_hrust
$LN83@emit_hrust:
  002fa	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv173[ebp], 0
$LN84@emit_hrust:
  00304	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  0030a	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 413  : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  0030d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00311	74 26		 je	 SHORT $LN85@emit_hrust
  00313	6a 02		 push	 2
  00315	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0031a	03 45 f8	 add	 eax, DWORD PTR _position$[ebp]
  0031d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00320	51		 push	 ecx
  00321	e8 00 00 00 00	 call	 _emit_byte
  00326	83 c4 08	 add	 esp, 8
  00329	85 c0		 test	 eax, eax
  0032b	74 0c		 je	 SHORT $LN85@emit_hrust
  0032d	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv180[ebp], 1
  00337	eb 0a		 jmp	 SHORT $LN86@emit_hrust
$LN85@emit_hrust:
  00339	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv180[ebp], 0
$LN86@emit_hrust:
  00343	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv180[ebp]
  00349	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx
  0034c	e9 06 01 00 00	 jmp	 $LN56@emit_hrust
$LN57@emit_hrust:

; 414  : 			}
; 415  : 			else if( (12<=length) && (length<=42) && ( !(length&1) ) ) // %0110001abcd<byte,byte,...>

  00351	83 7d ec 0c	 cmp	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  00355	0f 8c f7 00 00
	00		 jl	 $LN55@emit_hrust
  0035b	83 7d ec 2a	 cmp	 DWORD PTR _length$[ebp], 42 ; 0000002aH
  0035f	0f 8f ed 00 00
	00		 jg	 $LN55@emit_hrust
  00365	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00368	83 e0 01	 and	 eax, 1
  0036b	0f 85 e1 00 00
	00		 jne	 $LN55@emit_hrust

; 416  : 			{
; 417  : 				varbits = (length-12)<<27;

  00371	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00374	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00377	c1 e0 1b	 shl	 eax, 27			; 0000001bH
  0037a	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 418  : 				success = success && emit_bits( 0x62000000, 7 );

  0037d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00381	74 1f		 je	 SHORT $LN87@emit_hrust
  00383	6a 07		 push	 7
  00385	68 00 00 00 62	 push	 1644167168		; 62000000H
  0038a	e8 00 00 00 00	 call	 _emit_bits
  0038f	83 c4 08	 add	 esp, 8
  00392	85 c0		 test	 eax, eax
  00394	74 0c		 je	 SHORT $LN87@emit_hrust
  00396	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv192[ebp], 1
  003a0	eb 0a		 jmp	 SHORT $LN88@emit_hrust
$LN87@emit_hrust:
  003a2	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv192[ebp], 0
$LN88@emit_hrust:
  003ac	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv192[ebp]
  003b2	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 419  : 
; 420  : 				success = success && emit_bits( varbits, 4 );

  003b5	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  003b9	74 1e		 je	 SHORT $LN89@emit_hrust
  003bb	6a 04		 push	 4
  003bd	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 _emit_bits
  003c6	83 c4 08	 add	 esp, 8
  003c9	85 c0		 test	 eax, eax
  003cb	74 0c		 je	 SHORT $LN89@emit_hrust
  003cd	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv198[ebp], 1
  003d7	eb 0a		 jmp	 SHORT $LN90@emit_hrust
$LN89@emit_hrust:
  003d9	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv198[ebp], 0
$LN90@emit_hrust:
  003e3	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv198[ebp]
  003e9	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 421  : 
; 422  : 				varlen = 0;

  003ec	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 0
$LN54@emit_hrust:

; 423  : 				while( success && (varlen<(ULONG)length) )

  003f3	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  003f7	74 57		 je	 SHORT $LN53@emit_hrust
  003f9	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  003fc	3b 45 ec	 cmp	 eax, DWORD PTR _length$[ebp]
  003ff	73 4f		 jae	 SHORT $LN53@emit_hrust

; 424  : 				{
; 425  : 					success = success && emit_byte( wrk.indata[position+varlen], EMIT_BYTE_ADD );

  00401	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00405	74 2b		 je	 SHORT $LN91@emit_hrust
  00407	6a 02		 push	 2
  00409	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  0040c	03 45 bc	 add	 eax, DWORD PTR _varlen$[ebp]
  0040f	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  00415	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00419	52		 push	 edx
  0041a	e8 00 00 00 00	 call	 _emit_byte
  0041f	83 c4 08	 add	 esp, 8
  00422	85 c0		 test	 eax, eax
  00424	74 0c		 je	 SHORT $LN91@emit_hrust
  00426	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv208[ebp], 1
  00430	eb 0a		 jmp	 SHORT $LN92@emit_hrust
$LN91@emit_hrust:
  00432	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv208[ebp], 0
$LN92@emit_hrust:
  0043c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv208[ebp]
  00442	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 426  : 					varlen++;

  00445	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00448	83 c0 01	 add	 eax, 1
  0044b	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax

; 427  : 				}

  0044e	eb a3		 jmp	 SHORT $LN54@emit_hrust
$LN53@emit_hrust:

; 428  : 			}
; 429  : 			else

  00450	eb 05		 jmp	 SHORT $LN56@emit_hrust
$LN55@emit_hrust:

; 430  : 				goto INVALID_CODE_HRUST;

  00452	e9 a3 0a 00 00	 jmp	 $INVALID_CODE_HRUST$2754
$LN56@emit_hrust:

; 431  : 		}
; 432  : 		else if( length==(-3) ) // insertion code

  00457	e9 c4 0a 00 00	 jmp	 $LN59@emit_hrust
$LN58@emit_hrust:
  0045c	83 7d ec fd	 cmp	 DWORD PTR _length$[ebp], -3 ; fffffffdH
  00460	0f 85 48 02 00
	00		 jne	 $LN50@emit_hrust

; 433  : 		{
; 434  : 			if( (-16)<=disp && disp<=(-1) ) // %011001abcd<byte>

  00466	83 7d e0 f0	 cmp	 DWORD PTR _disp$[ebp], -16 ; fffffff0H
  0046a	7c 7d		 jl	 SHORT $LN49@emit_hrust
  0046c	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00470	7f 77		 jg	 SHORT $LN49@emit_hrust

; 435  : 			{
; 436  : 				success = success && emit_bits( 0x64000000, 6 );

  00472	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00476	74 1f		 je	 SHORT $LN93@emit_hrust
  00478	6a 06		 push	 6
  0047a	68 00 00 00 64	 push	 1677721600		; 64000000H
  0047f	e8 00 00 00 00	 call	 _emit_bits
  00484	83 c4 08	 add	 esp, 8
  00487	85 c0		 test	 eax, eax
  00489	74 0c		 je	 SHORT $LN93@emit_hrust
  0048b	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv218[ebp], 1
  00495	eb 0a		 jmp	 SHORT $LN94@emit_hrust
$LN93@emit_hrust:
  00497	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv218[ebp], 0
$LN94@emit_hrust:
  004a1	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv218[ebp]
  004a7	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 437  : 				success = success && emit_bits( disp<<(32-4), 4 );

  004aa	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  004ae	74 21		 je	 SHORT $LN95@emit_hrust
  004b0	6a 04		 push	 4
  004b2	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  004b5	c1 e0 1c	 shl	 eax, 28			; 0000001cH
  004b8	50		 push	 eax
  004b9	e8 00 00 00 00	 call	 _emit_bits
  004be	83 c4 08	 add	 esp, 8
  004c1	85 c0		 test	 eax, eax
  004c3	74 0c		 je	 SHORT $LN95@emit_hrust
  004c5	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv225[ebp], 1
  004cf	eb 0a		 jmp	 SHORT $LN96@emit_hrust
$LN95@emit_hrust:
  004d1	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv225[ebp], 0
$LN96@emit_hrust:
  004db	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv225[ebp]
  004e1	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  004e4	e9 80 01 00 00	 jmp	 $LN48@emit_hrust
$LN49@emit_hrust:

; 438  : 			}
; 439  : 			else if( (-79)<=disp && disp<(-16) )

  004e9	83 7d e0 b1	 cmp	 DWORD PTR _disp$[ebp], -79 ; ffffffb1H
  004ed	0f 8c 71 01 00
	00		 jl	 $LN47@emit_hrust
  004f3	83 7d e0 f0	 cmp	 DWORD PTR _disp$[ebp], -16 ; fffffff0H
  004f7	0f 8d 67 01 00
	00		 jge	 $LN47@emit_hrust

; 440  : 			{
; 441  : 				if( disp&1 ) // ffb1..ffef: %01001<byte><byte>

  004fd	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00500	83 e0 01	 and	 eax, 1
  00503	0f 84 af 00 00
	00		 je	 $LN46@emit_hrust

; 442  : 				{
; 443  : 					success = success && emit_bits( 0x48000000, 5 );

  00509	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0050d	74 1f		 je	 SHORT $LN97@emit_hrust
  0050f	6a 05		 push	 5
  00511	68 00 00 00 48	 push	 1207959552		; 48000000H
  00516	e8 00 00 00 00	 call	 _emit_bits
  0051b	83 c4 08	 add	 esp, 8
  0051e	85 c0		 test	 eax, eax
  00520	74 0c		 je	 SHORT $LN97@emit_hrust
  00522	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  0052c	eb 0a		 jmp	 SHORT $LN98@emit_hrust
$LN97@emit_hrust:
  0052e	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN98@emit_hrust:
  00538	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
  0053e	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 444  : 
; 445  : 					varbits = disp&0x00FF;

  00541	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00544	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00549	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 446  : 					varbits += 15;

  0054c	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  0054f	83 c0 0f	 add	 eax, 15			; 0000000fH
  00552	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 447  : 					varbits ^= 3;

  00555	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00558	83 f0 03	 xor	 eax, 3
  0055b	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 448  : 					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );

  0055e	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00561	d1 e8		 shr	 eax, 1
  00563	83 e0 7f	 and	 eax, 127		; 0000007fH
  00566	8b 4d c8	 mov	 ecx, DWORD PTR _varbits$[ebp]
  00569	c1 e1 07	 shl	 ecx, 7
  0056c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00572	0b c1		 or	 eax, ecx
  00574	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 449  : 
; 450  : 					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );

  00577	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0057b	74 23		 je	 SHORT $LN99@emit_hrust
  0057d	6a 02		 push	 2
  0057f	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00582	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00587	50		 push	 eax
  00588	e8 00 00 00 00	 call	 _emit_byte
  0058d	83 c4 08	 add	 esp, 8
  00590	85 c0		 test	 eax, eax
  00592	74 0c		 je	 SHORT $LN99@emit_hrust
  00594	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv251[ebp], 1
  0059e	eb 0a		 jmp	 SHORT $LN100@emit_hrust
$LN99@emit_hrust:
  005a0	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv251[ebp], 0
$LN100@emit_hrust:
  005aa	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv251[ebp]
  005b0	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 451  : 				}
; 452  : 				else // ffb2..ffee: %00110<byte><byte>

  005b3	e9 aa 00 00 00	 jmp	 $LN45@emit_hrust
$LN46@emit_hrust:

; 453  : 				{
; 454  : 					success = success && emit_bits( 0x30000000, 5 );

  005b8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  005bc	74 1f		 je	 SHORT $LN101@emit_hrust
  005be	6a 05		 push	 5
  005c0	68 00 00 00 30	 push	 805306368		; 30000000H
  005c5	e8 00 00 00 00	 call	 _emit_bits
  005ca	83 c4 08	 add	 esp, 8
  005cd	85 c0		 test	 eax, eax
  005cf	74 0c		 je	 SHORT $LN101@emit_hrust
  005d1	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv257[ebp], 1
  005db	eb 0a		 jmp	 SHORT $LN102@emit_hrust
$LN101@emit_hrust:
  005dd	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv257[ebp], 0
$LN102@emit_hrust:
  005e7	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv257[ebp]
  005ed	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 455  : 
; 456  : 					varbits = disp&0x00FF;

  005f0	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  005f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005f8	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 457  : 					varbits += 15;

  005fb	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  005fe	83 c0 0f	 add	 eax, 15			; 0000000fH
  00601	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 458  : 					varbits ^= 2;

  00604	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00607	83 f0 02	 xor	 eax, 2
  0060a	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 459  : 					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );

  0060d	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00610	d1 e8		 shr	 eax, 1
  00612	83 e0 7f	 and	 eax, 127		; 0000007fH
  00615	8b 4d c8	 mov	 ecx, DWORD PTR _varbits$[ebp]
  00618	c1 e1 07	 shl	 ecx, 7
  0061b	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00621	0b c1		 or	 eax, ecx
  00623	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 460  : 
; 461  : 					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );

  00626	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0062a	74 23		 je	 SHORT $LN103@emit_hrust
  0062c	6a 02		 push	 2
  0062e	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00631	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00636	50		 push	 eax
  00637	e8 00 00 00 00	 call	 _emit_byte
  0063c	83 c4 08	 add	 esp, 8
  0063f	85 c0		 test	 eax, eax
  00641	74 0c		 je	 SHORT $LN103@emit_hrust
  00643	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv273[ebp], 1
  0064d	eb 0a		 jmp	 SHORT $LN104@emit_hrust
$LN103@emit_hrust:
  0064f	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv273[ebp], 0
$LN104@emit_hrust:
  00659	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv273[ebp]
  0065f	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
$LN45@emit_hrust:

; 462  : 				}
; 463  : 			}
; 464  : 			else

  00662	eb 05		 jmp	 SHORT $LN48@emit_hrust
$LN47@emit_hrust:

; 465  : 				goto INVALID_CODE_HRUST;

  00664	e9 91 08 00 00	 jmp	 $INVALID_CODE_HRUST$2754
$LN48@emit_hrust:

; 466  : 
; 467  : 			success = success && emit_byte( wrk.indata[position+1], EMIT_BYTE_ADD );

  00669	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0066d	74 27		 je	 SHORT $LN105@emit_hrust
  0066f	6a 02		 push	 2
  00671	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00676	03 45 f8	 add	 eax, DWORD PTR _position$[ebp]
  00679	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0067d	51		 push	 ecx
  0067e	e8 00 00 00 00	 call	 _emit_byte
  00683	83 c4 08	 add	 esp, 8
  00686	85 c0		 test	 eax, eax
  00688	74 0c		 je	 SHORT $LN105@emit_hrust
  0068a	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv281[ebp], 1
  00694	eb 0a		 jmp	 SHORT $LN106@emit_hrust
$LN105@emit_hrust:
  00696	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv281[ebp], 0
$LN106@emit_hrust:
  006a0	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv281[ebp]
  006a6	89 55 b0	 mov	 DWORD PTR _success$[ebp], edx
  006a9	e9 72 08 00 00	 jmp	 $LN59@emit_hrust
$LN50@emit_hrust:

; 468  : 		}
; 469  : 		else if( length==1 ) // %000abc

  006ae	83 7d ec 01	 cmp	 DWORD PTR _length$[ebp], 1
  006b2	0f 85 87 00 00
	00		 jne	 $LN42@emit_hrust

; 470  : 		{
; 471  : 			if( (-8)<=disp && disp<=(-1) )

  006b8	83 7d e0 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  006bc	7c 77		 jl	 SHORT $LN41@emit_hrust
  006be	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  006c2	7f 71		 jg	 SHORT $LN41@emit_hrust

; 472  : 			{
; 473  : 				success = success && emit_bits( 0x00000000, 3 );

  006c4	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006c8	74 1c		 je	 SHORT $LN107@emit_hrust
  006ca	6a 03		 push	 3
  006cc	6a 00		 push	 0
  006ce	e8 00 00 00 00	 call	 _emit_bits
  006d3	83 c4 08	 add	 esp, 8
  006d6	85 c0		 test	 eax, eax
  006d8	74 0c		 je	 SHORT $LN107@emit_hrust
  006da	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv290[ebp], 1
  006e4	eb 0a		 jmp	 SHORT $LN108@emit_hrust
$LN107@emit_hrust:
  006e6	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv290[ebp], 0
$LN108@emit_hrust:
  006f0	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv290[ebp]
  006f6	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 474  : 				success = success && emit_bits( disp<<(32-3), 3 );

  006f9	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  006fd	74 21		 je	 SHORT $LN109@emit_hrust
  006ff	6a 03		 push	 3
  00701	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00704	c1 e0 1d	 shl	 eax, 29			; 0000001dH
  00707	50		 push	 eax
  00708	e8 00 00 00 00	 call	 _emit_bits
  0070d	83 c4 08	 add	 esp, 8
  00710	85 c0		 test	 eax, eax
  00712	74 0c		 je	 SHORT $LN109@emit_hrust
  00714	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv297[ebp], 1
  0071e	eb 0a		 jmp	 SHORT $LN110@emit_hrust
$LN109@emit_hrust:
  00720	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
$LN110@emit_hrust:
  0072a	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv297[ebp]
  00730	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 475  : 			}
; 476  : 			else

  00733	eb 05		 jmp	 SHORT $LN40@emit_hrust
$LN41@emit_hrust:

; 477  : 				goto INVALID_CODE_HRUST;

  00735	e9 c0 07 00 00	 jmp	 $INVALID_CODE_HRUST$2754
$LN40@emit_hrust:

; 478  : 		}
; 479  : 		else if( length==2 )

  0073a	e9 e1 07 00 00	 jmp	 $LN59@emit_hrust
$LN42@emit_hrust:
  0073f	83 7d ec 02	 cmp	 DWORD PTR _length$[ebp], 2
  00743	0f 85 2c 02 00
	00		 jne	 $LN38@emit_hrust

; 480  : 		{
; 481  : 			if( (-32)<=disp && disp<=(-1) ) // %00111abcde

  00749	83 7d e0 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  0074d	7c 7d		 jl	 SHORT $LN37@emit_hrust
  0074f	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00753	7f 77		 jg	 SHORT $LN37@emit_hrust

; 482  : 			{
; 483  : 				success = success && emit_bits( 0x38000000, 5 );

  00755	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00759	74 1f		 je	 SHORT $LN111@emit_hrust
  0075b	6a 05		 push	 5
  0075d	68 00 00 00 38	 push	 939524096		; 38000000H
  00762	e8 00 00 00 00	 call	 _emit_bits
  00767	83 c4 08	 add	 esp, 8
  0076a	85 c0		 test	 eax, eax
  0076c	74 0c		 je	 SHORT $LN111@emit_hrust
  0076e	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv306[ebp], 1
  00778	eb 0a		 jmp	 SHORT $LN112@emit_hrust
$LN111@emit_hrust:
  0077a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv306[ebp], 0
$LN112@emit_hrust:
  00784	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv306[ebp]
  0078a	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 484  : 				success = success && emit_bits( disp<<(32-5), 5 );

  0078d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00791	74 21		 je	 SHORT $LN113@emit_hrust
  00793	6a 05		 push	 5
  00795	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00798	c1 e0 1b	 shl	 eax, 27			; 0000001bH
  0079b	50		 push	 eax
  0079c	e8 00 00 00 00	 call	 _emit_bits
  007a1	83 c4 08	 add	 esp, 8
  007a4	85 c0		 test	 eax, eax
  007a6	74 0c		 je	 SHORT $LN113@emit_hrust
  007a8	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv313[ebp], 1
  007b2	eb 0a		 jmp	 SHORT $LN114@emit_hrust
$LN113@emit_hrust:
  007b4	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv313[ebp], 0
$LN114@emit_hrust:
  007be	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv313[ebp]
  007c4	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  007c7	e9 a4 01 00 00	 jmp	 $LN36@emit_hrust
$LN37@emit_hrust:

; 485  : 			}
; 486  : 			else if( (-256)<=disp && disp<(-32) ) // %00110<byte>

  007cc	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  007d3	7c 7f		 jl	 SHORT $LN35@emit_hrust
  007d5	83 7d e0 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  007d9	7d 79		 jge	 SHORT $LN35@emit_hrust

; 487  : 			{
; 488  : 				success = success && emit_bits( 0x30000000, 5 );

  007db	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  007df	74 1f		 je	 SHORT $LN115@emit_hrust
  007e1	6a 05		 push	 5
  007e3	68 00 00 00 30	 push	 805306368		; 30000000H
  007e8	e8 00 00 00 00	 call	 _emit_bits
  007ed	83 c4 08	 add	 esp, 8
  007f0	85 c0		 test	 eax, eax
  007f2	74 0c		 je	 SHORT $LN115@emit_hrust
  007f4	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv321[ebp], 1
  007fe	eb 0a		 jmp	 SHORT $LN116@emit_hrust
$LN115@emit_hrust:
  00800	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv321[ebp], 0
$LN116@emit_hrust:
  0080a	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv321[ebp]
  00810	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 489  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00813	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00817	74 23		 je	 SHORT $LN117@emit_hrust
  00819	6a 02		 push	 2
  0081b	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  0081e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00823	50		 push	 eax
  00824	e8 00 00 00 00	 call	 _emit_byte
  00829	83 c4 08	 add	 esp, 8
  0082c	85 c0		 test	 eax, eax
  0082e	74 0c		 je	 SHORT $LN117@emit_hrust
  00830	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv329[ebp], 1
  0083a	eb 0a		 jmp	 SHORT $LN118@emit_hrust
$LN117@emit_hrust:
  0083c	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv329[ebp], 0
$LN118@emit_hrust:
  00846	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv329[ebp]
  0084c	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  0084f	e9 1c 01 00 00	 jmp	 $LN36@emit_hrust
$LN35@emit_hrust:

; 490  : 			}
; 491  : 			else if( (-512)<=disp && disp<(-256) ) // %00101<byte>

  00854	81 7d e0 00 fe
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -512 ; fffffe00H
  0085b	0f 8c 82 00 00
	00		 jl	 $LN33@emit_hrust
  00861	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00868	7d 79		 jge	 SHORT $LN33@emit_hrust

; 492  : 			{
; 493  : 				success = success && emit_bits( 0x28000000, 5 );

  0086a	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0086e	74 1f		 je	 SHORT $LN119@emit_hrust
  00870	6a 05		 push	 5
  00872	68 00 00 00 28	 push	 671088640		; 28000000H
  00877	e8 00 00 00 00	 call	 _emit_bits
  0087c	83 c4 08	 add	 esp, 8
  0087f	85 c0		 test	 eax, eax
  00881	74 0c		 je	 SHORT $LN119@emit_hrust
  00883	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv337[ebp], 1
  0088d	eb 0a		 jmp	 SHORT $LN120@emit_hrust
$LN119@emit_hrust:
  0088f	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv337[ebp], 0
$LN120@emit_hrust:
  00899	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv337[ebp]
  0089f	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 494  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  008a2	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  008a6	74 23		 je	 SHORT $LN121@emit_hrust
  008a8	6a 02		 push	 2
  008aa	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  008ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008b2	50		 push	 eax
  008b3	e8 00 00 00 00	 call	 _emit_byte
  008b8	83 c4 08	 add	 esp, 8
  008bb	85 c0		 test	 eax, eax
  008bd	74 0c		 je	 SHORT $LN121@emit_hrust
  008bf	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv345[ebp], 1
  008c9	eb 0a		 jmp	 SHORT $LN122@emit_hrust
$LN121@emit_hrust:
  008cb	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv345[ebp], 0
$LN122@emit_hrust:
  008d5	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv345[ebp]
  008db	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  008de	e9 8d 00 00 00	 jmp	 $LN36@emit_hrust
$LN33@emit_hrust:

; 495  : 			}
; 496  : 			else if( (-768)<=disp && disp<(-512) ) // %00100<byte>

  008e3	81 7d e0 00 fd
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -768 ; fffffd00H
  008ea	7c 7f		 jl	 SHORT $LN31@emit_hrust
  008ec	81 7d e0 00 fe
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -512 ; fffffe00H
  008f3	7d 76		 jge	 SHORT $LN31@emit_hrust

; 497  : 			{
; 498  : 				success = success && emit_bits( 0x20000000, 5 );

  008f5	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  008f9	74 1f		 je	 SHORT $LN123@emit_hrust
  008fb	6a 05		 push	 5
  008fd	68 00 00 00 20	 push	 536870912		; 20000000H
  00902	e8 00 00 00 00	 call	 _emit_bits
  00907	83 c4 08	 add	 esp, 8
  0090a	85 c0		 test	 eax, eax
  0090c	74 0c		 je	 SHORT $LN123@emit_hrust
  0090e	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv353[ebp], 1
  00918	eb 0a		 jmp	 SHORT $LN124@emit_hrust
$LN123@emit_hrust:
  0091a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv353[ebp], 0
$LN124@emit_hrust:
  00924	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv353[ebp]
  0092a	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 499  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  0092d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00931	74 23		 je	 SHORT $LN125@emit_hrust
  00933	6a 02		 push	 2
  00935	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00938	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0093d	50		 push	 eax
  0093e	e8 00 00 00 00	 call	 _emit_byte
  00943	83 c4 08	 add	 esp, 8
  00946	85 c0		 test	 eax, eax
  00948	74 0c		 je	 SHORT $LN125@emit_hrust
  0094a	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv361[ebp], 1
  00954	eb 0a		 jmp	 SHORT $LN126@emit_hrust
$LN125@emit_hrust:
  00956	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv361[ebp], 0
$LN126@emit_hrust:
  00960	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv361[ebp]
  00966	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 500  : 			}
; 501  : 			else

  00969	eb 05		 jmp	 SHORT $LN36@emit_hrust
$LN31@emit_hrust:

; 502  : 				goto INVALID_CODE_HRUST;

  0096b	e9 8a 05 00 00	 jmp	 $INVALID_CODE_HRUST$2754
$LN36@emit_hrust:

; 503  : 		}
; 504  : 		else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )

  00970	e9 ab 05 00 00	 jmp	 $LN59@emit_hrust
$LN38@emit_hrust:
  00975	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  00979	0f 8c 7b 05 00
	00		 jl	 $INVALID_CODE_HRUST$2754
  0097f	81 7d ec ff 0e
	00 00		 cmp	 DWORD PTR _length$[ebp], 3839 ; 00000effH
  00986	0f 8f 6e 05 00
	00		 jg	 $INVALID_CODE_HRUST$2754
  0098c	81 7d e0 00 00
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -65536 ; ffff0000H
  00993	0f 8c 61 05 00
	00		 jl	 $INVALID_CODE_HRUST$2754
  00999	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  0099d	0f 8f 57 05 00
	00		 jg	 $INVALID_CODE_HRUST$2754

; 505  : 		{
; 506  : 			// first see if we need emitting expansion codes
; 507  : 
; 508  : 				//  -513.. -1024  (FDFF..FC00) - 2 bits
; 509  : 				//  -1025..-2048  (FBFF..F800) - 3
; 510  : 				//  -2049..-4096  (F7FF..F000) - 4
; 511  : 				//  -4097..-8192  (EFFF..E000) - 5
; 512  : 				//  -8193..-16384 (DFFF..C000) - 6
; 513  : 				// -16385..-32768 (BFFF..8000) - 7
; 514  : 				// -32769..-65536 (7FFF..0000) - 8
; 515  : 			if( disp<(-512) )

  009a3	81 7d e0 00 fe
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -512 ; fffffe00H
  009aa	0f 8d cc 00 00
	00		 jge	 $LN27@emit_hrust

; 516  : 			{
; 517  : 				varbits = 1024;

  009b0	c7 45 c8 00 04
	00 00		 mov	 DWORD PTR _varbits$[ebp], 1024 ; 00000400H

; 518  : 				varlen  = 2;

  009b7	c7 45 bc 02 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 2
$LN26@emit_hrust:

; 519  : 				while( (ULONG)(-disp) > varbits )

  009be	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  009c1	f7 d8		 neg	 eax
  009c3	3b 45 c8	 cmp	 eax, DWORD PTR _varbits$[ebp]
  009c6	76 13		 jbe	 SHORT $LN24@emit_hrust

; 520  : 				{
; 521  : 					varbits <<= 1;

  009c8	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  009cb	d1 e0		 shl	 eax, 1
  009cd	89 45 c8	 mov	 DWORD PTR _varbits$[ebp], eax

; 522  : 					varlen++;

  009d0	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  009d3	83 c0 01	 add	 eax, 1
  009d6	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax

; 523  : 				}

  009d9	eb e3		 jmp	 SHORT $LN26@emit_hrust
$LN24@emit_hrust:

; 524  : 
; 525  : 				// emit expansion codes, if necessary: %00110<FE>
; 526  : 				while( varlen>expbitlen )

  009db	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  009de	3b 45 98	 cmp	 eax, DWORD PTR _expbitlen$[ebp]
  009e1	0f 86 95 00 00
	00		 jbe	 $LN27@emit_hrust

; 527  : 				{
; 528  : 					success = success && emit_bits( 0x30000000, 5 );

  009e7	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  009eb	74 1f		 je	 SHORT $LN127@emit_hrust
  009ed	6a 05		 push	 5
  009ef	68 00 00 00 30	 push	 805306368		; 30000000H
  009f4	e8 00 00 00 00	 call	 _emit_bits
  009f9	83 c4 08	 add	 esp, 8
  009fc	85 c0		 test	 eax, eax
  009fe	74 0c		 je	 SHORT $LN127@emit_hrust
  00a00	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv377[ebp], 1
  00a0a	eb 0a		 jmp	 SHORT $LN128@emit_hrust
$LN127@emit_hrust:
  00a0c	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv377[ebp], 0
$LN128@emit_hrust:
  00a16	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]
  00a1c	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 529  : 					success = success && emit_byte( 0x00FE, EMIT_BYTE_ADD );

  00a1f	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00a23	74 1f		 je	 SHORT $LN129@emit_hrust
  00a25	6a 02		 push	 2
  00a27	68 fe 00 00 00	 push	 254			; 000000feH
  00a2c	e8 00 00 00 00	 call	 _emit_byte
  00a31	83 c4 08	 add	 esp, 8
  00a34	85 c0		 test	 eax, eax
  00a36	74 0c		 je	 SHORT $LN129@emit_hrust
  00a38	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv383[ebp], 1
  00a42	eb 0a		 jmp	 SHORT $LN130@emit_hrust
$LN129@emit_hrust:
  00a44	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv383[ebp], 0
$LN130@emit_hrust:
  00a4e	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv383[ebp]
  00a54	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 530  : 					#ifdef DBG
; 531  : 						printf("expansion\n");

  00a57	8b f4		 mov	 esi, esp
  00a59	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KFHJGGOL@expansion?6?$AA@
  00a5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a64	83 c4 04	 add	 esp, 4
  00a67	3b f4		 cmp	 esi, esp
  00a69	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 532  : 					#endif
; 533  : 
; 534  : 					expbitlen++;

  00a6e	8b 45 98	 mov	 eax, DWORD PTR _expbitlen$[ebp]
  00a71	83 c0 01	 add	 eax, 1
  00a74	89 45 98	 mov	 DWORD PTR _expbitlen$[ebp], eax

; 535  : 				}

  00a77	e9 5f ff ff ff	 jmp	 $LN24@emit_hrust
$LN27@emit_hrust:

; 536  : 			}
; 537  : 
; 538  : 
; 539  : 
; 540  : 
; 541  : 
; 542  : 			// emit length
; 543  : 
; 544  : 			if( length<=15 ) // 3..15

  00a7c	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00a80	0f 8f 12 01 00
	00		 jg	 $LN22@emit_hrust

; 545  : 			{
; 546  : 				success = success && emit_bits( 0, 1 );

  00a86	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00a8a	74 1c		 je	 SHORT $LN131@emit_hrust
  00a8c	6a 01		 push	 1
  00a8e	6a 00		 push	 0
  00a90	e8 00 00 00 00	 call	 _emit_bits
  00a95	83 c4 08	 add	 esp, 8
  00a98	85 c0		 test	 eax, eax
  00a9a	74 0c		 je	 SHORT $LN131@emit_hrust
  00a9c	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv392[ebp], 1
  00aa6	eb 0a		 jmp	 SHORT $LN132@emit_hrust
$LN131@emit_hrust:
  00aa8	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv392[ebp], 0
$LN132@emit_hrust:
  00ab2	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv392[ebp]
  00ab8	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 547  : 
; 548  : 				if( length==3 )

  00abb	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  00abf	75 3d		 jne	 SHORT $LN21@emit_hrust

; 549  : 				{
; 550  : 					success = success && emit_bits( 0x80000000, 2 ); // %010

  00ac1	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00ac5	74 1f		 je	 SHORT $LN133@emit_hrust
  00ac7	6a 02		 push	 2
  00ac9	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00ace	e8 00 00 00 00	 call	 _emit_bits
  00ad3	83 c4 08	 add	 esp, 8
  00ad6	85 c0		 test	 eax, eax
  00ad8	74 0c		 je	 SHORT $LN133@emit_hrust
  00ada	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv399[ebp], 1
  00ae4	eb 0a		 jmp	 SHORT $LN134@emit_hrust
$LN133@emit_hrust:
  00ae6	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv399[ebp], 0
$LN134@emit_hrust:
  00af0	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv399[ebp]
  00af6	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 551  : 				}
; 552  : 				else

  00af9	e9 95 00 00 00	 jmp	 $LN20@emit_hrust
$LN21@emit_hrust:

; 553  : 				{
; 554  : 					varlen  = length/3;

  00afe	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00b01	99		 cdq
  00b02	b9 03 00 00 00	 mov	 ecx, 3
  00b07	f7 f9		 idiv	 ecx
  00b09	89 45 bc	 mov	 DWORD PTR _varlen$[ebp], eax

; 555  : 					varbits = length%3;

  00b0c	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00b0f	99		 cdq
  00b10	b9 03 00 00 00	 mov	 ecx, 3
  00b15	f7 f9		 idiv	 ecx
  00b17	89 55 c8	 mov	 DWORD PTR _varbits$[ebp], edx

; 556  : 
; 557  : 					success = success && emit_bits( 0xFFFFFFFF, varlen<<1 );

  00b1a	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00b1e	74 20		 je	 SHORT $LN135@emit_hrust
  00b20	8b 45 bc	 mov	 eax, DWORD PTR _varlen$[ebp]
  00b23	d1 e0		 shl	 eax, 1
  00b25	50		 push	 eax
  00b26	6a ff		 push	 -1
  00b28	e8 00 00 00 00	 call	 _emit_bits
  00b2d	83 c4 08	 add	 esp, 8
  00b30	85 c0		 test	 eax, eax
  00b32	74 0c		 je	 SHORT $LN135@emit_hrust
  00b34	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv408[ebp], 1
  00b3e	eb 0a		 jmp	 SHORT $LN136@emit_hrust
$LN135@emit_hrust:
  00b40	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv408[ebp], 0
$LN136@emit_hrust:
  00b4a	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv408[ebp]
  00b50	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 558  : 
; 559  : 					if( length!=15 )

  00b53	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00b57	74 3a		 je	 SHORT $LN20@emit_hrust

; 560  : 						success = success && emit_bits( varbits<<(32-2), 2 );

  00b59	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00b5d	74 21		 je	 SHORT $LN137@emit_hrust
  00b5f	6a 02		 push	 2
  00b61	8b 45 c8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00b64	c1 e0 1e	 shl	 eax, 30			; 0000001eH
  00b67	50		 push	 eax
  00b68	e8 00 00 00 00	 call	 _emit_bits
  00b6d	83 c4 08	 add	 esp, 8
  00b70	85 c0		 test	 eax, eax
  00b72	74 0c		 je	 SHORT $LN137@emit_hrust
  00b74	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv416[ebp], 1
  00b7e	eb 0a		 jmp	 SHORT $LN138@emit_hrust
$LN137@emit_hrust:
  00b80	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv416[ebp], 0
$LN138@emit_hrust:
  00b8a	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv416[ebp]
  00b90	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
$LN20@emit_hrust:

; 561  : 				}

  00b93	e9 2b 01 00 00	 jmp	 $LN18@emit_hrust
$LN22@emit_hrust:

; 562  : 			}
; 563  : 			else if( length<=127 ) // 16..127: %0110000abcdefg

  00b98	83 7d ec 7f	 cmp	 DWORD PTR _length$[ebp], 127 ; 0000007fH
  00b9c	7f 77		 jg	 SHORT $LN17@emit_hrust

; 564  : 			{
; 565  : 				success = success && emit_bits( 0x60000000, 7 );

  00b9e	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00ba2	74 1f		 je	 SHORT $LN139@emit_hrust
  00ba4	6a 07		 push	 7
  00ba6	68 00 00 00 60	 push	 1610612736		; 60000000H
  00bab	e8 00 00 00 00	 call	 _emit_bits
  00bb0	83 c4 08	 add	 esp, 8
  00bb3	85 c0		 test	 eax, eax
  00bb5	74 0c		 je	 SHORT $LN139@emit_hrust
  00bb7	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv423[ebp], 1
  00bc1	eb 0a		 jmp	 SHORT $LN140@emit_hrust
$LN139@emit_hrust:
  00bc3	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv423[ebp], 0
$LN140@emit_hrust:
  00bcd	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv423[ebp]
  00bd3	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 566  : 				success = success && emit_bits( length<<(32-7), 7 );

  00bd6	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00bda	74 21		 je	 SHORT $LN141@emit_hrust
  00bdc	6a 07		 push	 7
  00bde	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00be1	c1 e0 19	 shl	 eax, 25			; 00000019H
  00be4	50		 push	 eax
  00be5	e8 00 00 00 00	 call	 _emit_bits
  00bea	83 c4 08	 add	 esp, 8
  00bed	85 c0		 test	 eax, eax
  00bef	74 0c		 je	 SHORT $LN141@emit_hrust
  00bf1	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv430[ebp], 1
  00bfb	eb 0a		 jmp	 SHORT $LN142@emit_hrust
$LN141@emit_hrust:
  00bfd	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv430[ebp], 0
$LN142@emit_hrust:
  00c07	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv430[ebp]
  00c0d	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 567  : 			}
; 568  : 			else // 128..3839

  00c10	e9 ae 00 00 00	 jmp	 $LN18@emit_hrust
$LN17@emit_hrust:

; 569  : 			{
; 570  : 				success = success && emit_bits( 0x60000000, 7 );

  00c15	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00c19	74 1f		 je	 SHORT $LN143@emit_hrust
  00c1b	6a 07		 push	 7
  00c1d	68 00 00 00 60	 push	 1610612736		; 60000000H
  00c22	e8 00 00 00 00	 call	 _emit_bits
  00c27	83 c4 08	 add	 esp, 8
  00c2a	85 c0		 test	 eax, eax
  00c2c	74 0c		 je	 SHORT $LN143@emit_hrust
  00c2e	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv436[ebp], 1
  00c38	eb 0a		 jmp	 SHORT $LN144@emit_hrust
$LN143@emit_hrust:
  00c3a	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv436[ebp], 0
$LN144@emit_hrust:
  00c44	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv436[ebp]
  00c4a	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 571  : 				success = success && emit_bits( length<<(32-15), 7 );

  00c4d	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00c51	74 21		 je	 SHORT $LN145@emit_hrust
  00c53	6a 07		 push	 7
  00c55	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00c58	c1 e0 11	 shl	 eax, 17			; 00000011H
  00c5b	50		 push	 eax
  00c5c	e8 00 00 00 00	 call	 _emit_bits
  00c61	83 c4 08	 add	 esp, 8
  00c64	85 c0		 test	 eax, eax
  00c66	74 0c		 je	 SHORT $LN145@emit_hrust
  00c68	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv443[ebp], 1
  00c72	eb 0a		 jmp	 SHORT $LN146@emit_hrust
$LN145@emit_hrust:
  00c74	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv443[ebp], 0
$LN146@emit_hrust:
  00c7e	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv443[ebp]
  00c84	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 572  : 				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );

  00c87	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00c8b	74 23		 je	 SHORT $LN147@emit_hrust
  00c8d	6a 02		 push	 2
  00c8f	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00c92	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c97	50		 push	 eax
  00c98	e8 00 00 00 00	 call	 _emit_byte
  00c9d	83 c4 08	 add	 esp, 8
  00ca0	85 c0		 test	 eax, eax
  00ca2	74 0c		 je	 SHORT $LN147@emit_hrust
  00ca4	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv451[ebp], 1
  00cae	eb 0a		 jmp	 SHORT $LN148@emit_hrust
$LN147@emit_hrust:
  00cb0	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv451[ebp], 0
$LN148@emit_hrust:
  00cba	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv451[ebp]
  00cc0	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
$LN18@emit_hrust:

; 573  : 			}
; 574  : 
; 575  : 
; 576  : 			// emit displacement
; 577  : 			if( (-32)<=disp ) // ffe0..ffff: %10abcde

  00cc3	83 7d e0 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  00cc7	7c 77		 jl	 SHORT $LN15@emit_hrust

; 578  : 			{
; 579  : 				success = success && emit_bits( 0x80000000, 2 );

  00cc9	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00ccd	74 1f		 je	 SHORT $LN149@emit_hrust
  00ccf	6a 02		 push	 2
  00cd1	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00cd6	e8 00 00 00 00	 call	 _emit_bits
  00cdb	83 c4 08	 add	 esp, 8
  00cde	85 c0		 test	 eax, eax
  00ce0	74 0c		 je	 SHORT $LN149@emit_hrust
  00ce2	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv458[ebp], 1
  00cec	eb 0a		 jmp	 SHORT $LN150@emit_hrust
$LN149@emit_hrust:
  00cee	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv458[ebp], 0
$LN150@emit_hrust:
  00cf8	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv458[ebp]
  00cfe	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 580  : 				success = success && emit_bits( disp<<(32-5), 5 );

  00d01	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00d05	74 21		 je	 SHORT $LN151@emit_hrust
  00d07	6a 05		 push	 5
  00d09	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00d0c	c1 e0 1b	 shl	 eax, 27			; 0000001bH
  00d0f	50		 push	 eax
  00d10	e8 00 00 00 00	 call	 _emit_bits
  00d15	83 c4 08	 add	 esp, 8
  00d18	85 c0		 test	 eax, eax
  00d1a	74 0c		 je	 SHORT $LN151@emit_hrust
  00d1c	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv465[ebp], 1
  00d26	eb 0a		 jmp	 SHORT $LN152@emit_hrust
$LN151@emit_hrust:
  00d28	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv465[ebp], 0
$LN152@emit_hrust:
  00d32	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv465[ebp]
  00d38	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  00d3b	e9 b8 01 00 00	 jmp	 $LN14@emit_hrust
$LN15@emit_hrust:

; 581  : 			}
; 582  : 			else if( (-256)<=disp ) // ff00..ffdf: %01<byte>

  00d40	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00d47	7c 79		 jl	 SHORT $LN13@emit_hrust

; 583  : 			{
; 584  : 				success = success && emit_bits( 0x40000000, 2 );

  00d49	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00d4d	74 1f		 je	 SHORT $LN153@emit_hrust
  00d4f	6a 02		 push	 2
  00d51	68 00 00 00 40	 push	 1073741824		; 40000000H
  00d56	e8 00 00 00 00	 call	 _emit_bits
  00d5b	83 c4 08	 add	 esp, 8
  00d5e	85 c0		 test	 eax, eax
  00d60	74 0c		 je	 SHORT $LN153@emit_hrust
  00d62	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv472[ebp], 1
  00d6c	eb 0a		 jmp	 SHORT $LN154@emit_hrust
$LN153@emit_hrust:
  00d6e	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv472[ebp], 0
$LN154@emit_hrust:
  00d78	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv472[ebp]
  00d7e	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 585  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  00d81	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00d85	74 23		 je	 SHORT $LN155@emit_hrust
  00d87	6a 02		 push	 2
  00d89	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00d8c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d91	50		 push	 eax
  00d92	e8 00 00 00 00	 call	 _emit_byte
  00d97	83 c4 08	 add	 esp, 8
  00d9a	85 c0		 test	 eax, eax
  00d9c	74 0c		 je	 SHORT $LN155@emit_hrust
  00d9e	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv480[ebp], 1
  00da8	eb 0a		 jmp	 SHORT $LN156@emit_hrust
$LN155@emit_hrust:
  00daa	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv480[ebp], 0
$LN156@emit_hrust:
  00db4	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv480[ebp]
  00dba	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
  00dbd	e9 36 01 00 00	 jmp	 $LN14@emit_hrust
$LN13@emit_hrust:

; 586  : 			}
; 587  : 			else if( (-512)<=disp ) // fe00..feff: %00<byte>

  00dc2	81 7d e0 00 fe
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -512 ; fffffe00H
  00dc9	7c 76		 jl	 SHORT $LN11@emit_hrust

; 588  : 			{
; 589  : 				success = success && emit_bits( 0x00000000, 2 );

  00dcb	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00dcf	74 1c		 je	 SHORT $LN157@emit_hrust
  00dd1	6a 02		 push	 2
  00dd3	6a 00		 push	 0
  00dd5	e8 00 00 00 00	 call	 _emit_bits
  00dda	83 c4 08	 add	 esp, 8
  00ddd	85 c0		 test	 eax, eax
  00ddf	74 0c		 je	 SHORT $LN157@emit_hrust
  00de1	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv487[ebp], 1
  00deb	eb 0a		 jmp	 SHORT $LN158@emit_hrust
$LN157@emit_hrust:
  00ded	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv487[ebp], 0
$LN158@emit_hrust:
  00df7	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv487[ebp]
  00dfd	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 590  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  00e00	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00e04	74 23		 je	 SHORT $LN159@emit_hrust
  00e06	6a 02		 push	 2
  00e08	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00e0b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e10	50		 push	 eax
  00e11	e8 00 00 00 00	 call	 _emit_byte
  00e16	83 c4 08	 add	 esp, 8
  00e19	85 c0		 test	 eax, eax
  00e1b	74 0c		 je	 SHORT $LN159@emit_hrust
  00e1d	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv495[ebp], 1
  00e27	eb 0a		 jmp	 SHORT $LN160@emit_hrust
$LN159@emit_hrust:
  00e29	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv495[ebp], 0
$LN160@emit_hrust:
  00e33	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv495[ebp]
  00e39	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx

; 591  : 			}
; 592  : 			else // variable code length: [-65536..-512)

  00e3c	e9 b7 00 00 00	 jmp	 $LN14@emit_hrust
$LN11@emit_hrust:

; 593  : 			{
; 594  : 
; 595  : 				// displacement itself: %11ab[cdefgh]<byte>
; 596  : 				success = success && emit_bits( 0xC0000000, 2 );

  00e41	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00e45	74 1f		 je	 SHORT $LN161@emit_hrust
  00e47	6a 02		 push	 2
  00e49	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00e4e	e8 00 00 00 00	 call	 _emit_bits
  00e53	83 c4 08	 add	 esp, 8
  00e56	85 c0		 test	 eax, eax
  00e58	74 0c		 je	 SHORT $LN161@emit_hrust
  00e5a	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv501[ebp], 1
  00e64	eb 0a		 jmp	 SHORT $LN162@emit_hrust
$LN161@emit_hrust:
  00e66	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv501[ebp], 0
$LN162@emit_hrust:
  00e70	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv501[ebp]
  00e76	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 597  : 				success = success && emit_bits( disp<<(24-expbitlen), expbitlen );

  00e79	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00e7d	74 2a		 je	 SHORT $LN163@emit_hrust
  00e7f	8b 45 98	 mov	 eax, DWORD PTR _expbitlen$[ebp]
  00e82	50		 push	 eax
  00e83	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00e88	2b 4d 98	 sub	 ecx, DWORD PTR _expbitlen$[ebp]
  00e8b	8b 55 e0	 mov	 edx, DWORD PTR _disp$[ebp]
  00e8e	d3 e2		 shl	 edx, cl
  00e90	52		 push	 edx
  00e91	e8 00 00 00 00	 call	 _emit_bits
  00e96	83 c4 08	 add	 esp, 8
  00e99	85 c0		 test	 eax, eax
  00e9b	74 0c		 je	 SHORT $LN163@emit_hrust
  00e9d	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv509[ebp], 1
  00ea7	eb 0a		 jmp	 SHORT $LN164@emit_hrust
$LN163@emit_hrust:
  00ea9	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv509[ebp], 0
$LN164@emit_hrust:
  00eb3	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv509[ebp]
  00eb9	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 598  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  00ebc	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00ec0	74 23		 je	 SHORT $LN165@emit_hrust
  00ec2	6a 02		 push	 2
  00ec4	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00ec7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ecc	50		 push	 eax
  00ecd	e8 00 00 00 00	 call	 _emit_byte
  00ed2	83 c4 08	 add	 esp, 8
  00ed5	85 c0		 test	 eax, eax
  00ed7	74 0c		 je	 SHORT $LN165@emit_hrust
  00ed9	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv517[ebp], 1
  00ee3	eb 0a		 jmp	 SHORT $LN166@emit_hrust
$LN165@emit_hrust:
  00ee5	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv517[ebp], 0
$LN166@emit_hrust:
  00eef	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv517[ebp]
  00ef5	89 4d b0	 mov	 DWORD PTR _success$[ebp], ecx
$LN14@emit_hrust:

; 599  : 			}
; 600  : 		}
; 601  : 		else

  00ef8	eb 26		 jmp	 SHORT $LN59@emit_hrust
$INVALID_CODE_HRUST$2754:

; 602  : 		{
; 603  : INVALID_CODE_HRUST:
; 604  : 			printf("mhmt-emit.c:emit_hrust() - invalid code: length=%d, displacement=%d\n",length,disp);

  00efa	8b f4		 mov	 esi, esp
  00efc	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00eff	50		 push	 eax
  00f00	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00f03	51		 push	 ecx
  00f04	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@
  00f09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00f0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f12	3b f4		 cmp	 esi, esp
  00f14	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 605  : 			return 0;

  00f19	33 c0		 xor	 eax, eax
  00f1b	e9 60 01 00 00	 jmp	 $LN65@emit_hrust
$LN59@emit_hrust:

; 606  : 		}
; 607  : 
; 608  : 		#ifdef DBG
; 609  : 			if( length==(-3) )

  00f20	83 7d ec fd	 cmp	 DWORD PTR _length$[ebp], -3 ; fffffffdH
  00f24	75 23		 jne	 SHORT $LN8@emit_hrust

; 610  : 			{
; 611  : 				printf("insert-match.len=%d,disp=%d\n",(-length),disp);

  00f26	8b f4		 mov	 esi, esp
  00f28	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00f2b	50		 push	 eax
  00f2c	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00f2f	f7 d9		 neg	 ecx
  00f31	51		 push	 ecx
  00f32	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PGKHIFD@insert?9match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
  00f37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00f3d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f40	3b f4		 cmp	 esi, esp
  00f42	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f47	eb 42		 jmp	 SHORT $LN7@emit_hrust
$LN8@emit_hrust:

; 612  : 			}
; 613  : 			else if( disp==0 )

  00f49	83 7d e0 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00f4d	75 1d		 jne	 SHORT $LN6@emit_hrust

; 614  : 			{
; 615  : 				printf("copy.len=%d\n",length);

  00f4f	8b f4		 mov	 esi, esp
  00f51	8b 45 ec	 mov	 eax, DWORD PTR _length$[ebp]
  00f54	50		 push	 eax
  00f55	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LAGBEJNF@copy?4len?$DN?$CFd?6?$AA@
  00f5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00f60	83 c4 08	 add	 esp, 8
  00f63	3b f4		 cmp	 esi, esp
  00f65	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 616  : 			}
; 617  : 			else

  00f6a	eb 1f		 jmp	 SHORT $LN7@emit_hrust
$LN6@emit_hrust:

; 618  : 			{
; 619  : 				printf("match.len=%d,disp=%d\n",length,disp);

  00f6c	8b f4		 mov	 esi, esp
  00f6e	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00f71	50		 push	 eax
  00f72	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00f75	51		 push	 ecx
  00f76	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HDAEJJHJ@match?4len?$DN?$CFd?0disp?$DN?$CFd?6?$AA@
  00f7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00f81	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f84	3b f4		 cmp	 esi, esp
  00f86	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@emit_hrust:

; 620  : 			}
; 621  : 		#endif
; 622  : 
; 623  : 
; 624  : 		if( max_disp > disp ) max_disp = disp;

  00f8b	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  00f8e	3b 45 e0	 cmp	 eax, DWORD PTR _disp$[ebp]
  00f91	7e 06		 jle	 SHORT $LN4@emit_hrust
  00f93	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  00f96	89 45 d4	 mov	 DWORD PTR _max_disp$[ebp], eax
$LN4@emit_hrust:

; 625  : 
; 626  : 		if( length>0 ) // account for negative length

  00f99	83 7d ec 00	 cmp	 DWORD PTR _length$[ebp], 0
  00f9d	7e 0b		 jle	 SHORT $LN3@emit_hrust

; 627  : 			position += length;

  00f9f	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00fa2	03 45 ec	 add	 eax, DWORD PTR _length$[ebp]
  00fa5	89 45 f8	 mov	 DWORD PTR _position$[ebp], eax

; 628  : 		else

  00fa8	eb 09		 jmp	 SHORT $LN2@emit_hrust
$LN3@emit_hrust:

; 629  : 			position -= length;

  00faa	8b 45 f8	 mov	 eax, DWORD PTR _position$[ebp]
  00fad	2b 45 ec	 sub	 eax, DWORD PTR _length$[ebp]
  00fb0	89 45 f8	 mov	 DWORD PTR _position$[ebp], eax
$LN2@emit_hrust:

; 630  : 	}

  00fb3	e9 94 f2 ff ff	 jmp	 $LN62@emit_hrust
$LN61@emit_hrust:

; 631  : 
; 632  : 	// stop-code: %0110_0000_0011_11
; 633  : 	success = success && emit_bits( 0x603C0000, 14 );

  00fb8	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00fbc	74 1f		 je	 SHORT $LN167@emit_hrust
  00fbe	6a 0e		 push	 14			; 0000000eH
  00fc0	68 00 00 3c 60	 push	 1614544896		; 603c0000H
  00fc5	e8 00 00 00 00	 call	 _emit_bits
  00fca	83 c4 08	 add	 esp, 8
  00fcd	85 c0		 test	 eax, eax
  00fcf	74 0c		 je	 SHORT $LN167@emit_hrust
  00fd1	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv541[ebp], 1
  00fdb	eb 0a		 jmp	 SHORT $LN168@emit_hrust
$LN167@emit_hrust:
  00fdd	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv541[ebp], 0
$LN168@emit_hrust:
  00fe7	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv541[ebp]
  00fed	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 634  : 
; 635  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  00ff0	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  00ff4	74 1c		 je	 SHORT $LN169@emit_hrust
  00ff6	6a 00		 push	 0
  00ff8	6a 00		 push	 0
  00ffa	e8 00 00 00 00	 call	 _emit_bits
  00fff	83 c4 08	 add	 esp, 8
  01002	85 c0		 test	 eax, eax
  01004	74 0c		 je	 SHORT $LN169@emit_hrust
  01006	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv547[ebp], 1
  01010	eb 0a		 jmp	 SHORT $LN170@emit_hrust
$LN169@emit_hrust:
  01012	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv547[ebp], 0
$LN170@emit_hrust:
  0101c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv547[ebp]
  01022	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 636  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  01025	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  01029	74 1c		 je	 SHORT $LN171@emit_hrust
  0102b	6a 00		 push	 0
  0102d	6a 00		 push	 0
  0102f	e8 00 00 00 00	 call	 _emit_file
  01034	83 c4 08	 add	 esp, 8
  01037	85 c0		 test	 eax, eax
  01039	74 0c		 je	 SHORT $LN171@emit_hrust
  0103b	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv553[ebp], 1
  01045	eb 0a		 jmp	 SHORT $LN172@emit_hrust
$LN171@emit_hrust:
  01047	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv553[ebp], 0
$LN172@emit_hrust:
  01051	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv553[ebp]
  01057	89 45 b0	 mov	 DWORD PTR _success$[ebp], eax

; 637  : 
; 638  : 	if( success )

  0105a	83 7d b0 00	 cmp	 DWORD PTR _success$[ebp], 0
  0105e	74 1d		 je	 SHORT $LN1@emit_hrust

; 639  : 	{
; 640  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  01060	8b 45 d4	 mov	 eax, DWORD PTR _max_disp$[ebp]
  01063	f7 d8		 neg	 eax
  01065	8b f4		 mov	 esi, esp
  01067	50		 push	 eax
  01068	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  0106d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  01073	83 c4 08	 add	 esp, 8
  01076	3b f4		 cmp	 esi, esp
  01078	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@emit_hrust:

; 641  : 
; 642  : 		// TODO: patch packed length in file, if zx header
; 643  : 	}
; 644  : 
; 645  : 
; 646  : 	return success;

  0107d	8b 45 b0	 mov	 eax, DWORD PTR _success$[ebp]
$LN65@emit_hrust:

; 647  : }

  01080	52		 push	 edx
  01081	8b cd		 mov	 ecx, ebp
  01083	50		 push	 eax
  01084	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN175@emit_hrust
  0108a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0108f	58		 pop	 eax
  01090	5a		 pop	 edx
  01091	5f		 pop	 edi
  01092	5e		 pop	 esi
  01093	5b		 pop	 ebx
  01094	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  0109a	3b ec		 cmp	 ebp, esp
  0109c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010a1	8b e5		 mov	 esp, ebp
  010a3	5d		 pop	 ebp
  010a4	c3		 ret	 0
  010a5	8d 49 00	 npad	 3
$LN175@emit_hrust:
  010a8	01 00 00 00	 DD	 1
  010ac	00 00 00 00	 DD	 $LN174@emit_hrust
$LN174@emit_hrust:
  010b0	a4 ff ff ff	 DD	 -92			; ffffffa4H
  010b4	02 00 00 00	 DD	 2
  010b8	00 00 00 00	 DD	 $LN173@emit_hrust
$LN173@emit_hrust:
  010bc	77		 DB	 119			; 00000077H
  010bd	72		 DB	 114			; 00000072H
  010be	6c		 DB	 108			; 0000006cH
  010bf	65		 DB	 101			; 00000065H
  010c0	6e		 DB	 110			; 0000006eH
  010c1	00		 DB	 0
_emit_hrust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@ ; `string'
PUBLIC	??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@ ; `string'
EXTRN	__imp__fwrite:PROC
_BSS	SEGMENT
?buffer@?1??emit_file@@9@9 DB 01000H DUP (?)		; `emit_file'::`2'::buffer
?position@?1??emit_file@@9@9 DD 01H DUP (?)		; `emit_file'::`2'::position
_BSS	ENDS
;	COMDAT ??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_file() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@
CONST	SEGMENT
??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@ DB 'mhmt'
	DB	'-emit.c:emit_file() can''t write to file!', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _emit_file
_TEXT	SEGMENT
tv82 = -196						; size = 4
_bytes$ = 8						; size = 4
_length$ = 12						; size = 4
_emit_file PROC						; COMDAT

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 684  : 	static UBYTE buffer[EMIT_FILEBUF_SIZE];
; 685  : 
; 686  : 	static ULONG position;
; 687  : 
; 688  : 
; 689  : 	if( length==EMIT_FILE_INIT )

  0001e	83 7d 0c ff	 cmp	 DWORD PTR _length$[ebp], -1
  00022	75 19		 jne	 SHORT $LN15@emit_file

; 690  : 	{
; 691  : 		position = 0;

  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, 0

; 692  : 
; 693  : 		return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	e9 87 01 00 00	 jmp	 $LN16@emit_file
  00038	e9 82 01 00 00	 jmp	 $LN16@emit_file
$LN15@emit_file:

; 694  : 	}
; 695  : 	else if( length>0 )

  0003d	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  00041	0f 8e fe 00 00
	00		 jle	 $LN13@emit_file
$LN12@emit_file:

; 696  : 	{
; 697  : 		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  0004c	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  0004f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00054	0f 82 9f 00 00
	00		 jb	 $LN7@emit_file

; 698  : 		{
; 699  : 			length -= (EMIT_FILEBUF_SIZE-position);

  0005a	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0005f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00068	2b c8		 sub	 ecx, eax
  0006a	89 4d 0c	 mov	 DWORD PTR _length$[ebp], ecx
$LN10@emit_file:

; 700  : 
; 701  : 			while( position < EMIT_FILEBUF_SIZE ) // fill buffer to the end, if possible

  0006d	81 3d 00 00 00
	00 00 10 00 00	 cmp	 DWORD PTR ?position@?1??emit_file@@9@9, 4096 ; 00001000H
  00077	73 28		 jae	 SHORT $LN9@emit_file

; 702  : 			{
; 703  :                                 buffer[position++] = *(bytes++);

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _bytes$[ebp]
  00081	8a 11		 mov	 dl, BYTE PTR [ecx]
  00083	88 90 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_file@@9@9[eax], dl
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  0008e	83 c0 01	 add	 eax, 1
  00091	a3 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, eax
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _bytes$[ebp]
  00099	83 c1 01	 add	 ecx, 1
  0009c	89 4d 08	 mov	 DWORD PTR _bytes$[ebp], ecx

; 704  : 			}

  0009f	eb cc		 jmp	 SHORT $LN10@emit_file
$LN9@emit_file:

; 705  : 
; 706  : 			if( EMIT_FILEBUF_SIZE!=fwrite(buffer, 1, EMIT_FILEBUF_SIZE, wrk.file_out) )

  000a1	8b f4		 mov	 esi, esp
  000a3	a1 2c 00 00 00	 mov	 eax, DWORD PTR _wrk+44
  000a8	50		 push	 eax
  000a9	68 00 10 00 00	 push	 4096			; 00001000H
  000ae	6a 01		 push	 1
  000b0	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_file@@9@9
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000ca	74 1e		 je	 SHORT $LN8@emit_file

; 707  : 			{
; 708  : 				printf("mhmt-emit.c:emit_file() can't write to file!\n");

  000cc	8b f4		 mov	 esi, esp
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000d9	83 c4 04	 add	 esp, 4
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 709  : 				return 0;

  000e3	33 c0		 xor	 eax, eax
  000e5	e9 d5 00 00 00	 jmp	 $LN16@emit_file
$LN8@emit_file:

; 710  : 			}
; 711  : 
; 712  : 			position=0;

  000ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, 0

; 713  : 		}

  000f4	e9 4e ff ff ff	 jmp	 $LN12@emit_file
$LN7@emit_file:

; 714  : 
; 715  : 		while( length-- ) // if something left that does not need flushing

  000f9	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  000fc	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00105	83 e9 01	 sub	 ecx, 1
  00108	89 4d 0c	 mov	 DWORD PTR _length$[ebp], ecx
  0010b	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv82[ebp], 0
  00112	74 28		 je	 SHORT $LN6@emit_file

; 716  : 		{
; 717  : 			buffer[position++] = *(bytes++);

  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _bytes$[ebp]
  0011c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0011e	88 90 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_file@@9@9[eax], dl
  00124	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  00129	83 c0 01	 add	 eax, 1
  0012c	a3 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, eax
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _bytes$[ebp]
  00134	83 c1 01	 add	 ecx, 1
  00137	89 4d 08	 mov	 DWORD PTR _bytes$[ebp], ecx

; 718  : 		}

  0013a	eb bd		 jmp	 SHORT $LN7@emit_file
$LN6@emit_file:

; 719  : 
; 720  : 		return 1;

  0013c	b8 01 00 00 00	 mov	 eax, 1
  00141	eb 7c		 jmp	 SHORT $LN16@emit_file
  00143	eb 7a		 jmp	 SHORT $LN16@emit_file
$LN13@emit_file:

; 721  : 	}
; 722  : 	else if( length==EMIT_FILE_FINISH )

  00145	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  00149	75 5b		 jne	 SHORT $LN4@emit_file

; 723  : 	{
; 724  : 		if( position>0 ) // do we have anything to flush?

  0014b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?position@?1??emit_file@@9@9, 0
  00152	76 49		 jbe	 SHORT $LN3@emit_file

; 725  : 		{
; 726  : 			if( position!=fwrite(buffer, 1, position, wrk.file_out) )

  00154	8b f4		 mov	 esi, esp
  00156	a1 2c 00 00 00	 mov	 eax, DWORD PTR _wrk+44
  0015b	50		 push	 eax
  0015c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?position@?1??emit_file@@9@9
  00162	51		 push	 ecx
  00163	6a 01		 push	 1
  00165	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_file@@9@9
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00170	83 c4 10	 add	 esp, 16			; 00000010H
  00173	3b f4		 cmp	 esi, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?position@?1??emit_file@@9@9, eax
  00180	74 1b		 je	 SHORT $LN3@emit_file

; 727  : 			{
; 728  : 				printf("mhmt-emit.c:emit_file() can't write to file!\n");

  00182	8b f4		 mov	 esi, esp
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0018f	83 c4 04	 add	 esp, 4
  00192	3b f4		 cmp	 esi, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 729  : 				return 0;

  00199	33 c0		 xor	 eax, eax
  0019b	eb 22		 jmp	 SHORT $LN16@emit_file
$LN3@emit_file:

; 730  : 			}
; 731  : 		}
; 732  : 
; 733  : 		return 1;

  0019d	b8 01 00 00 00	 mov	 eax, 1
  001a2	eb 1b		 jmp	 SHORT $LN16@emit_file

; 734  : 	}
; 735  : 	else

  001a4	eb 19		 jmp	 SHORT $LN16@emit_file
$LN4@emit_file:

; 736  : 	{
; 737  : 		printf("mhmt-emit.c:emit_file() encountered invalid arguments!\n");

  001a6	8b f4		 mov	 esi, esp
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001b3	83 c4 04	 add	 esp, 4
  001b6	3b f4		 cmp	 esi, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 738  : 		return 0;

  001bd	33 c0		 xor	 eax, eax
$LN16@emit_file:

; 739  : 	}
; 740  : }

  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  001c8	3b ec		 cmp	 ebp, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
_emit_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@ ; `string'
PUBLIC	??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@ ; `string'
PUBLIC	??_C@_06LKBFNBBL@?$DM?$CF02x?$DO?$AA@		; `string'
_BSS	SEGMENT
?buffer@?1??emit_byte@@9@9 DB 0100H DUP (?)		; `emit_byte'::`2'::buffer
?out_pos@?1??emit_byte@@9@9 DD 01H DUP (?)		; `emit_byte'::`2'::out_pos
?in_pos@?1??emit_byte@@9@9 DD 01H DUP (?)		; `emit_byte'::`2'::in_pos
_BSS	ENDS
;	COMDAT ??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_byte() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@
CONST	SEGMENT
??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@ DB 'mhmt-'
	DB	'emit.c:emit_byte() buffer overflow!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LKBFNBBL@?$DM?$CF02x?$DO?$AA@
CONST	SEGMENT
??_C@_06LKBFNBBL@?$DM?$CF02x?$DO?$AA@ DB '<%02x>', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _emit_byte
_TEXT	SEGMENT
tv92 = -208						; size = 4
tv64 = -208						; size = 4
_success$ = -8						; size = 4
_byte$ = 8						; size = 1
_operation$ = 12					; size = 4
_emit_byte PROC						; COMDAT

; 748  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 749  : 	static UBYTE buffer[EMIT_BYTEBUF_SIZE];
; 750  : 
; 751  : 	static ULONG in_pos, out_pos;
; 752  : 
; 753  : 	ULONG success;
; 754  : 
; 755  : 
; 756  : 	switch( operation )

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _operation$[ebp]
  00021	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00027	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR tv64[ebp], 0
  0002e	74 1b		 je	 SHORT $LN10@emit_byte
  00030	83 bd 30 ff ff
	ff 01		 cmp	 DWORD PTR tv64[ebp], 1
  00037	0f 84 a2 00 00
	00		 je	 $LN7@emit_byte
  0003d	83 bd 30 ff ff
	ff 02		 cmp	 DWORD PTR tv64[ebp], 2
  00044	74 23		 je	 SHORT $LN9@emit_byte
  00046	e9 5b 01 00 00	 jmp	 $LN1@emit_byte
$LN10@emit_byte:

; 757  : 	{
; 758  : 	case EMIT_BYTE_INIT:
; 759  : 
; 760  : 		in_pos  = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, 0

; 761  : 		out_pos = 0;

  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, 0

; 762  : 
; 763  : 		return 1;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	e9 56 01 00 00	 jmp	 $LN13@emit_byte
$LN9@emit_byte:

; 764  : 
; 765  : 
; 766  : 	case EMIT_BYTE_ADD:
; 767  : 
; 768  : 		#ifdef DBG
; 769  : 			printf("<%02x>",byte&0x00FF);

  00069	0f b6 45 08	 movzx	 eax, BYTE PTR _byte$[ebp]
  0006d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00072	8b f4		 mov	 esi, esp
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_06LKBFNBBL@?$DM?$CF02x?$DO?$AA@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00080	83 c4 08	 add	 esp, 8
  00083	3b f4		 cmp	 esi, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 770  : 		#endif
; 771  : 
; 772  : 		buffer[in_pos] = byte;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  0008f	8a 4d 08	 mov	 cl, BYTE PTR _byte$[ebp]
  00092	88 88 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_byte@@9@9[eax], cl

; 773  : 
; 774  : 		in_pos = (in_pos+1) & (EMIT_BYTEBUF_SIZE-1);

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  0009d	83 c0 01	 add	 eax, 1
  000a0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a5	a3 00 00 00 00	 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, eax

; 775  : 
; 776  : 
; 777  : 		if( in_pos==out_pos ) // overflow!

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  000af	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  000b5	75 1e		 jne	 SHORT $LN8@emit_byte

; 778  : 		{
; 779  : 			printf("mhmt-emit.c:emit_byte() buffer overflow!\n");

  000b7	8b f4		 mov	 esi, esp
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 780  : 			return 0;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 ea 00 00 00	 jmp	 $LN13@emit_byte
$LN8@emit_byte:

; 781  : 		}
; 782  : 
; 783  : 		return 1;

  000d5	b8 01 00 00 00	 mov	 eax, 1
  000da	e9 e0 00 00 00	 jmp	 $LN13@emit_byte
$LN7@emit_byte:

; 784  : 
; 785  : 
; 786  : 	case EMIT_BYTE_FLUSH:
; 787  : 
; 788  : 		if( in_pos==out_pos ) // nothing to do?

  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  000e4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  000ea	75 0f		 jne	 SHORT $LN6@emit_byte

; 789  : 			return 1;

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	e9 c9 00 00 00	 jmp	 $LN13@emit_byte
  000f6	e9 9c 00 00 00	 jmp	 $LN5@emit_byte
$LN6@emit_byte:

; 790  : 		else if( in_pos>out_pos ) // no index wraparound

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  00100	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00106	76 26		 jbe	 SHORT $LN4@emit_byte

; 791  : 		{
; 792  : 			success = emit_file( &buffer[out_pos], in_pos-out_pos );

  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  0010d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00113	50		 push	 eax
  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  0011a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?buffer@?1??emit_byte@@9@9
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 _emit_file
  00126	83 c4 08	 add	 esp, 8
  00129	89 45 f8	 mov	 DWORD PTR _success$[ebp], eax

; 793  : 		}
; 794  : 		else // in_pos<out_pos - wraparound

  0012c	eb 69		 jmp	 SHORT $LN5@emit_byte
$LN4@emit_byte:

; 795  : 		{
; 796  : 			success = emit_file( &buffer[out_pos], EMIT_BYTEBUF_SIZE-out_pos );

  0012e	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00133	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00139	50		 push	 eax
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00140	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?buffer@?1??emit_byte@@9@9
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 _emit_file
  0014c	83 c4 08	 add	 esp, 8
  0014f	89 45 f8	 mov	 DWORD PTR _success$[ebp], eax

; 797  : 
; 798  : 			if( in_pos )

  00152	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, 0
  00159	74 3c		 je	 SHORT $LN5@emit_byte

; 799  : 				success = success && emit_file( &buffer[0], in_pos );

  0015b	83 7d f8 00	 cmp	 DWORD PTR _success$[ebp], 0
  0015f	74 23		 je	 SHORT $LN15@emit_byte
  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  00166	50		 push	 eax
  00167	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_byte@@9@9
  0016c	e8 00 00 00 00	 call	 _emit_file
  00171	83 c4 08	 add	 esp, 8
  00174	85 c0		 test	 eax, eax
  00176	74 0c		 je	 SHORT $LN15@emit_byte
  00178	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv92[ebp], 1
  00182	eb 0a		 jmp	 SHORT $LN16@emit_byte
$LN15@emit_byte:
  00184	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN16@emit_byte:
  0018e	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  00194	89 4d f8	 mov	 DWORD PTR _success$[ebp], ecx
$LN5@emit_byte:

; 800  : 		}
; 801  : 
; 802  : 		out_pos=in_pos;

  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  0019c	a3 00 00 00 00	 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, eax

; 803  : 		return success;

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _success$[ebp]
  001a4	eb 19		 jmp	 SHORT $LN13@emit_byte
$LN1@emit_byte:

; 804  : 
; 805  : 	default:
; 806  : 		printf("mhmt-emit.c:emit_byte() encountered invalid arguments!\n");

  001a6	8b f4		 mov	 esi, esp
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001b3	83 c4 04	 add	 esp, 4
  001b6	3b f4		 cmp	 esi, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 807  : 		return 0;

  001bd	33 c0		 xor	 eax, eax
$LN13@emit_byte:

; 808  : 	}
; 809  : }

  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  001c8	3b ec		 cmp	 ebp, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
_emit_byte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_emit_bits_flush
_BSS	SEGMENT
?bit_count@?1??emit_bits@@9@9 DD 01H DUP (?)		; `emit_bits'::`2'::bit_count
?bit_store@?1??emit_bits@@9@9 DD 01H DUP (?)		; `emit_bits'::`2'::bit_store
_BSS	ENDS
;	COMDAT ??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_bits() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _emit_bits
_TEXT	SEGMENT
tv153 = -220						; size = 4
tv147 = -220						; size = 4
tv130 = -220						; size = 4
tv92 = -220						; size = 4
tv84 = -220						; size = 4
tv78 = -220						; size = 4
tv71 = -220						; size = 4
_success$ = -20						; size = 4
_max_bits$ = -8						; size = 4
_msb_aligned_bits$ = 8					; size = 4
_length$ = 12						; size = 4
_emit_bits PROC						; COMDAT

; 816  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 817  : 	static ULONG bit_store;
; 818  : 	static ULONG bit_count;
; 819  : 
; 820  : 	ULONG max_bits;
; 821  : 
; 822  : 	ULONG success = 1;

  0001e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 823  : 
; 824  : 
; 825  : 	max_bits = wrk.wordbit ? 16 : 8;

  00025	33 c0		 xor	 eax, eax
  00027	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  0002e	0f 95 c0	 setne	 al
  00031	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  00038	89 45 f8	 mov	 DWORD PTR _max_bits$[ebp], eax

; 826  : 
; 827  : 	if( length==EMIT_BITS_INIT )

  0003b	83 7d 0c ff	 cmp	 DWORD PTR _length$[ebp], -1
  0003f	75 23		 jne	 SHORT $LN16@emit_bits

; 828  : 	{
; 829  : 		bit_store = 0;

  00041	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, 0

; 830  : 		bit_count = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0

; 831  : 		return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	e9 79 02 00 00	 jmp	 $LN17@emit_bits
  0005f	e9 74 02 00 00	 jmp	 $LN17@emit_bits
$LN16@emit_bits:

; 832  : 	}
; 833  : 	else if( length==EMIT_BITS_FINISH )

  00064	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  00068	0f 85 ca 00 00
	00		 jne	 $LN14@emit_bits

; 834  : 	{
; 835  : 		if( bit_count ) // some bits to flush

  0006e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0
  00075	74 7f		 je	 SHORT $LN13@emit_bits
$LN12@emit_bits:

; 836  : 		{
; 837  : 			while( (bit_count++)<max_bits )

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _max_bits$[ebp]
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  00085	83 c2 01	 add	 edx, 1
  00088	89 15 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, edx
  0008e	3b c1		 cmp	 eax, ecx
  00090	73 0c		 jae	 SHORT $LN19@emit_bits
  00092	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  0009c	eb 0a		 jmp	 SHORT $LN20@emit_bits
$LN19@emit_bits:
  0009e	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN20@emit_bits:
  000a8	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv71[ebp], 0
  000af	74 0e		 je	 SHORT $LN11@emit_bits

; 838  : 				bit_store <<= 1;

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  000b6	d1 e0		 shl	 eax, 1
  000b8	a3 00 00 00 00	 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, eax
  000bd	eb b8		 jmp	 SHORT $LN12@emit_bits
$LN11@emit_bits:

; 839  : 
; 840  : 			success = success && emit_bits_flush(bit_store);

  000bf	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  000c3	74 1e		 je	 SHORT $LN21@emit_bits
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _emit_bits_flush
  000d0	83 c4 04	 add	 esp, 4
  000d3	85 c0		 test	 eax, eax
  000d5	74 0c		 je	 SHORT $LN21@emit_bits
  000d7	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
  000e1	eb 0a		 jmp	 SHORT $LN22@emit_bits
$LN21@emit_bits:
  000e3	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN22@emit_bits:
  000ed	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  000f3	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx
$LN13@emit_bits:

; 841  : 		}
; 842  : 
; 843  : 		success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  000f6	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  000fa	74 1c		 je	 SHORT $LN23@emit_bits
  000fc	6a 01		 push	 1
  000fe	6a 00		 push	 0
  00100	e8 00 00 00 00	 call	 _emit_byte
  00105	83 c4 08	 add	 esp, 8
  00108	85 c0		 test	 eax, eax
  0010a	74 0c		 je	 SHORT $LN23@emit_bits
  0010c	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  00116	eb 0a		 jmp	 SHORT $LN24@emit_bits
$LN23@emit_bits:
  00118	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN24@emit_bits:
  00122	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  00128	89 45 ec	 mov	 DWORD PTR _success$[ebp], eax

; 844  : 
; 845  : 		return success;

  0012b	8b 45 ec	 mov	 eax, DWORD PTR _success$[ebp]
  0012e	e9 a5 01 00 00	 jmp	 $LN17@emit_bits
  00133	e9 a0 01 00 00	 jmp	 $LN17@emit_bits
$LN14@emit_bits:

; 846  : 	}
; 847  : 	else if( length>0 ) // add bits

  00138	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  0013c	0f 8e 7d 01 00
	00		 jle	 $LN9@emit_bits
$LN8@emit_bits:

; 848  : 	{
; 849  : 		do
; 850  : 		{
; 851  : 			if( !wrk.fullbits ) // empty bits - check for flushing before shiftin

  00142	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  00149	0f 85 80 00 00
	00		 jne	 $LN5@emit_bits

; 852  : 			{
; 853  : 				if( bit_count==max_bits )

  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  00154	3b 45 f8	 cmp	 eax, DWORD PTR _max_bits$[ebp]
  00157	75 76		 jne	 SHORT $LN5@emit_bits

; 854  : 				{
; 855  : 					success = success && emit_bits_flush(bit_store);

  00159	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  0015d	74 1e		 je	 SHORT $LN25@emit_bits
  0015f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _emit_bits_flush
  0016a	83 c4 04	 add	 esp, 4
  0016d	85 c0		 test	 eax, eax
  0016f	74 0c		 je	 SHORT $LN25@emit_bits
  00171	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv92[ebp], 1
  0017b	eb 0a		 jmp	 SHORT $LN26@emit_bits
$LN25@emit_bits:
  0017d	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN26@emit_bits:
  00187	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  0018d	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx

; 856  : 					success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  00190	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  00194	74 1c		 je	 SHORT $LN27@emit_bits
  00196	6a 01		 push	 1
  00198	6a 00		 push	 0
  0019a	e8 00 00 00 00	 call	 _emit_byte
  0019f	83 c4 08	 add	 esp, 8
  001a2	85 c0		 test	 eax, eax
  001a4	74 0c		 je	 SHORT $LN27@emit_bits
  001a6	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv130[ebp], 1
  001b0	eb 0a		 jmp	 SHORT $LN28@emit_bits
$LN27@emit_bits:
  001b2	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
$LN28@emit_bits:
  001bc	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  001c2	89 45 ec	 mov	 DWORD PTR _success$[ebp], eax

; 857  : 
; 858  : 					bit_count = 0;

  001c5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0
$LN5@emit_bits:

; 859  : 				}
; 860  : 			}
; 861  : 
; 862  : 			#ifdef DBG
; 863  : 				printf("%d",1&(msb_aligned_bits>>31));

  001cf	8b 45 08	 mov	 eax, DWORD PTR _msb_aligned_bits$[ebp]
  001d2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001d5	83 e0 01	 and	 eax, 1
  001d8	8b f4		 mov	 esi, esp
  001da	50		 push	 eax
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001e6	83 c4 08	 add	 esp, 8
  001e9	3b f4		 cmp	 esi, esp
  001eb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 864  : 			#endif
; 865  : 			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );

  001f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  001f5	d1 e0		 shl	 eax, 1
  001f7	8b 4d 08	 mov	 ecx, DWORD PTR _msb_aligned_bits$[ebp]
  001fa	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001fd	83 e1 01	 and	 ecx, 1
  00200	0b c1		 or	 eax, ecx
  00202	a3 00 00 00 00	 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, eax

; 866  : 			msb_aligned_bits <<= 1;

  00207	8b 45 08	 mov	 eax, DWORD PTR _msb_aligned_bits$[ebp]
  0020a	d1 e0		 shl	 eax, 1
  0020c	89 45 08	 mov	 DWORD PTR _msb_aligned_bits$[ebp], eax

; 867  : 			bit_count++;

  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  00214	83 c0 01	 add	 eax, 1
  00217	a3 00 00 00 00	 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, eax

; 868  : 
; 869  : 			if( wrk.fullbits ) // full bits - check for flushing after bit shiftin

  0021c	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  00223	0f 84 80 00 00
	00		 je	 $LN7@emit_bits

; 870  : 			{
; 871  : 				if( bit_count==max_bits )

  00229	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  0022e	3b 45 f8	 cmp	 eax, DWORD PTR _max_bits$[ebp]
  00231	75 76		 jne	 SHORT $LN7@emit_bits

; 872  : 				{
; 873  : 					success = success && emit_bits_flush(bit_store);

  00233	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  00237	74 1e		 je	 SHORT $LN29@emit_bits
  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 _emit_bits_flush
  00244	83 c4 04	 add	 esp, 4
  00247	85 c0		 test	 eax, eax
  00249	74 0c		 je	 SHORT $LN29@emit_bits
  0024b	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv147[ebp], 1
  00255	eb 0a		 jmp	 SHORT $LN30@emit_bits
$LN29@emit_bits:
  00257	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
$LN30@emit_bits:
  00261	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv147[ebp]
  00267	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx

; 874  : 					success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  0026a	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  0026e	74 1c		 je	 SHORT $LN31@emit_bits
  00270	6a 01		 push	 1
  00272	6a 00		 push	 0
  00274	e8 00 00 00 00	 call	 _emit_byte
  00279	83 c4 08	 add	 esp, 8
  0027c	85 c0		 test	 eax, eax
  0027e	74 0c		 je	 SHORT $LN31@emit_bits
  00280	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  0028a	eb 0a		 jmp	 SHORT $LN32@emit_bits
$LN31@emit_bits:
  0028c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN32@emit_bits:
  00296	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  0029c	89 45 ec	 mov	 DWORD PTR _success$[ebp], eax

; 875  : 
; 876  : 					bit_count = 0;

  0029f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0
$LN7@emit_bits:

; 877  : 				}
; 878  : 			}
; 879  : 
; 880  : 		} while( --length );

  002a9	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  002ac	83 e8 01	 sub	 eax, 1
  002af	89 45 0c	 mov	 DWORD PTR _length$[ebp], eax
  002b2	0f 85 8a fe ff
	ff		 jne	 $LN8@emit_bits

; 881  : 
; 882  : 		return success;

  002b8	8b 45 ec	 mov	 eax, DWORD PTR _success$[ebp]
  002bb	eb 1b		 jmp	 SHORT $LN17@emit_bits

; 883  : 	}
; 884  : 	else

  002bd	eb 19		 jmp	 SHORT $LN17@emit_bits
$LN9@emit_bits:

; 885  : 	{
; 886  : 		printf("mhmt-emit.c:emit_bits() encountered invalid arguments!\n");

  002bf	8b f4		 mov	 esi, esp
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@
  002c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002cc	83 c4 04	 add	 esp, 4
  002cf	3b f4		 cmp	 esi, esp
  002d1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 887  : 		return 0;

  002d6	33 c0		 xor	 eax, eax
$LN17@emit_bits:

; 888  : 	}
; 889  : }

  002d8	5f		 pop	 edi
  002d9	5e		 pop	 esi
  002da	5b		 pop	 ebx
  002db	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  002e1	3b ec		 cmp	 ebp, esp
  002e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c3		 ret	 0
_emit_bits ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _emit_bits_flush
_TEXT	SEGMENT
tv139 = -220						; size = 4
tv131 = -220						; size = 4
tv90 = -220						; size = 4
tv82 = -220						; size = 4
tv74 = -220						; size = 4
_success$ = -20						; size = 4
_store_byte$ = -5					; size = 1
_bits$ = 8						; size = 4
_emit_bits_flush PROC					; COMDAT

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 895  : 	UBYTE store_byte;
; 896  : 
; 897  : 	ULONG success = 1;

  0001e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 898  : 
; 899  : 	if( wrk.wordbit ) // 16bits

  00025	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  0002c	0f 84 22 01 00
	00		 je	 $LN4@emit_bits_

; 900  : 	{
; 901  : 		if( wrk.bigend ) // big endian

  00032	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _wrk+20, 0
  00039	0f 84 8c 00 00
	00		 je	 $LN3@emit_bits_

; 902  : 		{
; 903  : 			store_byte = 0x00FF & (bits >> 8);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  00042	c1 e8 08	 shr	 eax, 8
  00045	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004a	88 45 fb	 mov	 BYTE PTR _store_byte$[ebp], al

; 904  : 			success = success && emit_file( &store_byte, 1);

  0004d	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  00051	74 1e		 je	 SHORT $LN7@emit_bits_
  00053	6a 01		 push	 1
  00055	8d 45 fb	 lea	 eax, DWORD PTR _store_byte$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _emit_file
  0005e	83 c4 08	 add	 esp, 8
  00061	85 c0		 test	 eax, eax
  00063	74 0c		 je	 SHORT $LN7@emit_bits_
  00065	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
  0006f	eb 0a		 jmp	 SHORT $LN8@emit_bits_
$LN7@emit_bits_:
  00071	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN8@emit_bits_:
  0007b	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00081	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx

; 905  : 
; 906  : 			store_byte = 0x00FF & bits;

  00084	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  00087	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008c	88 45 fb	 mov	 BYTE PTR _store_byte$[ebp], al

; 907  : 			success = success && emit_file( &store_byte, 1);

  0008f	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  00093	74 1e		 je	 SHORT $LN9@emit_bits_
  00095	6a 01		 push	 1
  00097	8d 45 fb	 lea	 eax, DWORD PTR _store_byte$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _emit_file
  000a0	83 c4 08	 add	 esp, 8
  000a3	85 c0		 test	 eax, eax
  000a5	74 0c		 je	 SHORT $LN9@emit_bits_
  000a7	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv82[ebp], 1
  000b1	eb 0a		 jmp	 SHORT $LN10@emit_bits_
$LN9@emit_bits_:
  000b3	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
$LN10@emit_bits_:
  000bd	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  000c3	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx

; 908  : 		}
; 909  : 		else // little endian

  000c6	e9 87 00 00 00	 jmp	 $LN2@emit_bits_
$LN3@emit_bits_:

; 910  : 		{
; 911  : 			store_byte = 0x00FF & bits;

  000cb	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  000ce	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d3	88 45 fb	 mov	 BYTE PTR _store_byte$[ebp], al

; 912  : 			success = success && emit_file( &store_byte, 1);

  000d6	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  000da	74 1e		 je	 SHORT $LN11@emit_bits_
  000dc	6a 01		 push	 1
  000de	8d 45 fb	 lea	 eax, DWORD PTR _store_byte$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _emit_file
  000e7	83 c4 08	 add	 esp, 8
  000ea	85 c0		 test	 eax, eax
  000ec	74 0c		 je	 SHORT $LN11@emit_bits_
  000ee	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv90[ebp], 1
  000f8	eb 0a		 jmp	 SHORT $LN12@emit_bits_
$LN11@emit_bits_:
  000fa	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$LN12@emit_bits_:
  00104	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  0010a	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx

; 913  : 
; 914  : 			store_byte = 0x00FF & (bits >> 8);

  0010d	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  00110	c1 e8 08	 shr	 eax, 8
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	88 45 fb	 mov	 BYTE PTR _store_byte$[ebp], al

; 915  : 			success = success && emit_file( &store_byte, 1);

  0011b	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  0011f	74 1e		 je	 SHORT $LN13@emit_bits_
  00121	6a 01		 push	 1
  00123	8d 45 fb	 lea	 eax, DWORD PTR _store_byte$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _emit_file
  0012c	83 c4 08	 add	 esp, 8
  0012f	85 c0		 test	 eax, eax
  00131	74 0c		 je	 SHORT $LN13@emit_bits_
  00133	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv131[ebp], 1
  0013d	eb 0a		 jmp	 SHORT $LN14@emit_bits_
$LN13@emit_bits_:
  0013f	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
$LN14@emit_bits_:
  00149	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv131[ebp]
  0014f	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx
$LN2@emit_bits_:

; 916  : 		}
; 917  : 	}
; 918  : 	else // 8bits

  00152	eb 42		 jmp	 SHORT $LN1@emit_bits_
$LN4@emit_bits_:

; 919  : 	{
; 920  : 		store_byte = 0x00FF & bits;

  00154	8b 45 08	 mov	 eax, DWORD PTR _bits$[ebp]
  00157	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0015c	88 45 fb	 mov	 BYTE PTR _store_byte$[ebp], al

; 921  : 		success = success && emit_file( &store_byte, 1);

  0015f	83 7d ec 00	 cmp	 DWORD PTR _success$[ebp], 0
  00163	74 1e		 je	 SHORT $LN15@emit_bits_
  00165	6a 01		 push	 1
  00167	8d 45 fb	 lea	 eax, DWORD PTR _store_byte$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _emit_file
  00170	83 c4 08	 add	 esp, 8
  00173	85 c0		 test	 eax, eax
  00175	74 0c		 je	 SHORT $LN15@emit_bits_
  00177	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv139[ebp], 1
  00181	eb 0a		 jmp	 SHORT $LN16@emit_bits_
$LN15@emit_bits_:
  00183	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
$LN16@emit_bits_:
  0018d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  00193	89 4d ec	 mov	 DWORD PTR _success$[ebp], ecx
$LN1@emit_bits_:

; 922  : 	}
; 923  : 
; 924  : 	return success;

  00196	8b 45 ec	 mov	 eax, DWORD PTR _success$[ebp]

; 925  : }

  00199	52		 push	 edx
  0019a	8b cd		 mov	 ecx, ebp
  0019c	50		 push	 eax
  0019d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@emit_bits_
  001a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a8	58		 pop	 eax
  001a9	5a		 pop	 edx
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5b		 pop	 ebx
  001ad	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  001b3	3b ec		 cmp	 ebp, esp
  001b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
  001be	8b ff		 npad	 2
$LN19@emit_bits_:
  001c0	01 00 00 00	 DD	 1
  001c4	00 00 00 00	 DD	 $LN18@emit_bits_
$LN18@emit_bits_:
  001c8	fb ff ff ff	 DD	 -5			; fffffffbH
  001cc	01 00 00 00	 DD	 1
  001d0	00 00 00 00	 DD	 $LN17@emit_bits_
$LN17@emit_bits_:
  001d4	73		 DB	 115			; 00000073H
  001d5	74		 DB	 116			; 00000074H
  001d6	6f		 DB	 111			; 0000006fH
  001d7	72		 DB	 114			; 00000072H
  001d8	65		 DB	 101			; 00000065H
  001d9	5f		 DB	 95			; 0000005fH
  001da	62		 DB	 98			; 00000062H
  001db	79		 DB	 121			; 00000079H
  001dc	74		 DB	 116			; 00000074H
  001dd	65		 DB	 101			; 00000065H
  001de	00		 DB	 0
_emit_bits_flush ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-globals.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_wrk:BYTE:038H
_DATA	ENDS
PUBLIC	_init_globals
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\d\mhmt\src\mhmt-globals.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _init_globals
_TEXT	SEGMENT
_init_globals PROC					; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 11   : 	wrk.packtype = PK_MLZ;

  0001e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk, 1

; 12   : 	wrk.greedy   = 0;

  00028	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+4, 0

; 13   : 	wrk.mode     = 0;

  00032	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+8, 0

; 14   : 	wrk.zxheader = 0;

  0003c	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+12, 0

; 15   : 	wrk.wordbit  = 0;

  00046	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+16, 0

; 16   : 	wrk.bigend   = 0;

  00050	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+20, 0

; 17   : 	wrk.fullbits = 0;

  0005a	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+24, 0

; 18   : 	wrk.maxwin   = 4352;

  00064	c7 05 1c 00 00
	00 00 11 00 00	 mov	 DWORD PTR _wrk+28, 4352	; 00001100H

; 19   : 
; 20   : 	wrk.fname_in  = NULL;

  0006e	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+32, 0

; 21   : 	wrk.fname_out = NULL;

  00078	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+36, 0

; 22   : 
; 23   : 	wrk.file_in  = NULL;

  00082	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+40, 0

; 24   : 	wrk.file_out = NULL;

  0008c	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+44, 0

; 25   : 
; 26   : 	wrk.indata = NULL;

  00096	c7 05 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+48, 0

; 27   : 	wrk.inlen = 0;

  000a0	c7 05 34 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+52, 0

; 28   : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_init_globals ENDP
_TEXT	ENDS
PUBLIC	_free_globals
EXTRN	__imp__fclose:PROC
EXTRN	__imp__free:PROC
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _free_globals
_TEXT	SEGMENT
_free_globals PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 35   : 	if( wrk.indata ) free( wrk.indata );

  0001e	83 3d 30 00 00
	00 00		 cmp	 DWORD PTR _wrk+48, 0
  00025	74 18		 je	 SHORT $LN5@free_globa
  00027	8b f4		 mov	 esi, esp
  00029	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00035	83 c4 04	 add	 esp, 4
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@free_globa:

; 36   : 
; 37   : 	if( wrk.file_out ) fclose( wrk.file_out );

  0003f	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR _wrk+44, 0
  00046	74 18		 je	 SHORT $LN4@free_globa
  00048	8b f4		 mov	 esi, esp
  0004a	a1 2c 00 00 00	 mov	 eax, DWORD PTR _wrk+44
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00056	83 c4 04	 add	 esp, 4
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@free_globa:

; 38   : 	if( wrk.file_in )  fclose( wrk.file_in );

  00060	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR _wrk+40, 0
  00067	74 18		 je	 SHORT $LN3@free_globa
  00069	8b f4		 mov	 esi, esp
  0006b	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00077	83 c4 04	 add	 esp, 4
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@free_globa:

; 39   : 
; 40   : 	if( wrk.fname_out ) free( wrk.fname_out );

  00081	83 3d 24 00 00
	00 00		 cmp	 DWORD PTR _wrk+36, 0
  00088	74 18		 je	 SHORT $LN2@free_globa
  0008a	8b f4		 mov	 esi, esp
  0008c	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00098	83 c4 04	 add	 esp, 4
  0009b	3b f4		 cmp	 esi, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@free_globa:

; 41   : 	if( wrk.fname_in )  free( wrk.fname_in );

  000a2	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR _wrk+32, 0
  000a9	74 18		 je	 SHORT $LN6@free_globa
  000ab	8b f4		 mov	 esi, esp
  000ad	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b9	83 c4 04	 add	 esp, 4
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@free_globa:

; 42   : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_free_globals ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_build_hash
EXTRN	__imp__malloc:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\d\mhmt\src\mhmt-hash.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _build_hash
_TEXT	SEGMENT
_prev2$ = -77						; size = 1
_prev$ = -65						; size = 1
_curr$ = -53						; size = 1
_dst$ = -44						; size = 4
_src$ = -32						; size = 4
_i$ = -20						; size = 4
_hash$ = -8						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_build_hash PROC					; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 11   : 	UBYTE * hash;
; 12   : 
; 13   : 	ULONG i; UBYTE *src,*dst;
; 14   : 	UBYTE curr,prev,prev2;
; 15   : 
; 16   : 	if( !length )

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  00022	75 07		 jne	 SHORT $LN5@build_hash

; 17   : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 a0 00 00 00	 jmp	 $LN6@build_hash
$LN5@build_hash:

; 18   : 
; 19   : 	hash=(UBYTE *)malloc( length );

  0002b	8b f4		 mov	 esi, esp
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00037	83 c4 04	 add	 esp, 4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	89 45 f8	 mov	 DWORD PTR _hash$[ebp], eax

; 20   :         if( !hash )

  00044	83 7d f8 00	 cmp	 DWORD PTR _hash$[ebp], 0
  00048	75 04		 jne	 SHORT $LN4@build_hash

; 21   :         	return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 7d		 jmp	 SHORT $LN6@build_hash
$LN4@build_hash:

; 22   : 
; 23   : 
; 24   : 	prev=curr=0;

  0004e	c6 45 cb 00	 mov	 BYTE PTR _curr$[ebp], 0
  00052	8a 45 cb	 mov	 al, BYTE PTR _curr$[ebp]
  00055	88 45 bf	 mov	 BYTE PTR _prev$[ebp], al

; 25   : 	i=length;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 26   : 	src = data;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR _src$[ebp], eax

; 27   : 	dst = hash;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _hash$[ebp]
  00067	89 45 d4	 mov	 DWORD PTR _dst$[ebp], eax
$LN3@build_hash:

; 28   : 
; 29   : 	do
; 30   : 	{
; 31   : 		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );

  0006a	0f b6 45 bf	 movzx	 eax, BYTE PTR _prev$[ebp]
  0006e	d1 f8		 sar	 eax, 1
  00070	0f b6 4d bf	 movzx	 ecx, BYTE PTR _prev$[ebp]
  00074	c1 e1 07	 shl	 ecx, 7
  00077	0b c1		 or	 eax, ecx
  00079	88 45 b3	 mov	 BYTE PTR _prev2$[ebp], al

; 32   : 		prev  = (UBYTE)( (curr>>1) | (curr<<7) );

  0007c	0f b6 45 cb	 movzx	 eax, BYTE PTR _curr$[ebp]
  00080	d1 f8		 sar	 eax, 1
  00082	0f b6 4d cb	 movzx	 ecx, BYTE PTR _curr$[ebp]
  00086	c1 e1 07	 shl	 ecx, 7
  00089	0b c1		 or	 eax, ecx
  0008b	88 45 bf	 mov	 BYTE PTR _prev$[ebp], al

; 33   : 		curr  = *(src++);

  0008e	8b 45 e0	 mov	 eax, DWORD PTR _src$[ebp]
  00091	8a 08		 mov	 cl, BYTE PTR [eax]
  00093	88 4d cb	 mov	 BYTE PTR _curr$[ebp], cl
  00096	8b 55 e0	 mov	 edx, DWORD PTR _src$[ebp]
  00099	83 c2 01	 add	 edx, 1
  0009c	89 55 e0	 mov	 DWORD PTR _src$[ebp], edx

; 34   : 
; 35   : 		*(dst++) = curr^prev^prev2;

  0009f	0f b6 45 cb	 movzx	 eax, BYTE PTR _curr$[ebp]
  000a3	0f b6 4d bf	 movzx	 ecx, BYTE PTR _prev$[ebp]
  000a7	33 c1		 xor	 eax, ecx
  000a9	0f b6 55 b3	 movzx	 edx, BYTE PTR _prev2$[ebp]
  000ad	33 c2		 xor	 eax, edx
  000af	8b 4d d4	 mov	 ecx, DWORD PTR _dst$[ebp]
  000b2	88 01		 mov	 BYTE PTR [ecx], al
  000b4	8b 55 d4	 mov	 edx, DWORD PTR _dst$[ebp]
  000b7	83 c2 01	 add	 edx, 1
  000ba	89 55 d4	 mov	 DWORD PTR _dst$[ebp], edx

; 36   : 
; 37   : 	} while( --i );

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	83 e8 01	 sub	 eax, 1
  000c3	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  000c6	75 a2		 jne	 SHORT $LN3@build_hash

; 38   : 
; 39   : 
; 40   : 
; 41   : 	return hash;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _hash$[ebp]
$LN6@build_hash:

; 42   : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_build_hash ENDP
_TEXT	ENDS
PUBLIC	_destroy_hash
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _destroy_hash
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_destroy_hash PROC					; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 49   : 	if( hash ) free(hash);

  0001e	83 7d 08 00	 cmp	 DWORD PTR _hash$[ebp], 0
  00022	74 16		 je	 SHORT $LN2@destroy_ha
  00024	8b f4		 mov	 esi, esp
  00026	8b 45 08	 mov	 eax, DWORD PTR _hash$[ebp]
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00030	83 c4 04	 add	 esp, 4
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@destroy_ha:

; 50   : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_destroy_hash ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-lz.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0FO@HJBIFDCL@mhmt?9lz?4c?3make_lz_codes_megalz?$CI?$CJ@ ; `string'
PUBLIC	_make_lz_codes_megalz
EXTRN	__imp__exit:PROC
EXTRN	__imp__printf:PROC
EXTRN	_memcmp:PROC
EXTRN	_tb_entry:BYTE
EXTRN	_wrk:BYTE
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0FO@HJBIFDCL@mhmt?9lz?4c?3make_lz_codes_megalz?$CI?$CJ@
; File d:\d\mhmt\src\mhmt-lz.c
CONST	SEGMENT
??_C@_0FO@HJBIFDCL@mhmt?9lz?4c?3make_lz_codes_megalz?$CI?$CJ@ DB 'mhmt-lz'
	DB	'.c:make_lz_codes_megalz() encountered too many entries in cod'
	DB	'es[] table. Fatal error.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _make_lz_codes_megalz
_TEXT	SEGMENT
tv84 = -304						; size = 4
tv68 = -304						; size = 4
_max_lookback$ = -104					; size = 4
_index$ = -92						; size = 2
_curr_tb$ = -80						; size = 4
_next_byte$ = -65					; size = 1
_curr_byte$ = -53					; size = 1
_was_match$ = -44					; size = 4
_i$ = -32						; size = 4
_codelen$ = -20						; size = 4
_codepos$ = -8						; size = 4
_position$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_hash$ = 16						; size = 4
_codes$ = 20						; size = 4
_make_lz_codes_megalz PROC				; COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 15   : 	ULONG codepos;
; 16   : 	ULONG codelen,i;
; 17   : 	ULONG was_match;
; 18   : 	UBYTE curr_byte,next_byte;
; 19   : 	struct tb_chain * curr_tb;
; 20   : 	UWORD index;
; 21   : 	ULONG max_lookback;
; 22   : 
; 23   : 	// copy-byte code is always present
; 24   : 	codes[0].length = 1;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00021	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 25   : 	codes[0].disp   = 0;

  00027	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  0002a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 26   : 
; 27   : 	// start more filling of codes[] from that position
; 28   : 	codepos = 1;

  00031	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _codepos$[ebp], 1

; 29   : 
; 30   : 
; 31   : 	curr_byte=wrk.indata[position];

  00038	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0003d	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 4d cb	 mov	 BYTE PTR _curr_byte$[ebp], cl

; 32   : 
; 33   : 	// check for one-byter (-1..-8)
; 34   : 	i = (position>8) ? position-8 : 0;

  00045	83 7d 08 08	 cmp	 DWORD PTR _position$[ebp], 8
  00049	76 0e		 jbe	 SHORT $LN24@make_lz_co
  0004b	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0004e	83 e8 08	 sub	 eax, 8
  00051	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00057	eb 0a		 jmp	 SHORT $LN25@make_lz_co
$LN24@make_lz_co:
  00059	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN25@make_lz_co:
  00063	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  00069	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$LN21@make_lz_co:

; 35   : 	do
; 36   : 	{
; 37   : 		if( wrk.indata[i] == curr_byte )

  0006c	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00071	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00074	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00077	0f b6 55 cb	 movzx	 edx, BYTE PTR _curr_byte$[ebp]
  0007b	3b ca		 cmp	 ecx, edx
  0007d	75 2a		 jne	 SHORT $LN20@make_lz_co

; 38   : 		{
; 39   : 			codes[codepos].length = 1;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00082	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00085	c7 04 c1 01 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 1

; 40   : 			codes[codepos].disp   = -(LONG)(position-i);

  0008c	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0008f	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  00092	f7 d8		 neg	 eax
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _codepos$[ebp]
  00097	8b 55 14	 mov	 edx, DWORD PTR _codes$[ebp]
  0009a	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 41   : 			codepos++;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 42   : 			break;

  000a7	eb 11		 jmp	 SHORT $LN19@make_lz_co
$LN20@make_lz_co:

; 43   : 		}
; 44   : 	} while( (++i)<position );

  000a9	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000ac	83 c0 01	 add	 eax, 1
  000af	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  000b5	3b 4d 08	 cmp	 ecx, DWORD PTR _position$[ebp]
  000b8	72 b2		 jb	 SHORT $LN21@make_lz_co
$LN19@make_lz_co:

; 45   : 
; 46   : 
; 47   : 
; 48   : 	max_lookback = (wrk.maxwin<4352) ? wrk.maxwin : 4352;

  000ba	81 3d 1c 00 00
	00 00 11 00 00	 cmp	 DWORD PTR _wrk+28, 4352	; 00001100H
  000c4	73 0d		 jae	 SHORT $LN26@make_lz_co
  000c6	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  000cb	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  000d1	eb 0a		 jmp	 SHORT $LN27@make_lz_co
$LN26@make_lz_co:
  000d3	c7 85 d0 fe ff
	ff 00 11 00 00	 mov	 DWORD PTR tv84[ebp], 4352 ; 00001100H
$LN27@make_lz_co:
  000dd	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv84[ebp]
  000e3	89 4d 98	 mov	 DWORD PTR _max_lookback$[ebp], ecx

; 49   : 
; 50   : 	// check for two-byter (-1..-256), no check for wrk.maxwin since it can't be less than 256
; 51   : 	//
; 52   : 	curr_tb = NULL;

  000e6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _curr_tb$[ebp], 0

; 53   : 	//
; 54   : 	if( position<(actual_len-1) ) // don't try two-byter if we are at the byte before last one

  000ed	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  000f0	83 e8 01	 sub	 eax, 1
  000f3	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  000f6	73 7a		 jae	 SHORT $LN17@make_lz_co

; 55   : 	{
; 56   : 		next_byte = wrk.indata[position+1];

  000f8	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000fd	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  00100	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00103	88 4d bf	 mov	 BYTE PTR _next_byte$[ebp], cl

; 57   : 		index=(curr_byte<<8) + next_byte;

  00106	0f b6 45 cb	 movzx	 eax, BYTE PTR _curr_byte$[ebp]
  0010a	c1 e0 08	 shl	 eax, 8
  0010d	0f b6 4d bf	 movzx	 ecx, BYTE PTR _next_byte$[ebp]
  00111	03 c1		 add	 eax, ecx
  00113	66 89 45 a4	 mov	 WORD PTR _index$[ebp], ax

; 58   : 		curr_tb = tb_entry[index];

  00117	0f b7 45 a4	 movzx	 eax, WORD PTR _index$[ebp]
  0011b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _tb_entry[eax*4]
  00122	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 59   : 
; 60   : 		// there is two-byters!
; 61   : 		if( curr_tb )

  00125	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00129	74 47		 je	 SHORT $LN17@make_lz_co

; 62   : 		{
; 63   :                         if( ((position-curr_tb->pos)<=256) && ((position-curr_tb->pos)<=max_lookback) ) // 2byters are no longer than 256 bytes, as well as no lookbacks (wrk.maxwin)

  0012b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00131	2b 08		 sub	 ecx, DWORD PTR [eax]
  00133	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00139	77 37		 ja	 SHORT $LN17@make_lz_co
  0013b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00141	2b 08		 sub	 ecx, DWORD PTR [eax]
  00143	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00146	77 2a		 ja	 SHORT $LN17@make_lz_co

; 64   :                                                              // lesser than 256
; 65   : 			{
; 66   : 				codes[codepos].length = 2;

  00148	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0014b	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0014e	c7 04 c1 02 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 2

; 67   : 				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00155	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0015b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0015d	f7 d9		 neg	 ecx
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  00162	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00165	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 68   : 				codepos++;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0016c	83 c0 01	 add	 eax, 1
  0016f	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax
$LN17@make_lz_co:

; 69   : 			}
; 70   : 		}
; 71   : 	}
; 72   : 
; 73   : 	// at last, check for lengths=3..255 up to 4352 or wrk.maxwin
; 74   : 	//
; 75   : 	//
; 76   : 	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all

  00172	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00176	0f 84 77 01 00
	00		 je	 $LN14@make_lz_co
  0017c	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00182	2b 08		 sub	 ecx, DWORD PTR [eax]
  00184	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00187	0f 87 66 01 00
	00		 ja	 $LN14@make_lz_co
  0018d	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00190	83 e8 02	 sub	 eax, 2
  00193	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  00196	0f 83 57 01 00
	00		 jae	 $LN14@make_lz_co

; 77   : 	{
; 78   : 		was_match = 1; // there was match at codelen-1

  0019c	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 79   : 
; 80   : 		for( codelen=3; ( codelen<=255 )&&( position<(actual_len-codelen+1) ); /*nothing*/ )

  001a3	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _codelen$[ebp], 3
$LN13@make_lz_co:
  001aa	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _codelen$[ebp], 255 ; 000000ffH
  001b1	0f 87 3c 01 00
	00		 ja	 $LN14@make_lz_co
  001b7	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  001ba	2b 45 ec	 sub	 eax, DWORD PTR _codelen$[ebp]
  001bd	83 c0 01	 add	 eax, 1
  001c0	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  001c3	0f 83 2a 01 00
	00		 jae	 $LN14@make_lz_co

; 81   : 		{
; 82   : 			if( was_match ) // for codelen-1

  001c9	83 7d d4 00	 cmp	 DWORD PTR _was_match$[ebp], 0
  001cd	0f 84 8d 00 00
	00		 je	 $LN11@make_lz_co

; 83   : 			{
; 84   : 				// codelen-1 bytes are matched, compare one more byte
; 85   : 				if( wrk.indata[position+codelen-1] == wrk.indata[curr_tb->pos+codelen-1] )

  001d3	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  001d6	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  001d9	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  001df	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  001e4	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  001e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e9	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  001ec	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001f1	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  001f6	3b d1		 cmp	 edx, ecx
  001f8	75 34		 jne	 SHORT $MATCH_FAIL_MEGALZ$4666

; 86   : 				{
; 87   : 					// add code to the table
; 88   : 					codes[codepos].length = codelen;

  001fa	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  001fd	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00200	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  00203	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 89   : 					codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00206	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0020c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0020e	f7 d9		 neg	 ecx
  00210	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  00213	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00216	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 90   : 					codepos++;

  0021a	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0021d	83 c0 01	 add	 eax, 1
  00220	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 91   : 
; 92   : 					codelen++; // next time do comparision of greater size

  00223	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00226	83 c0 01	 add	 eax, 1
  00229	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 93   : 				}
; 94   : 				else // last bytes do not match

  0022c	eb 2d		 jmp	 SHORT $LN9@make_lz_co
$MATCH_FAIL_MEGALZ$4666:

; 95   : 				{
; 96   : 
; 97   : MATCH_FAIL_MEGALZ: // entrance for failed matches here: used 3-fold so we set "goto" here
; 98   : 
; 99   : 					// go for older twobyter
; 100  : 					curr_tb = curr_tb->next;

  0022e	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00231	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00234	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 101  : 
; 102  : 					// no more twobyters or they are too far - stop search at all
; 103  : 					if( !curr_tb ) break;

  00237	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  0023b	75 05		 jne	 SHORT $LN8@make_lz_co
  0023d	e9 b1 00 00 00	 jmp	 $LN14@make_lz_co
$LN8@make_lz_co:

; 104  : 					if( (position - curr_tb->pos)>max_lookback ) break;

  00242	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00245	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00248	2b 08		 sub	 ecx, DWORD PTR [eax]
  0024a	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  0024d	76 05		 jbe	 SHORT $LN7@make_lz_co
  0024f	e9 9f 00 00 00	 jmp	 $LN14@make_lz_co
$LN7@make_lz_co:

; 105  : 
; 106  : 					// mark there was no matches
; 107  : 					was_match = 0;

  00254	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 0
$LN9@make_lz_co:

; 108  : 				}
; 109  : 			}
; 110  : 			else // there were no matches for previous codelen

  0025b	e9 8e 00 00 00	 jmp	 $LN6@make_lz_co
$LN11@make_lz_co:

; 111  : 			{
; 112  : 				// next twobyter is already taken, but no comparision is done for codelen bytes
; 113  : 				// first we check if we need to do such comparision at all by seeing to the hashes of the ends of strings
; 114  : 				if( hash[position+codelen-1] == hash[curr_tb->pos+codelen-1] )

  00260	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00263	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  00266	8b 4d 10	 mov	 ecx, DWORD PTR _hash$[ebp]
  00269	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  0026e	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00271	8b 08		 mov	 ecx, DWORD PTR [eax]
  00273	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  00276	8b 45 10	 mov	 eax, DWORD PTR _hash$[ebp]
  00279	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  0027e	3b d1		 cmp	 edx, ecx
  00280	75 67		 jne	 SHORT $LN5@make_lz_co

; 115  : 				{	// hashes match, so try matching complete string
; 116  : 					if( !memcmp( &wrk.indata[position], &wrk.indata[curr_tb->pos], codelen ) )

  00282	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00285	50		 push	 eax
  00286	8b 4d b0	 mov	 ecx, DWORD PTR _curr_tb$[ebp]
  00289	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  0028f	03 11		 add	 edx, DWORD PTR [ecx]
  00291	52		 push	 edx
  00292	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00297	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 _memcmp
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a3	85 c0		 test	 eax, eax
  002a5	75 3b		 jne	 SHORT $LN4@make_lz_co

; 117  : 					{
; 118  : 						was_match = 1;

  002a7	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 119  : 						codes[codepos].length = codelen;

  002ae	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  002b1	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  002b4	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  002b7	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 120  : 						codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  002ba	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  002bd	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  002c0	2b 08		 sub	 ecx, DWORD PTR [eax]
  002c2	f7 d9		 neg	 ecx
  002c4	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  002c7	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  002ca	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 121  : 						codepos++;

  002ce	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  002d1	83 c0 01	 add	 eax, 1
  002d4	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 122  : 
; 123  : 						codelen++;

  002d7	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  002da	83 c0 01	 add	 eax, 1
  002dd	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 124  : 					}
; 125  : 					else

  002e0	eb 05		 jmp	 SHORT $LN3@make_lz_co
$LN4@make_lz_co:

; 126  : 						// no match of whole string
; 127  : 						goto MATCH_FAIL_MEGALZ;

  002e2	e9 47 ff ff ff	 jmp	 $MATCH_FAIL_MEGALZ$4666
$LN3@make_lz_co:

; 128  : 				}
; 129  : 				else

  002e7	eb 05		 jmp	 SHORT $LN6@make_lz_co
$LN5@make_lz_co:

; 130  : 					// no match of hashes
; 131  : 					goto MATCH_FAIL_MEGALZ;

  002e9	e9 40 ff ff ff	 jmp	 $MATCH_FAIL_MEGALZ$4666
$LN6@make_lz_co:

; 132  : 			}
; 133  : 		}

  002ee	e9 b7 fe ff ff	 jmp	 $LN13@make_lz_co
$LN14@make_lz_co:

; 134  : 	}
; 135  : 
; 136  : 
; 137  : 	// here we assume to have found all possible matches. check for codes[] table overflow:
; 138  : 	// there could be matches for length 1..255, and there is copy-byte, total 256 entries
; 139  : 	if( codepos>256 ) // this should not happen!

  002f3	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _codepos$[ebp], 256 ; 00000100H
  002fa	76 28		 jbe	 SHORT $LN1@make_lz_co

; 140  : 	{
; 141  : 		printf("mhmt-lz.c:make_lz_codes_megalz() encountered too many entries in codes[] table. Fatal error.\n");

  002fc	8b f4		 mov	 esi, esp
  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@HJBIFDCL@mhmt?9lz?4c?3make_lz_codes_megalz?$CI?$CJ@
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00309	83 c4 04	 add	 esp, 4
  0030c	3b f4		 cmp	 esi, esp
  0030e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 142  : 		exit(1);

  00313	8b f4		 mov	 esi, esp
  00315	6a 01		 push	 1
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0031d	3b f4		 cmp	 esi, esp
  0031f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@make_lz_co:

; 143  : 	}
; 144  : 
; 145  : 	// mark end-of-records in codes[]
; 146  : 	codes[codepos].length = 0;

  00324	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00327	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0032a	c7 04 c1 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 0

; 147  : 	codes[codepos].disp   = 0;

  00331	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00334	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00337	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0
$LN23@make_lz_co:

; 148  : }

  0033f	5f		 pop	 edi
  00340	5e		 pop	 esi
  00341	5b		 pop	 ebx
  00342	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00348	3b ec		 cmp	 ebp, esp
  0034a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c3		 ret	 0
_make_lz_codes_megalz ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FM@ONCNBKEO@mhmt?9lz?4c?3make_lz_codes_hrum?$CI?$CJ?5e@ ; `string'
PUBLIC	_make_lz_codes_hrum
;	COMDAT ??_C@_0FM@ONCNBKEO@mhmt?9lz?4c?3make_lz_codes_hrum?$CI?$CJ?5e@
CONST	SEGMENT
??_C@_0FM@ONCNBKEO@mhmt?9lz?4c?3make_lz_codes_hrum?$CI?$CJ?5e@ DB 'mhmt-l'
	DB	'z.c:make_lz_codes_hrum() encountered too many entries in code'
	DB	's[] table. Fatal error.', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _make_lz_codes_hrum
_TEXT	SEGMENT
tv84 = -304						; size = 4
tv68 = -304						; size = 4
_max_lookback$ = -104					; size = 4
_index$ = -92						; size = 2
_curr_tb$ = -80						; size = 4
_next_byte$ = -65					; size = 1
_curr_byte$ = -53					; size = 1
_was_match$ = -44					; size = 4
_i$ = -32						; size = 4
_codelen$ = -20						; size = 4
_codepos$ = -8						; size = 4
_position$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_hash$ = 16						; size = 4
_codes$ = 20						; size = 4
_make_lz_codes_hrum PROC				; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 160  : 	ULONG codepos;
; 161  : 	ULONG codelen,i;
; 162  : 	ULONG was_match;
; 163  : 	UBYTE curr_byte,next_byte;
; 164  : 	struct tb_chain * curr_tb;
; 165  : 	UWORD index;
; 166  : 	ULONG max_lookback;
; 167  : 
; 168  : 	// copy-byte code is always present
; 169  : 	codes[0].length = 1;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00021	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 170  : 	codes[0].disp   = 0;

  00027	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  0002a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 171  : 
; 172  : 	// start more filling of codes[] from that position
; 173  : 	codepos = 1;

  00031	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _codepos$[ebp], 1

; 174  : 
; 175  : 	curr_byte=wrk.indata[position];

  00038	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0003d	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 4d cb	 mov	 BYTE PTR _curr_byte$[ebp], cl

; 176  : 
; 177  : 	// check for one-byter (-1..-8)
; 178  : 	i = (position>8) ? position-8 : 0;

  00045	83 7d 08 08	 cmp	 DWORD PTR _position$[ebp], 8
  00049	76 0e		 jbe	 SHORT $LN24@make_lz_co@2
  0004b	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0004e	83 e8 08	 sub	 eax, 8
  00051	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00057	eb 0a		 jmp	 SHORT $LN25@make_lz_co@2
$LN24@make_lz_co@2:
  00059	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN25@make_lz_co@2:
  00063	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  00069	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$LN21@make_lz_co@2:

; 179  : 	do
; 180  : 	{
; 181  : 		if( wrk.indata[i] == curr_byte )

  0006c	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00071	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00074	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00077	0f b6 55 cb	 movzx	 edx, BYTE PTR _curr_byte$[ebp]
  0007b	3b ca		 cmp	 ecx, edx
  0007d	75 2a		 jne	 SHORT $LN20@make_lz_co@2

; 182  : 		{
; 183  : 			codes[codepos].length = 1;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00082	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00085	c7 04 c1 01 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 1

; 184  : 			codes[codepos].disp   = -(LONG)(position-i);

  0008c	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0008f	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  00092	f7 d8		 neg	 eax
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _codepos$[ebp]
  00097	8b 55 14	 mov	 edx, DWORD PTR _codes$[ebp]
  0009a	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 185  : 			codepos++;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 186  : 			break;

  000a7	eb 11		 jmp	 SHORT $LN19@make_lz_co@2
$LN20@make_lz_co@2:

; 187  : 		}
; 188  : 	} while( (++i)<position );

  000a9	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000ac	83 c0 01	 add	 eax, 1
  000af	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  000b5	3b 4d 08	 cmp	 ecx, DWORD PTR _position$[ebp]
  000b8	72 b2		 jb	 SHORT $LN21@make_lz_co@2
$LN19@make_lz_co@2:

; 189  : 
; 190  : 
; 191  : 	max_lookback = (wrk.maxwin<4096) ? wrk.maxwin : 4096;

  000ba	81 3d 1c 00 00
	00 00 10 00 00	 cmp	 DWORD PTR _wrk+28, 4096	; 00001000H
  000c4	73 0d		 jae	 SHORT $LN26@make_lz_co@2
  000c6	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  000cb	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  000d1	eb 0a		 jmp	 SHORT $LN27@make_lz_co@2
$LN26@make_lz_co@2:
  000d3	c7 85 d0 fe ff
	ff 00 10 00 00	 mov	 DWORD PTR tv84[ebp], 4096 ; 00001000H
$LN27@make_lz_co@2:
  000dd	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv84[ebp]
  000e3	89 4d 98	 mov	 DWORD PTR _max_lookback$[ebp], ecx

; 192  : 
; 193  : 
; 194  : 	// check for two-byter (-1..-256)
; 195  : 	//
; 196  : 	curr_tb = NULL;

  000e6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _curr_tb$[ebp], 0

; 197  : 	//
; 198  : 	if( position<(actual_len-1) ) // don't try two-byter if we are at the byte before last one

  000ed	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  000f0	83 e8 01	 sub	 eax, 1
  000f3	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  000f6	73 7a		 jae	 SHORT $LN17@make_lz_co@2

; 199  : 	{
; 200  : 		next_byte = wrk.indata[position+1];

  000f8	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000fd	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  00100	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00103	88 4d bf	 mov	 BYTE PTR _next_byte$[ebp], cl

; 201  : 		index=(curr_byte<<8) + next_byte;

  00106	0f b6 45 cb	 movzx	 eax, BYTE PTR _curr_byte$[ebp]
  0010a	c1 e0 08	 shl	 eax, 8
  0010d	0f b6 4d bf	 movzx	 ecx, BYTE PTR _next_byte$[ebp]
  00111	03 c1		 add	 eax, ecx
  00113	66 89 45 a4	 mov	 WORD PTR _index$[ebp], ax

; 202  : 		curr_tb = tb_entry[index];

  00117	0f b7 45 a4	 movzx	 eax, WORD PTR _index$[ebp]
  0011b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _tb_entry[eax*4]
  00122	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 203  : 
; 204  : 		// there is two-byters!
; 205  : 		if( curr_tb )

  00125	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00129	74 47		 je	 SHORT $LN17@make_lz_co@2

; 206  : 		{
; 207  : 			if( ((position-curr_tb->pos)<=256) && ((position-curr_tb->pos)<=max_lookback) ) // 2byters are no longer than 256 bytes, as well as no lookbacks (wrk.maxwin)

  0012b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00131	2b 08		 sub	 ecx, DWORD PTR [eax]
  00133	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00139	77 37		 ja	 SHORT $LN17@make_lz_co@2
  0013b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00141	2b 08		 sub	 ecx, DWORD PTR [eax]
  00143	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00146	77 2a		 ja	 SHORT $LN17@make_lz_co@2

; 208  : 			                                                                                // lesser than 256
; 209  : 			{
; 210  : 				codes[codepos].length = 2;

  00148	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0014b	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0014e	c7 04 c1 02 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 2

; 211  : 				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00155	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0015b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0015d	f7 d9		 neg	 ecx
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  00162	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00165	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 212  : 				codepos++;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0016c	83 c0 01	 add	 eax, 1
  0016f	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax
$LN17@make_lz_co@2:

; 213  : 			}
; 214  : 		}
; 215  : 	}
; 216  : 
; 217  : 
; 218  : 	// at last, check for lengths=3..255 up to 4096 or wrk.maxwin
; 219  : 	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all

  00172	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00176	0f 84 77 01 00
	00		 je	 $LN14@make_lz_co@2
  0017c	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00182	2b 08		 sub	 ecx, DWORD PTR [eax]
  00184	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00187	0f 87 66 01 00
	00		 ja	 $LN14@make_lz_co@2
  0018d	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00190	83 e8 02	 sub	 eax, 2
  00193	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  00196	0f 83 57 01 00
	00		 jae	 $LN14@make_lz_co@2

; 220  : 	{
; 221  : 		was_match = 1; // there was match at codelen-1

  0019c	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 222  : 
; 223  : 		for( codelen=3; ( codelen<=255 )&&( position<(actual_len-codelen+1) ); /*nothing*/ )

  001a3	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _codelen$[ebp], 3
$LN13@make_lz_co@2:
  001aa	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _codelen$[ebp], 255 ; 000000ffH
  001b1	0f 87 3c 01 00
	00		 ja	 $LN14@make_lz_co@2
  001b7	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  001ba	2b 45 ec	 sub	 eax, DWORD PTR _codelen$[ebp]
  001bd	83 c0 01	 add	 eax, 1
  001c0	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  001c3	0f 83 2a 01 00
	00		 jae	 $LN14@make_lz_co@2

; 224  : 		{
; 225  : 			if( was_match ) // for codelen-1

  001c9	83 7d d4 00	 cmp	 DWORD PTR _was_match$[ebp], 0
  001cd	0f 84 8d 00 00
	00		 je	 $LN11@make_lz_co@2

; 226  : 			{
; 227  : 				// codelen-1 bytes are matched, compare one more byte
; 228  : 				if( wrk.indata[position+codelen-1] == wrk.indata[curr_tb->pos+codelen-1] )

  001d3	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  001d6	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  001d9	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  001df	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  001e4	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  001e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e9	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  001ec	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001f1	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  001f6	3b d1		 cmp	 edx, ecx
  001f8	75 34		 jne	 SHORT $MATCH_FAIL_HRUM$4713

; 229  : 				{
; 230  : 					// add code to the table
; 231  : 					codes[codepos].length = codelen;

  001fa	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  001fd	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00200	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  00203	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 232  : 					codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00206	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0020c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0020e	f7 d9		 neg	 ecx
  00210	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  00213	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00216	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 233  : 					codepos++;

  0021a	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0021d	83 c0 01	 add	 eax, 1
  00220	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 234  : 
; 235  : 					codelen++; // next time do comparision of greater size

  00223	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00226	83 c0 01	 add	 eax, 1
  00229	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 236  : 				}
; 237  : 				else // last bytes do not match

  0022c	eb 2d		 jmp	 SHORT $LN9@make_lz_co@2
$MATCH_FAIL_HRUM$4713:

; 238  : 				{
; 239  : 
; 240  : MATCH_FAIL_HRUM: // entrance for failed matches here: used 3-fold so we set "goto" here
; 241  : 
; 242  : 					// go for older twobyter
; 243  : 					curr_tb = curr_tb->next;

  0022e	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00231	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00234	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 244  : 
; 245  : 					// no more twobyters or they are too far - stop search at all
; 246  : 					if( !curr_tb ) break;

  00237	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  0023b	75 05		 jne	 SHORT $LN8@make_lz_co@2
  0023d	e9 b1 00 00 00	 jmp	 $LN14@make_lz_co@2
$LN8@make_lz_co@2:

; 247  : 					if( (position - curr_tb->pos)>max_lookback ) break;

  00242	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00245	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00248	2b 08		 sub	 ecx, DWORD PTR [eax]
  0024a	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  0024d	76 05		 jbe	 SHORT $LN7@make_lz_co@2
  0024f	e9 9f 00 00 00	 jmp	 $LN14@make_lz_co@2
$LN7@make_lz_co@2:

; 248  : 
; 249  : 					// mark there was no matches
; 250  : 					was_match = 0;

  00254	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 0
$LN9@make_lz_co@2:

; 251  : 				}
; 252  : 			}
; 253  : 			else // there were no matches for previous codelen

  0025b	e9 8e 00 00 00	 jmp	 $LN6@make_lz_co@2
$LN11@make_lz_co@2:

; 254  : 			{
; 255  : 				// next twobyter is already taken, but no comparision is done for codelen bytes
; 256  : 				// first we check if we need to do such comparision at all by seeing to the hashes of the ends of strings
; 257  : 				if( hash[position+codelen-1] == hash[curr_tb->pos+codelen-1] )

  00260	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00263	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  00266	8b 4d 10	 mov	 ecx, DWORD PTR _hash$[ebp]
  00269	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  0026e	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00271	8b 08		 mov	 ecx, DWORD PTR [eax]
  00273	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  00276	8b 45 10	 mov	 eax, DWORD PTR _hash$[ebp]
  00279	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  0027e	3b d1		 cmp	 edx, ecx
  00280	75 67		 jne	 SHORT $LN5@make_lz_co@2

; 258  : 				{	// hashes match, so try matching complete string
; 259  : 					if( !memcmp( &wrk.indata[position], &wrk.indata[curr_tb->pos], codelen ) )

  00282	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00285	50		 push	 eax
  00286	8b 4d b0	 mov	 ecx, DWORD PTR _curr_tb$[ebp]
  00289	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  0028f	03 11		 add	 edx, DWORD PTR [ecx]
  00291	52		 push	 edx
  00292	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00297	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 _memcmp
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a3	85 c0		 test	 eax, eax
  002a5	75 3b		 jne	 SHORT $LN4@make_lz_co@2

; 260  : 					{
; 261  : 						was_match = 1;

  002a7	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 262  : 						codes[codepos].length = codelen;

  002ae	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  002b1	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  002b4	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  002b7	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 263  : 						codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  002ba	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  002bd	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  002c0	2b 08		 sub	 ecx, DWORD PTR [eax]
  002c2	f7 d9		 neg	 ecx
  002c4	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  002c7	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  002ca	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 264  : 						codepos++;

  002ce	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  002d1	83 c0 01	 add	 eax, 1
  002d4	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 265  : 
; 266  : 						codelen++;

  002d7	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  002da	83 c0 01	 add	 eax, 1
  002dd	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 267  : 					}
; 268  : 					else

  002e0	eb 05		 jmp	 SHORT $LN3@make_lz_co@2
$LN4@make_lz_co@2:

; 269  : 						// no match of whole string
; 270  : 						goto MATCH_FAIL_HRUM;

  002e2	e9 47 ff ff ff	 jmp	 $MATCH_FAIL_HRUM$4713
$LN3@make_lz_co@2:

; 271  : 				}
; 272  : 				else

  002e7	eb 05		 jmp	 SHORT $LN6@make_lz_co@2
$LN5@make_lz_co@2:

; 273  : 					// no match of hashes
; 274  : 					goto MATCH_FAIL_HRUM;

  002e9	e9 40 ff ff ff	 jmp	 $MATCH_FAIL_HRUM$4713
$LN6@make_lz_co@2:

; 275  : 			}
; 276  : 		}

  002ee	e9 b7 fe ff ff	 jmp	 $LN13@make_lz_co@2
$LN14@make_lz_co@2:

; 277  : 	}
; 278  : 
; 279  : 
; 280  : 	// here we assume to have found all possible matches. check for codes[] table overflow:
; 281  : 	// there could be matches for length 1..255, and there is copy-byte, total 256 entries
; 282  : 	if( codepos>256 ) // this should not happen!

  002f3	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _codepos$[ebp], 256 ; 00000100H
  002fa	76 28		 jbe	 SHORT $LN1@make_lz_co@2

; 283  : 	{
; 284  : 		printf("mhmt-lz.c:make_lz_codes_hrum() encountered too many entries in codes[] table. Fatal error.\n");

  002fc	8b f4		 mov	 esi, esp
  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@ONCNBKEO@mhmt?9lz?4c?3make_lz_codes_hrum?$CI?$CJ?5e@
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00309	83 c4 04	 add	 esp, 4
  0030c	3b f4		 cmp	 esi, esp
  0030e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 285  : 		exit(1);

  00313	8b f4		 mov	 esi, esp
  00315	6a 01		 push	 1
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0031d	3b f4		 cmp	 esi, esp
  0031f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@make_lz_co@2:

; 286  : 	}
; 287  : 
; 288  : 	// mark end-of-records in codes[]
; 289  : 	codes[codepos].length = 0;

  00324	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00327	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0032a	c7 04 c1 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 0

; 290  : 	codes[codepos].disp   = 0;

  00331	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00334	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00337	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0
$LN23@make_lz_co@2:

; 291  : 
; 292  : }

  0033f	5f		 pop	 edi
  00340	5e		 pop	 esi
  00341	5b		 pop	 ebx
  00342	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00348	3b ec		 cmp	 ebp, esp
  0034a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c3		 ret	 0
_make_lz_codes_hrum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@ ; `string'
PUBLIC	_make_lz_codes_hrust
;	COMDAT ??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@ DB 'mhmt-l'
	DB	'z.c:make_lz_codes_hrust() encountered too many entries in cod'
	DB	'es[] table. Fatal error.', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _make_lz_codes_hrust
_TEXT	SEGMENT
tv152 = -304						; size = 4
tv129 = -304						; size = 4
tv78 = -304						; size = 4
_max_lookback$ = -104					; size = 4
_index$ = -92						; size = 2
_curr_tb$ = -80						; size = 4
_next_byte$ = -65					; size = 1
_curr_byte$ = -53					; size = 1
_was_match$ = -44					; size = 4
_i$ = -32						; size = 4
_codelen$ = -20						; size = 4
_codepos$ = -8						; size = 4
_position$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_hash$ = 16						; size = 4
_codes$ = 20						; size = 4
_make_lz_codes_hrust PROC				; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 325  : 	ULONG codepos;
; 326  : 	ULONG codelen,i;
; 327  : 	ULONG was_match;
; 328  : 	UBYTE curr_byte,next_byte;
; 329  : 	struct tb_chain * curr_tb;
; 330  : 	UWORD index;
; 331  : 	ULONG max_lookback;
; 332  : 
; 333  : 	// copy-byte code is always present
; 334  : 	codes[0].length = 1;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00021	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 335  : 	codes[0].disp   = 0;

  00027	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  0002a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 336  : 
; 337  : 	// start more filling of codes[] from that position
; 338  : 	codepos = 1;

  00031	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _codepos$[ebp], 1

; 339  : 
; 340  : 	// add 12,14,16,...,40,42 bytes copies, if possible
; 341  : 	for(codelen=12;codelen<=42;codelen+=2)

  00038	c7 45 ec 0c 00
	00 00		 mov	 DWORD PTR _codelen$[ebp], 12 ; 0000000cH
  0003f	eb 09		 jmp	 SHORT $LN31@make_lz_co@3
$LN30@make_lz_co@3:
  00041	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00044	83 c0 02	 add	 eax, 2
  00047	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax
$LN31@make_lz_co@3:
  0004a	83 7d ec 2a	 cmp	 DWORD PTR _codelen$[ebp], 42 ; 0000002aH
  0004e	77 34		 ja	 SHORT $LN29@make_lz_co@3

; 342  : 	{
; 343  : 		if( position <= (actual_len-codelen) )

  00050	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00053	2b 45 ec	 sub	 eax, DWORD PTR _codelen$[ebp]
  00056	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  00059	77 25		 ja	 SHORT $LN28@make_lz_co@3

; 344  : 		{
; 345  : 			codes[codepos].length = codelen;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0005e	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00061	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  00064	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 346  : 			codes[codepos].disp   = 0;

  00067	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0006a	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0006d	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0

; 347  : 			codepos++;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 348  : 		}
; 349  : 		else

  0007e	eb 02		 jmp	 SHORT $LN27@make_lz_co@3
$LN28@make_lz_co@3:

; 350  : 			break;

  00080	eb 02		 jmp	 SHORT $LN29@make_lz_co@3
$LN27@make_lz_co@3:

; 351  : 	}

  00082	eb bd		 jmp	 SHORT $LN30@make_lz_co@3
$LN29@make_lz_co@3:

; 352  : 
; 353  : 	// check for one-byter (-1..-8)
; 354  : 	//
; 355  : 	curr_byte=wrk.indata[position];

  00084	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00089	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  0008c	8a 08		 mov	 cl, BYTE PTR [eax]
  0008e	88 4d cb	 mov	 BYTE PTR _curr_byte$[ebp], cl

; 356  : 	//
; 357  : 	i = (position>8) ? position-8 : 0;

  00091	83 7d 08 08	 cmp	 DWORD PTR _position$[ebp], 8
  00095	76 0e		 jbe	 SHORT $LN34@make_lz_co@3
  00097	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0009a	83 e8 08	 sub	 eax, 8
  0009d	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  000a3	eb 0a		 jmp	 SHORT $LN35@make_lz_co@3
$LN34@make_lz_co@3:
  000a5	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN35@make_lz_co@3:
  000af	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  000b5	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$LN26@make_lz_co@3:

; 358  : 	do
; 359  : 	{
; 360  : 		if( wrk.indata[i] == curr_byte )

  000b8	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000bd	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  000c0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c3	0f b6 55 cb	 movzx	 edx, BYTE PTR _curr_byte$[ebp]
  000c7	3b ca		 cmp	 ecx, edx
  000c9	75 2a		 jne	 SHORT $LN25@make_lz_co@3

; 361  : 		{
; 362  : 			codes[codepos].length = 1;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  000d1	c7 04 c1 01 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 1

; 363  : 			codes[codepos].disp   = -(LONG)(position-i);

  000d8	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  000db	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  000de	f7 d8		 neg	 eax
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _codepos$[ebp]
  000e3	8b 55 14	 mov	 edx, DWORD PTR _codes$[ebp]
  000e6	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 364  : 			codepos++;

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 365  : 			break;

  000f3	eb 11		 jmp	 SHORT $LN24@make_lz_co@3
$LN25@make_lz_co@3:

; 366  : 		}
; 367  : 	} while( (++i)<position );

  000f5	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000f8	83 c0 01	 add	 eax, 1
  000fb	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
  000fe	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  00101	3b 4d 08	 cmp	 ecx, DWORD PTR _position$[ebp]
  00104	72 b2		 jb	 SHORT $LN26@make_lz_co@3
$LN24@make_lz_co@3:

; 368  : 
; 369  : 
; 370  : 
; 371  : 	// check 3-byte insertion code (-1..-79)
; 372  : 	if( (position < (actual_len-2)) )

  00106	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00109	83 e8 02	 sub	 eax, 2
  0010c	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  0010f	0f 83 92 00 00
	00		 jae	 $LN22@make_lz_co@3

; 373  : 	{
; 374  : 		i = (position>79) ? position-79 : 0;

  00115	83 7d 08 4f	 cmp	 DWORD PTR _position$[ebp], 79 ; 0000004fH
  00119	76 0e		 jbe	 SHORT $LN36@make_lz_co@3
  0011b	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0011e	83 e8 4f	 sub	 eax, 79			; 0000004fH
  00121	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  00127	eb 0a		 jmp	 SHORT $LN37@make_lz_co@3
$LN36@make_lz_co@3:
  00129	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
$LN37@make_lz_co@3:
  00133	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  00139	89 4d e0	 mov	 DWORD PTR _i$[ebp], ecx
$LN21@make_lz_co@3:

; 375  : 		do
; 376  : 		{
; 377  : 			if( (wrk.indata[i]==curr_byte) && (wrk.indata[i+2]==wrk.indata[position+2]) )

  0013c	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00141	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00144	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00147	0f b6 55 cb	 movzx	 edx, BYTE PTR _curr_byte$[ebp]
  0014b	3b ca		 cmp	 ecx, edx
  0014d	75 47		 jne	 SHORT $LN20@make_lz_co@3
  0014f	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00154	03 45 e0	 add	 eax, DWORD PTR _i$[ebp]
  00157	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0015b	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  00161	03 55 08	 add	 edx, DWORD PTR _position$[ebp]
  00164	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00168	3b c8		 cmp	 ecx, eax
  0016a	75 2a		 jne	 SHORT $LN20@make_lz_co@3

; 378  : 			{
; 379  : 				codes[codepos].length = (-3);

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0016f	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00172	c7 04 c1 fd ff
	ff ff		 mov	 DWORD PTR [ecx+eax*8], -3 ; fffffffdH

; 380  : 				codes[codepos].disp   = -(LONG)(position-i);

  00179	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0017c	2b 45 e0	 sub	 eax, DWORD PTR _i$[ebp]
  0017f	f7 d8		 neg	 eax
  00181	8b 4d f8	 mov	 ecx, DWORD PTR _codepos$[ebp]
  00184	8b 55 14	 mov	 edx, DWORD PTR _codes$[ebp]
  00187	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 381  : 				codepos++;

  0018b	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 382  : 				break;

  00194	eb 11		 jmp	 SHORT $LN22@make_lz_co@3
$LN20@make_lz_co@3:

; 383  : 			}
; 384  : 		} while( (++i)<position );

  00196	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00199	83 c0 01	 add	 eax, 1
  0019c	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
  0019f	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  001a2	3b 4d 08	 cmp	 ecx, DWORD PTR _position$[ebp]
  001a5	72 95		 jb	 SHORT $LN21@make_lz_co@3
$LN22@make_lz_co@3:

; 385  : 	}
; 386  : 
; 387  : 
; 388  : 	max_lookback = (wrk.maxwin<65536) ? wrk.maxwin : 65536;

  001a7	81 3d 1c 00 00
	00 00 00 01 00	 cmp	 DWORD PTR _wrk+28, 65536 ; 00010000H
  001b1	73 0d		 jae	 SHORT $LN38@make_lz_co@3
  001b3	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  001b8	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  001be	eb 0a		 jmp	 SHORT $LN39@make_lz_co@3
$LN38@make_lz_co@3:
  001c0	c7 85 d0 fe ff
	ff 00 00 01 00	 mov	 DWORD PTR tv152[ebp], 65536 ; 00010000H
$LN39@make_lz_co@3:
  001ca	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv152[ebp]
  001d0	89 4d 98	 mov	 DWORD PTR _max_lookback$[ebp], ecx

; 389  : 
; 390  : 	// check for two-byter (-1..!-768!)
; 391  : 	//
; 392  : 	curr_tb = NULL;

  001d3	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _curr_tb$[ebp], 0

; 393  : 	//
; 394  : 	if( position<(actual_len-1) ) // don't try two-byter if we are at the byte before last one

  001da	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  001dd	83 e8 01	 sub	 eax, 1
  001e0	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  001e3	73 7a		 jae	 SHORT $LN17@make_lz_co@3

; 395  : 	{
; 396  : 		next_byte = wrk.indata[position+1];

  001e5	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001ea	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  001ed	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001f0	88 4d bf	 mov	 BYTE PTR _next_byte$[ebp], cl

; 397  : 		index=(curr_byte<<8) + next_byte;

  001f3	0f b6 45 cb	 movzx	 eax, BYTE PTR _curr_byte$[ebp]
  001f7	c1 e0 08	 shl	 eax, 8
  001fa	0f b6 4d bf	 movzx	 ecx, BYTE PTR _next_byte$[ebp]
  001fe	03 c1		 add	 eax, ecx
  00200	66 89 45 a4	 mov	 WORD PTR _index$[ebp], ax

; 398  : 		curr_tb = tb_entry[index];

  00204	0f b7 45 a4	 movzx	 eax, WORD PTR _index$[ebp]
  00208	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _tb_entry[eax*4]
  0020f	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 399  : 
; 400  : 		// there are two-byters!
; 401  : 		if( curr_tb )

  00212	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00216	74 47		 je	 SHORT $LN17@make_lz_co@3

; 402  : 		{
; 403  : 			if( ((position-curr_tb->pos)<=768) && ((position-curr_tb->pos)<=max_lookback) )

  00218	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0021b	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0021e	2b 08		 sub	 ecx, DWORD PTR [eax]
  00220	81 f9 00 03 00
	00		 cmp	 ecx, 768		; 00000300H
  00226	77 37		 ja	 SHORT $LN17@make_lz_co@3
  00228	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0022b	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0022e	2b 08		 sub	 ecx, DWORD PTR [eax]
  00230	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00233	77 2a		 ja	 SHORT $LN17@make_lz_co@3

; 404  : 			{
; 405  : 				codes[codepos].length = 2;

  00235	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00238	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  0023b	c7 04 c1 02 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 2

; 406  : 				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00242	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00245	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00248	2b 08		 sub	 ecx, DWORD PTR [eax]
  0024a	f7 d9		 neg	 ecx
  0024c	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  0024f	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00252	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 407  : 				codepos++;

  00256	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00259	83 c0 01	 add	 eax, 1
  0025c	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax
$LN17@make_lz_co@3:

; 408  : 			}
; 409  : 		}
; 410  : 	}
; 411  : 
; 412  : 
; 413  : 	// at last, check for lengths=3..3839 up to lookback 65536 or wrk.maxwin
; 414  : 	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all

  0025f	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00263	0f 84 77 01 00
	00		 je	 $LN14@make_lz_co@3
  00269	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0026c	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0026f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00271	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00274	0f 87 66 01 00
	00		 ja	 $LN14@make_lz_co@3
  0027a	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0027d	83 e8 02	 sub	 eax, 2
  00280	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  00283	0f 83 57 01 00
	00		 jae	 $LN14@make_lz_co@3

; 415  : 	{
; 416  : 		was_match = 1; // there was match at codelen-1

  00289	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 417  : 
; 418  : 		for( codelen=3; ( codelen<=3839 )&&( position<(actual_len-codelen+1) ); /*nothing*/ )

  00290	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _codelen$[ebp], 3
$LN13@make_lz_co@3:
  00297	81 7d ec ff 0e
	00 00		 cmp	 DWORD PTR _codelen$[ebp], 3839 ; 00000effH
  0029e	0f 87 3c 01 00
	00		 ja	 $LN14@make_lz_co@3
  002a4	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  002a7	2b 45 ec	 sub	 eax, DWORD PTR _codelen$[ebp]
  002aa	83 c0 01	 add	 eax, 1
  002ad	39 45 08	 cmp	 DWORD PTR _position$[ebp], eax
  002b0	0f 83 2a 01 00
	00		 jae	 $LN14@make_lz_co@3

; 419  : 		{
; 420  : 			if( was_match ) // for codelen-1

  002b6	83 7d d4 00	 cmp	 DWORD PTR _was_match$[ebp], 0
  002ba	0f 84 8d 00 00
	00		 je	 $LN11@make_lz_co@3

; 421  : 			{
; 422  : 				// codelen-1 bytes are matched, compare one more byte
; 423  : 				if( wrk.indata[position+codelen-1] == wrk.indata[curr_tb->pos+codelen-1] )

  002c0	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  002c3	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  002c6	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  002cc	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  002d1	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  002d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d6	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  002d9	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  002de	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  002e3	3b d1		 cmp	 edx, ecx
  002e5	75 34		 jne	 SHORT $MATCH_FAIL_HRUST$4771

; 424  : 				{
; 425  : 					// add code to the table
; 426  : 					codes[codepos].length = codelen;

  002e7	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  002ea	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  002ed	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  002f0	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 427  : 					codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  002f3	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  002f6	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  002f9	2b 08		 sub	 ecx, DWORD PTR [eax]
  002fb	f7 d9		 neg	 ecx
  002fd	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  00300	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  00303	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 428  : 					codepos++;

  00307	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0030a	83 c0 01	 add	 eax, 1
  0030d	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 429  : 
; 430  : 					codelen++; // next time do comparision of greater size

  00310	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00313	83 c0 01	 add	 eax, 1
  00316	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 431  : 				}
; 432  : 				else // last bytes do not match

  00319	eb 2d		 jmp	 SHORT $LN9@make_lz_co@3
$MATCH_FAIL_HRUST$4771:

; 433  : 				{
; 434  : 
; 435  : MATCH_FAIL_HRUST: // entrance for failed matches here: used 3-fold so we set "goto" here
; 436  : 
; 437  : 					// go for older twobyter
; 438  : 					curr_tb = curr_tb->next;

  0031b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0031e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00321	89 4d b0	 mov	 DWORD PTR _curr_tb$[ebp], ecx

; 439  : 
; 440  : 					// no more twobyters or they are too far - stop search at all
; 441  : 					if( !curr_tb ) break;

  00324	83 7d b0 00	 cmp	 DWORD PTR _curr_tb$[ebp], 0
  00328	75 05		 jne	 SHORT $LN8@make_lz_co@3
  0032a	e9 b1 00 00 00	 jmp	 $LN14@make_lz_co@3
$LN8@make_lz_co@3:

; 442  : 					if( (position - curr_tb->pos)>max_lookback ) break;

  0032f	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  00332	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00335	2b 08		 sub	 ecx, DWORD PTR [eax]
  00337	3b 4d 98	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  0033a	76 05		 jbe	 SHORT $LN7@make_lz_co@3
  0033c	e9 9f 00 00 00	 jmp	 $LN14@make_lz_co@3
$LN7@make_lz_co@3:

; 443  : 
; 444  : 					// mark there was no matches
; 445  : 					was_match = 0;

  00341	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 0
$LN9@make_lz_co@3:

; 446  : 				}
; 447  : 			}
; 448  : 			else // there were no matches for previous codelen

  00348	e9 8e 00 00 00	 jmp	 $LN6@make_lz_co@3
$LN11@make_lz_co@3:

; 449  : 			{
; 450  : 				// next twobyter is already taken, but no comparision is done for codelen bytes
; 451  : 				// first we check if we need to do such comparision at all by seeing to the hashes of the ends of strings
; 452  : 				if( hash[position+codelen-1] == hash[curr_tb->pos+codelen-1] )

  0034d	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00350	03 45 ec	 add	 eax, DWORD PTR _codelen$[ebp]
  00353	8b 4d 10	 mov	 ecx, DWORD PTR _hash$[ebp]
  00356	0f b6 54 01 ff	 movzx	 edx, BYTE PTR [ecx+eax-1]
  0035b	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  0035e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00360	03 4d ec	 add	 ecx, DWORD PTR _codelen$[ebp]
  00363	8b 45 10	 mov	 eax, DWORD PTR _hash$[ebp]
  00366	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  0036b	3b d1		 cmp	 edx, ecx
  0036d	75 67		 jne	 SHORT $LN5@make_lz_co@3

; 453  : 				{	// hashes match, so try matching complete string
; 454  : 					if( !memcmp( &wrk.indata[position], &wrk.indata[curr_tb->pos], codelen ) )

  0036f	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  00372	50		 push	 eax
  00373	8b 4d b0	 mov	 ecx, DWORD PTR _curr_tb$[ebp]
  00376	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  0037c	03 11		 add	 edx, DWORD PTR [ecx]
  0037e	52		 push	 edx
  0037f	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00384	03 45 08	 add	 eax, DWORD PTR _position$[ebp]
  00387	50		 push	 eax
  00388	e8 00 00 00 00	 call	 _memcmp
  0038d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00390	85 c0		 test	 eax, eax
  00392	75 3b		 jne	 SHORT $LN4@make_lz_co@3

; 455  : 					{
; 456  : 						was_match = 1;

  00394	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 457  : 						codes[codepos].length = codelen;

  0039b	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0039e	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  003a1	8b 55 ec	 mov	 edx, DWORD PTR _codelen$[ebp]
  003a4	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx

; 458  : 						codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  003a7	8b 45 b0	 mov	 eax, DWORD PTR _curr_tb$[ebp]
  003aa	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  003ad	2b 08		 sub	 ecx, DWORD PTR [eax]
  003af	f7 d9		 neg	 ecx
  003b1	8b 55 f8	 mov	 edx, DWORD PTR _codepos$[ebp]
  003b4	8b 45 14	 mov	 eax, DWORD PTR _codes$[ebp]
  003b7	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 459  : 						codepos++;

  003bb	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  003be	83 c0 01	 add	 eax, 1
  003c1	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax

; 460  : 
; 461  : 						codelen++;

  003c4	8b 45 ec	 mov	 eax, DWORD PTR _codelen$[ebp]
  003c7	83 c0 01	 add	 eax, 1
  003ca	89 45 ec	 mov	 DWORD PTR _codelen$[ebp], eax

; 462  : 					}
; 463  : 					else

  003cd	eb 05		 jmp	 SHORT $LN3@make_lz_co@3
$LN4@make_lz_co@3:

; 464  : 						// no match of whole string
; 465  : 						goto MATCH_FAIL_HRUST;

  003cf	e9 47 ff ff ff	 jmp	 $MATCH_FAIL_HRUST$4771
$LN3@make_lz_co@3:

; 466  : 				}
; 467  : 				else

  003d4	eb 05		 jmp	 SHORT $LN6@make_lz_co@3
$LN5@make_lz_co@3:

; 468  : 					// no match of hashes
; 469  : 					goto MATCH_FAIL_HRUST;

  003d6	e9 40 ff ff ff	 jmp	 $MATCH_FAIL_HRUST$4771
$LN6@make_lz_co@3:

; 470  : 			}
; 471  : 		}

  003db	e9 b7 fe ff ff	 jmp	 $LN13@make_lz_co@3
$LN14@make_lz_co@3:

; 472  : 	}
; 473  : 
; 474  : 	// here we assume to have found all possible matches. check for codes[] table overflow:
; 475  : 	// there could be matches for length 1..3839, and there is copy-1-byte, 16 copymanybyters, 1 insertion match, total 3857 entries
; 476  : 	if( codepos>3857 ) // this should not happen!

  003e0	81 7d f8 11 0f
	00 00		 cmp	 DWORD PTR _codepos$[ebp], 3857 ; 00000f11H
  003e7	76 28		 jbe	 SHORT $LN1@make_lz_co@3

; 477  : 	{
; 478  : 		printf("mhmt-lz.c:make_lz_codes_hrust() encountered too many entries in codes[] table. Fatal error.\n");

  003e9	8b f4		 mov	 esi, esp
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003f6	83 c4 04	 add	 esp, 4
  003f9	3b f4		 cmp	 esi, esp
  003fb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 479  : 		exit(1);

  00400	8b f4		 mov	 esi, esp
  00402	6a 01		 push	 1
  00404	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0040a	3b f4		 cmp	 esi, esp
  0040c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@make_lz_co@3:

; 480  : 	}
; 481  : 
; 482  : 	// mark end-of-records in codes[]
; 483  : 	codes[codepos].length = 0;

  00411	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00414	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00417	c7 04 c1 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*8], 0

; 484  : 	codes[codepos].disp   = 0;

  0041e	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00421	8b 4d 14	 mov	 ecx, DWORD PTR _codes$[ebp]
  00424	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0
$LN33@make_lz_co@3:

; 485  : }

  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi
  0042e	5b		 pop	 ebx
  0042f	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00435	3b ec		 cmp	 ebp, esp
  00437	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0043c	8b e5		 mov	 esp, ebp
  0043e	5d		 pop	 ebp
  0043f	c3		 ret	 0
_make_lz_codes_hrust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@ ; `string'
PUBLIC	_get_lz_price_megalz
;	COMDAT ??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@
CONST	SEGMENT
??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@ DB 'mhmt-l'
	DB	'z.c:get_lz_price_megalz(): Found invalid code length=%d, disp'
	DB	'lacement=%d', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _get_lz_price_megalz
_TEXT	SEGMENT
_disp$ = -44						; size = 4
_length$ = -32						; size = 4
_varlen$ = -20						; size = 4
_varbits$ = -8						; size = 4
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_megalz PROC				; COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 514  : 	ULONG varbits,varlen;
; 515  : 	LONG length,disp;
; 516  : 
; 517  : 	length = lzcode->length;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d e0	 mov	 DWORD PTR _length$[ebp], ecx

; 518  : 	disp   = lzcode->disp;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d d4	 mov	 DWORD PTR _disp$[ebp], ecx

; 519  : 
; 520  : 	if( length==1 )

  0002f	83 7d e0 01	 cmp	 DWORD PTR _length$[ebp], 1
  00033	75 34		 jne	 SHORT $LN24@get_lz_pri

; 521  : 	{
; 522  : 		if( disp==0 )

  00035	83 7d d4 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00039	75 0c		 jne	 SHORT $LN23@get_lz_pri

; 523  : 			return 9;

  0003b	b8 09 00 00 00	 mov	 eax, 9
  00040	e9 36 01 00 00	 jmp	 $LN25@get_lz_pri
  00045	eb 1d		 jmp	 SHORT $LN22@get_lz_pri
$LN23@get_lz_pri:

; 524  : 		else if( (-8)<=disp && disp<=(-1) )

  00047	83 7d d4 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  0004b	7c 12		 jl	 SHORT $LN21@get_lz_pri
  0004d	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00051	7f 0c		 jg	 SHORT $LN21@get_lz_pri

; 525  : 			return 6;

  00053	b8 06 00 00 00	 mov	 eax, 6
  00058	e9 1e 01 00 00	 jmp	 $LN25@get_lz_pri

; 526  : 		else

  0005d	eb 05		 jmp	 SHORT $LN22@get_lz_pri
$LN21@get_lz_pri:

; 527  : 			goto INVALID_CODE_MEGALZ;

  0005f	e9 f6 00 00 00	 jmp	 $INVALID_CODE_MEGALZ$4796
$LN22@get_lz_pri:

; 528  : 	}
; 529  : 	else if( length==2 )

  00064	e9 12 01 00 00	 jmp	 $LN25@get_lz_pri
$LN24@get_lz_pri:
  00069	83 7d e0 02	 cmp	 DWORD PTR _length$[ebp], 2
  0006d	75 25		 jne	 SHORT $LN18@get_lz_pri

; 530  : 	{
; 531  : 		if( (-256)<=disp && disp<=(-1) )

  0006f	81 7d d4 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00076	7c 12		 jl	 SHORT $LN17@get_lz_pri
  00078	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  0007c	7f 0c		 jg	 SHORT $LN17@get_lz_pri

; 532  : 			return 11;

  0007e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00083	e9 f3 00 00 00	 jmp	 $LN25@get_lz_pri

; 533  : 		else

  00088	eb 05		 jmp	 SHORT $LN16@get_lz_pri
$LN17@get_lz_pri:

; 534  : 			goto INVALID_CODE_MEGALZ;

  0008a	e9 cb 00 00 00	 jmp	 $INVALID_CODE_MEGALZ$4796
$LN16@get_lz_pri:

; 535  : 	}
; 536  : 	else if( length==3 )

  0008f	e9 e7 00 00 00	 jmp	 $LN25@get_lz_pri
$LN18@get_lz_pri:
  00094	83 7d e0 03	 cmp	 DWORD PTR _length$[ebp], 3
  00098	75 43		 jne	 SHORT $LN14@get_lz_pri

; 537  : 	{
; 538  : 		if( (-256)<=disp && disp<=(-1) )

  0009a	81 7d d4 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  000a1	7c 12		 jl	 SHORT $LN13@get_lz_pri
  000a3	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  000a7	7f 0c		 jg	 SHORT $LN13@get_lz_pri

; 539  : 			return 12;

  000a9	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000ae	e9 c8 00 00 00	 jmp	 $LN25@get_lz_pri
  000b3	eb 23		 jmp	 SHORT $LN12@get_lz_pri
$LN13@get_lz_pri:

; 540  : 		else if( (-4352)<=disp && disp<(-256) )

  000b5	81 7d d4 00 ef
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -4352 ; ffffef00H
  000bc	7c 15		 jl	 SHORT $LN11@get_lz_pri
  000be	81 7d d4 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  000c5	7d 0c		 jge	 SHORT $LN11@get_lz_pri

; 541  : 			return 16;

  000c7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000cc	e9 aa 00 00 00	 jmp	 $LN25@get_lz_pri

; 542  : 		else

  000d1	eb 05		 jmp	 SHORT $LN12@get_lz_pri
$LN11@get_lz_pri:

; 543  : 			goto INVALID_CODE_MEGALZ;

  000d3	e9 82 00 00 00	 jmp	 $INVALID_CODE_MEGALZ$4796
$LN12@get_lz_pri:

; 544  : 	}
; 545  : 	else if( 4<=length && length<=255 )

  000d8	e9 9e 00 00 00	 jmp	 $LN25@get_lz_pri
$LN14@get_lz_pri:
  000dd	83 7d e0 04	 cmp	 DWORD PTR _length$[ebp], 4
  000e1	7c 77		 jl	 SHORT $INVALID_CODE_MEGALZ$4796
  000e3	81 7d e0 ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  000ea	7f 6e		 jg	 SHORT $INVALID_CODE_MEGALZ$4796

; 546  : 	{
; 547  : 		varlen = 0;

  000ec	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 0

; 548  : 		varbits = (length-2)>>1;

  000f3	8b 45 e0	 mov	 eax, DWORD PTR _length$[ebp]
  000f6	83 e8 02	 sub	 eax, 2
  000f9	d1 f8		 sar	 eax, 1
  000fb	89 45 f8	 mov	 DWORD PTR _varbits$[ebp], eax
$LN7@get_lz_pri:

; 549  : 		while( varbits )

  000fe	83 7d f8 00	 cmp	 DWORD PTR _varbits$[ebp], 0
  00102	74 13		 je	 SHORT $LN6@get_lz_pri

; 550  : 		{
; 551  : 			varbits >>= 1;

  00104	8b 45 f8	 mov	 eax, DWORD PTR _varbits$[ebp]
  00107	d1 e8		 shr	 eax, 1
  00109	89 45 f8	 mov	 DWORD PTR _varbits$[ebp], eax

; 552  : 			varlen+=2;

  0010c	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  0010f	83 c0 02	 add	 eax, 2
  00112	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 553  : 		}

  00115	eb e7		 jmp	 SHORT $LN7@get_lz_pri
$LN6@get_lz_pri:

; 554  : 
; 555  : 		if( (-256)<=disp && disp<=(-1) )

  00117	81 7d d4 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  0011e	7c 11		 jl	 SHORT $LN5@get_lz_pri
  00120	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00124	7f 0b		 jg	 SHORT $LN5@get_lz_pri

; 556  : 			varlen += 9;

  00126	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  00129	83 c0 09	 add	 eax, 9
  0012c	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax
  0012f	eb 1f		 jmp	 SHORT $LN4@get_lz_pri
$LN5@get_lz_pri:

; 557  : 		else if( (-4352)<=disp && disp<(-256) )

  00131	81 7d d4 00 ef
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -4352 ; ffffef00H
  00138	7c 14		 jl	 SHORT $LN3@get_lz_pri
  0013a	81 7d d4 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00141	7d 0b		 jge	 SHORT $LN3@get_lz_pri

; 558  : 			varlen += 13;

  00143	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  00146	83 c0 0d	 add	 eax, 13			; 0000000dH
  00149	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 559  : 		else

  0014c	eb 02		 jmp	 SHORT $LN4@get_lz_pri
$LN3@get_lz_pri:

; 560  : 			goto INVALID_CODE_MEGALZ;

  0014e	eb 0a		 jmp	 SHORT $INVALID_CODE_MEGALZ$4796
$LN4@get_lz_pri:

; 561  : 
; 562  : 		return varlen+3;

  00150	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  00153	83 c0 03	 add	 eax, 3
  00156	eb 23		 jmp	 SHORT $LN25@get_lz_pri

; 563  : 	}
; 564  : 	else

  00158	eb 21		 jmp	 SHORT $LN25@get_lz_pri
$INVALID_CODE_MEGALZ$4796:

; 565  : 	{
; 566  : INVALID_CODE_MEGALZ:
; 567  : 		printf("mhmt-lz.c:get_lz_price_megalz(): Found invalid code length=%d, displacement=%d\n",length, disp);

  0015a	8b f4		 mov	 esi, esp
  0015c	8b 45 d4	 mov	 eax, DWORD PTR _disp$[ebp]
  0015f	50		 push	 eax
  00160	8b 4d e0	 mov	 ecx, DWORD PTR _length$[ebp]
  00163	51		 push	 ecx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00172	3b f4		 cmp	 esi, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 568  : 		return 0;

  00179	33 c0		 xor	 eax, eax
$LN25@get_lz_pri:

; 569  : 	}
; 570  : }

  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00184	3b ec		 cmp	 ebp, esp
  00186	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
_get_lz_price_megalz ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@ ; `string'
PUBLIC	_get_lz_price_hrum
;	COMDAT ??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@
CONST	SEGMENT
??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@ DB 'mhmt-'
	DB	'lz.c:get_lz_price_hrum(): Found invalid code length=%d, displ'
	DB	'acement=%d', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _get_lz_price_hrum
_TEXT	SEGMENT
_disp$ = -32						; size = 4
_length$ = -20						; size = 4
_varlen$ = -8						; size = 4
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_hrum PROC					; COMDAT

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 575  : 	ULONG varlen;
; 576  : 	LONG length,disp;
; 577  : 
; 578  : 	length = lzcode->length;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d ec	 mov	 DWORD PTR _length$[ebp], ecx

; 579  : 	disp   = lzcode->disp;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d e0	 mov	 DWORD PTR _disp$[ebp], ecx

; 580  : 
; 581  : 	if( length==1 )

  0002f	83 7d ec 01	 cmp	 DWORD PTR _length$[ebp], 1
  00033	75 34		 jne	 SHORT $LN22@get_lz_pri@2

; 582  : 	{
; 583  : 		if( disp==0 )

  00035	83 7d e0 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00039	75 0c		 jne	 SHORT $LN21@get_lz_pri@2

; 584  : 			return 9;

  0003b	b8 09 00 00 00	 mov	 eax, 9
  00040	e9 26 01 00 00	 jmp	 $LN23@get_lz_pri@2
  00045	eb 1d		 jmp	 SHORT $LN20@get_lz_pri@2
$LN21@get_lz_pri@2:

; 585  : 		else if( (-8)<=disp && disp<=(-1) )

  00047	83 7d e0 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  0004b	7c 12		 jl	 SHORT $LN19@get_lz_pri@2
  0004d	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00051	7f 0c		 jg	 SHORT $LN19@get_lz_pri@2

; 586  : 			return 6;

  00053	b8 06 00 00 00	 mov	 eax, 6
  00058	e9 0e 01 00 00	 jmp	 $LN23@get_lz_pri@2

; 587  : 		else

  0005d	eb 05		 jmp	 SHORT $LN20@get_lz_pri@2
$LN19@get_lz_pri@2:

; 588  : 			goto INVALID_CODE_HRUM;

  0005f	e9 e6 00 00 00	 jmp	 $INVALID_CODE_HRUM$4831
$LN20@get_lz_pri@2:

; 589  : 	}
; 590  : 	else if( length==2 )

  00064	e9 02 01 00 00	 jmp	 $LN23@get_lz_pri@2
$LN22@get_lz_pri@2:
  00069	83 7d ec 02	 cmp	 DWORD PTR _length$[ebp], 2
  0006d	75 25		 jne	 SHORT $LN16@get_lz_pri@2

; 591  : 	{
; 592  : 		if( (-256)<=disp && disp<=(-1) )

  0006f	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00076	7c 12		 jl	 SHORT $LN15@get_lz_pri@2
  00078	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  0007c	7f 0c		 jg	 SHORT $LN15@get_lz_pri@2

; 593  : 			return 11;

  0007e	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00083	e9 e3 00 00 00	 jmp	 $LN23@get_lz_pri@2

; 594  : 		else

  00088	eb 05		 jmp	 SHORT $LN14@get_lz_pri@2
$LN15@get_lz_pri@2:

; 595  : 			goto INVALID_CODE_HRUM;

  0008a	e9 bb 00 00 00	 jmp	 $INVALID_CODE_HRUM$4831
$LN14@get_lz_pri@2:

; 596  : 	}
; 597  : 	else if (3<=length && length<=255)

  0008f	e9 d7 00 00 00	 jmp	 $LN23@get_lz_pri@2
$LN16@get_lz_pri@2:
  00094	83 7d ec 03	 cmp	 DWORD PTR _length$[ebp], 3
  00098	0f 8c ac 00 00
	00		 jl	 $INVALID_CODE_HRUM$4831
  0009e	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  000a5	0f 8f 9f 00 00
	00		 jg	 $INVALID_CODE_HRUM$4831

; 598  : 	{
; 599  : 		varlen = 3;

  000ab	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 3

; 600  : 
; 601  : 		if( 4<=length && length<=15 )

  000b2	83 7d ec 04	 cmp	 DWORD PTR _length$[ebp], 4
  000b6	7c 3c		 jl	 SHORT $LN11@get_lz_pri@2
  000b8	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  000bc	7f 36		 jg	 SHORT $LN11@get_lz_pri@2

; 602  : 		{
; 603  : 			varlen = 5;

  000be	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 5

; 604  : 			if( length>=6 ) varlen += 2;

  000c5	83 7d ec 06	 cmp	 DWORD PTR _length$[ebp], 6
  000c9	7c 09		 jl	 SHORT $LN10@get_lz_pri@2
  000cb	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  000ce	83 c0 02	 add	 eax, 2
  000d1	89 45 f8	 mov	 DWORD PTR _varlen$[ebp], eax
$LN10@get_lz_pri@2:

; 605  : 			if( length>=9 ) varlen += 2;

  000d4	83 7d ec 09	 cmp	 DWORD PTR _length$[ebp], 9
  000d8	7c 09		 jl	 SHORT $LN9@get_lz_pri@2
  000da	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  000dd	83 c0 02	 add	 eax, 2
  000e0	89 45 f8	 mov	 DWORD PTR _varlen$[ebp], eax
$LN9@get_lz_pri@2:

; 606  : 			if( length>=12) varlen += 2;

  000e3	83 7d ec 0c	 cmp	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  000e7	7c 09		 jl	 SHORT $LN8@get_lz_pri@2
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  000ec	83 c0 02	 add	 eax, 2
  000ef	89 45 f8	 mov	 DWORD PTR _varlen$[ebp], eax
$LN8@get_lz_pri@2:

; 607  : 		}
; 608  : 		else if( 15<length && length<=255 )

  000f2	eb 16		 jmp	 SHORT $LN7@get_lz_pri@2
$LN11@get_lz_pri@2:
  000f4	83 7d ec 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  000f8	7e 10		 jle	 SHORT $LN7@get_lz_pri@2
  000fa	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 255 ; 000000ffH
  00101	7f 07		 jg	 SHORT $LN7@get_lz_pri@2

; 609  : 		{
; 610  : 			varlen = 13;

  00103	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 13 ; 0000000dH
$LN7@get_lz_pri@2:

; 611  : 		}
; 612  : 
; 613  : 		if( (-256)<=disp && disp<=(-1) )

  0010a	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00111	7c 11		 jl	 SHORT $LN5@get_lz_pri@2
  00113	83 7d e0 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00117	7f 0b		 jg	 SHORT $LN5@get_lz_pri@2

; 614  : 			varlen += 9;

  00119	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  0011c	83 c0 09	 add	 eax, 9
  0011f	89 45 f8	 mov	 DWORD PTR _varlen$[ebp], eax
  00122	eb 1f		 jmp	 SHORT $LN4@get_lz_pri@2
$LN5@get_lz_pri@2:

; 615  : 		else if( (-4096)<=disp && disp<(-256) )

  00124	81 7d e0 00 f0
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -4096 ; fffff000H
  0012b	7c 14		 jl	 SHORT $LN3@get_lz_pri@2
  0012d	81 7d e0 00 ff
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -256 ; ffffff00H
  00134	7d 0b		 jge	 SHORT $LN3@get_lz_pri@2

; 616  : 			varlen += 13;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  00139	83 c0 0d	 add	 eax, 13			; 0000000dH
  0013c	89 45 f8	 mov	 DWORD PTR _varlen$[ebp], eax

; 617  : 		else

  0013f	eb 02		 jmp	 SHORT $LN4@get_lz_pri@2
$LN3@get_lz_pri@2:

; 618  : 			goto INVALID_CODE_HRUM;

  00141	eb 07		 jmp	 SHORT $INVALID_CODE_HRUM$4831
$LN4@get_lz_pri@2:

; 619  : 
; 620  : 		return varlen;

  00143	8b 45 f8	 mov	 eax, DWORD PTR _varlen$[ebp]
  00146	eb 23		 jmp	 SHORT $LN23@get_lz_pri@2

; 621  : 	}
; 622  : 	else

  00148	eb 21		 jmp	 SHORT $LN23@get_lz_pri@2
$INVALID_CODE_HRUM$4831:

; 623  : 	{
; 624  : INVALID_CODE_HRUM:
; 625  : 		printf("mhmt-lz.c:get_lz_price_hrum(): Found invalid code length=%d, displacement=%d\n",length, disp);

  0014a	8b f4		 mov	 esi, esp
  0014c	8b 45 e0	 mov	 eax, DWORD PTR _disp$[ebp]
  0014f	50		 push	 eax
  00150	8b 4d ec	 mov	 ecx, DWORD PTR _length$[ebp]
  00153	51		 push	 ecx
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	3b f4		 cmp	 esi, esp
  00164	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 626  : 		return 0;

  00169	33 c0		 xor	 eax, eax
$LN23@get_lz_pri@2:

; 627  : 	}
; 628  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00174	3b ec		 cmp	 ebp, esp
  00176	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
_get_lz_price_hrum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@ ; `string'
PUBLIC	_get_lz_price_hrust
;	COMDAT ??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@
CONST	SEGMENT
??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@ DB 'mhmt-'
	DB	'lz.c:get_lz_price_hrust(): Found invalid code length=%d, disp'
	DB	'lacement=%d', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _get_lz_price_hrust
_TEXT	SEGMENT
_tmp$ = -56						; size = 4
_disp$ = -44						; size = 4
_length$ = -32						; size = 4
_varlen$ = -20						; size = 4
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_hrust PROC				; COMDAT

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 642  : 	ULONG varbits,varlen;
; 643  : 	LONG length,disp,tmp;
; 644  : 
; 645  : 	length = lzcode->length;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d e0	 mov	 DWORD PTR _length$[ebp], ecx

; 646  : 	disp   = lzcode->disp;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _lzcode$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d d4	 mov	 DWORD PTR _disp$[ebp], ecx

; 647  : 
; 648  : 
; 649  : 	if( disp==0 )

  0002f	83 7d d4 00	 cmp	 DWORD PTR _disp$[ebp], 0
  00033	75 41		 jne	 SHORT $LN38@get_lz_pri@3

; 650  : 	{
; 651  : 		if( length==1 )

  00035	83 7d e0 01	 cmp	 DWORD PTR _length$[ebp], 1
  00039	75 0c		 jne	 SHORT $LN37@get_lz_pri@3

; 652  : 		{
; 653  : 			return 9; // copy-1-byte

  0003b	b8 09 00 00 00	 mov	 eax, 9
  00040	e9 e0 01 00 00	 jmp	 $LN39@get_lz_pri@3
  00045	eb 2a		 jmp	 SHORT $LN36@get_lz_pri@3
$LN37@get_lz_pri@3:

; 654  : 		}
; 655  : 		else if( (12<=length) && (length<=42) && ( !(length&1) ) )

  00047	83 7d e0 0c	 cmp	 DWORD PTR _length$[ebp], 12 ; 0000000cH
  0004b	7c 1f		 jl	 SHORT $LN35@get_lz_pri@3
  0004d	83 7d e0 2a	 cmp	 DWORD PTR _length$[ebp], 42 ; 0000002aH
  00051	7f 19		 jg	 SHORT $LN35@get_lz_pri@3
  00053	8b 45 e0	 mov	 eax, DWORD PTR _length$[ebp]
  00056	83 e0 01	 and	 eax, 1
  00059	75 11		 jne	 SHORT $LN35@get_lz_pri@3

; 656  : 		{
; 657  : 			return 11 + 8*length;

  0005b	8b 45 e0	 mov	 eax, DWORD PTR _length$[ebp]
  0005e	8d 04 c5 0b 00
	00 00		 lea	 eax, DWORD PTR [eax*8+11]
  00065	e9 bb 01 00 00	 jmp	 $LN39@get_lz_pri@3

; 658  : 		}
; 659  : 		else

  0006a	eb 05		 jmp	 SHORT $LN36@get_lz_pri@3
$LN35@get_lz_pri@3:

; 660  : 			goto INVALID_CODE_HRUST;

  0006c	e9 93 01 00 00	 jmp	 $INVALID_CODE_HRUST$4865
$LN36@get_lz_pri@3:

; 661  : 	}
; 662  : 	else if( length==(-3) ) // insertion match!

  00071	e9 af 01 00 00	 jmp	 $LN39@get_lz_pri@3
$LN38@get_lz_pri@3:
  00076	83 7d e0 fd	 cmp	 DWORD PTR _length$[ebp], -3 ; fffffffdH
  0007a	75 3a		 jne	 SHORT $LN32@get_lz_pri@3

; 663  : 	{
; 664  : 		if( (-16)<=disp && disp<=(-1) )

  0007c	83 7d d4 f0	 cmp	 DWORD PTR _disp$[ebp], -16 ; fffffff0H
  00080	7c 12		 jl	 SHORT $LN31@get_lz_pri@3
  00082	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00086	7f 0c		 jg	 SHORT $LN31@get_lz_pri@3

; 665  : 		{
; 666  : 			return 10+8;

  00088	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  0008d	e9 93 01 00 00	 jmp	 $LN39@get_lz_pri@3
  00092	eb 1d		 jmp	 SHORT $LN30@get_lz_pri@3
$LN31@get_lz_pri@3:

; 667  : 		}
; 668  : 		else if( (-79)<=disp && disp<(-16) )

  00094	83 7d d4 b1	 cmp	 DWORD PTR _disp$[ebp], -79 ; ffffffb1H
  00098	7c 12		 jl	 SHORT $LN29@get_lz_pri@3
  0009a	83 7d d4 f0	 cmp	 DWORD PTR _disp$[ebp], -16 ; fffffff0H
  0009e	7d 0c		 jge	 SHORT $LN29@get_lz_pri@3

; 669  : 		{
; 670  : 			return 5+8+8;

  000a0	b8 15 00 00 00	 mov	 eax, 21			; 00000015H
  000a5	e9 7b 01 00 00	 jmp	 $LN39@get_lz_pri@3

; 671  : 		}
; 672  : 		else

  000aa	eb 05		 jmp	 SHORT $LN30@get_lz_pri@3
$LN29@get_lz_pri@3:

; 673  : 			goto INVALID_CODE_HRUST;

  000ac	e9 53 01 00 00	 jmp	 $INVALID_CODE_HRUST$4865
$LN30@get_lz_pri@3:

; 674  : 	}
; 675  : 	else if( length==1 )

  000b1	e9 6f 01 00 00	 jmp	 $LN39@get_lz_pri@3
$LN32@get_lz_pri@3:
  000b6	83 7d e0 01	 cmp	 DWORD PTR _length$[ebp], 1
  000ba	75 22		 jne	 SHORT $LN26@get_lz_pri@3

; 676  : 	{
; 677  : 		if( (-8)<=disp && disp<=(-1) )

  000bc	83 7d d4 f8	 cmp	 DWORD PTR _disp$[ebp], -8 ; fffffff8H
  000c0	7c 12		 jl	 SHORT $LN25@get_lz_pri@3
  000c2	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  000c6	7f 0c		 jg	 SHORT $LN25@get_lz_pri@3

; 678  : 			return 6;

  000c8	b8 06 00 00 00	 mov	 eax, 6
  000cd	e9 53 01 00 00	 jmp	 $LN39@get_lz_pri@3

; 679  : 		else

  000d2	eb 05		 jmp	 SHORT $LN24@get_lz_pri@3
$LN25@get_lz_pri@3:

; 680  : 			goto INVALID_CODE_HRUST;

  000d4	e9 2b 01 00 00	 jmp	 $INVALID_CODE_HRUST$4865
$LN24@get_lz_pri@3:

; 681  : 	}
; 682  : 	else if( length==2 )

  000d9	e9 47 01 00 00	 jmp	 $LN39@get_lz_pri@3
$LN26@get_lz_pri@3:
  000de	83 7d e0 02	 cmp	 DWORD PTR _length$[ebp], 2
  000e2	75 3d		 jne	 SHORT $LN22@get_lz_pri@3

; 683  : 	{
; 684  : 		if( (-32)<=disp && disp<=(-1) )

  000e4	83 7d d4 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  000e8	7c 12		 jl	 SHORT $LN21@get_lz_pri@3
  000ea	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  000ee	7f 0c		 jg	 SHORT $LN21@get_lz_pri@3

; 685  : 		{
; 686  : 			return 10;

  000f0	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000f5	e9 2b 01 00 00	 jmp	 $LN39@get_lz_pri@3
  000fa	eb 20		 jmp	 SHORT $LN20@get_lz_pri@3
$LN21@get_lz_pri@3:

; 687  : 		}
; 688  : 		else if( (-768)<=disp && disp<(-32) )

  000fc	81 7d d4 00 fd
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -768 ; fffffd00H
  00103	7c 12		 jl	 SHORT $LN19@get_lz_pri@3
  00105	83 7d d4 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  00109	7d 0c		 jge	 SHORT $LN19@get_lz_pri@3

; 689  : 		{
; 690  : 			return 13;

  0010b	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00110	e9 10 01 00 00	 jmp	 $LN39@get_lz_pri@3

; 691  : 		}
; 692  : 		else

  00115	eb 05		 jmp	 SHORT $LN20@get_lz_pri@3
$LN19@get_lz_pri@3:

; 693  : 			goto INVALID_CODE_HRUST;

  00117	e9 e8 00 00 00	 jmp	 $INVALID_CODE_HRUST$4865
$LN20@get_lz_pri@3:

; 694  : 	}
; 695  : 	else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )

  0011c	e9 04 01 00 00	 jmp	 $LN39@get_lz_pri@3
$LN22@get_lz_pri@3:
  00121	83 7d e0 03	 cmp	 DWORD PTR _length$[ebp], 3
  00125	0f 8c d9 00 00
	00		 jl	 $INVALID_CODE_HRUST$4865
  0012b	81 7d e0 ff 0e
	00 00		 cmp	 DWORD PTR _length$[ebp], 3839 ; 00000effH
  00132	0f 8f cc 00 00
	00		 jg	 $INVALID_CODE_HRUST$4865
  00138	81 7d d4 00 00
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -65536 ; ffff0000H
  0013f	0f 8c bf 00 00
	00		 jl	 $INVALID_CODE_HRUST$4865
  00145	83 7d d4 ff	 cmp	 DWORD PTR _disp$[ebp], -1
  00149	0f 8f b5 00 00
	00		 jg	 $INVALID_CODE_HRUST$4865

; 696  : 	{
; 697  : 		// first, calc influence of length
; 698  : 		if( length<=15 ) // 3..15

  0014f	83 7d e0 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00153	7f 2e		 jg	 SHORT $LN15@get_lz_pri@3

; 699  : 		{
; 700  : 			varlen = 3 + ( (length/3)<<1 );

  00155	8b 45 e0	 mov	 eax, DWORD PTR _length$[ebp]
  00158	99		 cdq
  00159	b9 03 00 00 00	 mov	 ecx, 3
  0015e	f7 f9		 idiv	 ecx
  00160	8d 54 00 03	 lea	 edx, DWORD PTR [eax+eax+3]
  00164	89 55 ec	 mov	 DWORD PTR _varlen$[ebp], edx

; 701  : 
; 702  : 			if( length==3 )  varlen = 3;

  00167	83 7d e0 03	 cmp	 DWORD PTR _length$[ebp], 3
  0016b	75 07		 jne	 SHORT $LN14@get_lz_pri@3
  0016d	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 3
$LN14@get_lz_pri@3:

; 703  : 
; 704  : 			if( length==15 ) varlen = 11;

  00174	83 7d e0 0f	 cmp	 DWORD PTR _length$[ebp], 15 ; 0000000fH
  00178	75 07		 jne	 SHORT $LN13@get_lz_pri@3
  0017a	c7 45 ec 0b 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 11 ; 0000000bH
$LN13@get_lz_pri@3:

; 705  : 		}
; 706  : 		else if( length<=127 ) // 16..127

  00181	eb 16		 jmp	 SHORT $LN12@get_lz_pri@3
$LN15@get_lz_pri@3:
  00183	83 7d e0 7f	 cmp	 DWORD PTR _length$[ebp], 127 ; 0000007fH
  00187	7f 09		 jg	 SHORT $LN11@get_lz_pri@3

; 707  : 		{
; 708  : 			varlen = 14;

  00189	c7 45 ec 0e 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 14 ; 0000000eH

; 709  : 		}
; 710  : 		else // 128..3839

  00190	eb 07		 jmp	 SHORT $LN12@get_lz_pri@3
$LN11@get_lz_pri@3:

; 711  : 		{
; 712  : 			varlen = 14+8;

  00192	c7 45 ec 16 00
	00 00		 mov	 DWORD PTR _varlen$[ebp], 22 ; 00000016H
$LN12@get_lz_pri@3:

; 713  : 		}
; 714  : 
; 715  : 
; 716  : 		// add displacement length
; 717  : 		if( (-32)<=disp ) // ffe0..ffff

  00199	83 7d d4 e0	 cmp	 DWORD PTR _disp$[ebp], -32 ; ffffffe0H
  0019d	7c 0b		 jl	 SHORT $LN9@get_lz_pri@3

; 718  : 		{
; 719  : 			varlen += 7;

  0019f	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  001a2	83 c0 07	 add	 eax, 7
  001a5	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax
  001a8	eb 53		 jmp	 SHORT $LN8@get_lz_pri@3
$LN9@get_lz_pri@3:

; 720  : 		}
; 721  : 		else if( (-512)<=disp ) // fe00..ffdf

  001aa	81 7d d4 00 fe
	ff ff		 cmp	 DWORD PTR _disp$[ebp], -512 ; fffffe00H
  001b1	7c 0b		 jl	 SHORT $LN7@get_lz_pri@3

; 722  : 		{
; 723  : 			varlen += 10;

  001b3	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  001b6	83 c0 0a	 add	 eax, 10			; 0000000aH
  001b9	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 724  : 		}
; 725  : 		else // 0000(-65536)..fdff: -513:-1024, -1025:-2048, -2049:-4096, ... ,-32769:-65536

  001bc	eb 3f		 jmp	 SHORT $LN8@get_lz_pri@3
$LN7@get_lz_pri@3:

; 726  : 		{    // bits:                   12           13           14               18
; 727  : 
; 728  : 			varlen += 12;

  001be	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  001c1	83 c0 0c	 add	 eax, 12			; 0000000cH
  001c4	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 729  : 
; 730  : 			if( position>32768 )

  001c7	81 7d 08 00 80
	00 00		 cmp	 DWORD PTR _position$[ebp], 32768 ; 00008000H
  001ce	76 0b		 jbe	 SHORT $LN5@get_lz_pri@3

; 731  : 			{
; 732  : 				varlen += 6; // 8bits

  001d0	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  001d3	83 c0 06	 add	 eax, 6
  001d6	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 733  : 			}
; 734  : 			else

  001d9	eb 22		 jmp	 SHORT $LN8@get_lz_pri@3
$LN5@get_lz_pri@3:

; 735  : 			{
; 736  : 				tmp = 1024;

  001db	c7 45 c8 00 04
	00 00		 mov	 DWORD PTR _tmp$[ebp], 1024 ; 00000400H
$LN3@get_lz_pri@3:

; 737  : 
; 738  : 				while( position>(ULONG)tmp )

  001e2	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  001e5	3b 45 c8	 cmp	 eax, DWORD PTR _tmp$[ebp]
  001e8	76 13		 jbe	 SHORT $LN8@get_lz_pri@3

; 739  : 				{
; 740  : 					varlen++;

  001ea	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  001ed	83 c0 01	 add	 eax, 1
  001f0	89 45 ec	 mov	 DWORD PTR _varlen$[ebp], eax

; 741  : 
; 742  : 					tmp <<= 1;

  001f3	8b 45 c8	 mov	 eax, DWORD PTR _tmp$[ebp]
  001f6	d1 e0		 shl	 eax, 1
  001f8	89 45 c8	 mov	 DWORD PTR _tmp$[ebp], eax

; 743  : 				}

  001fb	eb e5		 jmp	 SHORT $LN3@get_lz_pri@3
$LN8@get_lz_pri@3:

; 744  : 			}
; 745  : 		}
; 746  : 
; 747  : 		return varlen;

  001fd	8b 45 ec	 mov	 eax, DWORD PTR _varlen$[ebp]
  00200	eb 23		 jmp	 SHORT $LN39@get_lz_pri@3

; 748  : 	}
; 749  : 	else

  00202	eb 21		 jmp	 SHORT $LN39@get_lz_pri@3
$INVALID_CODE_HRUST$4865:

; 750  : 	{
; 751  : INVALID_CODE_HRUST:
; 752  : 		printf("mhmt-lz.c:get_lz_price_hrust(): Found invalid code length=%d, displacement=%d\n",length, disp);

  00204	8b f4		 mov	 esi, esp
  00206	8b 45 d4	 mov	 eax, DWORD PTR _disp$[ebp]
  00209	50		 push	 eax
  0020a	8b 4d e0	 mov	 ecx, DWORD PTR _length$[ebp]
  0020d	51		 push	 ecx
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00219	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 753  : 		return 0;

  00223	33 c0		 xor	 eax, eax
$LN39@get_lz_pri@3:

; 754  : 	}
; 755  : }

  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	5b		 pop	 ebx
  00228	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0022e	3b ec		 cmp	 ebp, esp
  00230	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00235	8b e5		 mov	 esp, ebp
  00237	5d		 pop	 ebp
  00238	c3		 ret	 0
_get_lz_price_hrust ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_dump_config
PUBLIC	_do_files
PUBLIC	??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@ ; `string'
PUBLIC	_show_help
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@ ; `string'
PUBLIC	_main
EXTRN	_free_globals:PROC
EXTRN	_pack:PROC
EXTRN	_depack:PROC
EXTRN	_wrk:BYTE
EXTRN	_parse_args:PROC
EXTRN	__imp__printf:PROC
EXTRN	_init_globals:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@
; File d:\d\mhmt\src\mhmt-main.c
CONST	SEGMENT
??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@ DB 'There were'
	DB	' errors in arguments.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@
CONST	SEGMENT
??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@ DB 'mhmt - '
	DB	'MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_parse_result$ = -20					; size = 4
_error$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 18   : 	int error=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _error$[ebp], 0

; 19   : 	ULONG parse_result;
; 20   : 
; 21   : 
; 22   : 	init_globals();

  00025	e8 00 00 00 00	 call	 _init_globals

; 23   : 
; 24   : 
; 25   : 	// printf short info
; 26   : 	printf("mhmt - MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc\n\n");

  0002a	8b f4		 mov	 esi, esp
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00037	83 c4 04	 add	 esp, 4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 27   : 
; 28   : 	// parse arguments
; 29   : 	parse_result = parse_args(argc, argv);

  00041	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _argc$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _parse_args
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 ec	 mov	 DWORD PTR _parse_result$[ebp], eax

; 30   : 
; 31   : 	if( parse_result&ARG_PARSER_SHOWHELP )

  00054	8b 45 ec	 mov	 eax, DWORD PTR _parse_result$[ebp]
  00057	83 e0 01	 and	 eax, 1
  0005a	74 26		 je	 SHORT $LN9@main

; 32   : 	{
; 33   : 		if( parse_result&ARG_PARSER_ERROR )

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _parse_result$[ebp]
  0005f	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00064	74 17		 je	 SHORT $LN8@main

; 34   : 			printf("\n");

  00066	8b f4		 mov	 esi, esp
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00073	83 c4 04	 add	 esp, 4
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@main:

; 35   : 
; 36   : 		show_help();

  0007d	e8 00 00 00 00	 call	 _show_help
$LN9@main:

; 37   : 	}
; 38   : 
; 39   : 	if( parse_result&ARG_PARSER_ERROR )

  00082	8b 45 ec	 mov	 eax, DWORD PTR _parse_result$[ebp]
  00085	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0008a	74 22		 je	 SHORT $LN7@main

; 40   : 	{
; 41   : 		printf("There were errors in arguments.\n");

  0008c	8b f4		 mov	 esi, esp
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00099	83 c4 04	 add	 esp, 4
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 42   : 		error++;

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _error$[ebp]
  000a6	83 c0 01	 add	 eax, 1
  000a9	89 45 f8	 mov	 DWORD PTR _error$[ebp], eax
  000ac	eb 50		 jmp	 SHORT $LN6@main
$LN7@main:

; 43   : 	}
; 44   : 	else if( parse_result&ARG_PARSER_GO )

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _parse_result$[ebp]
  000b1	83 e0 02	 and	 eax, 2
  000b4	74 48		 je	 SHORT $LN6@main

; 45   : 	{
; 46   : 		if( do_files() )

  000b6	e8 00 00 00 00	 call	 _do_files
  000bb	85 c0		 test	 eax, eax
  000bd	74 36		 je	 SHORT $LN4@main

; 47   : 		{
; 48   : 			dump_config();

  000bf	e8 00 00 00 00	 call	 _dump_config

; 49   : 			if( wrk.mode )

  000c4	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _wrk+8, 0
  000cb	74 14		 je	 SHORT $LN3@main

; 50   : 			{
; 51   : 				error += depack() ? 0 : 1;

  000cd	e8 00 00 00 00	 call	 _depack
  000d2	f7 d8		 neg	 eax
  000d4	1b c0		 sbb	 eax, eax
  000d6	83 c0 01	 add	 eax, 1
  000d9	03 45 f8	 add	 eax, DWORD PTR _error$[ebp]
  000dc	89 45 f8	 mov	 DWORD PTR _error$[ebp], eax

; 52   : 			}
; 53   : 			else

  000df	eb 12		 jmp	 SHORT $LN2@main
$LN3@main:

; 54   : 			{
; 55   : 				error += pack() ? 0 : 1;

  000e1	e8 00 00 00 00	 call	 _pack
  000e6	f7 d8		 neg	 eax
  000e8	1b c0		 sbb	 eax, eax
  000ea	83 c0 01	 add	 eax, 1
  000ed	03 45 f8	 add	 eax, DWORD PTR _error$[ebp]
  000f0	89 45 f8	 mov	 DWORD PTR _error$[ebp], eax
$LN2@main:

; 56   : 			}
; 57   : 		}
; 58   : 		else

  000f3	eb 09		 jmp	 SHORT $LN6@main
$LN4@main:

; 59   : 		{
; 60   : 			error++;

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _error$[ebp]
  000f8	83 c0 01	 add	 eax, 1
  000fb	89 45 f8	 mov	 DWORD PTR _error$[ebp], eax
$LN6@main:

; 61   : 		}
; 62   : 	}
; 63   : 
; 64   : 
; 65   : 
; 66   : 	free_globals();

  000fe	e8 00 00 00 00	 call	 _free_globals

; 67   : 
; 68   : 	return error;

  00103	8b 45 f8	 mov	 eax, DWORD PTR _error$[ebp]

; 69   : }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0010f	3b ec		 cmp	 ebp, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ ; `string'
PUBLIC	??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@ ; `string'
PUBLIC	??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@ ; `string'
PUBLIC	??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@ ; `string'
PUBLIC	??_C@_07JELMINIL@usage?3?6?$AA@			; `string'
PUBLIC	??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@ ; `string'
PUBLIC	??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@ ; `string'
PUBLIC	??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@ ; `string'
PUBLIC	??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@ ; `string'
PUBLIC	??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@ ; `string'
PUBLIC	??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@ ; `string'
PUBLIC	??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@ ; `string'
PUBLIC	??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@ ; `string'
PUBLIC	??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@ ; `string'
PUBLIC	??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@ ; `string'
PUBLIC	??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@ ; `string'
PUBLIC	??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@ ; `string'
PUBLIC	??_C@_0N@DNFBPHAO@parameters?3?6?$AA@		; `string'
PUBLIC	??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ ; `string'
;	COMDAT ??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ DB '='
	DB	'===== mhmt help end ======', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@
CONST	SEGMENT
??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@ DB 'in accordanc'
	DB	'e with format chosen; for depacking ".dpk" is appended', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@
CONST	SEGMENT
??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@ DB 'if no outpu'
	DB	't filename given, filename is appended with ".mlz", ".hrm" or'
	DB	' ".hst"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@
CONST	SEGMENT
??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@ DB 'mhm'
	DB	't [parameter list] <input filename> [<output filename>]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07JELMINIL@usage?3?6?$AA@
CONST	SEGMENT
??_C@_07JELMINIL@usage?3?6?$AA@ DB 'usage:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@
CONST	SEGMENT
??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@ DB ' '
	DB	'          For given format, window can''t be greater than def'
	DB	'ault value', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@
CONST	SEGMENT
??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@ DB '  '
	DB	'         maximum window: MegaLZ is 4352, hrum is 4096, hrust '
	DB	'is 65536.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@
CONST	SEGMENT
??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@ DB ' '
	DB	'          256,512,1024,2048,4096,8192,16384,32768. Default is'
	DB	' format-specific', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@
CONST	SEGMENT
??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@ DB '-maxwinN -'
	DB	' maximum lookback window. N is decimal number, which can only'
	DB	' be', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@
CONST	SEGMENT
??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@ DB '-bend '
	DB	'- if -16 specified, this makes words big-endian. Default is l'
	DB	'ittle-endian.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@
CONST	SEGMENT
??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@ DB '  '
	DB	'        Default for MegaLZ is -8, for hrum and hrust is -16.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@
CONST	SEGMENT
??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@ DB '-8, -'
	DB	'16 - bitstream is in bytes or words in packed file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@ DB '     '
	DB	'  NO -mlz is forced.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@
CONST	SEGMENT
??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@ DB '      '
	DB	' Not applicable for MegaLZ. If -zxh is specified, -16, NO -be'
	DB	'nd and', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@
CONST	SEGMENT
??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@ DB '-zxh - u'
	DB	'se zx-specific header for hrum or hrust. DEFAULT is NO HEADER'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@
CONST	SEGMENT
??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@ DB '-d - depa'
	DB	'cking instead of packing (default is packing)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@
CONST	SEGMENT
??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@ DB '-g - '
	DB	'greedy coding (default is optimal coding)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@
CONST	SEGMENT
??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@ DB '-ml'
	DB	'z, -hrm, -hst - use MegaLZ, hrum3.5 or hrust1.x format (defau'
	DB	'lt is MegaLZ)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNFBPHAO@parameters?3?6?$AA@
CONST	SEGMENT
??_C@_0N@DNFBPHAO@parameters?3?6?$AA@ DB 'parameters:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ DB '='
	DB	'======= mhmt help ========', 0aH, 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _show_help
_TEXT	SEGMENT
_show_help PROC						; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 73   : 	printf("======== mhmt help ========\n");

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   : 	printf("parameters:\n");

  00035	8b f4		 mov	 esi, esp
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DNFBPHAO@parameters?3?6?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 75   : 	printf("-mlz, -hrm, -hst - use MegaLZ, hrum3.5 or hrust1.x format (default is MegaLZ)\n");

  0004c	8b f4		 mov	 esi, esp
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   : 	printf("-g - greedy coding (default is optimal coding)\n");

  00063	8b f4		 mov	 esi, esp
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   : 	printf("-d - depacking instead of packing (default is packing)\n");

  0007a	8b f4		 mov	 esi, esp
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00087	83 c4 04	 add	 esp, 4
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 78   : 	printf("\n");

  00091	8b f4		 mov	 esi, esp
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009e	83 c4 04	 add	 esp, 4
  000a1	3b f4		 cmp	 esi, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 79   : 	printf("-zxh - use zx-specific header for hrum or hrust. DEFAULT is NO HEADER!\n");

  000a8	8b f4		 mov	 esi, esp
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000b5	83 c4 04	 add	 esp, 4
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 80   : 	printf("       Not applicable for MegaLZ. If -zxh is specified, -16, NO -bend and\n");

  000bf	8b f4		 mov	 esi, esp
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000cc	83 c4 04	 add	 esp, 4
  000cf	3b f4		 cmp	 esi, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 81   : 	printf("       NO -mlz is forced.\n");

  000d6	8b f4		 mov	 esi, esp
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000e3	83 c4 04	 add	 esp, 4
  000e6	3b f4		 cmp	 esi, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 82   : 	printf("\n");

  000ed	8b f4		 mov	 esi, esp
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000fa	83 c4 04	 add	 esp, 4
  000fd	3b f4		 cmp	 esi, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 83   : 	printf("-8, -16 - bitstream is in bytes or words in packed file.\n");

  00104	8b f4		 mov	 esi, esp
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00111	83 c4 04	 add	 esp, 4
  00114	3b f4		 cmp	 esi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 84   : 	printf("          Default for MegaLZ is -8, for hrum and hrust is -16.\n");

  0011b	8b f4		 mov	 esi, esp
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00128	83 c4 04	 add	 esp, 4
  0012b	3b f4		 cmp	 esi, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 85   : 	printf("\n");

  00132	8b f4		 mov	 esi, esp
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0013f	83 c4 04	 add	 esp, 4
  00142	3b f4		 cmp	 esi, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 86   : 	printf("-bend - if -16 specified, this makes words big-endian. Default is little-endian.\n");

  00149	8b f4		 mov	 esi, esp
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00156	83 c4 04	 add	 esp, 4
  00159	3b f4		 cmp	 esi, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 87   : 	printf("\n");

  00160	8b f4		 mov	 esi, esp
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0016d	83 c4 04	 add	 esp, 4
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 88   : 	printf("-maxwinN - maximum lookback window. N is decimal number, which can only be\n");

  00177	8b f4		 mov	 esi, esp
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00184	83 c4 04	 add	 esp, 4
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 89   : 	printf("           256,512,1024,2048,4096,8192,16384,32768. Default is format-specific\n");

  0018e	8b f4		 mov	 esi, esp
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0019b	83 c4 04	 add	 esp, 4
  0019e	3b f4		 cmp	 esi, esp
  001a0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   : 	printf("           maximum window: MegaLZ is 4352, hrum is 4096, hrust is 65536.\n");

  001a5	8b f4		 mov	 esi, esp
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001b2	83 c4 04	 add	 esp, 4
  001b5	3b f4		 cmp	 esi, esp
  001b7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 91   : 	printf("           For given format, window can't be greater than default value\n");

  001bc	8b f4		 mov	 esi, esp
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001c9	83 c4 04	 add	 esp, 4
  001cc	3b f4		 cmp	 esi, esp
  001ce	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 92   : 	printf("\n");

  001d3	8b f4		 mov	 esi, esp
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001e0	83 c4 04	 add	 esp, 4
  001e3	3b f4		 cmp	 esi, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 93   : 	printf("usage:\n");

  001ea	8b f4		 mov	 esi, esp
  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_07JELMINIL@usage?3?6?$AA@
  001f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001f7	83 c4 04	 add	 esp, 4
  001fa	3b f4		 cmp	 esi, esp
  001fc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 94   : 	printf("mhmt [parameter list] <input filename> [<output filename>]\n");

  00201	8b f4		 mov	 esi, esp
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0020e	83 c4 04	 add	 esp, 4
  00211	3b f4		 cmp	 esi, esp
  00213	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 95   : 	printf("\n");

  00218	8b f4		 mov	 esi, esp
  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00225	83 c4 04	 add	 esp, 4
  00228	3b f4		 cmp	 esi, esp
  0022a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 96   : 	printf("if no output filename given, filename is appended with \".mlz\", \".hrm\" or \".hst\"\n");

  0022f	8b f4		 mov	 esi, esp
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0023c	83 c4 04	 add	 esp, 4
  0023f	3b f4		 cmp	 esi, esp
  00241	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 97   : 	printf("in accordance with format chosen; for depacking \".dpk\" is appended\n");

  00246	8b f4		 mov	 esi, esp
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00253	83 c4 04	 add	 esp, 4
  00256	3b f4		 cmp	 esi, esp
  00258	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 98   : 	printf("====== mhmt help end ======\n");

  0025d	8b f4		 mov	 esi, esp
  0025f	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0026a	83 c4 04	 add	 esp, 4
  0026d	3b f4		 cmp	 esi, esp
  0026f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 99   : 	printf("\n");

  00274	8b f4		 mov	 esi, esp
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00281	83 c4 04	 add	 esp, 4
  00284	3b f4		 cmp	 esi, esp
  00286	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 100  : }

  0028b	5f		 pop	 edi
  0028c	5e		 pop	 esi
  0028d	5b		 pop	 ebx
  0028e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00294	3b ec		 cmp	 ebp, esp
  00296	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c3		 ret	 0
_show_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@ ; `string'
PUBLIC	??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@ ; `string'
PUBLIC	??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@ ; `string'
PUBLIC	??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@ ; `string'
PUBLIC	??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@ ; `string'
PUBLIC	??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@ ; `string'
PUBLIC	??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@ ; `string'
PUBLIC	??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@ ; `string'
PUBLIC	??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@	; `string'
PUBLIC	??_C@_09LKFJHGLK@hrust1?4x?5?$AA@		; `string'
PUBLIC	??_C@_08LEKKEIK@hrum3?45?5?$AA@			; `string'
PUBLIC	??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@	; `string'
PUBLIC	??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@ ; `string'
PUBLIC	??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@		; `string'
PUBLIC	??_C@_09BBMFODNF@packing?4?6?$AA@		; `string'
PUBLIC	??_C@_0M@IDENCAMB@depacking?4?6?$AA@		; `string'
PUBLIC	??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_09GPCJIKDG@unknown?4?6?$AA@		; `string'
PUBLIC	??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@		; `string'
PUBLIC	??_C@_08OGNAOKAB@Hrum3?45?6?$AA@		; `string'
PUBLIC	??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@		; `string'
PUBLIC	??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@		; `string'
PUBLIC	??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@ ; `string'
;	COMDAT ??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@ DB 'Outp'
	DB	'ut file "%s" created.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@
CONST	SEGMENT
??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@ DB 'I'
	DB	'nput file "%s" (%d bytes) successfully loaded.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@
CONST	SEGMENT
??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@ DB 'Maximum loo'
	DB	'kback window size is %d bytes.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@
CONST	SEGMENT
??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@ DB ' INCOMPATIBL'
	DB	'E with old ZX depackers!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@
CONST	SEGMENT
??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@ DB ' compatible'
	DB	' with old ZX depackers.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@
CONST	SEGMENT
??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@ DB 'Bitstream'
	DB	' is grouped in bytes -', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@
CONST	SEGMENT
??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@ DB 'compatible w'
	DB	'ith old ZX depackers.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@
CONST	SEGMENT
??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@ DB ' words are l'
	DB	'ittle-endian, ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@ DB ' words are'
	DB	' big-endian, %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
CONST	SEGMENT
??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@ DB 'INCOMPATIBLE w'
	DB	'ith old ZX depackers!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@
CONST	SEGMENT
??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@ DB 'Bitstream'
	DB	' is grouped in words -', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@ DB 'depackers is on.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKFJHGLK@hrust1?4x?5?$AA@
CONST	SEGMENT
??_C@_09LKFJHGLK@hrust1?4x?5?$AA@ DB 'hrust1.x ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEKKEIK@hrum3?45?5?$AA@
CONST	SEGMENT
??_C@_08LEKKEIK@hrum3?45?5?$AA@ DB 'hrum3.5 ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@
CONST	SEGMENT
??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@ DB 'Header for old ZX ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@ DB 'optimal (slower).'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@
CONST	SEGMENT
??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@ DB 'greed'
	DB	'y (sub-optimal but faster).', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@
CONST	SEGMENT
??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@ DB 'Pack coding: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBMFODNF@packing?4?6?$AA@
CONST	SEGMENT
??_C@_09BBMFODNF@packing?4?6?$AA@ DB 'packing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDENCAMB@depacking?4?6?$AA@
CONST	SEGMENT
??_C@_0M@IDENCAMB@depacking?4?6?$AA@ DB 'depacking.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@ DB 'Mode:        ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPCJIKDG@unknown?4?6?$AA@
CONST	SEGMENT
??_C@_09GPCJIKDG@unknown?4?6?$AA@ DB 'unknown.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@
CONST	SEGMENT
??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@ DB 'Hrust1.x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGNAOKAB@Hrum3?45?6?$AA@
CONST	SEGMENT
??_C@_08OGNAOKAB@Hrum3?45?6?$AA@ DB 'Hrum3.5', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@
CONST	SEGMENT
??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@ DB 'MegaLZ.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@
CONST	SEGMENT
??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@ DB 'Pack format: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@
CONST	SEGMENT
??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@ DB 'Configuration review'
	DB	':', 0aH, 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _dump_config
_TEXT	SEGMENT
_dump_config PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 104  : 	printf("Configuration review:\n");

  0001e	8b f4		 mov	 esi, esp
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  : 	printf("\n");

  00035	8b f4		 mov	 esi, esp
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 106  : 
; 107  : 	printf("Pack format: ");

  0004c	8b f4		 mov	 esi, esp
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 	if( wrk.packtype==PK_MLZ )

  00063	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  0006a	75 19		 jne	 SHORT $LN24@dump_confi

; 109  : 		printf("MegaLZ.\n");

  0006c	8b f4		 mov	 esi, esp
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00079	83 c4 04	 add	 esp, 4
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	eb 5b		 jmp	 SHORT $LN23@dump_confi
$LN24@dump_confi:

; 110  : 	else if( wrk.packtype==PK_HRM )

  00085	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  0008c	75 19		 jne	 SHORT $LN22@dump_confi

; 111  : 		printf("Hrum3.5\n");

  0008e	8b f4		 mov	 esi, esp
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_08OGNAOKAB@Hrum3?45?6?$AA@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	eb 39		 jmp	 SHORT $LN23@dump_confi
$LN22@dump_confi:

; 112  : 	else if( wrk.packtype==PK_HST )

  000a7	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  000ae	75 19		 jne	 SHORT $LN20@dump_confi

; 113  : 		printf("Hrust1.x\n");

  000b0	8b f4		 mov	 esi, esp
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 114  : 	else

  000c7	eb 17		 jmp	 SHORT $LN23@dump_confi
$LN20@dump_confi:

; 115  : 		printf("unknown.\n"); // this should be actually never displayed

  000c9	8b f4		 mov	 esi, esp
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_09GPCJIKDG@unknown?4?6?$AA@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000d6	83 c4 04	 add	 esp, 4
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@dump_confi:

; 116  : 
; 117  : 	printf("Mode:        ");

  000e0	8b f4		 mov	 esi, esp
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ed	83 c4 04	 add	 esp, 4
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 118  : 	if( wrk.mode )

  000f7	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _wrk+8, 0
  000fe	74 19		 je	 SHORT $LN18@dump_confi

; 119  : 		printf("depacking.\n");

  00100	8b f4		 mov	 esi, esp
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IDENCAMB@depacking?4?6?$AA@
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0010d	83 c4 04	 add	 esp, 4
  00110	3b f4		 cmp	 esi, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 120  : 	else

  00117	eb 17		 jmp	 SHORT $LN17@dump_confi
$LN18@dump_confi:

; 121  : 		printf("packing.\n");

  00119	8b f4		 mov	 esi, esp
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_09BBMFODNF@packing?4?6?$AA@
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00126	83 c4 04	 add	 esp, 4
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@dump_confi:

; 122  : 
; 123  : 	if( !wrk.mode )

  00130	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _wrk+8, 0
  00137	75 50		 jne	 SHORT $LN16@dump_confi

; 124  : 	{
; 125  : 		printf("Pack coding: ");

  00139	8b f4		 mov	 esi, esp
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00146	83 c4 04	 add	 esp, 4
  00149	3b f4		 cmp	 esi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 126  : 		if( wrk.greedy )

  00150	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _wrk+4, 0
  00157	74 19		 je	 SHORT $LN15@dump_confi

; 127  : 			printf("greedy (sub-optimal but faster).\n");

  00159	8b f4		 mov	 esi, esp
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00166	83 c4 04	 add	 esp, 4
  00169	3b f4		 cmp	 esi, esp
  0016b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 128  : 		else

  00170	eb 17		 jmp	 SHORT $LN16@dump_confi
$LN15@dump_confi:

; 129  : 			printf("optimal (slower).\n");

  00172	8b f4		 mov	 esi, esp
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0017f	83 c4 04	 add	 esp, 4
  00182	3b f4		 cmp	 esi, esp
  00184	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@dump_confi:

; 130  : 	}
; 131  : 
; 132  : 	if( wrk.zxheader )

  00189	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00190	74 70		 je	 SHORT $LN13@dump_confi

; 133  : 	{
; 134  : 		printf("Header for old ZX ");

  00192	8b f4		 mov	 esi, esp
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0019f	83 c4 04	 add	 esp, 4
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 135  : 		if( wrk.packtype==PK_HRM )

  001a9	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  001b0	75 19		 jne	 SHORT $LN12@dump_confi

; 136  : 			printf("hrum3.5 ");

  001b2	8b f4		 mov	 esi, esp
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_08LEKKEIK@hrum3?45?5?$AA@
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001bf	83 c4 04	 add	 esp, 4
  001c2	3b f4		 cmp	 esi, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c9	eb 20		 jmp	 SHORT $LN11@dump_confi
$LN12@dump_confi:

; 137  : 		else if( wrk.packtype==PK_HST )

  001cb	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  001d2	75 17		 jne	 SHORT $LN11@dump_confi

; 138  : 			printf("hrust1.x ");

  001d4	8b f4		 mov	 esi, esp
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_09LKFJHGLK@hrust1?4x?5?$AA@
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001e1	83 c4 04	 add	 esp, 4
  001e4	3b f4		 cmp	 esi, esp
  001e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@dump_confi:

; 139  : 
; 140  : 		printf("depackers is on.\n");

  001eb	8b f4		 mov	 esi, esp
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001f8	83 c4 04	 add	 esp, 4
  001fb	3b f4		 cmp	 esi, esp
  001fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@dump_confi:

; 141  : 	}
; 142  : 
; 143  : 	if( wrk.wordbit )

  00202	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  00209	0f 84 99 00 00
	00		 je	 $LN9@dump_confi

; 144  : 	{
; 145  : 		printf("Bitstream is grouped in words -\n");

  0020f	8b f4		 mov	 esi, esp
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0021c	83 c4 04	 add	 esp, 4
  0021f	3b f4		 cmp	 esi, esp
  00221	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 146  : 		if( wrk.bigend )

  00226	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _wrk+20, 0
  0022d	74 1e		 je	 SHORT $LN8@dump_confi

; 147  : 		{
; 148  : 			printf(" words are big-endian, %s","INCOMPATIBLE with old ZX depackers!\n");

  0022f	8b f4		 mov	 esi, esp
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00241	83 c4 08	 add	 esp, 8
  00244	3b f4		 cmp	 esi, esp
  00246	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 149  : 		}
; 150  : 		else

  0024b	eb 59		 jmp	 SHORT $LN7@dump_confi
$LN8@dump_confi:

; 151  : 		{
; 152  : 			printf(" words are little-endian, ");

  0024d	8b f4		 mov	 esi, esp
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0025a	83 c4 04	 add	 esp, 4
  0025d	3b f4		 cmp	 esi, esp
  0025f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 153  : 			if( (wrk.packtype==PK_HRM) || (wrk.packtype==PK_HST) )

  00264	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  0026b	74 09		 je	 SHORT $LN5@dump_confi
  0026d	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  00274	75 19		 jne	 SHORT $LN6@dump_confi
$LN5@dump_confi:

; 154  : 				printf("compatible with old ZX depackers.\n");

  00276	8b f4		 mov	 esi, esp
  00278	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00283	83 c4 04	 add	 esp, 4
  00286	3b f4		 cmp	 esi, esp
  00288	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 155  : 			else

  0028d	eb 17		 jmp	 SHORT $LN7@dump_confi
$LN6@dump_confi:

; 156  : 				printf("INCOMPATIBLE with old ZX depackers!\n");

  0028f	8b f4		 mov	 esi, esp
  00291	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
  00296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0029c	83 c4 04	 add	 esp, 4
  0029f	3b f4		 cmp	 esi, esp
  002a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@dump_confi:

; 157  : 		}
; 158  : 	}
; 159  : 	else

  002a6	eb 50		 jmp	 SHORT $LN3@dump_confi
$LN9@dump_confi:

; 160  : 	{
; 161  : 		printf("Bitstream is grouped in bytes -\n");

  002a8	8b f4		 mov	 esi, esp
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002b5	83 c4 04	 add	 esp, 4
  002b8	3b f4		 cmp	 esi, esp
  002ba	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 162  : 		if( wrk.packtype==PK_MLZ )

  002bf	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  002c6	75 19		 jne	 SHORT $LN2@dump_confi

; 163  : 			printf(" compatible with old ZX depackers.\n");

  002c8	8b f4		 mov	 esi, esp
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002d5	83 c4 04	 add	 esp, 4
  002d8	3b f4		 cmp	 esi, esp
  002da	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 164  : 		else

  002df	eb 17		 jmp	 SHORT $LN3@dump_confi
$LN2@dump_confi:

; 165  : 			printf(" INCOMPATIBLE with old ZX depackers!\n");

  002e1	8b f4		 mov	 esi, esp
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002ee	83 c4 04	 add	 esp, 4
  002f1	3b f4		 cmp	 esi, esp
  002f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@dump_confi:

; 166  : 	}
; 167  : 
; 168  : 	printf("Maximum lookback window size is %d bytes.\n\n",wrk.maxwin);

  002f8	8b f4		 mov	 esi, esp
  002fa	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  002ff	50		 push	 eax
  00300	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0030b	83 c4 08	 add	 esp, 8
  0030e	3b f4		 cmp	 esi, esp
  00310	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  : 
; 170  : 
; 171  : 	// files
; 172  : 	printf("Input file \"%s\" (%d bytes) successfully loaded.\n", wrk.fname_in, wrk.inlen);

  00315	8b f4		 mov	 esi, esp
  00317	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  0031c	50		 push	 eax
  0031d	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR _wrk+32
  00323	51		 push	 ecx
  00324	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@
  00329	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0032f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00332	3b f4		 cmp	 esi, esp
  00334	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 173  : 	printf("Output file \"%s\" created.\n", wrk.fname_out );

  00339	8b f4		 mov	 esi, esp
  0033b	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  00340	50		 push	 eax
  00341	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@
  00346	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0034c	83 c4 08	 add	 esp, 8
  0034f	3b f4		 cmp	 esi, esp
  00351	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 174  : 
; 175  : //	...more info...?
; 176  : }

  00356	5f		 pop	 edi
  00357	5e		 pop	 esi
  00358	5b		 pop	 ebx
  00359	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0035f	3b ec		 cmp	 ebp, esp
  00361	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c3		 ret	 0
_dump_config ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@ ; `string'
PUBLIC	??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@ ; `string'
PUBLIC	??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@ ; `string'
PUBLIC	??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@ ; `string'
PUBLIC	??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@ ; `string'
PUBLIC	??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@ ; `string'
PUBLIC	??_C@_04ODAPCKGA@?4pak?$AA@			; `string'
PUBLIC	??_C@_04KEFKCMJA@?4hst?$AA@			; `string'
PUBLIC	??_C@_04DOJIOPLP@?4hrm?$AA@			; `string'
PUBLIC	??_C@_04BKHNBFGB@?4mlz?$AA@			; `string'
PUBLIC	??_C@_04CBJACDOP@?4dpk?$AA@			; `string'
EXTRN	__imp__fread:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fopen:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_strlen:PROC
;	COMDAT ??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@
CONST	SEGMENT
??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@ DB 'Cannot succe'
	DB	'ssfully load input file "%s" in memory!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@
CONST	SEGMENT
??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@ DB 'Cannot a'
	DB	'llocate %d bytes of memory for loading input file "%s"!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@
CONST	SEGMENT
??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@ DB 'I'
	DB	'nput file "%s" is smaller than 16 bytes - I won''t process it'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@
CONST	SEGMENT
??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@ DB 'Canno'
	DB	't ftell() length of input file "%s"!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@
CONST	SEGMENT
??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@ DB 'C'
	DB	'annot fseek() input file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@
CONST	SEGMENT
??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@ DB 'C'
	DB	'annot create output file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@ DB 'C'
	DB	'annot open input file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@
CONST	SEGMENT
??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@ DB 'Can''t allo'
	DB	'cate memory for output filename!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODAPCKGA@?4pak?$AA@
CONST	SEGMENT
??_C@_04ODAPCKGA@?4pak?$AA@ DB '.pak', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEFKCMJA@?4hst?$AA@
CONST	SEGMENT
??_C@_04KEFKCMJA@?4hst?$AA@ DB '.hst', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOJIOPLP@?4hrm?$AA@
CONST	SEGMENT
??_C@_04DOJIOPLP@?4hrm?$AA@ DB '.hrm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKHNBFGB@?4mlz?$AA@
CONST	SEGMENT
??_C@_04BKHNBFGB@?4mlz?$AA@ DB '.mlz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CBJACDOP@?4dpk?$AA@
CONST	SEGMENT
??_C@_04CBJACDOP@?4dpk?$AA@ DB '.dpk', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _do_files
_TEXT	SEGMENT
_ext_pos$ = -32						; size = 4
_depk_ext$ = -20					; size = 4
_pack_ext$ = -8						; size = 4
_do_files PROC						; COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 182  : 	char * pack_ext;
; 183  : 	char * depk_ext;
; 184  : 	LONG ext_pos;
; 185  : 
; 186  : 
; 187  : 	// if there is no output filename, create it
; 188  : 	if( !wrk.fname_out )

  0001e	83 3d 24 00 00
	00 00		 cmp	 DWORD PTR _wrk+36, 0
  00025	0f 85 22 01 00
	00		 jne	 $LN21@do_files

; 189  : 	{
; 190  : 		depk_ext = ".dpk";

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _depk_ext$[ebp], OFFSET ??_C@_04CBJACDOP@?4dpk?$AA@

; 191  : 
; 192  : 		if( wrk.packtype==PK_MLZ )

  00032	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  00039	75 09		 jne	 SHORT $LN20@do_files

; 193  : 			pack_ext = ".mlz";

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pack_ext$[ebp], OFFSET ??_C@_04BKHNBFGB@?4mlz?$AA@
  00042	eb 2b		 jmp	 SHORT $LN19@do_files
$LN20@do_files:

; 194  : 		else if( wrk.packtype==PK_HRM )

  00044	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  0004b	75 09		 jne	 SHORT $LN18@do_files

; 195  : 			pack_ext = ".hrm";

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pack_ext$[ebp], OFFSET ??_C@_04DOJIOPLP@?4hrm?$AA@
  00054	eb 19		 jmp	 SHORT $LN19@do_files
$LN18@do_files:

; 196  : 		else if( wrk.packtype==PK_HST )

  00056	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  0005d	75 09		 jne	 SHORT $LN16@do_files

; 197  : 			pack_ext = ".hst";

  0005f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pack_ext$[ebp], OFFSET ??_C@_04KEFKCMJA@?4hst?$AA@

; 198  : 		else

  00066	eb 07		 jmp	 SHORT $LN19@do_files
$LN16@do_files:

; 199  : 			pack_ext = ".pak"; // all have the same size, as well as depk_ext - 4 bytes!

  00068	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pack_ext$[ebp], OFFSET ??_C@_04ODAPCKGA@?4pak?$AA@
$LN19@do_files:

; 200  : 
; 201  : 
; 202  : 		wrk.fname_out = (char *)malloc( 5 + strlen(wrk.fname_in) );

  0006f	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _strlen
  0007a	83 c4 04	 add	 esp, 4
  0007d	83 c0 05	 add	 eax, 5
  00080	8b f4		 mov	 esi, esp
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00089	83 c4 04	 add	 esp, 4
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	a3 24 00 00 00	 mov	 DWORD PTR _wrk+36, eax

; 203  : 		if( !wrk.fname_out )

  00098	83 3d 24 00 00
	00 00		 cmp	 DWORD PTR _wrk+36, 0
  0009f	75 1e		 jne	 SHORT $LN14@do_files

; 204  : 		{
; 205  : 			printf("Can't allocate memory for output filename!\n");

  000a1	8b f4		 mov	 esi, esp
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ae	83 c4 04	 add	 esp, 4
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 206  : 			return 0;

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 db 02 00 00	 jmp	 $LN22@do_files
$LN14@do_files:

; 207  : 		}
; 208  : 
; 209  : 		strcpy(wrk.fname_out, wrk.fname_in);

  000bf	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  000c4	50		 push	 eax
  000c5	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _wrk+36
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _strcpy
  000d1	83 c4 08	 add	 esp, 8

; 210  : 
; 211  : 		if( !wrk.mode ) // packing

  000d4	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _wrk+8, 0
  000db	75 15		 jne	 SHORT $LN13@do_files

; 212  : 		{
; 213  : 			strcat(wrk.fname_out, pack_ext);

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _pack_ext$[ebp]
  000e0	50		 push	 eax
  000e1	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _wrk+36
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _strcat
  000ed	83 c4 08	 add	 esp, 8

; 214  : 		}
; 215  : 		else // depacking

  000f0	eb 5b		 jmp	 SHORT $LN21@do_files
$LN13@do_files:

; 216  : 		{
; 217  : 			ext_pos = strlen( wrk.fname_out ) - 4;

  000f2	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _strlen
  000fd	83 c4 04	 add	 esp, 4
  00100	83 e8 04	 sub	 eax, 4
  00103	89 45 e0	 mov	 DWORD PTR _ext_pos$[ebp], eax

; 218  : 
; 219  : 			if( (ext_pos>=0) && (!strcmp(&wrk.fname_out[ext_pos], pack_ext)) )

  00106	78 32		 js	 SHORT $LN11@do_files
  00108	8b 45 f8	 mov	 eax, DWORD PTR _pack_ext$[ebp]
  0010b	50		 push	 eax
  0010c	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _wrk+36
  00112	03 4d e0	 add	 ecx, DWORD PTR _ext_pos$[ebp]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _strcmp
  0011b	83 c4 08	 add	 esp, 8
  0011e	85 c0		 test	 eax, eax
  00120	75 18		 jne	 SHORT $LN11@do_files

; 220  : 				strcpy( &wrk.fname_out[ext_pos], depk_ext );

  00122	8b 45 ec	 mov	 eax, DWORD PTR _depk_ext$[ebp]
  00125	50		 push	 eax
  00126	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _wrk+36
  0012c	03 4d e0	 add	 ecx, DWORD PTR _ext_pos$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 _strcpy
  00135	83 c4 08	 add	 esp, 8

; 221  : 			else

  00138	eb 13		 jmp	 SHORT $LN21@do_files
$LN11@do_files:

; 222  : 				strcat( wrk.fname_out, depk_ext );

  0013a	8b 45 ec	 mov	 eax, DWORD PTR _depk_ext$[ebp]
  0013d	50		 push	 eax
  0013e	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _wrk+36
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 _strcat
  0014a	83 c4 08	 add	 esp, 8
$LN21@do_files:

; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 
; 227  : 	//open files
; 228  : 	wrk.file_in=fopen(wrk.fname_in,"rb");

  0014d	8b f4		 mov	 esi, esp
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00154	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00159	50		 push	 eax
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00160	83 c4 08	 add	 esp, 8
  00163	3b f4		 cmp	 esi, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016a	a3 28 00 00 00	 mov	 DWORD PTR _wrk+40, eax

; 229  : 
; 230  : 	if(!wrk.file_in)

  0016f	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR _wrk+40, 0
  00176	75 24		 jne	 SHORT $LN9@do_files

; 231  : 	{
; 232  : 		printf("Cannot open input file \"%s\"!\n",wrk.fname_in);

  00178	8b f4		 mov	 esi, esp
  0017a	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  0017f	50		 push	 eax
  00180	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0018b	83 c4 08	 add	 esp, 8
  0018e	3b f4		 cmp	 esi, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 233  : 		return 0;

  00195	33 c0		 xor	 eax, eax
  00197	e9 fe 01 00 00	 jmp	 $LN22@do_files
$LN9@do_files:

; 234  : 	}
; 235  : 
; 236  : 	wrk.file_out=fopen(wrk.fname_out,"wb");

  0019c	8b f4		 mov	 esi, esp
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  001a3	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  001a8	50		 push	 eax
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  001af	83 c4 08	 add	 esp, 8
  001b2	3b f4		 cmp	 esi, esp
  001b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b9	a3 2c 00 00 00	 mov	 DWORD PTR _wrk+44, eax

; 237  : 	if(!wrk.file_out)

  001be	83 3d 2c 00 00
	00 00		 cmp	 DWORD PTR _wrk+44, 0
  001c5	75 24		 jne	 SHORT $LN8@do_files

; 238  : 	{
; 239  : 		printf("Cannot create output file \"%s\"!\n",wrk.fname_out);

  001c7	8b f4		 mov	 esi, esp
  001c9	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  001ce	50		 push	 eax
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001da	83 c4 08	 add	 esp, 8
  001dd	3b f4		 cmp	 esi, esp
  001df	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 240  : 		return 0;

  001e4	33 c0		 xor	 eax, eax
  001e6	e9 af 01 00 00	 jmp	 $LN22@do_files
$LN8@do_files:

; 241  : 	}
; 242  : 
; 243  : 
; 244  : 	// get length of input file
; 245  : 	if( fseek(wrk.file_in,0,SEEK_END) )

  001eb	8b f4		 mov	 esi, esp
  001ed	6a 02		 push	 2
  001ef	6a 00		 push	 0
  001f1	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  001f6	50		 push	 eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00200	3b f4		 cmp	 esi, esp
  00202	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00207	85 c0		 test	 eax, eax
  00209	74 24		 je	 SHORT $LN7@do_files

; 246  : 	{
; 247  : 		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);

  0020b	8b f4		 mov	 esi, esp
  0020d	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00212	50		 push	 eax
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0021e	83 c4 08	 add	 esp, 8
  00221	3b f4		 cmp	 esi, esp
  00223	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 248  : 		return 0;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 6b 01 00 00	 jmp	 $LN22@do_files
$LN7@do_files:

; 249  : 	}
; 250  : 	wrk.inlen=(ULONG)ftell(wrk.file_in);

  0022f	8b f4		 mov	 esi, esp
  00231	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  00236	50		 push	 eax
  00237	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  0023d	83 c4 04	 add	 esp, 4
  00240	3b f4		 cmp	 esi, esp
  00242	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00247	a3 34 00 00 00	 mov	 DWORD PTR _wrk+52, eax

; 251  : 	if( wrk.inlen==(ULONG)(-1L)  )

  0024c	83 3d 34 00 00
	00 ff		 cmp	 DWORD PTR _wrk+52, -1
  00253	75 30		 jne	 SHORT $LN6@do_files

; 252  : 	{
; 253  : 		printf("Cannot ftell() length of input file \"%s\"!\n",wrk.fname_in);

  00255	8b f4		 mov	 esi, esp
  00257	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  0025c	50		 push	 eax
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00268	83 c4 08	 add	 esp, 8
  0026b	3b f4		 cmp	 esi, esp
  0026d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 254  : 		wrk.inlen=0;

  00272	c7 05 34 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+52, 0

; 255  : 		return 0;

  0027c	33 c0		 xor	 eax, eax
  0027e	e9 17 01 00 00	 jmp	 $LN22@do_files
  00283	eb 2d		 jmp	 SHORT $LN5@do_files
$LN6@do_files:

; 256  : 	}
; 257  : 	else if( wrk.inlen<16 )

  00285	83 3d 34 00 00
	00 10		 cmp	 DWORD PTR _wrk+52, 16	; 00000010H
  0028c	73 24		 jae	 SHORT $LN5@do_files

; 258  : 	{
; 259  : 		printf("Input file \"%s\" is smaller than 16 bytes - I won't process it!\n",wrk.fname_in);

  0028e	8b f4		 mov	 esi, esp
  00290	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00295	50		 push	 eax
  00296	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002a1	83 c4 08	 add	 esp, 8
  002a4	3b f4		 cmp	 esi, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 260  : 		return 0;

  002ab	33 c0		 xor	 eax, eax
  002ad	e9 e8 00 00 00	 jmp	 $LN22@do_files
$LN5@do_files:

; 261  : 	}
; 262  : 	if( fseek(wrk.file_in,0,SEEK_SET) )

  002b2	8b f4		 mov	 esi, esp
  002b4	6a 00		 push	 0
  002b6	6a 00		 push	 0
  002b8	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  002bd	50		 push	 eax
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c7	3b f4		 cmp	 esi, esp
  002c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ce	85 c0		 test	 eax, eax
  002d0	74 24		 je	 SHORT $LN3@do_files

; 263  : 	{
; 264  : 		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);

  002d2	8b f4		 mov	 esi, esp
  002d4	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  002d9	50		 push	 eax
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002e5	83 c4 08	 add	 esp, 8
  002e8	3b f4		 cmp	 esi, esp
  002ea	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 265  : 		return 0;

  002ef	33 c0		 xor	 eax, eax
  002f1	e9 a4 00 00 00	 jmp	 $LN22@do_files
$LN3@do_files:

; 266  : 	}
; 267  : 
; 268  : 
; 269  : 	// load input file in mem
; 270  : 	wrk.indata=(UBYTE *)malloc(wrk.inlen);

  002f6	8b f4		 mov	 esi, esp
  002f8	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  002fd	50		 push	 eax
  002fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00304	83 c4 04	 add	 esp, 4
  00307	3b f4		 cmp	 esi, esp
  00309	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0030e	a3 30 00 00 00	 mov	 DWORD PTR _wrk+48, eax

; 271  : 	if( !wrk.indata )

  00313	83 3d 30 00 00
	00 00		 cmp	 DWORD PTR _wrk+48, 0
  0031a	75 28		 jne	 SHORT $LN2@do_files

; 272  : 	{
; 273  : 		printf("Cannot allocate %d bytes of memory for loading input file \"%s\"!\n", wrk.inlen, wrk.fname_in);

  0031c	8b f4		 mov	 esi, esp
  0031e	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00323	50		 push	 eax
  00324	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR _wrk+52
  0032a	51		 push	 ecx
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00336	83 c4 0c	 add	 esp, 12			; 0000000cH
  00339	3b f4		 cmp	 esi, esp
  0033b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 274  : 		return 0;

  00340	33 c0		 xor	 eax, eax
  00342	eb 56		 jmp	 SHORT $LN22@do_files
$LN2@do_files:

; 275  : 	}
; 276  : 
; 277  : 	if( wrk.inlen!=fread(wrk.indata,1,wrk.inlen,wrk.file_in) )

  00344	8b f4		 mov	 esi, esp
  00346	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  0034b	50		 push	 eax
  0034c	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR _wrk+52
  00352	51		 push	 ecx
  00353	6a 01		 push	 1
  00355	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  0035b	52		 push	 edx
  0035c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00362	83 c4 10	 add	 esp, 16			; 00000010H
  00365	3b f4		 cmp	 esi, esp
  00367	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0036c	39 05 34 00 00
	00		 cmp	 DWORD PTR _wrk+52, eax
  00372	74 21		 je	 SHORT $LN1@do_files

; 278  : 	{
; 279  : 		printf("Cannot successfully load input file \"%s\" in memory!\n",wrk.fname_in);

  00374	8b f4		 mov	 esi, esp
  00376	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  0037b	50		 push	 eax
  0037c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@
  00381	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00387	83 c4 08	 add	 esp, 8
  0038a	3b f4		 cmp	 esi, esp
  0038c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 280  : 		return 0;

  00391	33 c0		 xor	 eax, eax
  00393	eb 05		 jmp	 SHORT $LN22@do_files
$LN1@do_files:

; 281  : 	}
; 282  : 
; 283  : 
; 284  : 	return 1;// no errors

  00395	b8 01 00 00 00	 mov	 eax, 1
$LN22@do_files:

; 285  : }

  0039a	5f		 pop	 edi
  0039b	5e		 pop	 esi
  0039c	5b		 pop	 ebx
  0039d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  003a3	3b ec		 cmp	 ebp, esp
  003a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003aa	8b e5		 mov	 esp, ebp
  003ac	5d		 pop	 ebp
  003ad	c3		 ret	 0
_do_files ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-optimal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_make_optch
EXTRN	__imp__malloc:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\d\mhmt\src\mhmt-optimal.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _make_optch
_TEXT	SEGMENT
_i$ = -20						; size = 4
_optch$ = -8						; size = 4
_actual_len$ = 8					; size = 4
_make_optch PROC					; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 11   : 	struct optchain * optch;
; 12   : 
; 13   : 	ULONG i;
; 14   : 
; 15   : 	// we allocate length+1 because all codes at the end of input stream will point
; 16   : 	// to the length+1 place. Also we'll start reversing from length+1 position in optch array
; 17   : 	optch = (struct optchain *)malloc( (actual_len+1)*sizeof(struct optchain) );

  0001e	8b 45 08	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	c1 e0 04	 shl	 eax, 4
  00027	8b f4		 mov	 esi, esp
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00030	83 c4 04	 add	 esp, 4
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	89 45 f8	 mov	 DWORD PTR _optch$[ebp], eax

; 18   : 
; 19   : 	if( optch )

  0003d	83 7d f8 00	 cmp	 DWORD PTR _optch$[ebp], 0
  00041	74 57		 je	 SHORT $LN4@make_optch

; 20   : 	{
; 21   : 		optch[0].code.length = 1; // 1st byte is always copied 'as-is', however, this is just filler,

  00043	8b 45 f8	 mov	 eax, DWORD PTR _optch$[ebp]
  00046	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 22   : 		optch[0].code.disp   = 0; // not accounted elsewhere

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _optch$[ebp]
  0004f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 23   : 
; 24   : 		// init prices to absolute maximum for optimal chain build-up
; 25   : 		optch[0].price = 0;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _optch$[ebp]
  00059	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 26   : 		optch[1].price = 8;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _optch$[ebp]
  00063	c7 40 18 08 00
	00 00		 mov	 DWORD PTR [eax+24], 8

; 27   : 		for(i=2;i<(actual_len+1);i++)

  0006a	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  00071	eb 09		 jmp	 SHORT $LN3@make_optch
$LN2@make_optch:
  00073	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN3@make_optch:
  0007c	8b 45 08	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  00085	73 13		 jae	 SHORT $LN4@make_optch

; 28   : 			optch[i].price = 0xFFFFFFFF;

  00087	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	c1 e0 04	 shl	 eax, 4
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _optch$[ebp]
  00090	c7 44 01 08 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+8], -1
  00098	eb d9		 jmp	 SHORT $LN2@make_optch
$LN4@make_optch:

; 29   : 	}
; 30   : 
; 31   : 	return optch;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _optch$[ebp]

; 32   : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_make_optch ENDP
_TEXT	ENDS
PUBLIC	_free_optch
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _free_optch
_TEXT	SEGMENT
_optch$ = 8						; size = 4
_free_optch PROC					; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 37   : 	if( optch )

  0001e	83 7d 08 00	 cmp	 DWORD PTR _optch$[ebp], 0
  00022	74 16		 je	 SHORT $LN2@free_optch

; 38   : 		free( optch );

  00024	8b f4		 mov	 esi, esp
  00026	8b 45 08	 mov	 eax, DWORD PTR _optch$[ebp]
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00030	83 c4 04	 add	 esp, 4
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@free_optch:

; 39   : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_free_optch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@ ; `string'
PUBLIC	_update_optch
EXTRN	__imp__exit:PROC
EXTRN	__imp__printf:PROC
;	COMDAT ??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@
CONST	SEGMENT
??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@ DB 'mhmt-'
	DB	'optimal.c: update_optch() found zero bitlength of lz code. Fa'
	DB	'tal error.', 0aH, 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _update_optch
_TEXT	SEGMENT
_len$ = -44						; size = 4
_newpos$ = -32						; size = 4
_bitlen$ = -20						; size = 4
_codepos$ = -8						; size = 4
_position$ = 8						; size = 4
_codes$ = 12						; size = 4
_get_lz_price$ = 16					; size = 4
_optch$ = 20						; size = 4
_update_optch PROC					; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 45   : 	ULONG codepos;
; 46   : 	ULONG bitlen;
; 47   : 	ULONG newpos;
; 48   : 	LONG len;
; 49   : 
; 50   : 	for( codepos = 0; len=codes[codepos].length; codepos++ ) // loop through all existing lz codes

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _codepos$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN7@update_opt
$LN6@update_opt:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _codepos$[ebp], eax
$LN7@update_opt:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  00036	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00039	89 55 d4	 mov	 DWORD PTR _len$[ebp], edx
  0003c	83 7d d4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00040	0f 84 c5 00 00
	00		 je	 $LN9@update_opt

; 51   : 	{
; 52   : 		bitlen = (*get_lz_price)(position, &codes[codepos]); // get bit length of given lz code

  00046	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  0004c	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0004f	8b f4		 mov	 esi, esp
  00051	52		 push	 edx
  00052	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00055	50		 push	 eax
  00056	ff 55 10	 call	 DWORD PTR _get_lz_price$[ebp]
  00059	83 c4 08	 add	 esp, 8
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	89 45 ec	 mov	 DWORD PTR _bitlen$[ebp], eax

; 53   : 		if( !bitlen )

  00066	83 7d ec 00	 cmp	 DWORD PTR _bitlen$[ebp], 0
  0006a	75 2a		 jne	 SHORT $LN4@update_opt

; 54   : 		{
; 55   : 			printf("mhmt-optimal.c: update_optch() found zero bitlength of lz code. Fatal error.\n");

  0006c	8b f4		 mov	 esi, esp
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00079	83 c4 04	 add	 esp, 4
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 56   : 			exit(1);

  00083	8b f4		 mov	 esi, esp
  00085	6a 01		 push	 1
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 57   : 		}
; 58   : 		else

  00094	eb 70		 jmp	 SHORT $LN3@update_opt
$LN4@update_opt:

; 59   : 		{
; 60   : 			if( len<0 ) len=(-len); // deal with negative lengths (special markers)

  00096	83 7d d4 00	 cmp	 DWORD PTR _len$[ebp], 0
  0009a	7d 08		 jge	 SHORT $LN2@update_opt
  0009c	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  0009f	f7 d8		 neg	 eax
  000a1	89 45 d4	 mov	 DWORD PTR _len$[ebp], eax
$LN2@update_opt:

; 61   : 
; 62   : 			newpos = position + len; // look where current lz code points to and take from there old price reaching that location

  000a4	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  000a7	03 45 d4	 add	 eax, DWORD PTR _len$[ebp]
  000aa	89 45 e0	 mov	 DWORD PTR _newpos$[ebp], eax

; 63   : 
; 64   : 			if( optch[newpos].price > bitlen + optch[position].price ) // if oldprice is worse than with current lz code

  000ad	8b 45 e0	 mov	 eax, DWORD PTR _newpos$[ebp]
  000b0	c1 e0 04	 shl	 eax, 4
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  000b6	c1 e1 04	 shl	 ecx, 4
  000b9	8b 55 14	 mov	 edx, DWORD PTR _optch$[ebp]
  000bc	8b 75 ec	 mov	 esi, DWORD PTR _bitlen$[ebp]
  000bf	03 74 0a 08	 add	 esi, DWORD PTR [edx+ecx+8]
  000c3	8b 4d 14	 mov	 ecx, DWORD PTR _optch$[ebp]
  000c6	39 74 01 08	 cmp	 DWORD PTR [ecx+eax+8], esi
  000ca	76 3a		 jbe	 SHORT $LN3@update_opt

; 65   : 			{
; 66   : 				optch[newpos].price = bitlen + optch[position].price;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  000cf	c1 e0 04	 shl	 eax, 4
  000d2	8b 4d 14	 mov	 ecx, DWORD PTR _optch$[ebp]
  000d5	8b 55 ec	 mov	 edx, DWORD PTR _bitlen$[ebp]
  000d8	03 54 01 08	 add	 edx, DWORD PTR [ecx+eax+8]
  000dc	8b 45 e0	 mov	 eax, DWORD PTR _newpos$[ebp]
  000df	c1 e0 04	 shl	 eax, 4
  000e2	8b 4d 14	 mov	 ecx, DWORD PTR _optch$[ebp]
  000e5	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 67   : 				optch[newpos].code  = codes[codepos];

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _codepos$[ebp]
  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR _codes$[ebp]
  000ef	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  000f2	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  000f6	8b 4d e0	 mov	 ecx, DWORD PTR _newpos$[ebp]
  000f9	c1 e1 04	 shl	 ecx, 4
  000fc	8b 75 14	 mov	 esi, DWORD PTR _optch$[ebp]
  000ff	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  00102	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
$LN3@update_opt:

; 68   : 			}
; 69   : 		}
; 70   : 	}

  00106	e9 1c ff ff ff	 jmp	 $LN6@update_opt
$LN9@update_opt:

; 71   : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_update_optch ENDP
_TEXT	ENDS
PUBLIC	_reverse_optch
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _reverse_optch
_TEXT	SEGMENT
_len$ = -52						; size = 4
_position$ = -40					; size = 4
_temp$ = -28						; size = 8
_curr$ = -12						; size = 8
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_reverse_optch PROC					; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 78   : 	struct lzcode curr, temp;
; 79   : 	ULONG position;
; 80   : 	LONG len;
; 81   : 
; 82   : 	position = actual_len;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00021	89 45 d8	 mov	 DWORD PTR _position$[ebp], eax

; 83   : 
; 84   : 	temp = optch[position].code;

  00024	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  00027	c1 e0 04	 shl	 eax, 4
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  0002d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00030	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  00034	89 55 e4	 mov	 DWORD PTR _temp$[ebp], edx
  00037	89 45 e8	 mov	 DWORD PTR _temp$[ebp+4], eax
$LN3@reverse_op:

; 85   : 
; 86   : 	while(position>1)

  0003a	83 7d d8 01	 cmp	 DWORD PTR _position$[ebp], 1
  0003e	76 57		 jbe	 SHORT $LN4@reverse_op

; 87   : 	{
; 88   : 		len = temp.length;

  00040	8b 45 e4	 mov	 eax, DWORD PTR _temp$[ebp]
  00043	89 45 cc	 mov	 DWORD PTR _len$[ebp], eax

; 89   : 		if( len<0 ) len=(-len);

  00046	83 7d cc 00	 cmp	 DWORD PTR _len$[ebp], 0
  0004a	7d 08		 jge	 SHORT $LN1@reverse_op
  0004c	8b 45 cc	 mov	 eax, DWORD PTR _len$[ebp]
  0004f	f7 d8		 neg	 eax
  00051	89 45 cc	 mov	 DWORD PTR _len$[ebp], eax
$LN1@reverse_op:

; 90   : 
; 91   : 		position -= len;

  00054	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  00057	2b 45 cc	 sub	 eax, DWORD PTR _len$[ebp]
  0005a	89 45 d8	 mov	 DWORD PTR _position$[ebp], eax

; 92   : 
; 93   : 		curr = temp;

  0005d	8b 45 e4	 mov	 eax, DWORD PTR _temp$[ebp]
  00060	89 45 f4	 mov	 DWORD PTR _curr$[ebp], eax
  00063	8b 4d e8	 mov	 ecx, DWORD PTR _temp$[ebp+4]
  00066	89 4d f8	 mov	 DWORD PTR _curr$[ebp+4], ecx

; 94   : 
; 95   : 		temp = optch[position].code;

  00069	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  0006c	c1 e0 04	 shl	 eax, 4
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  00072	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00075	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  00079	89 55 e4	 mov	 DWORD PTR _temp$[ebp], edx
  0007c	89 45 e8	 mov	 DWORD PTR _temp$[ebp+4], eax

; 96   : 		optch[position].code = curr;

  0007f	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  00082	c1 e0 04	 shl	 eax, 4
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _optch$[ebp]
  00088	8b 55 f4	 mov	 edx, DWORD PTR _curr$[ebp]
  0008b	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  0008e	8b 55 f8	 mov	 edx, DWORD PTR _curr$[ebp+4]
  00091	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 97   : 	}

  00095	eb a3		 jmp	 SHORT $LN3@reverse_op
$LN4@reverse_op:

; 98   : }

  00097	52		 push	 edx
  00098	8b cd		 mov	 ecx, ebp
  0009a	50		 push	 eax
  0009b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@reverse_op
  000a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a6	58		 pop	 eax
  000a7	5a		 pop	 edx
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
  000af	90		 npad	 1
$LN9@reverse_op:
  000b0	02 00 00 00	 DD	 2
  000b4	00 00 00 00	 DD	 $LN8@reverse_op
$LN8@reverse_op:
  000b8	f4 ff ff ff	 DD	 -12			; fffffff4H
  000bc	08 00 00 00	 DD	 8
  000c0	00 00 00 00	 DD	 $LN6@reverse_op
  000c4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000c8	08 00 00 00	 DD	 8
  000cc	00 00 00 00	 DD	 $LN7@reverse_op
$LN7@reverse_op:
  000d0	74		 DB	 116			; 00000074H
  000d1	65		 DB	 101			; 00000065H
  000d2	6d		 DB	 109			; 0000006dH
  000d3	70		 DB	 112			; 00000070H
  000d4	00		 DB	 0
$LN6@reverse_op:
  000d5	63		 DB	 99			; 00000063H
  000d6	75		 DB	 117			; 00000075H
  000d7	72		 DB	 114			; 00000072H
  000d8	72		 DB	 114			; 00000072H
  000d9	00		 DB	 0
_reverse_optch ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-pack.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@ ; `string'
PUBLIC	??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@ ; `string'
PUBLIC	??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@ ; `string'
PUBLIC	??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@ ; `string'
PUBLIC	??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@ ; `string'
PUBLIC	??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@ ; `string'
PUBLIC	_pack
EXTRN	_destroy_hash:PROC
EXTRN	_free_optch:PROC
EXTRN	_reverse_optch:PROC
EXTRN	_update_optch:PROC
EXTRN	_add_tb:PROC
EXTRN	_make_optch:PROC
EXTRN	_build_hash:PROC
EXTRN	_init_tb:PROC
EXTRN	__imp__printf:PROC
EXTRN	_emit_hrust:PROC
EXTRN	_get_lz_price_hrust:PROC
EXTRN	_make_lz_codes_hrust:PROC
EXTRN	_emit_hrum:PROC
EXTRN	_get_lz_price_hrum:PROC
EXTRN	_make_lz_codes_hrum:PROC
EXTRN	_emit_megalz:PROC
EXTRN	_get_lz_price_megalz:PROC
EXTRN	_make_lz_codes_megalz:PROC
EXTRN	_wrk:BYTE
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
_BSS	SEGMENT
?codes@?1??pack@@9@9 DQ 0f14H DUP (?)			; `pack'::`2'::codes
_BSS	ENDS
;	COMDAT ??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@
; File d:\d\mhmt\src\mhmt-pack.c
CONST	SEGMENT
??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@ DB 'mhm'
	DB	't-pack.c:pack() - greedy coding not supported!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@
CONST	SEGMENT
??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@ DB 'm'
	DB	'hmt-pack.c:pack() - add_tb() failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@
CONST	SEGMENT
??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@ DB 'm'
	DB	'hmt-pack.c:pack() - can''t make optchain array!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@
CONST	SEGMENT
??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@ DB 'm'
	DB	'hmt-pack.c:pack() - build_hash() failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@
CONST	SEGMENT
??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@ DB 'mh'
	DB	'mt-pack.c:pack() - there must be no zxheader for anything exc'
	DB	'ept hrust or hrum!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@
CONST	SEGMENT
??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@ DB 'mhm'
	DB	't-pack.c:pack() - format unsupported!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _pack
_TEXT	SEGMENT
tv147 = -328						; size = 4
_position$ = -128					; size = 4
_index$ = -116						; size = 2
_last_byte$ = -101					; size = 1
_curr_byte$ = -89					; size = 1
_optch$ = -80						; size = 4
_hash$ = -68						; size = 4
_actual_len$ = -56					; size = 4
_success$ = -44						; size = 4
_emit$ = -32						; size = 4
_get_lz_price$ = -20					; size = 4
_make_lz_codes$ = -8					; size = 4
_pack	PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 18   : 
; 19   : 
; 20   : 	// some format-specific function pointers
; 21   : 	void (*make_lz_codes)(ULONG position, ULONG actual_len, UBYTE * hash, struct lzcode * codes) = NULL; // searches for all

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _make_lz_codes$[ebp], 0

; 22   : 	                                                                                                     // possible lz codes
; 23   : 
; 24   : 	ULONG (*get_lz_price)(ULONG position, struct lzcode * lzcode) = NULL; // generates correct bitlen (price) of code

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _get_lz_price$[ebp], 0

; 25   : 
; 26   : 	ULONG (*emit)(struct optchain * optch, ULONG actual_len) = NULL; // emits lzcode to the output bit/byte stream

  0002c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _emit$[ebp], 0

; 27   : 
; 28   : 
; 29   : 	ULONG success=1;

  00033	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _success$[ebp], 1

; 30   : 
; 31   : 
; 32   : 	ULONG actual_len; // actual length of packing (to account for ZX headers containing last unpacked bytes)
; 33   : 
; 34   : 	UBYTE * hash;
; 35   : 
; 36   : 	struct optchain * optch=NULL;

  0003a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _optch$[ebp], 0

; 37   : 
; 38   : 	static struct lzcode codes[MAX_CODES_SIZE]; // generate codes here; static to ensure it's not on the stack
; 39   : 
; 40   : 
; 41   : 	UBYTE curr_byte, last_byte;
; 42   : 	UWORD index;
; 43   : 	ULONG position;
; 44   : 
; 45   : 
; 46   : 	// some preparations
; 47   : 	//
; 48   : 	if( wrk.packtype==PK_MLZ )

  00041	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  00048	75 17		 jne	 SHORT $LN21@pack

; 49   : 	{
; 50   : 		make_lz_codes = &make_lz_codes_megalz;

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _make_lz_codes$[ebp], OFFSET _make_lz_codes_megalz

; 51   : 		get_lz_price  = &get_lz_price_megalz;

  00051	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _get_lz_price$[ebp], OFFSET _get_lz_price_megalz

; 52   : 		emit          = &emit_megalz;

  00058	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _emit$[ebp], OFFSET _emit_megalz
  0005f	eb 5e		 jmp	 SHORT $LN20@pack
$LN21@pack:

; 53   : 	}
; 54   : 	else if( wrk.packtype==PK_HRM )

  00061	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  00068	75 17		 jne	 SHORT $LN19@pack

; 55   : 	{
; 56   : 		make_lz_codes = &make_lz_codes_hrum;

  0006a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _make_lz_codes$[ebp], OFFSET _make_lz_codes_hrum

; 57   : 		get_lz_price  = &get_lz_price_hrum;

  00071	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _get_lz_price$[ebp], OFFSET _get_lz_price_hrum

; 58   : 		emit          = &emit_hrum;

  00078	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _emit$[ebp], OFFSET _emit_hrum
  0007f	eb 3e		 jmp	 SHORT $LN20@pack
$LN19@pack:

; 59   : 	}
; 60   : 	else if( wrk.packtype==PK_HST )

  00081	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  00088	75 17		 jne	 SHORT $LN17@pack

; 61   : 	{
; 62   : 		make_lz_codes = &make_lz_codes_hrust;

  0008a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _make_lz_codes$[ebp], OFFSET _make_lz_codes_hrust

; 63   : 		get_lz_price  = &get_lz_price_hrust;

  00091	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _get_lz_price$[ebp], OFFSET _get_lz_price_hrust

; 64   : 		emit          = &emit_hrust;

  00098	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _emit$[ebp], OFFSET _emit_hrust

; 65   : 	}
; 66   : 	else

  0009f	eb 1e		 jmp	 SHORT $LN20@pack
$LN17@pack:

; 67   : 	{
; 68   : 		printf("mhmt-pack.c:pack() - format unsupported!\n");

  000a1	8b f4		 mov	 esi, esp
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ae	83 c4 04	 add	 esp, 4
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   : 		return 0;

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 33 02 00 00	 jmp	 $LN22@pack
$LN20@pack:

; 70   : 	}
; 71   : 
; 72   : 
; 73   : 	actual_len = wrk.inlen;

  000bf	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  000c4	89 45 c8	 mov	 DWORD PTR _actual_len$[ebp], eax

; 74   : 	if( wrk.zxheader )

  000c7	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  000ce	74 46		 je	 SHORT $LN15@pack

; 75   : 	{
; 76   : 		if( wrk.packtype==PK_HRM )

  000d0	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _wrk, 2
  000d7	75 0b		 jne	 SHORT $LN14@pack

; 77   : 		{
; 78   : 			actual_len -= 5;

  000d9	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  000dc	83 e8 05	 sub	 eax, 5
  000df	89 45 c8	 mov	 DWORD PTR _actual_len$[ebp], eax
  000e2	eb 32		 jmp	 SHORT $LN15@pack
$LN14@pack:

; 79   : 		}
; 80   : 		else if( wrk.packtype==PK_HST )

  000e4	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  000eb	75 0b		 jne	 SHORT $LN12@pack

; 81   : 		{
; 82   : 			actual_len -= 6;

  000ed	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  000f0	83 e8 06	 sub	 eax, 6
  000f3	89 45 c8	 mov	 DWORD PTR _actual_len$[ebp], eax

; 83   : 		}
; 84   : 		else

  000f6	eb 1e		 jmp	 SHORT $LN15@pack
$LN12@pack:

; 85   : 		{
; 86   : 			printf("mhmt-pack.c:pack() - there must be no zxheader for anything except hrust or hrum!\n");

  000f8	8b f4		 mov	 esi, esp
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00105	83 c4 04	 add	 esp, 4
  00108	3b f4		 cmp	 esi, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 87   : 			return 0;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 dc 01 00 00	 jmp	 $LN22@pack
$LN15@pack:

; 88   : 		}
; 89   : 	}
; 90   : 
; 91   : 
; 92   :         // initializations and preparations
; 93   : 	init_tb();

  00116	e8 00 00 00 00	 call	 _init_tb

; 94   : 
; 95   : 	hash = build_hash(wrk.indata, actual_len);

  0011b	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0011e	50		 push	 eax
  0011f	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 _build_hash
  0012b	83 c4 08	 add	 esp, 8
  0012e	89 45 bc	 mov	 DWORD PTR _hash$[ebp], eax

; 96   : 	if( !hash )

  00131	83 7d bc 00	 cmp	 DWORD PTR _hash$[ebp], 0
  00135	75 1e		 jne	 SHORT $LN10@pack

; 97   : 	{
; 98   : 		printf("mhmt-pack.c:pack() - build_hash() failed!\n");

  00137	8b f4		 mov	 esi, esp
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00144	83 c4 04	 add	 esp, 4
  00147	3b f4		 cmp	 esi, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 99   : 		success = 0;

  0014e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0
$LN10@pack:

; 100  : 	}
; 101  : 
; 102  : 	if( success )

  00155	83 7d d4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00159	74 33		 je	 SHORT $LN9@pack

; 103  : 	{
; 104  : 		optch = make_optch(actual_len);

  0015b	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _make_optch
  00164	83 c4 04	 add	 esp, 4
  00167	89 45 b0	 mov	 DWORD PTR _optch$[ebp], eax

; 105  : 		if( !optch )

  0016a	83 7d b0 00	 cmp	 DWORD PTR _optch$[ebp], 0
  0016e	75 1e		 jne	 SHORT $LN9@pack

; 106  : 		{
; 107  : 			printf("mhmt-pack.c:pack() - can't make optchain array!\n");

  00170	8b f4		 mov	 esi, esp
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0017d	83 c4 04	 add	 esp, 4
  00180	3b f4		 cmp	 esi, esp
  00182	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 			success = 0;

  00187	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0
$LN9@pack:

; 109  : 		}
; 110  : 	}
; 111  : 
; 112  : 
; 113  : 	// go packing!
; 114  : 	if( success )

  0018e	83 7d d4 00	 cmp	 DWORD PTR _success$[ebp], 0
  00192	0f 84 3f 01 00
	00		 je	 $ERROR$3951

; 115  : 	{
; 116  : 		if( !wrk.greedy ) // default optimal coding

  00198	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _wrk+4, 0
  0019f	0f 85 d4 00 00
	00		 jne	 $LN6@pack

; 117  : 		{
; 118  : 			// go generating lzcodes byte-by-byte
; 119  : 			//
; 120  : 			curr_byte = wrk.indata[0];

  001a5	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001aa	8a 08		 mov	 cl, BYTE PTR [eax]
  001ac	88 4d a7	 mov	 BYTE PTR _curr_byte$[ebp], cl

; 121  : 			//
; 122  : 			for(position=1;position<actual_len;position++)

  001af	c7 45 80 01 00
	00 00		 mov	 DWORD PTR _position$[ebp], 1
  001b6	eb 09		 jmp	 SHORT $LN5@pack
$LN4@pack:
  001b8	8b 45 80	 mov	 eax, DWORD PTR _position$[ebp]
  001bb	83 c0 01	 add	 eax, 1
  001be	89 45 80	 mov	 DWORD PTR _position$[ebp], eax
$LN5@pack:
  001c1	8b 45 80	 mov	 eax, DWORD PTR _position$[ebp]
  001c4	3b 45 c8	 cmp	 eax, DWORD PTR _actual_len$[ebp]
  001c7	0f 83 9a 00 00
	00		 jae	 $LN3@pack

; 123  : 			{
; 124  : 				last_byte = curr_byte;

  001cd	8a 45 a7	 mov	 al, BYTE PTR _curr_byte$[ebp]
  001d0	88 45 9b	 mov	 BYTE PTR _last_byte$[ebp], al

; 125  : 				curr_byte = wrk.indata[position];

  001d3	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  001d8	03 45 80	 add	 eax, DWORD PTR _position$[ebp]
  001db	8a 08		 mov	 cl, BYTE PTR [eax]
  001dd	88 4d a7	 mov	 BYTE PTR _curr_byte$[ebp], cl

; 126  : 
; 127  : 				// add current two-byter to the chains
; 128  : 				index = (last_byte<<8) + curr_byte;

  001e0	0f b6 45 9b	 movzx	 eax, BYTE PTR _last_byte$[ebp]
  001e4	c1 e0 08	 shl	 eax, 8
  001e7	0f b6 4d a7	 movzx	 ecx, BYTE PTR _curr_byte$[ebp]
  001eb	03 c1		 add	 eax, ecx
  001ed	66 89 45 8c	 mov	 WORD PTR _index$[ebp], ax

; 129  : 				if( !add_tb(index,position) )

  001f1	8b 45 80	 mov	 eax, DWORD PTR _position$[ebp]
  001f4	50		 push	 eax
  001f5	0f b7 4d 8c	 movzx	 ecx, WORD PTR _index$[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _add_tb
  001ff	83 c4 08	 add	 esp, 8
  00202	85 c0		 test	 eax, eax
  00204	75 23		 jne	 SHORT $LN2@pack

; 130  : 				{
; 131  : 					printf("mhmt-pack.c:pack() - add_tb() failed!\n");

  00206	8b f4		 mov	 esi, esp
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00213	83 c4 04	 add	 esp, 4
  00216	3b f4		 cmp	 esi, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 132  : 					success = 0;

  0021d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 133  : 					goto ERROR;

  00224	e9 ae 00 00 00	 jmp	 $ERROR$3951
$LN2@pack:

; 134  : 				}
; 135  : 
; 136  : 				// search lzcodes for given position
; 137  : 				(*make_lz_codes)(position, actual_len, hash, codes);

  00229	8b f4		 mov	 esi, esp
  0022b	68 00 00 00 00	 push	 OFFSET ?codes@?1??pack@@9@9
  00230	8b 45 bc	 mov	 eax, DWORD PTR _hash$[ebp]
  00233	50		 push	 eax
  00234	8b 4d c8	 mov	 ecx, DWORD PTR _actual_len$[ebp]
  00237	51		 push	 ecx
  00238	8b 55 80	 mov	 edx, DWORD PTR _position$[ebp]
  0023b	52		 push	 edx
  0023c	ff 55 f8	 call	 DWORD PTR _make_lz_codes$[ebp]
  0023f	83 c4 10	 add	 esp, 16			; 00000010H
  00242	3b f4		 cmp	 esi, esp
  00244	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 138  : 
; 139  : 				// update optimal chain with lzcodes
; 140  : 				update_optch(position, codes, get_lz_price, optch);

  00249	8b 45 b0	 mov	 eax, DWORD PTR _optch$[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d ec	 mov	 ecx, DWORD PTR _get_lz_price$[ebp]
  00250	51		 push	 ecx
  00251	68 00 00 00 00	 push	 OFFSET ?codes@?1??pack@@9@9
  00256	8b 55 80	 mov	 edx, DWORD PTR _position$[ebp]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 _update_optch
  0025f	83 c4 10	 add	 esp, 16			; 00000010H

; 141  : 			}

  00262	e9 51 ff ff ff	 jmp	 $LN4@pack
$LN3@pack:

; 142  : 
; 143  : 
; 144  : 			// all input bytes scanned, chain built, so now reverse it (prepare for scanning in output generation part)
; 145  : 			reverse_optch(optch, actual_len);

  00267	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0026a	50		 push	 eax
  0026b	8b 4d b0	 mov	 ecx, DWORD PTR _optch$[ebp]
  0026e	51		 push	 ecx
  0026f	e8 00 00 00 00	 call	 _reverse_optch
  00274	83 c4 08	 add	 esp, 8

; 146  : 		}
; 147  : 		else // greedy coding

  00277	eb 1e		 jmp	 SHORT $LN1@pack
$LN6@pack:

; 148  : 		{
; 149  : 			printf("mhmt-pack.c:pack() - greedy coding not supported!\n");

  00279	8b f4		 mov	 esi, esp
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@
  00280	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00286	83 c4 04	 add	 esp, 4
  00289	3b f4		 cmp	 esi, esp
  0028b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 150  : 			success = 0;

  00290	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0
$LN1@pack:

; 151  : 		}
; 152  : 
; 153  : 		// data built, now emit packed file
; 154  : 		success = success && (*emit)(optch, actual_len);

  00297	83 7d d4 00	 cmp	 DWORD PTR _success$[ebp], 0
  0029b	74 27		 je	 SHORT $LN24@pack
  0029d	8b f4		 mov	 esi, esp
  0029f	8b 45 c8	 mov	 eax, DWORD PTR _actual_len$[ebp]
  002a2	50		 push	 eax
  002a3	8b 4d b0	 mov	 ecx, DWORD PTR _optch$[ebp]
  002a6	51		 push	 ecx
  002a7	ff 55 e0	 call	 DWORD PTR _emit$[ebp]
  002aa	83 c4 08	 add	 esp, 8
  002ad	3b f4		 cmp	 esi, esp
  002af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b4	85 c0		 test	 eax, eax
  002b6	74 0c		 je	 SHORT $LN24@pack
  002b8	c7 85 b8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv147[ebp], 1
  002c2	eb 0a		 jmp	 SHORT $LN25@pack
$LN24@pack:
  002c4	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
$LN25@pack:
  002ce	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv147[ebp]
  002d4	89 55 d4	 mov	 DWORD PTR _success$[ebp], edx
$ERROR$3951:

; 155  : 	}
; 156  : 
; 157  : 
; 158  : 
; 159  : 
; 160  : 
; 161  : ERROR:
; 162  : 	free_optch(optch);

  002d7	8b 45 b0	 mov	 eax, DWORD PTR _optch$[ebp]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 _free_optch
  002e0	83 c4 04	 add	 esp, 4

; 163  : 
; 164  : 	destroy_hash(hash);

  002e3	8b 45 bc	 mov	 eax, DWORD PTR _hash$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _destroy_hash
  002ec	83 c4 04	 add	 esp, 4

; 165  : 
; 166  : 	return success;

  002ef	8b 45 d4	 mov	 eax, DWORD PTR _success$[ebp]
$LN22@pack:

; 167  : }

  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  002fb	3b ec		 cmp	 ebp, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
_pack	ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-parsearg.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@BFNKOLLP@maxwin65536?$AA@		; `string'
PUBLIC	??_C@_0M@MFHGIBPC@maxwin32768?$AA@		; `string'
PUBLIC	??_C@_0M@FEHHHDGI@maxwin16384?$AA@		; `string'
PUBLIC	??_C@_0L@OPCPICNH@maxwin8192?$AA@		; `string'
PUBLIC	??_C@_0L@IJMMFODJ@maxwin4352?$AA@		; `string'
PUBLIC	??_C@_0L@PGAPMNLH@maxwin4096?$AA@		; `string'
PUBLIC	??_C@_0L@OPBEIGMK@maxwin2048?$AA@		; `string'
PUBLIC	??_C@_0L@IMMPKE@maxwin1024?$AA@			; `string'
PUBLIC	??_C@_09CDNLKNNF@maxwin512?$AA@			; `string'
PUBLIC	??_C@_09NNGJPILE@maxwin256?$AA@			; `string'
PUBLIC	??_C@_04JFAPGDHH@bend?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_03CNPPLIFM@zxh?$AA@			; `string'
PUBLIC	??_C@_03DNMNJFPE@hst?$AA@			; `string'
PUBLIC	??_C@_03KHAPFGNL@hrm?$AA@			; `string'
PUBLIC	??_C@_03IDOKKMAF@mlz?$AA@			; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	_default_arg_table
_DATA	SEGMENT
_default_arg_table DD FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	01H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	02H
	DD	FLAT:??_C@_03IDOKKMAF@mlz?$AA@
	DD	03H
	DD	FLAT:??_C@_03KHAPFGNL@hrm?$AA@
	DD	03H
	DD	FLAT:??_C@_03DNMNJFPE@hst?$AA@
	DD	03H
	DD	FLAT:??_C@_03CNPPLIFM@zxh?$AA@
	DD	04H
	DD	FLAT:??_C@_01KJLJFBPL@8?$AA@
	DD	05H
	DD	FLAT:??_C@_02KMALDIDP@16?$AA@
	DD	05H
	DD	FLAT:??_C@_04JFAPGDHH@bend?$AA@
	DD	06H
	DD	FLAT:??_C@_09NNGJPILE@maxwin256?$AA@
	DD	07H
	DD	FLAT:??_C@_09CDNLKNNF@maxwin512?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@IMMPKE@maxwin1024?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@OPBEIGMK@maxwin2048?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@PGAPMNLH@maxwin4096?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@IJMMFODJ@maxwin4352?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@OPCPICNH@maxwin8192?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@FEHHHDGI@maxwin16384?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@MFHGIBPC@maxwin32768?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@BFNKOLLP@maxwin65536?$AA@
	DD	07H
	DD	00H
	DD	00H
?strings@?1??get_maxwin@@9@9 DD FLAT:??_C@_09NNGJPILE@maxwin256?$AA@ ; `get_maxwin'::`2'::strings
	DD	FLAT:??_C@_09CDNLKNNF@maxwin512?$AA@
	DD	FLAT:??_C@_0L@IMMPKE@maxwin1024?$AA@
	DD	FLAT:??_C@_0L@OPBEIGMK@maxwin2048?$AA@
	DD	FLAT:??_C@_0L@PGAPMNLH@maxwin4096?$AA@
	DD	FLAT:??_C@_0L@IJMMFODJ@maxwin4352?$AA@
	DD	FLAT:??_C@_0L@OPCPICNH@maxwin8192?$AA@
	DD	FLAT:??_C@_0M@FEHHHDGI@maxwin16384?$AA@
	DD	FLAT:??_C@_0M@MFHGIBPC@maxwin32768?$AA@
	DD	FLAT:??_C@_0M@BFNKOLLP@maxwin65536?$AA@
	DD	00H
?sizes@?1??get_maxwin@@9@9 DD 0100H			; `get_maxwin'::`2'::sizes
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	01100H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0M@BFNKOLLP@maxwin65536?$AA@
CONST	SEGMENT
??_C@_0M@BFNKOLLP@maxwin65536?$AA@ DB 'maxwin65536', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MFHGIBPC@maxwin32768?$AA@
CONST	SEGMENT
??_C@_0M@MFHGIBPC@maxwin32768?$AA@ DB 'maxwin32768', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEHHHDGI@maxwin16384?$AA@
CONST	SEGMENT
??_C@_0M@FEHHHDGI@maxwin16384?$AA@ DB 'maxwin16384', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPCPICNH@maxwin8192?$AA@
CONST	SEGMENT
??_C@_0L@OPCPICNH@maxwin8192?$AA@ DB 'maxwin8192', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IJMMFODJ@maxwin4352?$AA@
CONST	SEGMENT
??_C@_0L@IJMMFODJ@maxwin4352?$AA@ DB 'maxwin4352', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGAPMNLH@maxwin4096?$AA@
CONST	SEGMENT
??_C@_0L@PGAPMNLH@maxwin4096?$AA@ DB 'maxwin4096', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPBEIGMK@maxwin2048?$AA@
CONST	SEGMENT
??_C@_0L@OPBEIGMK@maxwin2048?$AA@ DB 'maxwin2048', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IMMPKE@maxwin1024?$AA@
CONST	SEGMENT
??_C@_0L@IMMPKE@maxwin1024?$AA@ DB 'maxwin1024', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CDNLKNNF@maxwin512?$AA@
CONST	SEGMENT
??_C@_09CDNLKNNF@maxwin512?$AA@ DB 'maxwin512', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNGJPILE@maxwin256?$AA@
CONST	SEGMENT
??_C@_09NNGJPILE@maxwin256?$AA@ DB 'maxwin256', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFAPGDHH@bend?$AA@
CONST	SEGMENT
??_C@_04JFAPGDHH@bend?$AA@ DB 'bend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNPPLIFM@zxh?$AA@
CONST	SEGMENT
??_C@_03CNPPLIFM@zxh?$AA@ DB 'zxh', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNMNJFPE@hst?$AA@
CONST	SEGMENT
??_C@_03DNMNJFPE@hst?$AA@ DB 'hst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHAPFGNL@hrm?$AA@
CONST	SEGMENT
??_C@_03KHAPFGNL@hrm?$AA@ DB 'hrm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDOKKMAF@mlz?$AA@
CONST	SEGMENT
??_C@_03IDOKKMAF@mlz?$AA@ DB 'mlz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@ ; `string'
PUBLIC	??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@ ; `string'
PUBLIC	_get_maxwin
PUBLIC	??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@ ; `string'
PUBLIC	??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@ ; `string'
PUBLIC	??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@ ; `string'
PUBLIC	??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@ ; `string'
PUBLIC	??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@ ; `string'
PUBLIC	_sort_args
PUBLIC	??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@ ; `string'
PUBLIC	??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@ ; `string'
PUBLIC	_match_arg
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	_cmp_str_nocase
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@ ; `string'
PUBLIC	_parse_args
EXTRN	_wrk:BYTE
EXTRN	_strcpy:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__printf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@
; File d:\d\mhmt\src\mhmt-parsearg.c
CONST	SEGMENT
??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #4! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@
CONST	SEGMENT
??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@ DB 'Maximum win'
	DB	'dow specified is too big for given packing type!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #3! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@
CONST	SEGMENT
??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@ DB 'There can '
	DB	'be only little-endian arrangement of bits when ZX-header is a'
	DB	'ctive!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #2! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@
CONST	SEGMENT
??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@ DB 'There can b'
	DB	'e only 16bit grouping of bits when ZX-header is active!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@
CONST	SEGMENT
??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@ DB 'There cou'
	DB	'ldn''t be zx-header in megalz mode!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #1! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@
CONST	SEGMENT
??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@ DB 'No greedy mo'
	DB	'de specification for DEpacking!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@ DB 'Redundant argument'
	DB	's!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@ DB 'No filenames s'
	DB	'pecified!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@
CONST	SEGMENT
??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@ DB 'Cannot alloc'
	DB	'ate memory for filename string!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@ DB 'Too man'
	DB	'y filenames specified!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@ DB 'Wrong arguments!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@ DB 'Too many arguments'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@
CONST	SEGMENT
??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@ DB 'N'
	DB	'o arguments! Use "mhmt -h" or "mhmt -help" for help!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _parse_args
_TEXT	SEGMENT
tv172 = -436						; size = 4
_i$ = -236						; size = 4
_maxwin$ = -224						; size = 4
_last_arg_type$ = -212					; size = 4
_temp_filename$ = -200					; size = 4
_files_num$ = -188					; size = 4
_storearg_pos$ = -176					; size = 4
_inarg_pos$ = -164					; size = 4
_arg$ = -152						; size = 4
_argstore$ = -140					; size = 136
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_parse_args PROC					; COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 4c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-436]
  00012	b9 6d 00 00 00	 mov	 ecx, 109		; 0000006dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 47   : 	struct argtbl argstore[ARG_STORE_SIZE+1]; // last element is always stop-value
; 48   : 
; 49   : 
; 50   : 
; 51   : 	struct argtbl * arg;
; 52   : 
; 53   : 	ULONG inarg_pos; // position in argv[] array
; 54   : 	ULONG storearg_pos; // position in argstore[] array
; 55   : 
; 56   : 	ULONG files_num; // number of filenames specified
; 57   : 
; 58   : 	char * temp_filename;
; 59   : 
; 60   : 	ULONG last_arg_type;
; 61   : 
; 62   : 	ULONG maxwin;
; 63   : 
; 64   : 
; 65   : 	ULONG i;
; 66   : 	for(i=0;i<ARG_STORE_SIZE+1;i++)

  0001e	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00028	eb 0f		 jmp	 SHORT $LN47@parse_args
$LN46@parse_args:
  0002a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 85 14 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN47@parse_args:
  00039	83 bd 14 ff ff
	ff 11		 cmp	 DWORD PTR _i$[ebp], 17	; 00000011H
  00040	73 24		 jae	 SHORT $LN45@parse_args

; 67   : 	{
; 68   : 		argstore[i].name = NULL;

  00042	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00048	c7 84 c5 74 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _argstore$[ebp+eax*8], 0

; 69   : 		argstore[i].type = ARG_NOARG;

  00053	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00059	c7 84 c5 78 ff
	ff ff ff 00 00
	00		 mov	 DWORD PTR _argstore$[ebp+eax*8+4], 255 ; 000000ffH

; 70   : 	}

  00064	eb c4		 jmp	 SHORT $LN46@parse_args
$LN45@parse_args:

; 71   : 
; 72   : 
; 73   : 	if( argc<2 )

  00066	83 7d 08 02	 cmp	 DWORD PTR _argc$[ebp], 2
  0006a	7d 1e		 jge	 SHORT $LN44@parse_args

; 74   : 	{
; 75   : 		printf("No arguments! Use \"mhmt -h\" or \"mhmt -help\" for help!\n");

  0006c	8b f4		 mov	 esi, esp
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00079	83 c4 04	 add	 esp, 4
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   : 		return 0L;

  00083	33 c0		 xor	 eax, eax
  00085	e9 70 06 00 00	 jmp	 $LN48@parse_args
$LN44@parse_args:

; 77   : 	}
; 78   : 
; 79   : 	// shortcut for help request
; 80   : 	if( !cmp_str_nocase( argv[1]+1, "h" ) || !cmp_str_nocase( argv[1]+1, "help" ) )

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_01BDACAMKP@h?$AA@
  0008f	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 01	 add	 ecx, 1
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _cmp_str_nocase
  0009e	83 c4 08	 add	 esp, 8
  000a1	85 c0		 test	 eax, eax
  000a3	74 1b		 je	 SHORT $LN42@parse_args
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_04PCJFHION@help?$AA@
  000aa	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  000ad	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b0	83 c1 01	 add	 ecx, 1
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _cmp_str_nocase
  000b9	83 c4 08	 add	 esp, 8
  000bc	85 c0		 test	 eax, eax
  000be	75 0a		 jne	 SHORT $LN43@parse_args
$LN42@parse_args:

; 81   : 		return ARG_PARSER_SHOWHELP;

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	e9 30 06 00 00	 jmp	 $LN48@parse_args
$LN43@parse_args:

; 82   : 
; 83   : 
; 84   : 	inarg_pos = 1;

  000ca	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _inarg_pos$[ebp], 1

; 85   : 	storearg_pos = 0;

  000d4	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _storearg_pos$[ebp], 0

; 86   : 	files_num = 0;

  000de	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _files_num$[ebp], 0
$LN41@parse_args:

; 87   : 
; 88   : 	// first find all arguments beginning with "-"
; 89   : 	while( inarg_pos<(ULONG)argc && *(argv[inarg_pos])=='-' )

  000e8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  000ee	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  000f1	0f 83 ce 00 00
	00		 jae	 $LN36@parse_args
  000f7	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00100	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00103	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00106	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00109	0f 85 b6 00 00
	00		 jne	 $LN36@parse_args

; 90   : 	{
; 91   : 		arg=match_arg(argv[inarg_pos]+1); // search match...

  0010f	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  00115	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00118	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0011b	83 c2 01	 add	 edx, 1
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _match_arg
  00124	83 c4 04	 add	 esp, 4
  00127	89 85 68 ff ff
	ff		 mov	 DWORD PTR _arg$[ebp], eax

; 92   : 		if( arg ) // match!

  0012d	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _arg$[ebp], 0
  00134	74 5a		 je	 SHORT $LN39@parse_args

; 93   : 		{
; 94   : 			if( storearg_pos>=ARG_STORE_SIZE )

  00136	83 bd 50 ff ff
	ff 10		 cmp	 DWORD PTR _storearg_pos$[ebp], 16 ; 00000010H
  0013d	72 21		 jb	 SHORT $LN38@parse_args

; 95   : 			{
; 96   : 				printf("Too many arguments!\n");

  0013f	8b f4		 mov	 esi, esp
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0014c	83 c4 04	 add	 esp, 4
  0014f	3b f4		 cmp	 esi, esp
  00151	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 97   : 				return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  00156	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  0015b	e9 9a 05 00 00	 jmp	 $LN48@parse_args
$LN38@parse_args:

; 98   : 			}
; 99   : 
; 100  : 			argstore[storearg_pos++] = *arg;

  00160	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _arg$[ebp]
  00166	8b 08		 mov	 ecx, DWORD PTR [eax]
  00168	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0016b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  00171	89 8c c5 74 ff
	ff ff		 mov	 DWORD PTR _argstore$[ebp+eax*8], ecx
  00178	89 94 c5 78 ff
	ff ff		 mov	 DWORD PTR _argstore$[ebp+eax*8+4], edx
  0017f	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _storearg_pos$[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _storearg_pos$[ebp], ecx

; 101  : 		}
; 102  : 		else // argument does not match predefined set

  0018e	eb 21		 jmp	 SHORT $LN37@parse_args
$LN39@parse_args:

; 103  : 		{
; 104  : 			printf("Wrong arguments!\n");

  00190	8b f4		 mov	 esi, esp
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0019d	83 c4 04	 add	 esp, 4
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  001a7	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  001ac	e9 49 05 00 00	 jmp	 $LN48@parse_args
$LN37@parse_args:

; 106  : 		}
; 107  : 
; 108  : 		inarg_pos++;

  001b1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	89 85 5c ff ff
	ff		 mov	 DWORD PTR _inarg_pos$[ebp], eax

; 109  : 	}

  001c0	e9 23 ff ff ff	 jmp	 $LN41@parse_args
$LN36@parse_args:

; 110  : 
; 111  : 	// parse filenames then
; 112  : 	while( inarg_pos<(ULONG)argc )

  001c5	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  001cb	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  001ce	0f 83 e5 00 00
	00		 jae	 $LN35@parse_args

; 113  : 	{
; 114  : 		if( files_num>=2 ) // there should be no more than two filenames

  001d4	83 bd 44 ff ff
	ff 02		 cmp	 DWORD PTR _files_num$[ebp], 2
  001db	72 21		 jb	 SHORT $LN34@parse_args

; 115  : 		{
; 116  : 			printf("Too many filenames specified!\n");

  001dd	8b f4		 mov	 esi, esp
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001ea	83 c4 04	 add	 esp, 4
  001ed	3b f4		 cmp	 esi, esp
  001ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 117  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  001f4	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  001f9	e9 fc 04 00 00	 jmp	 $LN48@parse_args
$LN34@parse_args:

; 118  : 		}
; 119  : 
; 120  : 		temp_filename = (char *)malloc( 1+strlen(argv[inarg_pos]) );

  001fe	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  00204	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00207	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0020a	52		 push	 edx
  0020b	e8 00 00 00 00	 call	 _strlen
  00210	83 c4 04	 add	 esp, 4
  00213	83 c0 01	 add	 eax, 1
  00216	8b f4		 mov	 esi, esp
  00218	50		 push	 eax
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0021f	83 c4 04	 add	 esp, 4
  00222	3b f4		 cmp	 esi, esp
  00224	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00229	89 85 38 ff ff
	ff		 mov	 DWORD PTR _temp_filename$[ebp], eax

; 121  : 		if( !temp_filename )

  0022f	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR _temp_filename$[ebp], 0
  00236	75 21		 jne	 SHORT $LN33@parse_args

; 122  : 		{
; 123  : 			printf("Cannot allocate memory for filename string!\n");

  00238	8b f4		 mov	 esi, esp
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00245	83 c4 04	 add	 esp, 4
  00248	3b f4		 cmp	 esi, esp
  0024a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 124  : 			return ARG_PARSER_ERROR;

  0024f	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00254	e9 a1 04 00 00	 jmp	 $LN48@parse_args
$LN33@parse_args:

; 125  : 		}
; 126  : 
; 127  : 		strcpy( temp_filename, argv[inarg_pos] );

  00259	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  0025f	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00262	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00265	52		 push	 edx
  00266	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _temp_filename$[ebp]
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _strcpy
  00272	83 c4 08	 add	 esp, 8

; 128  : 
; 129  : 		if( files_num==0 )

  00275	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _files_num$[ebp], 0
  0027c	75 0d		 jne	 SHORT $LN32@parse_args

; 130  : 			wrk.fname_in = temp_filename;

  0027e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _temp_filename$[ebp]
  00284	a3 20 00 00 00	 mov	 DWORD PTR _wrk+32, eax

; 131  : 		else // only files_num==1, because of condition in the beginning of current "while" cycle

  00289	eb 0b		 jmp	 SHORT $LN31@parse_args
$LN32@parse_args:

; 132  : 			wrk.fname_out = temp_filename;

  0028b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _temp_filename$[ebp]
  00291	a3 24 00 00 00	 mov	 DWORD PTR _wrk+36, eax
$LN31@parse_args:

; 133  : 
; 134  : 		files_num++;

  00296	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _files_num$[ebp]
  0029c	83 c0 01	 add	 eax, 1
  0029f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _files_num$[ebp], eax

; 135  : 		inarg_pos++;

  002a5	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _inarg_pos$[ebp]
  002ab	83 c0 01	 add	 eax, 1
  002ae	89 85 5c ff ff
	ff		 mov	 DWORD PTR _inarg_pos$[ebp], eax

; 136  : 	}

  002b4	e9 0c ff ff ff	 jmp	 $LN36@parse_args
$LN35@parse_args:

; 137  : 
; 138  : 	if( !files_num ) // there must be at least 1 filename specified

  002b9	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _files_num$[ebp], 0
  002c0	75 21		 jne	 SHORT $LN30@parse_args

; 139  : 	{
; 140  : 		printf("No filenames specified!\n");

  002c2	8b f4		 mov	 esi, esp
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002cf	83 c4 04	 add	 esp, 4
  002d2	3b f4		 cmp	 esi, esp
  002d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 141  : 		return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  002d9	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  002de	e9 17 04 00 00	 jmp	 $LN48@parse_args
$LN30@parse_args:

; 142  : 	}
; 143  : 
; 144  : 
; 145  : 	// now optional arguments (starting with "-") are stored in argstore[],
; 146  : 	// all needed filenames are also copied, go proceed configuring with
; 147  : 	// optional arguments
; 148  : 
; 149  : 	// sort argument array (in increasing .type order) to ensure correct parsing
; 150  : 	sort_args( argstore, ARG_STORE_SIZE );

  002e3	6a 10		 push	 16			; 00000010H
  002e5	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _argstore$[ebp]
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 _sort_args
  002f1	83 c4 08	 add	 esp, 8

; 151  : 
; 152  : 	storearg_pos = 0;

  002f4	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _storearg_pos$[ebp], 0

; 153  : 	last_arg_type = ARG_INIT; // there is no such value in argstore[].type

  002fe	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _last_arg_type$[ebp], 0
$LN29@parse_args:

; 154  : 	while( argstore[storearg_pos].type != ARG_NOARG )

  00308	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  0030e	81 bc c5 78 ff
	ff ff ff 00 00
	00		 cmp	 DWORD PTR _argstore$[ebp+eax*8+4], 255 ; 000000ffH
  00319	0f 84 d6 03 00
	00		 je	 $LN28@parse_args

; 155  : 	{
; 156  : 		if( last_arg_type == argstore[storearg_pos].type )

  0031f	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  00325	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _last_arg_type$[ebp]
  0032b	3b 8c c5 78 ff
	ff ff		 cmp	 ecx, DWORD PTR _argstore$[ebp+eax*8+4]
  00332	75 21		 jne	 SHORT $LN27@parse_args

; 157  : 		{
; 158  : 			printf("Redundant arguments!\n");

  00334	8b f4		 mov	 esi, esp
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00341	83 c4 04	 add	 esp, 4
  00344	3b f4		 cmp	 esi, esp
  00346	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 159  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  0034b	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  00350	e9 a5 03 00 00	 jmp	 $LN48@parse_args
$LN27@parse_args:

; 160  : 		}
; 161  : 
; 162  : 		switch( argstore[storearg_pos].type )

  00355	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  0035b	8b 8c c5 78 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8+4]
  00362	89 8d 4c fe ff
	ff		 mov	 DWORD PTR tv172[ebp], ecx
  00368	8b 95 4c fe ff
	ff		 mov	 edx, DWORD PTR tv172[ebp]
  0036e	83 ea 01	 sub	 edx, 1
  00371	89 95 4c fe ff
	ff		 mov	 DWORD PTR tv172[ebp], edx
  00377	83 bd 4c fe ff
	ff 06		 cmp	 DWORD PTR tv172[ebp], 6
  0037e	0f 87 2c 03 00
	00		 ja	 $LN1@parse_args
  00384	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  0038a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN53@parse_args[eax*4]
$LN24@parse_args:

; 163  : 		{
; 164  : 		case ARG_MODE:
; 165  : 			wrk.mode = 1; // set depack mode

  00391	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+8, 1

; 166  : 			break;

  0039b	e9 2e 03 00 00	 jmp	 $LN25@parse_args
$LN23@parse_args:

; 167  : 
; 168  : 		case ARG_GREEDY:
; 169  : 			if( wrk.mode ) // since sorted, argument list causes parsing go from up to down in this "case" list

  003a0	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _wrk+8, 0
  003a7	74 21		 je	 SHORT $LN22@parse_args

; 170  : 			{
; 171  : 				printf("No greedy mode specification for DEpacking!\n");

  003a9	8b f4		 mov	 esi, esp
  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@
  003b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003b6	83 c4 04	 add	 esp, 4
  003b9	3b f4		 cmp	 esi, esp
  003bb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  : 				return ARG_PARSER_ERROR;

  003c0	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  003c5	e9 30 03 00 00	 jmp	 $LN48@parse_args
$LN22@parse_args:

; 173  : 			}
; 174  : 			wrk.greedy = 1; // set greedy packing mode

  003ca	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+4, 1

; 175  : 			break;

  003d4	e9 f5 02 00 00	 jmp	 $LN25@parse_args
$LN21@parse_args:

; 176  : 
; 177  : 		case ARG_PTYPE:
; 178  : 			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_MEGALZ ) )

  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_03IDOKKMAF@mlz?$AA@
  003de	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  003e4	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  003eb	51		 push	 ecx
  003ec	e8 00 00 00 00	 call	 _cmp_str_nocase
  003f1	83 c4 08	 add	 esp, 8
  003f4	85 c0		 test	 eax, eax
  003f6	75 41		 jne	 SHORT $LN20@parse_args

; 179  : 			{
; 180  : 				wrk.packtype = PK_MLZ;

  003f8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk, 1

; 181  : 				wrk.zxheader = 0;

  00402	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+12, 0

; 182  : 				wrk.wordbit  = 0;

  0040c	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+16, 0

; 183  : 				wrk.bigend   = 0;

  00416	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+20, 0

; 184  : 				wrk.fullbits = 0;

  00420	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+24, 0

; 185  : 				wrk.maxwin   = 4352;

  0042a	c7 05 1c 00 00
	00 00 11 00 00	 mov	 DWORD PTR _wrk+28, 4352	; 00001100H
  00434	e9 db 00 00 00	 jmp	 $LN19@parse_args
$LN20@parse_args:

; 186  : 			}
; 187  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUM ) )

  00439	68 00 00 00 00	 push	 OFFSET ??_C@_03KHAPFGNL@hrm?$AA@
  0043e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  00444	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  0044b	51		 push	 ecx
  0044c	e8 00 00 00 00	 call	 _cmp_str_nocase
  00451	83 c4 08	 add	 esp, 8
  00454	85 c0		 test	 eax, eax
  00456	75 3e		 jne	 SHORT $LN18@parse_args

; 188  : 			{
; 189  : 				wrk.packtype = PK_HRM;

  00458	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _wrk, 2

; 190  : 				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified

  00462	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+12, 0

; 191  : 				wrk.wordbit  = 1;

  0046c	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+16, 1

; 192  : 				wrk.bigend   = 0;

  00476	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+20, 0

; 193  : 				wrk.fullbits = 1;

  00480	c7 05 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+24, 1

; 194  : 				wrk.maxwin   = 4096;

  0048a	c7 05 1c 00 00
	00 00 10 00 00	 mov	 DWORD PTR _wrk+28, 4096	; 00001000H
  00494	eb 7e		 jmp	 SHORT $LN19@parse_args
$LN18@parse_args:

; 195  : 			}
; 196  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUST ) )

  00496	68 00 00 00 00	 push	 OFFSET ??_C@_03DNMNJFPE@hst?$AA@
  0049b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  004a1	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  004a8	51		 push	 ecx
  004a9	e8 00 00 00 00	 call	 _cmp_str_nocase
  004ae	83 c4 08	 add	 esp, 8
  004b1	85 c0		 test	 eax, eax
  004b3	75 3e		 jne	 SHORT $LN16@parse_args

; 197  : 			{
; 198  : 				wrk.packtype = PK_HST;

  004b5	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _wrk, 3

; 199  : 				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified

  004bf	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+12, 0

; 200  : 				wrk.wordbit  = 1;

  004c9	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+16, 1

; 201  : 				wrk.bigend   = 0;

  004d3	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+20, 0

; 202  : 				wrk.fullbits = 1;

  004dd	c7 05 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+24, 1

; 203  : 				wrk.maxwin   = 65536;

  004e7	c7 05 1c 00 00
	00 00 00 01 00	 mov	 DWORD PTR _wrk+28, 65536 ; 00010000H

; 204  : 			}
; 205  : 			else // there shouldn't be this case, but nevertheless...

  004f1	eb 21		 jmp	 SHORT $LN19@parse_args
$LN16@parse_args:

; 206  : 			{
; 207  : 				printf("Impossible error #1! Press any key to continue or \"SPACE\" to exit... :-)\n");

  004f3	8b f4		 mov	 esi, esp
  004f5	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@
  004fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00500	83 c4 04	 add	 esp, 4
  00503	3b f4		 cmp	 esi, esp
  00505	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 208  : 				return ARG_PARSER_ERROR;

  0050a	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0050f	e9 e6 01 00 00	 jmp	 $LN48@parse_args
$LN19@parse_args:

; 209  : 			}
; 210  : 			break;

  00514	e9 b5 01 00 00	 jmp	 $LN25@parse_args
$LN14@parse_args:

; 211  : 
; 212  : 		case ARG_ZXHEAD:
; 213  : 			// ZX-header is not applicable for PK_MLZ type...
; 214  : 			// also wrk.packtype has been already set before...
; 215  : 			if( PK_MLZ==wrk.packtype )

  00519	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  00520	75 21		 jne	 SHORT $LN13@parse_args

; 216  : 			{
; 217  : 				printf("There couldn't be zx-header in megalz mode!\n");

  00522	8b f4		 mov	 esi, esp
  00524	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@
  00529	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0052f	83 c4 04	 add	 esp, 4
  00532	3b f4		 cmp	 esi, esp
  00534	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 218  : 				return ARG_PARSER_ERROR;

  00539	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0053e	e9 b7 01 00 00	 jmp	 $LN48@parse_args
$LN13@parse_args:

; 219  : 			}
; 220  : 			wrk.zxheader = 1;

  00543	c7 05 0c 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+12, 1

; 221  : 			break;

  0054d	e9 7c 01 00 00	 jmp	 $LN25@parse_args
$LN12@parse_args:

; 222  : 
; 223  : 		case ARG_WORD:
; 224  : 			// whether bits must be grouped in words or in bytes
; 225  : 			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_8 ) )

  00552	68 00 00 00 00	 push	 OFFSET ??_C@_01KJLJFBPL@8?$AA@
  00557	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  0055d	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  00564	51		 push	 ecx
  00565	e8 00 00 00 00	 call	 _cmp_str_nocase
  0056a	83 c4 08	 add	 esp, 8
  0056d	85 c0		 test	 eax, eax
  0056f	75 36		 jne	 SHORT $LN11@parse_args

; 226  : 			{
; 227  : 				if( wrk.zxheader ) // won't force byte-wise bits when there is a zx-header

  00571	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00578	74 21		 je	 SHORT $LN10@parse_args

; 228  : 				{
; 229  : 					printf("There can be only 16bit grouping of bits when ZX-header is active!\n");

  0057a	8b f4		 mov	 esi, esp
  0057c	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@
  00581	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00587	83 c4 04	 add	 esp, 4
  0058a	3b f4		 cmp	 esi, esp
  0058c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 230  : 					return ARG_PARSER_ERROR;

  00591	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00596	e9 5f 01 00 00	 jmp	 $LN48@parse_args
$LN10@parse_args:

; 231  : 				}
; 232  : 				wrk.wordbit = 0;

  0059b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wrk+16, 0
  005a5	eb 4c		 jmp	 SHORT $LN9@parse_args
$LN11@parse_args:

; 233  : 			}
; 234  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_16 ) )

  005a7	68 00 00 00 00	 push	 OFFSET ??_C@_02KMALDIDP@16?$AA@
  005ac	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  005b2	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  005b9	51		 push	 ecx
  005ba	e8 00 00 00 00	 call	 _cmp_str_nocase
  005bf	83 c4 08	 add	 esp, 8
  005c2	85 c0		 test	 eax, eax
  005c4	75 0c		 jne	 SHORT $LN8@parse_args

; 235  : 			{
; 236  : 				wrk.wordbit = 1;

  005c6	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+16, 1

; 237  : 			}
; 238  : 			else // there shouldn't be this case, but nevertheless...

  005d0	eb 21		 jmp	 SHORT $LN9@parse_args
$LN8@parse_args:

; 239  : 			{
; 240  : 				printf("Impossible error #2! Press any key to continue or \"SPACE\" to exit... :-)\n");

  005d2	8b f4		 mov	 esi, esp
  005d4	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@
  005d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005df	83 c4 04	 add	 esp, 4
  005e2	3b f4		 cmp	 esi, esp
  005e4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 241  : 				return ARG_PARSER_ERROR;

  005e9	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  005ee	e9 07 01 00 00	 jmp	 $LN48@parse_args
$LN9@parse_args:

; 242  : 			}
; 243  : 			break;

  005f3	e9 d6 00 00 00	 jmp	 $LN25@parse_args
$LN6@parse_args:

; 244  : 
; 245  : 		case ARG_BIGEND:
; 246  : 			// whether word-grouped bits must be big- or little-endian arranged
; 247  : 			if( wrk.zxheader )

  005f8	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  005ff	74 21		 je	 SHORT $LN5@parse_args

; 248  : 			{
; 249  : 				printf("There can be only little-endian arrangement of bits when ZX-header is active!\n");

  00601	8b f4		 mov	 esi, esp
  00603	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@
  00608	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0060e	83 c4 04	 add	 esp, 4
  00611	3b f4		 cmp	 esi, esp
  00613	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 250  : 				return ARG_PARSER_ERROR;

  00618	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0061d	e9 d8 00 00 00	 jmp	 $LN48@parse_args
$LN5@parse_args:

; 251  : 			}
; 252  : 			wrk.bigend = 1;

  00622	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk+20, 1

; 253  : 			break;

  0062c	e9 9d 00 00 00	 jmp	 $LN25@parse_args
$LN4@parse_args:

; 254  : 
; 255  : 		case ARG_MAXWIN:
; 256  : 			maxwin = get_maxwin( argstore[storearg_pos].name );

  00631	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  00637	8b 8c c5 74 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8]
  0063e	51		 push	 ecx
  0063f	e8 00 00 00 00	 call	 _get_maxwin
  00644	83 c4 04	 add	 esp, 4
  00647	89 85 20 ff ff
	ff		 mov	 DWORD PTR _maxwin$[ebp], eax

; 257  : 			if( !maxwin ) // there shouldn't be this case, but nevertheless...

  0064d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR _maxwin$[ebp], 0
  00654	75 21		 jne	 SHORT $LN3@parse_args

; 258  : 			{
; 259  : 				printf("Impossible error #3! Press any key to continue or \"SPACE\" to exit... :-)\n");

  00656	8b f4		 mov	 esi, esp
  00658	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@
  0065d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00663	83 c4 04	 add	 esp, 4
  00666	3b f4		 cmp	 esi, esp
  00668	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 260  : 				return ARG_PARSER_ERROR;

  0066d	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00672	e9 83 00 00 00	 jmp	 $LN48@parse_args
$LN3@parse_args:

; 261  : 			}
; 262  : 
; 263  :                         // wrk.maxwin is already initialized to the maximum value suitable for given packing type, so check new setting
; 264  : 			if( maxwin > wrk.maxwin )

  00677	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _maxwin$[ebp]
  0067d	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00683	76 1e		 jbe	 SHORT $LN2@parse_args

; 265  : 			{
; 266  : 				printf("Maximum window specified is too big for given packing type!\n");

  00685	8b f4		 mov	 esi, esp
  00687	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@
  0068c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00692	83 c4 04	 add	 esp, 4
  00695	3b f4		 cmp	 esi, esp
  00697	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 267  : 				return ARG_PARSER_ERROR;

  0069c	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  006a1	eb 57		 jmp	 SHORT $LN48@parse_args
$LN2@parse_args:

; 268  : 			}
; 269  : 			wrk.maxwin = maxwin;

  006a3	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _maxwin$[ebp]
  006a9	a3 1c 00 00 00	 mov	 DWORD PTR _wrk+28, eax

; 270  : 			break;

  006ae	eb 1e		 jmp	 SHORT $LN25@parse_args
$LN1@parse_args:

; 271  : 
; 272  : 		default:
; 273  : 			// once again impossible error: we shouldn't be here since "while" loop condition...
; 274  : 			printf("Impossible error #4! Press any key to continue or \"SPACE\" to exit... :-)\n");

  006b0	8b f4		 mov	 esi, esp
  006b2	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@
  006b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  006bd	83 c4 04	 add	 esp, 4
  006c0	3b f4		 cmp	 esi, esp
  006c2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 275  : 			return ARG_PARSER_ERROR;

  006c7	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  006cc	eb 2c		 jmp	 SHORT $LN48@parse_args
$LN25@parse_args:

; 276  : 			break;
; 277  : 		}
; 278  : 
; 279  : 
; 280  : 		last_arg_type = argstore[storearg_pos++].type;

  006ce	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _storearg_pos$[ebp]
  006d4	8b 8c c5 78 ff
	ff ff		 mov	 ecx, DWORD PTR _argstore$[ebp+eax*8+4]
  006db	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _last_arg_type$[ebp], ecx
  006e1	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _storearg_pos$[ebp]
  006e7	83 c2 01	 add	 edx, 1
  006ea	89 95 50 ff ff
	ff		 mov	 DWORD PTR _storearg_pos$[ebp], edx

; 281  : 	}

  006f0	e9 13 fc ff ff	 jmp	 $LN29@parse_args
$LN28@parse_args:

; 282  : 
; 283  : 
; 284  : 	return ARG_PARSER_GO;

  006f5	b8 02 00 00 00	 mov	 eax, 2
$LN48@parse_args:

; 285  : }

  006fa	52		 push	 edx
  006fb	8b cd		 mov	 ecx, ebp
  006fd	50		 push	 eax
  006fe	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@parse_args
  00704	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00709	58		 pop	 eax
  0070a	5a		 pop	 edx
  0070b	5f		 pop	 edi
  0070c	5e		 pop	 esi
  0070d	5b		 pop	 ebx
  0070e	81 c4 b4 01 00
	00		 add	 esp, 436		; 000001b4H
  00714	3b ec		 cmp	 ebp, esp
  00716	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0071b	8b e5		 mov	 esp, ebp
  0071d	5d		 pop	 ebp
  0071e	c3		 ret	 0
  0071f	90		 npad	 1
$LN52@parse_args:
  00720	01 00 00 00	 DD	 1
  00724	00 00 00 00	 DD	 $LN51@parse_args
$LN51@parse_args:
  00728	74 ff ff ff	 DD	 -140			; ffffff74H
  0072c	88 00 00 00	 DD	 136			; 00000088H
  00730	00 00 00 00	 DD	 $LN50@parse_args
$LN50@parse_args:
  00734	61		 DB	 97			; 00000061H
  00735	72		 DB	 114			; 00000072H
  00736	67		 DB	 103			; 00000067H
  00737	73		 DB	 115			; 00000073H
  00738	74		 DB	 116			; 00000074H
  00739	6f		 DB	 111			; 0000006fH
  0073a	72		 DB	 114			; 00000072H
  0073b	65		 DB	 101			; 00000065H
  0073c	00		 DB	 0
  0073d	8d 49 00	 npad	 3
$LN53@parse_args:
  00740	00 00 00 00	 DD	 $LN24@parse_args
  00744	00 00 00 00	 DD	 $LN23@parse_args
  00748	00 00 00 00	 DD	 $LN21@parse_args
  0074c	00 00 00 00	 DD	 $LN14@parse_args
  00750	00 00 00 00	 DD	 $LN12@parse_args
  00754	00 00 00 00	 DD	 $LN6@parse_args
  00758	00 00 00 00	 DD	 $LN4@parse_args
_parse_args ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _sort_args
_TEXT	SEGMENT
_j$ = -36						; size = 4
_i$ = -24						; size = 4
_temp$ = -12						; size = 8
_args$ = 8						; size = 4
_argsize$ = 12						; size = 4
_sort_args PROC						; COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 291  : 	struct argtbl temp;
; 292  : 	LONG i,j;
; 293  : 
; 294  : 	// simple bubble sort since there are not too many arguments
; 295  : 	for( i=(argsize-2); i>=0; i-- )

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _argsize$[ebp]
  00021	83 e8 02	 sub	 eax, 2
  00024	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  00027	eb 09		 jmp	 SHORT $LN7@sort_args
$LN6@sort_args:
  00029	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	83 e8 01	 sub	 eax, 1
  0002f	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@sort_args:
  00032	83 7d e8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00036	7c 79		 jl	 SHORT $LN8@sort_args

; 296  : 	{
; 297  : 		for( j=0; j<=i; j++ )

  00038	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN4@sort_args
$LN3@sort_args:
  00041	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 dc	 mov	 DWORD PTR _j$[ebp], eax
$LN4@sort_args:
  0004a	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  0004d	3b 45 e8	 cmp	 eax, DWORD PTR _i$[ebp]
  00050	7f 5a		 jg	 SHORT $LN2@sort_args

; 298  : 		{
; 299  : 			if( args[j].type > args[j+1].type )

  00052	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00058	8b 55 dc	 mov	 edx, DWORD PTR _j$[ebp]
  0005b	8b 75 08	 mov	 esi, DWORD PTR _args$[ebp]
  0005e	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00062	3b 44 d6 0c	 cmp	 eax, DWORD PTR [esi+edx*8+12]
  00066	76 42		 jbe	 SHORT $LN1@sort_args

; 300  : 			{
; 301  : 				temp      = args[j];

  00068	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0006e	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00071	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00075	89 55 f4	 mov	 DWORD PTR _temp$[ebp], edx
  00078	89 45 f8	 mov	 DWORD PTR _temp$[ebp+4], eax

; 302  : 				args[j]   = args[j+1];

  0007b	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  00081	8b 54 c1 08	 mov	 edx, DWORD PTR [ecx+eax*8+8]
  00085	8b 44 c1 0c	 mov	 eax, DWORD PTR [ecx+eax*8+12]
  00089	8b 4d dc	 mov	 ecx, DWORD PTR _j$[ebp]
  0008c	8b 75 08	 mov	 esi, DWORD PTR _args$[ebp]
  0008f	89 14 ce	 mov	 DWORD PTR [esi+ecx*8], edx
  00092	89 44 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], eax

; 303  : 				args[j+1] = temp;

  00096	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _args$[ebp]
  0009c	8b 55 f4	 mov	 edx, DWORD PTR _temp$[ebp]
  0009f	89 54 c1 08	 mov	 DWORD PTR [ecx+eax*8+8], edx
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _temp$[ebp+4]
  000a6	89 54 c1 0c	 mov	 DWORD PTR [ecx+eax*8+12], edx
$LN1@sort_args:

; 304  : 			}
; 305  : 		}

  000aa	eb 95		 jmp	 SHORT $LN3@sort_args
$LN2@sort_args:

; 306  : 	}

  000ac	e9 78 ff ff ff	 jmp	 $LN6@sort_args
$LN8@sort_args:

; 307  : }

  000b1	52		 push	 edx
  000b2	8b cd		 mov	 ecx, ebp
  000b4	50		 push	 eax
  000b5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@sort_args
  000bb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c0	58		 pop	 eax
  000c1	5a		 pop	 edx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
  000c9	8d 49 00	 npad	 3
$LN12@sort_args:
  000cc	01 00 00 00	 DD	 1
  000d0	00 00 00 00	 DD	 $LN11@sort_args
$LN11@sort_args:
  000d4	f4 ff ff ff	 DD	 -12			; fffffff4H
  000d8	08 00 00 00	 DD	 8
  000dc	00 00 00 00	 DD	 $LN10@sort_args
$LN10@sort_args:
  000e0	74		 DB	 116			; 00000074H
  000e1	65		 DB	 101			; 00000065H
  000e2	6d		 DB	 109			; 0000006dH
  000e3	70		 DB	 112			; 00000070H
  000e4	00		 DB	 0
_sort_args ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _get_maxwin
_TEXT	SEGMENT
_i$ = -8						; size = 4
_txtmaxwin$ = 8						; size = 4
_get_maxwin PROC					; COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 313  : 	static char * strings[] =
; 314  : 	{
; 315  : 		ARGSTR_MW256,
; 316  : 		ARGSTR_MW512,
; 317  : 		ARGSTR_MW1024,
; 318  : 		ARGSTR_MW2048,
; 319  : 		ARGSTR_MW4096,
; 320  : 		ARGSTR_MW4352,
; 321  : 		ARGSTR_MW8192,
; 322  : 		ARGSTR_MW16384,
; 323  : 		ARGSTR_MW32768,
; 324  : 		ARGSTR_MW65536,
; 325  : 		NULL
; 326  : 	};
; 327  : 
; 328  : 	static LONG sizes[] =
; 329  : 	{
; 330  : 		256,
; 331  : 		512,
; 332  : 		1024,
; 333  : 		2048,
; 334  : 		4096,
; 335  : 		4352,
; 336  : 		8192,
; 337  : 		16384,
; 338  : 		32768,
; 339  : 		65536,
; 340  : 		0
; 341  : 	};
; 342  : 
; 343  : 	ULONG i;
; 344  : 
; 345  : 
; 346  : 	i=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN3@get_maxwin:

; 347  : 	while( strings[i] )

  00025	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?strings@?1??get_maxwin@@9@9[eax*4], 0
  00030	74 32		 je	 SHORT $LN2@get_maxwin

; 348  : 	{
; 349  : 		if( !cmp_str_nocase( strings[i], txtmaxwin ) )

  00032	8b 45 08	 mov	 eax, DWORD PTR _txtmaxwin$[ebp]
  00035	50		 push	 eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?strings@?1??get_maxwin@@9@9[ecx*4]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _cmp_str_nocase
  00046	83 c4 08	 add	 esp, 8
  00049	85 c0		 test	 eax, eax
  0004b	75 0c		 jne	 SHORT $LN1@get_maxwin

; 350  : 		{
; 351  : 			return sizes[i];

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?sizes@?1??get_maxwin@@9@9[eax*4]
  00057	eb 0d		 jmp	 SHORT $LN4@get_maxwin
$LN1@get_maxwin:

; 352  : 		}
; 353  : 
; 354  : 		i++;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 355  : 	}

  00062	eb c1		 jmp	 SHORT $LN3@get_maxwin
$LN2@get_maxwin:

; 356  : 
; 357  : 	return 0;

  00064	33 c0		 xor	 eax, eax
$LN4@get_maxwin:

; 358  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_get_maxwin ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _match_arg
_TEXT	SEGMENT
tv71 = -208						; size = 4
_test_arg$ = -8						; size = 4
_argument$ = 8						; size = 4
_match_arg PROC						; COMDAT

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 368  : 	struct argtbl * test_arg = default_arg_table;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _test_arg$[ebp], OFFSET _default_arg_table
$LN2@match_arg:

; 369  : 
; 370  : 
; 371  : 	while( test_arg->name && cmp_str_nocase(test_arg->name,argument) )

  00025	8b 45 f8	 mov	 eax, DWORD PTR _test_arg$[ebp]
  00028	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002b	74 21		 je	 SHORT $LN1@match_arg
  0002d	8b 45 08	 mov	 eax, DWORD PTR _argument$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _test_arg$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _cmp_str_nocase
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	74 0b		 je	 SHORT $LN1@match_arg

; 372  : 		test_arg++;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _test_arg$[ebp]
  00046	83 c0 08	 add	 eax, 8
  00049	89 45 f8	 mov	 DWORD PTR _test_arg$[ebp], eax
  0004c	eb d7		 jmp	 SHORT $LN2@match_arg
$LN1@match_arg:

; 373  : 
; 374  : 	return (test_arg->name)?test_arg:NULL;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _test_arg$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 0b		 je	 SHORT $LN5@match_arg
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _test_arg$[ebp]
  00059	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  0005f	eb 0a		 jmp	 SHORT $LN6@match_arg
$LN5@match_arg:
  00061	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN6@match_arg:
  0006b	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]

; 375  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_match_arg ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _cmp_str_nocase
_TEXT	SEGMENT
_rightadd$ = -53					; size = 1
_leftadd$ = -41						; size = 1
_rightchar$ = -29					; size = 1
_leftchar$ = -17					; size = 1
_order$ = -8						; size = 4
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_cmp_str_nocase PROC					; COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 382  : 
; 383  : 	LONG order=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _order$[ebp], 0
$LN10@cmp_str_no:

; 384  : 
; 385  : 	UBYTE leftchar,rightchar;
; 386  : 	UBYTE leftadd,rightadd;
; 387  : 
; 388  : 	do
; 389  : 	{
; 390  : 		leftchar  = (UBYTE)*left;

  00025	8b 45 08	 mov	 eax, DWORD PTR _left$[ebp]
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	88 4d ef	 mov	 BYTE PTR _leftchar$[ebp], cl

; 391  : 		rightchar = (UBYTE)*right;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _right$[ebp]
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	88 4d e3	 mov	 BYTE PTR _rightchar$[ebp], cl

; 392  : 
; 393  : 		leftadd  = 0;

  00035	c6 45 d7 00	 mov	 BYTE PTR _leftadd$[ebp], 0

; 394  : 		rightadd = 0;

  00039	c6 45 cb 00	 mov	 BYTE PTR _rightadd$[ebp], 0

; 395  : 
; 396  : 		left++;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _left$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 08	 mov	 DWORD PTR _left$[ebp], eax

; 397  : 		right++;

  00046	8b 45 0c	 mov	 eax, DWORD PTR _right$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 0c	 mov	 DWORD PTR _right$[ebp], eax

; 398  : 
; 399  : 		if( leftchar  >= (UBYTE)'a' ) leftadd  = (UBYTE)('A'-'a');

  0004f	0f b6 45 ef	 movzx	 eax, BYTE PTR _leftchar$[ebp]
  00053	83 f8 61	 cmp	 eax, 97			; 00000061H
  00056	7c 04		 jl	 SHORT $LN7@cmp_str_no
  00058	c6 45 d7 e0	 mov	 BYTE PTR _leftadd$[ebp], 224 ; 000000e0H
$LN7@cmp_str_no:

; 400  : 		if( rightchar >= (UBYTE)'a' ) rightadd = (UBYTE)('A'-'a');

  0005c	0f b6 45 e3	 movzx	 eax, BYTE PTR _rightchar$[ebp]
  00060	83 f8 61	 cmp	 eax, 97			; 00000061H
  00063	7c 04		 jl	 SHORT $LN6@cmp_str_no
  00065	c6 45 cb e0	 mov	 BYTE PTR _rightadd$[ebp], 224 ; 000000e0H
$LN6@cmp_str_no:

; 401  : 
; 402  : 		if( leftchar  > (UBYTE)'z' ) leftadd  = 0;

  00069	0f b6 45 ef	 movzx	 eax, BYTE PTR _leftchar$[ebp]
  0006d	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00070	7e 04		 jle	 SHORT $LN5@cmp_str_no
  00072	c6 45 d7 00	 mov	 BYTE PTR _leftadd$[ebp], 0
$LN5@cmp_str_no:

; 403  : 		if( rightchar > (UBYTE)'z' ) rightadd = 0;

  00076	0f b6 45 e3	 movzx	 eax, BYTE PTR _rightchar$[ebp]
  0007a	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0007d	7e 04		 jle	 SHORT $LN4@cmp_str_no
  0007f	c6 45 cb 00	 mov	 BYTE PTR _rightadd$[ebp], 0
$LN4@cmp_str_no:

; 404  : 
; 405  : 		leftchar  += leftadd;

  00083	0f b6 45 d7	 movzx	 eax, BYTE PTR _leftadd$[ebp]
  00087	0f b6 4d ef	 movzx	 ecx, BYTE PTR _leftchar$[ebp]
  0008b	03 c8		 add	 ecx, eax
  0008d	88 4d ef	 mov	 BYTE PTR _leftchar$[ebp], cl

; 406  : 		rightchar += rightadd;

  00090	0f b6 45 cb	 movzx	 eax, BYTE PTR _rightadd$[ebp]
  00094	0f b6 4d e3	 movzx	 ecx, BYTE PTR _rightchar$[ebp]
  00098	03 c8		 add	 ecx, eax
  0009a	88 4d e3	 mov	 BYTE PTR _rightchar$[ebp], cl

; 407  : 
; 408  : 		if( leftchar<rightchar ) order = (-1);

  0009d	0f b6 45 ef	 movzx	 eax, BYTE PTR _leftchar$[ebp]
  000a1	0f b6 4d e3	 movzx	 ecx, BYTE PTR _rightchar$[ebp]
  000a5	3b c1		 cmp	 eax, ecx
  000a7	7d 07		 jge	 SHORT $LN3@cmp_str_no
  000a9	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _order$[ebp], -1
$LN3@cmp_str_no:

; 409  : 		if( leftchar>rightchar ) order = (+1);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR _leftchar$[ebp]
  000b4	0f b6 4d e3	 movzx	 ecx, BYTE PTR _rightchar$[ebp]
  000b8	3b c1		 cmp	 eax, ecx
  000ba	7e 07		 jle	 SHORT $LN9@cmp_str_no
  000bc	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _order$[ebp], 1
$LN9@cmp_str_no:

; 410  : 
; 411  : 	} while( (!order) && leftchar && rightchar );

  000c3	83 7d f8 00	 cmp	 DWORD PTR _order$[ebp], 0
  000c7	75 14		 jne	 SHORT $LN8@cmp_str_no
  000c9	0f b6 45 ef	 movzx	 eax, BYTE PTR _leftchar$[ebp]
  000cd	85 c0		 test	 eax, eax
  000cf	74 0c		 je	 SHORT $LN8@cmp_str_no
  000d1	0f b6 45 e3	 movzx	 eax, BYTE PTR _rightchar$[ebp]
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 48 ff ff
	ff		 jne	 $LN10@cmp_str_no
$LN8@cmp_str_no:

; 412  : 
; 413  : 	return order;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _order$[ebp]

; 414  : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_cmp_str_nocase ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-tb.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_tb_entry:DWORD:010000H
COMM	_tb_free:DWORD
COMM	_tb_bunches:DWORD
_DATA	ENDS
PUBLIC	_init_tb
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\d\mhmt\src\mhmt-tb.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _init_tb
_TEXT	SEGMENT
_i$ = -8						; size = 4
_init_tb PROC						; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 20   : 	ULONG i;
; 21   : 
; 22   : 	tb_free=NULL;    // init linked list of free tb_chain elements

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tb_free, 0

; 23   : 	tb_bunches=NULL; // no bunches already allocated

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tb_bunches, 0

; 24   : 
; 25   : 	for(i=0;i<65536;i++) // init array of 2-byte match pointers

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN3@init_tb
$LN2@init_tb:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@init_tb:
  00044	81 7d f8 00 00
	01 00		 cmp	 DWORD PTR _i$[ebp], 65536 ; 00010000H
  0004b	73 10		 jae	 SHORT $LN4@init_tb

; 26   : 	{
; 27   : 		tb_entry[i]=NULL;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _tb_entry[eax*4], 0

; 28   : 	}

  0005b	eb de		 jmp	 SHORT $LN2@init_tb
$LN4@init_tb:

; 29   : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_init_tb ENDP
_TEXT	ENDS
PUBLIC	_free_tb
EXTRN	__imp__free:PROC
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _free_tb
_TEXT	SEGMENT
_tbtmp$ = -8						; size = 4
_free_tb PROC						; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$LN2@free_tb:

; 34   : 	// free all allocated bunches
; 35   : 
; 36   : 	struct tb_bunch * tbtmp;
; 37   : 
; 38   : 	while( tb_bunches )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tb_bunches, 0
  00025	74 2d		 je	 SHORT $LN3@free_tb

; 39   : 	{
; 40   : 		tbtmp=tb_bunches;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _tb_bunches
  0002c	89 45 f8	 mov	 DWORD PTR _tbtmp$[ebp], eax

; 41   : 		tb_bunches=tb_bunches->next;

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tb_bunches
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	89 0d 00 00 00
	00		 mov	 DWORD PTR _tb_bunches, ecx

; 42   : 		free( tbtmp );

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _tbtmp$[ebp]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00048	83 c4 04	 add	 esp, 4
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 43   : 	}

  00052	eb ca		 jmp	 SHORT $LN2@free_tb
$LN3@free_tb:

; 44   : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_free_tb ENDP
_TEXT	ENDS
PUBLIC	_add_bunch_of_tb
PUBLIC	_cutoff_tb_chain
PUBLIC	_get_free_tb
PUBLIC	_add_tb
EXTRN	_wrk:BYTE
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _add_tb
_TEXT	SEGMENT
_newtb$ = -8						; size = 4
_index$ = 8						; size = 2
_position$ = 12						; size = 4
_add_tb	PROC						; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 52   : 	struct tb_chain * newtb;
; 53   : 
; 54   : 	newtb=get_free_tb();

  0001e	e8 00 00 00 00	 call	 _get_free_tb
  00023	89 45 f8	 mov	 DWORD PTR _newtb$[ebp], eax

; 55   : 	if( !newtb )

  00026	83 7d f8 00	 cmp	 DWORD PTR _newtb$[ebp], 0
  0002a	75 3f		 jne	 SHORT $LN4@add_tb

; 56   : 	{ // no free elements
; 57   : 
; 58   : 		if( position > wrk.maxwin ) // if there could be enough tbs to try to flush

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _position$[ebp]
  0002f	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  00035	76 11		 jbe	 SHORT $LN3@add_tb

; 59   : 		{
; 60   : 			// try to flush current chain
; 61   : 			cutoff_tb_chain(index,position);

  00037	8b 45 0c	 mov	 eax, DWORD PTR _position$[ebp]
  0003a	50		 push	 eax
  0003b	0f b7 4d 08	 movzx	 ecx, WORD PTR _index$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _cutoff_tb_chain
  00045	83 c4 08	 add	 esp, 8
$LN3@add_tb:

; 62   : 		}
; 63   : 
; 64   : 		newtb=get_free_tb();

  00048	e8 00 00 00 00	 call	 _get_free_tb
  0004d	89 45 f8	 mov	 DWORD PTR _newtb$[ebp], eax

; 65   : 		if( !newtb )

  00050	83 7d f8 00	 cmp	 DWORD PTR _newtb$[ebp], 0
  00054	75 15		 jne	 SHORT $LN4@add_tb

; 66   : 		{ // nothing free - allocate new bunch
; 67   : 			if( !add_bunch_of_tb() )

  00056	e8 00 00 00 00	 call	 _add_bunch_of_tb
  0005b	85 c0		 test	 eax, eax
  0005d	75 04		 jne	 SHORT $LN1@add_tb

; 68   : 			{
; 69   : 				return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 37		 jmp	 SHORT $LN5@add_tb
$LN1@add_tb:

; 70   : 			}
; 71   : 
; 72   : 			newtb=get_free_tb(); // here is no chance to fail!... hopefully...

  00063	e8 00 00 00 00	 call	 _get_free_tb
  00068	89 45 f8	 mov	 DWORD PTR _newtb$[ebp], eax
$LN4@add_tb:

; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : 
; 77   : 
; 78   : 	newtb->pos=position-1; // points to the first byte of given two bytes

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _position$[ebp]
  0006e	83 e8 01	 sub	 eax, 1
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _newtb$[ebp]
  00074	89 01		 mov	 DWORD PTR [ecx], eax

; 79   : 	newtb->next=tb_entry[index];

  00076	0f b7 45 08	 movzx	 eax, WORD PTR _index$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _newtb$[ebp]
  0007d	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _tb_entry[eax*4]
  00084	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 80   : 	tb_entry[index]=newtb;

  00087	0f b7 45 08	 movzx	 eax, WORD PTR _index$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _newtb$[ebp]
  0008e	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _tb_entry[eax*4], ecx

; 81   : 
; 82   : 
; 83   : 	return 1;

  00095	b8 01 00 00 00	 mov	 eax, 1
$LN5@add_tb:

; 84   : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_add_tb	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _cutoff_tb_chain
_TEXT	SEGMENT
_prev$ = -20						; size = 4
_curr$ = -8						; size = 4
_index$ = 8						; size = 2
_position$ = 12						; size = 4
_cutoff_tb_chain PROC					; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 90   : 	struct tb_chain * curr, * prev;
; 91   : 
; 92   : 
; 93   : 	curr=tb_entry[index];

  0001e	0f b7 45 08	 movzx	 eax, WORD PTR _index$[ebp]
  00022	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _tb_entry[eax*4]
  00029	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx

; 94   : 	if( !curr ) return; // if nothing to remove

  0002c	83 7d f8 00	 cmp	 DWORD PTR _curr$[ebp], 0
  00030	75 05		 jne	 SHORT $LN8@cutoff_tb_
  00032	e9 b1 00 00 00	 jmp	 $LN9@cutoff_tb_
$LN8@cutoff_tb_:

; 95   : 
; 96   : 
; 97   : 	// see if we should delete some elements after first element in the given chain
; 98   : 	prev=curr;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  0003a	89 45 ec	 mov	 DWORD PTR _prev$[ebp], eax

; 99   : 	curr=curr->next;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx
$LN7@cutoff_tb_:

; 100  : 
; 101  : 	while( curr )

  00046	83 7d f8 00	 cmp	 DWORD PTR _curr$[ebp], 0
  0004a	74 5b		 je	 SHORT $LN6@cutoff_tb_

; 102  : 	{
; 103  : 		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _position$[ebp]
  00052	2b 08		 sub	 ecx, DWORD PTR [eax]
  00054	3b 0d 1c 00 00
	00		 cmp	 ecx, DWORD PTR _wrk+28
  0005a	76 3a		 jbe	 SHORT $LN5@cutoff_tb_
$LN4@cutoff_tb_:

; 104  : 		{
; 105  : 			// find end of chain
; 106  : 			while( curr->next )

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  0005f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00063	74 0b		 je	 SHORT $LN3@cutoff_tb_

; 107  : 			{
; 108  : 				curr = curr->next;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  00068	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006b	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx

; 109  : 			}

  0006e	eb ec		 jmp	 SHORT $LN4@cutoff_tb_
$LN3@cutoff_tb_:

; 110  : 
; 111  : 			// now curr - last chain element, prev->next - beginning of orphaned chain
; 112  : 			// add orphaned chain to free list
; 113  : 			curr->next = tb_free;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_free
  00079	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 114  : 			tb_free = prev->next;

  0007c	8b 45 ec	 mov	 eax, DWORD PTR _prev$[ebp]
  0007f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00082	89 0d 00 00 00
	00		 mov	 DWORD PTR _tb_free, ecx

; 115  : 
; 116  : 			prev->next = NULL; // cut off chain

  00088	8b 45 ec	 mov	 eax, DWORD PTR _prev$[ebp]
  0008b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 117  : 
; 118  : 			break;

  00092	eb 13		 jmp	 SHORT $LN6@cutoff_tb_

; 119  : 		}
; 120  : 		else

  00094	eb 0f		 jmp	 SHORT $LN2@cutoff_tb_
$LN5@cutoff_tb_:

; 121  : 		{
; 122  : 			prev=curr;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  00099	89 45 ec	 mov	 DWORD PTR _prev$[ebp], eax

; 123  : 			curr=curr->next;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx
$LN2@cutoff_tb_:

; 124  : 		}
; 125  : 	}

  000a5	eb 9f		 jmp	 SHORT $LN7@cutoff_tb_
$LN6@cutoff_tb_:

; 126  : 
; 127  : 	// delete first (entry) element in chain if needed (in this case, all subsequent els are already deleted)
; 128  : 	curr=tb_entry[index];

  000a7	0f b7 45 08	 movzx	 eax, WORD PTR _index$[ebp]
  000ab	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _tb_entry[eax*4]
  000b2	89 4d f8	 mov	 DWORD PTR _curr$[ebp], ecx

; 129  : 	if( (position-(curr->pos)) > wrk.maxwin )

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _position$[ebp]
  000bb	2b 08		 sub	 ecx, DWORD PTR [eax]
  000bd	3b 0d 1c 00 00
	00		 cmp	 ecx, DWORD PTR _wrk+28
  000c3	76 23		 jbe	 SHORT $LN9@cutoff_tb_

; 130  : 	{
; 131  : 		tb_entry[index] = NULL;

  000c5	0f b7 45 08	 movzx	 eax, WORD PTR _index$[ebp]
  000c9	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _tb_entry[eax*4], 0

; 132  : 
; 133  : 		curr->next=tb_free; // element goes to free list

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_free
  000dd	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 134  : 		tb_free=curr;

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _curr$[ebp]
  000e3	a3 00 00 00 00	 mov	 DWORD PTR _tb_free, eax
$LN9@cutoff_tb_:

; 135  : 	}
; 136  : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_cutoff_tb_chain ENDP
_TEXT	ENDS
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _add_bunch_of_tb
_TEXT	SEGMENT
_newbunch$ = -20					; size = 4
_i$ = -8						; size = 4
_add_bunch_of_tb PROC					; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 143  : 	ULONG i;
; 144  : 	struct tb_bunch * newbunch;
; 145  : 
; 146  : 	// alloc new bunch
; 147  : 	newbunch=(struct tb_bunch *)malloc( sizeof(struct tb_bunch) );

  0001e	8b f4		 mov	 esi, esp
  00020	68 04 80 00 00	 push	 32772			; 00008004H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	89 45 ec	 mov	 DWORD PTR _newbunch$[ebp], eax

; 148  : 	if( !newbunch ) return 0;

  00038	83 7d ec 00	 cmp	 DWORD PTR _newbunch$[ebp], 0
  0003c	75 04		 jne	 SHORT $LN4@add_bunch_
  0003e	33 c0		 xor	 eax, eax
  00040	eb 63		 jmp	 SHORT $LN5@add_bunch_
$LN4@add_bunch_:

; 149  : 
; 150  : 	// link every twobyter into one list
; 151  : 	for(i=0;i<(BUNCHSIZE-1);i++)

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN3@add_bunch_
$LN2@add_bunch_:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@add_bunch_:
  00054	81 7d f8 ff 0f
	00 00		 cmp	 DWORD PTR _i$[ebp], 4095 ; 00000fffH
  0005b	73 16		 jae	 SHORT $LN1@add_bunch_

; 152  : 	{
; 153  : 		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR _newbunch$[ebp]
  00063	8d 54 c1 0c	 lea	 edx, DWORD PTR [ecx+eax*8+12]
  00067	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _newbunch$[ebp]
  0006d	89 54 c1 08	 mov	 DWORD PTR [ecx+eax*8+8], edx

; 154  : 	}

  00071	eb d8		 jmp	 SHORT $LN2@add_bunch_
$LN1@add_bunch_:

; 155  : 
; 156  : 	// add this list to the free list
; 157  : 	newbunch->bunch[BUNCHSIZE-1].next=tb_free;

  00073	8b 45 ec	 mov	 eax, DWORD PTR _newbunch$[ebp]
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_free
  0007c	89 88 00 80 00
	00		 mov	 DWORD PTR [eax+32768], ecx

; 158  : 	tb_free=&(newbunch->bunch[0]);

  00082	8b 45 ec	 mov	 eax, DWORD PTR _newbunch$[ebp]
  00085	83 c0 04	 add	 eax, 4
  00088	a3 00 00 00 00	 mov	 DWORD PTR _tb_free, eax

; 159  : 
; 160  : 	// add bunch to bunches list
; 161  : 	newbunch->next=tb_bunches;

  0008d	8b 45 ec	 mov	 eax, DWORD PTR _newbunch$[ebp]
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_bunches
  00096	89 08		 mov	 DWORD PTR [eax], ecx

; 162  : 	tb_bunches=newbunch;

  00098	8b 45 ec	 mov	 eax, DWORD PTR _newbunch$[ebp]
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _tb_bunches, eax

; 163  : 
; 164  : 	return 1;

  000a0	b8 01 00 00 00	 mov	 eax, 1
$LN5@add_bunch_:

; 165  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_add_bunch_of_tb ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _get_free_tb
_TEXT	SEGMENT
_newtb$ = -8						; size = 4
_get_free_tb PROC					; COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 171  : 	struct tb_chain * newtb;
; 172  : 
; 173  : 	if( tb_free )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tb_free, 0
  00025	74 1d		 je	 SHORT $LN2@get_free_t

; 174  : 	{
; 175  : 		newtb=tb_free;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _tb_free
  0002c	89 45 f8	 mov	 DWORD PTR _newtb$[ebp], eax

; 176  : 		tb_free=tb_free->next;

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tb_free
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 0d 00 00 00
	00		 mov	 DWORD PTR _tb_free, ecx

; 177  : 
; 178  : 		return newtb;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _newtb$[ebp]
  00040	eb 04		 jmp	 SHORT $LN3@get_free_t

; 179  : 	}
; 180  : 	else

  00042	eb 02		 jmp	 SHORT $LN3@get_free_t
$LN2@get_free_t:

; 181  : 	{
; 182  : 		return NULL;

  00044	33 c0		 xor	 eax, eax
$LN3@get_free_t:

; 183  : 	}
; 184  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_get_free_tb ENDP
_TEXT	ENDS
END
