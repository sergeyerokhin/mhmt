
mhmt-depack.o:     file format elf32-i386


Disassembly of section .text:

00000000 <depack_getbyte>:


// rewind - to the beginning of input stream, byte - next byte
// returns 0xFFFFFFFF if error (exhausted stream), otherwise byte (0..255)
ULONG depack_getbyte(ULONG operation)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 08             	sub    $0x8,%esp
       6:	8b 45 08             	mov    0x8(%ebp),%eax
	static ULONG position;

	if( operation==DEPACK_GETBYTE_REWIND )
       9:	85 c0                	test   %eax,%eax
       b:	75 0c                	jne    19 <depack_getbyte+0x19>
	{
		position=0;
       d:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
      14:	00 00 00 
		return 0;
      17:	eb 39                	jmp    52 <depack_getbyte+0x52>
	}
	else if( operation==DEPACK_GETBYTE_NEXT )
      19:	48                   	dec    %eax
      1a:	75 23                	jne    3f <depack_getbyte+0x3f>
	{
		if( position < wrk.inlen )
      1c:	8b 15 14 00 00 00    	mov    0x14,%edx
      22:	83 c8 ff             	or     $0xffffffff,%eax
      25:	3b 15 34 00 00 00    	cmp    0x34,%edx
      2b:	73 25                	jae    52 <depack_getbyte+0x52>
		{
//#ifdef DBG
//			printf("<%02x>", wrk.indata[position]);
//#endif
			return (ULONG)wrk.indata[position++];
      2d:	a1 30 00 00 00       	mov    0x30,%eax
      32:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
      36:	42                   	inc    %edx
      37:	89 15 14 00 00 00    	mov    %edx,0x14
      3d:	eb 13                	jmp    52 <depack_getbyte+0x52>
		}
	}
	else // should never happen in a correct program
		printf("mhmt-depack.c:depack_get() - wrong operation code\n");
      3f:	83 ec 0c             	sub    $0xc,%esp
      42:	68 00 00 00 00       	push   $0x0
      47:	e8 fc ff ff ff       	call   48 <depack_getbyte+0x48>
      4c:	83 c8 ff             	or     $0xffffffff,%eax
      4f:	83 c4 10             	add    $0x10,%esp

	return 0xFFFFFFFF;
}
      52:	c9                   	leave  
      53:	c3                   	ret    

00000054 <depack_getbits_word>:
// left-aligned bits.
ULONG depack_getbits_word(void)
{
	ULONG bits,bits2;

	if( wrk.wordbit ) // 16bits
      54:	83 3d 10 00 00 00 00 	cmpl   $0x0,0x10

// gets word of bits (UBYTE or UWORD), accounts for big-little endian
// returns 0xFFFFFFFF if no bytes in input stream (depack_getbyte()), otherwise
// left-aligned bits.
ULONG depack_getbits_word(void)
{
      5b:	55                   	push   %ebp
      5c:	89 e5                	mov    %esp,%ebp
      5e:	56                   	push   %esi
      5f:	53                   	push   %ebx
	ULONG bits,bits2;

	if( wrk.wordbit ) // 16bits
      60:	74 6f                	je     d1 <depack_getbits_word+0x7d>
	{
		if( wrk.bigend )
      62:	83 3d 14 00 00 00 00 	cmpl   $0x0,0x14
      69:	74 2a                	je     95 <depack_getbits_word+0x41>
		{
			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);
      6b:	83 ec 0c             	sub    $0xc,%esp
      6e:	6a 01                	push   $0x1
      70:	e8 fc ff ff ff       	call   71 <depack_getbits_word+0x1d>
			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;
      75:	83 c4 10             	add    $0x10,%esp
      78:	83 f8 ff             	cmp    $0xffffffff,%eax

	if( wrk.wordbit ) // 16bits
	{
		if( wrk.bigend )
		{
			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);
      7b:	89 c3                	mov    %eax,%ebx
			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;
      7d:	74 6e                	je     ed <depack_getbits_word+0x99>
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
      7f:	83 ec 0c             	sub    $0xc,%esp
      82:	6a 01                	push   $0x1
      84:	e8 fc ff ff ff       	call   85 <depack_getbits_word+0x31>
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
      89:	83 c4 10             	add    $0x10,%esp
      8c:	83 f8 ff             	cmp    $0xffffffff,%eax
	{
		if( wrk.bigend )
		{
			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);
			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
      8f:	89 c6                	mov    %eax,%esi
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
      91:	75 2a                	jne    bd <depack_getbits_word+0x69>
      93:	eb 55                	jmp    ea <depack_getbits_word+0x96>
		}
		else
		{
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
      95:	83 ec 0c             	sub    $0xc,%esp
      98:	6a 01                	push   $0x1
      9a:	e8 fc ff ff ff       	call   9b <depack_getbits_word+0x47>
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
      9f:	83 c4 10             	add    $0x10,%esp
      a2:	83 f8 ff             	cmp    $0xffffffff,%eax
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
		}
		else
		{
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
      a5:	89 c6                	mov    %eax,%esi
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
      a7:	74 41                	je     ea <depack_getbits_word+0x96>
			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);
      a9:	83 ec 0c             	sub    $0xc,%esp
      ac:	6a 01                	push   $0x1
      ae:	e8 fc ff ff ff       	call   af <depack_getbits_word+0x5b>
			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;
      b3:	83 c4 10             	add    $0x10,%esp
      b6:	83 f8 ff             	cmp    $0xffffffff,%eax
		}
		else
		{
			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);
			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;
			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);
      b9:	89 c3                	mov    %eax,%ebx
			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;
      bb:	74 30                	je     ed <depack_getbits_word+0x99>
		}

		bits = (bits<<24) | ( 0x00FF0000&(bits2<<16) );
      bd:	89 d8                	mov    %ebx,%eax
      bf:	89 f3                	mov    %esi,%ebx
      c1:	c1 e3 10             	shl    $0x10,%ebx
      c4:	c1 e0 18             	shl    $0x18,%eax
      c7:	81 e3 00 00 ff 00    	and    $0xff0000,%ebx
      cd:	09 c3                	or     %eax,%ebx
      cf:	eb 1c                	jmp    ed <depack_getbits_word+0x99>
	}
	else // 8bits
	{
		bits=depack_getbyte(DEPACK_GETBYTE_NEXT);
      d1:	83 ec 0c             	sub    $0xc,%esp
      d4:	6a 01                	push   $0x1
      d6:	e8 fc ff ff ff       	call   d7 <depack_getbits_word+0x83>
		if( bits!=0xFFFFFFFF)
      db:	83 c4 10             	add    $0x10,%esp
      de:	83 f8 ff             	cmp    $0xffffffff,%eax

		bits = (bits<<24) | ( 0x00FF0000&(bits2<<16) );
	}
	else // 8bits
	{
		bits=depack_getbyte(DEPACK_GETBYTE_NEXT);
      e1:	89 c3                	mov    %eax,%ebx
		if( bits!=0xFFFFFFFF)
      e3:	74 08                	je     ed <depack_getbits_word+0x99>
			bits <<= 24;
      e5:	c1 e3 18             	shl    $0x18,%ebx
      e8:	eb 03                	jmp    ed <depack_getbits_word+0x99>
      ea:	83 cb ff             	or     $0xffffffff,%ebx
	}

	return bits;
}
      ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
      f0:	89 d8                	mov    %ebx,%eax
      f2:	5b                   	pop    %ebx
      f3:	5e                   	pop    %esi
      f4:	5d                   	pop    %ebp
      f5:	c3                   	ret    

000000f6 <depack_getbits>:
//#define DEPACK_GETBITS_FORCE 1
//#define DEPACK_GETBITS_NEXT  2
//
// returns 0xFFFFFFFF if error, otherwise LSB-aligned, zero-extended bits
ULONG depack_getbits(ULONG numbits, ULONG operation)
{	static ULONG bits;
      f6:	55                   	push   %ebp
      f7:	89 e5                	mov    %esp,%ebp
      f9:	57                   	push   %edi
      fa:	56                   	push   %esi
      fb:	53                   	push   %ebx
      fc:	83 ec 0c             	sub    $0xc,%esp
      ff:	8b 45 0c             	mov    0xc(%ebp),%eax
     102:	8b 75 08             	mov    0x8(%ebp),%esi
	static ULONG num_bits_left;

	ULONG fetched_bits;


	if( operation==DEPACK_GETBITS_FORCE ) // force word retrieval (for start of stream)
     105:	83 f8 01             	cmp    $0x1,%eax
     108:	75 2c                	jne    136 <depack_getbits+0x40>
	{
		bits = depack_getbits_word();
     10a:	e8 fc ff ff ff       	call   10b <depack_getbits+0x15>
     10f:	a3 10 00 00 00       	mov    %eax,0x10
		if( bits==0xFFFFFFFF) return 0xFFFFFFFF;
     114:	40                   	inc    %eax
     115:	0f 84 de 00 00 00    	je     1f9 <depack_getbits+0x103>
		num_bits_left = wrk.wordbit ? 16 : 8;
     11b:	83 3d 10 00 00 00 01 	cmpl   $0x1,0x10
     122:	19 c0                	sbb    %eax,%eax
     124:	31 db                	xor    %ebx,%ebx
     126:	83 e0 f8             	and    $0xfffffff8,%eax
     129:	83 c0 10             	add    $0x10,%eax
     12c:	a3 0c 00 00 00       	mov    %eax,0xc
		return 0;
     131:	e9 c6 00 00 00       	jmp    1fc <depack_getbits+0x106>
	}
	else if( operation==DEPACK_GETBITS_NEXT ) // return bits and fetch new as needed (wrk.fullbits accounted for)
     136:	83 f8 02             	cmp    $0x2,%eax
     139:	0f 85 a5 00 00 00    	jne    1e4 <depack_getbits+0xee>
	{
		if( (numbits==0) || (numbits>31) )
     13f:	8d 46 ff             	lea    -0x1(%esi),%eax
		{
			printf("mhmt-depack.c:depack_getbits() - too many (>31) or zero bits requested\n");
			return 0xFFFFFFFF;
     142:	31 db                	xor    %ebx,%ebx
		num_bits_left = wrk.wordbit ? 16 : 8;
		return 0;
	}
	else if( operation==DEPACK_GETBITS_NEXT ) // return bits and fetch new as needed (wrk.fullbits accounted for)
	{
		if( (numbits==0) || (numbits>31) )
     144:	83 f8 1e             	cmp    $0x1e,%eax
     147:	76 0d                	jbe    156 <depack_getbits+0x60>
		{
			printf("mhmt-depack.c:depack_getbits() - too many (>31) or zero bits requested\n");
     149:	83 ec 0c             	sub    $0xc,%esp
     14c:	68 32 00 00 00       	push   $0x32
     151:	e9 96 00 00 00       	jmp    1ec <depack_getbits+0xf6>
		}

		fetched_bits = 0;
		do
		{
			if( !wrk.fullbits ) // empty bits
     156:	83 3d 18 00 00 00 00 	cmpl   $0x0,0x18
     15d:	75 2e                	jne    18d <depack_getbits+0x97>
			{
				if( !num_bits_left )
     15f:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     166:	75 25                	jne    18d <depack_getbits+0x97>
				{
					bits = depack_getbits_word();
     168:	e8 fc ff ff ff       	call   169 <depack_getbits+0x73>
     16d:	a3 10 00 00 00       	mov    %eax,0x10
					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;
     172:	40                   	inc    %eax
     173:	0f 84 80 00 00 00    	je     1f9 <depack_getbits+0x103>
					num_bits_left = wrk.wordbit ? 16 : 8;
     179:	83 3d 10 00 00 00 01 	cmpl   $0x1,0x10
     180:	19 c0                	sbb    %eax,%eax
     182:	83 e0 f8             	and    $0xfffffff8,%eax
     185:	83 c0 10             	add    $0x10,%eax
     188:	a3 0c 00 00 00       	mov    %eax,0xc
			}

//#ifdef DBG
//			printf("%d",bits>>31);
//#endif
			fetched_bits = ( fetched_bits<<1 ) | ( 1&(bits>>31) );
     18d:	8b 3d 10 00 00 00    	mov    0x10,%edi
			bits <<= 1;
     193:	8d 04 3f             	lea    (%edi,%edi,1),%eax
     196:	a3 10 00 00 00       	mov    %eax,0x10
			num_bits_left--;
     19b:	a1 0c 00 00 00       	mov    0xc,%eax
     1a0:	48                   	dec    %eax

			if( wrk.fullbits )
     1a1:	83 3d 18 00 00 00 00 	cmpl   $0x0,0x18
//#ifdef DBG
//			printf("%d",bits>>31);
//#endif
			fetched_bits = ( fetched_bits<<1 ) | ( 1&(bits>>31) );
			bits <<= 1;
			num_bits_left--;
     1a8:	a3 0c 00 00 00       	mov    %eax,0xc

			if( wrk.fullbits )
     1ad:	74 25                	je     1d4 <depack_getbits+0xde>
			{
				if( !num_bits_left )
     1af:	85 c0                	test   %eax,%eax
     1b1:	75 21                	jne    1d4 <depack_getbits+0xde>
				{
					bits = depack_getbits_word();
     1b3:	e8 fc ff ff ff       	call   1b4 <depack_getbits+0xbe>
     1b8:	a3 10 00 00 00       	mov    %eax,0x10
					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;
     1bd:	40                   	inc    %eax
     1be:	74 39                	je     1f9 <depack_getbits+0x103>
					num_bits_left = wrk.wordbit ? 16 : 8;
     1c0:	83 3d 10 00 00 00 01 	cmpl   $0x1,0x10
     1c7:	19 c0                	sbb    %eax,%eax
     1c9:	83 e0 f8             	and    $0xfffffff8,%eax
     1cc:	83 c0 10             	add    $0x10,%eax
     1cf:	a3 0c 00 00 00       	mov    %eax,0xc
			}

//#ifdef DBG
//			printf("%d",bits>>31);
//#endif
			fetched_bits = ( fetched_bits<<1 ) | ( 1&(bits>>31) );
     1d4:	01 db                	add    %ebx,%ebx
     1d6:	c1 ef 1f             	shr    $0x1f,%edi
     1d9:	09 fb                	or     %edi,%ebx
					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;
					num_bits_left = wrk.wordbit ? 16 : 8;
				}
			}

		} while( --numbits );
     1db:	4e                   	dec    %esi
     1dc:	0f 85 74 ff ff ff    	jne    156 <depack_getbits+0x60>
     1e2:	eb 18                	jmp    1fc <depack_getbits+0x106>

		return fetched_bits;
	}
	else
	{
		printf("mhmt-depack.c:depack_getbits() - wrong operation code\n");
     1e4:	83 ec 0c             	sub    $0xc,%esp
     1e7:	68 79 00 00 00       	push   $0x79
     1ec:	e8 fc ff ff ff       	call   1ed <depack_getbits+0xf7>
     1f1:	83 cb ff             	or     $0xffffffff,%ebx
		return 0xFFFFFFFF;
     1f4:	83 c4 10             	add    $0x10,%esp
     1f7:	eb 03                	jmp    1fc <depack_getbits+0x106>
     1f9:	83 cb ff             	or     $0xffffffff,%ebx
	}
}
     1fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
     1ff:	89 d8                	mov    %ebx,%eax
     201:	5b                   	pop    %ebx
     202:	5e                   	pop    %esi
     203:	5f                   	pop    %edi
     204:	5d                   	pop    %ebp
     205:	c3                   	ret    

00000206 <depack_outbyte>:

// puts byte to the output buffer. if it is full, flushes via mhmt-emit.c:emit_file()
// relies on initialized globals: buffer, buf_size, buf_ptr
// returns zero if error (in emit_file()), otherwise non-zero
ULONG depack_outbyte(UBYTE byte, ULONG operation)
{
     206:	55                   	push   %ebp
     207:	89 e5                	mov    %esp,%ebp
     209:	83 ec 08             	sub    $0x8,%esp
     20c:	8b 45 0c             	mov    0xc(%ebp),%eax
     20f:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if( operation==DEPACK_OUTBYTE_ADD )
     212:	83 f8 02             	cmp    $0x2,%eax
     215:	75 2a                	jne    241 <depack_outbyte+0x3b>
	{
		buffer[buf_ptr++] = byte;
     217:	8b 15 00 00 00 00    	mov    0x0,%edx
     21d:	a1 00 00 00 00       	mov    0x0,%eax
     222:	88 0c 10             	mov    %cl,(%eax,%edx,1)
		{
//			printf("слом\n");
		}


		if( buf_ptr >= buf_size )
     225:	a1 00 00 00 00       	mov    0x0,%eax
// returns zero if error (in emit_file()), otherwise non-zero
ULONG depack_outbyte(UBYTE byte, ULONG operation)
{
	if( operation==DEPACK_OUTBYTE_ADD )
	{
		buffer[buf_ptr++] = byte;
     22a:	42                   	inc    %edx
     22b:	89 15 00 00 00 00    	mov    %edx,0x0
		{
//			printf("слом\n");
		}


		if( buf_ptr >= buf_size )
     231:	39 c2                	cmp    %eax,%edx
     233:	72 3d                	jb     272 <depack_outbyte+0x6c>
		{
			buf_ptr=0;
     235:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     23c:	00 00 00 
     23f:	eb 0c                	jmp    24d <depack_outbyte+0x47>
			return emit_file( buffer, buf_size );
		}

		return 1;
	}
	else if( operation==DEPACK_OUTBYTE_FLUSH )
     241:	48                   	dec    %eax
     242:	75 1a                	jne    25e <depack_outbyte+0x58>
	{
		if( buf_ptr ) return emit_file( buffer, buf_ptr );
     244:	a1 00 00 00 00       	mov    0x0,%eax
     249:	85 c0                	test   %eax,%eax
     24b:	74 25                	je     272 <depack_outbyte+0x6c>
     24d:	89 45 0c             	mov    %eax,0xc(%ebp)
     250:	a1 00 00 00 00       	mov    0x0,%eax
     255:	89 45 08             	mov    %eax,0x8(%ebp)
	else
	{
		printf("mhmt-depack.c:depack_outbyte() - bad operation requested\n");
		return 0;
	}
}
     258:	c9                   	leave  

		return 1;
	}
	else if( operation==DEPACK_OUTBYTE_FLUSH )
	{
		if( buf_ptr ) return emit_file( buffer, buf_ptr );
     259:	e9 fc ff ff ff       	jmp    25a <depack_outbyte+0x54>
		return 1;
	}
	else
	{
		printf("mhmt-depack.c:depack_outbyte() - bad operation requested\n");
     25e:	83 ec 0c             	sub    $0xc,%esp
     261:	68 af 00 00 00       	push   $0xaf
     266:	e8 fc ff ff ff       	call   267 <depack_outbyte+0x61>
     26b:	31 c0                	xor    %eax,%eax
		return 0;
     26d:	83 c4 10             	add    $0x10,%esp
     270:	eb 05                	jmp    277 <depack_outbyte+0x71>
     272:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
     277:	c9                   	leave  
     278:	c3                   	ret    

00000279 <depack_repeat>:
// repeats data in output buffer, flushes buffer if needed.
// relies on initialized globals, also relies on buf_size being 2^N
// displacement is back-displacement (negative)
// non-zero if success
ULONG depack_repeat(LONG disp, ULONG length)
{
     279:	55                   	push   %ebp
     27a:	89 e5                	mov    %esp,%ebp
     27c:	56                   	push   %esi
     27d:	8b 75 0c             	mov    0xc(%ebp),%esi
     280:	53                   	push   %ebx
     281:	8b 5d 08             	mov    0x8(%ebp),%ebx
//	printf("\n");
//#endif


	// in a self-consistent system, these three errors should never appear, since there is input stream check before actual depacking
	if( !length )
     284:	85 f6                	test   %esi,%esi
     286:	75 0a                	jne    292 <depack_repeat+0x19>
	{
		printf("mhmt-depack.c:depack_repeat() - zero length!\n");
     288:	83 ec 0c             	sub    $0xc,%esp
     28b:	68 e8 00 00 00       	push   $0xe8
     290:	eb 0c                	jmp    29e <depack_repeat+0x25>
		return 0;
	}
	else if( disp>=0 )
     292:	85 db                	test   %ebx,%ebx
     294:	78 14                	js     2aa <depack_repeat+0x31>
	{
		printf("mhmt-depack.c:depack_repeat() - non-negative displacement!\n");
     296:	83 ec 0c             	sub    $0xc,%esp
     299:	68 15 01 00 00       	push   $0x115
     29e:	e8 fc ff ff ff       	call   29f <depack_repeat+0x26>
     2a3:	31 c0                	xor    %eax,%eax
		return 0;
     2a5:	83 c4 10             	add    $0x10,%esp
     2a8:	eb 5b                	jmp    305 <depack_repeat+0x8c>
	}
	else if( (ULONG)(-disp)>buf_size )
     2aa:	a1 00 00 00 00       	mov    0x0,%eax
     2af:	89 da                	mov    %ebx,%edx
     2b1:	f7 da                	neg    %edx
     2b3:	39 c2                	cmp    %eax,%edx
     2b5:	76 0a                	jbe    2c1 <depack_repeat+0x48>
	{
		printf("mhmt-depack.c:depack_repeat() - displacement greater than buffer size!\n");
     2b7:	83 ec 0c             	sub    $0xc,%esp
     2ba:	68 50 01 00 00       	push   $0x150
     2bf:	eb dd                	jmp    29e <depack_repeat+0x25>
		return 0;
	}
	else
	{
		back_ptr = (disp+buf_ptr) & (buf_size-1); // buf_size MUST BE 2^N!
     2c1:	03 1d 00 00 00 00    	add    0x0,%ebx
     2c7:	48                   	dec    %eax
     2c8:	21 c3                	and    %eax,%ebx
     2ca:	b8 01 00 00 00       	mov    $0x1,%eax

		do
		{
			success = success && depack_outbyte( buffer[back_ptr], DEPACK_OUTBYTE_ADD ); // also increases buf_ptr
     2cf:	85 c0                	test   %eax,%eax
     2d1:	74 21                	je     2f4 <depack_repeat+0x7b>
     2d3:	50                   	push   %eax
     2d4:	50                   	push   %eax
     2d5:	a1 00 00 00 00       	mov    0x0,%eax
     2da:	6a 02                	push   $0x2
     2dc:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
     2e0:	50                   	push   %eax
     2e1:	e8 fc ff ff ff       	call   2e2 <depack_repeat+0x69>
     2e6:	83 c4 10             	add    $0x10,%esp
     2e9:	89 c2                	mov    %eax,%edx
     2eb:	b8 01 00 00 00       	mov    $0x1,%eax
     2f0:	85 d2                	test   %edx,%edx
     2f2:	75 02                	jne    2f6 <depack_repeat+0x7d>
     2f4:	31 c0                	xor    %eax,%eax

			back_ptr = (back_ptr+1) & (buf_size-1); // buf_size MUST BE 2^N!

		} while( --length );
     2f6:	4e                   	dec    %esi

		do
		{
			success = success && depack_outbyte( buffer[back_ptr], DEPACK_OUTBYTE_ADD ); // also increases buf_ptr

			back_ptr = (back_ptr+1) & (buf_size-1); // buf_size MUST BE 2^N!
     2f7:	8b 15 00 00 00 00    	mov    0x0,%edx

		} while( --length );
     2fd:	74 06                	je     305 <depack_repeat+0x8c>

		do
		{
			success = success && depack_outbyte( buffer[back_ptr], DEPACK_OUTBYTE_ADD ); // also increases buf_ptr

			back_ptr = (back_ptr+1) & (buf_size-1); // buf_size MUST BE 2^N!
     2ff:	43                   	inc    %ebx
     300:	4a                   	dec    %edx
     301:	21 d3                	and    %edx,%ebx
     303:	eb ca                	jmp    2cf <depack_repeat+0x56>

		} while( --length );
	}

	return success;
}
     305:	8d 65 f8             	lea    -0x8(%ebp),%esp
     308:	5b                   	pop    %ebx
     309:	5e                   	pop    %esi
     30a:	5d                   	pop    %ebp
     30b:	c3                   	ret    

0000030c <depacker_hrum>:
//
//                   // example defines:
//#define DPK_CHECK  // check input stream for consistency
//#define DPK_DEPACK // do depacking
//#define DPK_REPERR // report errors via printf
{
     30c:	55                   	push   %ebp
     30d:	89 e5                	mov    %esp,%ebp
     30f:	56                   	push   %esi
     310:	53                   	push   %ebx
	ULONG success = 1;


	// rewind input stream
	//
	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     311:	83 ec 0c             	sub    $0xc,%esp
     314:	6a 00                	push   $0x0
     316:	e8 fc ff ff ff       	call   317 <depacker_hrum+0xb>
	}
#endif


	// manage zx header if needed
	if( wrk.zxheader )
     31b:	83 c4 10             	add    $0x10,%esp
     31e:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     325:	74 55                	je     37c <depacker_hrum+0x70>
	{
		// skip 5 bytes (they will go to the end of output file)
		for(i=0;i<5;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     327:	83 ec 0c             	sub    $0xc,%esp
     32a:	6a 01                	push   $0x1
     32c:	e8 fc ff ff ff       	call   32d <depacker_hrum+0x21>
     331:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     338:	e8 fc ff ff ff       	call   339 <depacker_hrum+0x2d>
     33d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     344:	e8 fc ff ff ff       	call   345 <depacker_hrum+0x39>
     349:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     350:	e8 fc ff ff ff       	call   351 <depacker_hrum+0x45>
     355:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     35c:	e8 fc ff ff ff       	call   35d <depacker_hrum+0x51>
		}

		// next 2 bytes must be 0x10
		for(i=0;i<2;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     361:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     368:	e8 fc ff ff ff       	call   369 <depacker_hrum+0x5d>
     36d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     374:	e8 fc ff ff ff       	call   375 <depacker_hrum+0x69>
     379:	83 c4 10             	add    $0x10,%esp



	// initialize bitstream first
	//
	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...
     37c:	53                   	push   %ebx
     37d:	53                   	push   %ebx
     37e:	6a 01                	push   $0x1
     380:	6a 10                	push   $0x10
     382:	e8 fc ff ff ff       	call   383 <depacker_hrum+0x77>



	// then byte of input stream goes to the output unchanged
	//
	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     387:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     38e:	e8 fc ff ff ff       	call   38f <depacker_hrum+0x83>
		return 0;
	}
#endif

#ifdef DPK_DEPACK
	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     393:	5a                   	pop    %edx
     394:	59                   	pop    %ecx
     395:	6a 02                	push   $0x2
     397:	0f b6 c0             	movzbl %al,%eax
     39a:	50                   	push   %eax
     39b:	e8 fc ff ff ff       	call   39c <depacker_hrum+0x90>
     3a0:	e9 9c 01 00 00       	jmp    541 <depacker_hrum+0x235>
	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
 	{
		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     3a5:	50                   	push   %eax
     3a6:	50                   	push   %eax
     3a7:	6a 02                	push   $0x2
     3a9:	6a 01                	push   $0x1
     3ab:	e8 fc ff ff ff       	call   3ac <depacker_hrum+0xa0>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif

		if( 1&bits ) // %1<byte>
     3b0:	83 c4 10             	add    $0x10,%esp
     3b3:	a8 01                	test   $0x1,%al
     3b5:	74 19                	je     3d0 <depacker_hrum+0xc4>
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     3b7:	83 ec 0c             	sub    $0xc,%esp
     3ba:	6a 01                	push   $0x1
     3bc:	e8 fc ff ff ff       	call   3bd <depacker_hrum+0xb1>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
#endif

#ifdef DPK_DEPACK
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     3c1:	59                   	pop    %ecx
     3c2:	5b                   	pop    %ebx
     3c3:	6a 02                	push   $0x2
     3c5:	0f b6 c0             	movzbl %al,%eax
     3c8:	50                   	push   %eax
     3c9:	e8 fc ff ff ff       	call   3ca <depacker_hrum+0xbe>
     3ce:	eb 47                	jmp    417 <depacker_hrum+0x10b>
#endif
		}
		else // %0xx
		{
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     3d0:	52                   	push   %edx
     3d1:	52                   	push   %edx
     3d2:	6a 02                	push   $0x2
     3d4:	6a 02                	push   $0x2
     3d6:	e8 fc ff ff ff       	call   3d7 <depacker_hrum+0xcb>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif

			switch( 0x03 & bits )
     3db:	83 c4 10             	add    $0x10,%esp
     3de:	83 e0 03             	and    $0x3,%eax
     3e1:	74 07                	je     3ea <depacker_hrum+0xde>
     3e3:	83 f8 01             	cmp    $0x1,%eax
     3e6:	75 3e                	jne    426 <depacker_hrum+0x11a>
     3e8:	eb 14                	jmp    3fe <depacker_hrum+0xf2>
			{
			case 0x00: // %000xxx

				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);
     3ea:	50                   	push   %eax
     3eb:	50                   	push   %eax
     3ec:	6a 02                	push   $0x2
     3ee:	6a 03                	push   $0x3
     3f0:	e8 fc ff ff ff       	call   3f1 <depacker_hrum+0xe5>
					return 0;
				}
#endif

#ifdef DPK_DEPACK
				success = success && depack_repeat(disp,1);
     3f5:	59                   	pop    %ecx
     3f6:	5b                   	pop    %ebx
     3f7:	6a 01                	push   $0x1
     3f9:	83 c8 f8             	or     $0xfffffff8,%eax
     3fc:	eb 13                	jmp    411 <depacker_hrum+0x105>
				break;


			case 0x01: // %001

				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     3fe:	83 ec 0c             	sub    $0xc,%esp
     401:	6a 01                	push   $0x1
     403:	e8 fc ff ff ff       	call   404 <depacker_hrum+0xf8>
#ifdef DPK_CHECK
				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
#endif

#ifdef DPK_DEPACK
				success = success && depack_repeat(disp,2);
     408:	5b                   	pop    %ebx
     409:	5a                   	pop    %edx
     40a:	6a 02                	push   $0x2
     40c:	0d 00 ff ff ff       	or     $0xffffff00,%eax
     411:	50                   	push   %eax
     412:	e8 fc ff ff ff       	call   413 <depacker_hrum+0x107>
     417:	31 db                	xor    %ebx,%ebx
     419:	83 c4 10             	add    $0x10,%esp
     41c:	85 c0                	test   %eax,%eax
     41e:	0f 95 c3             	setne  %bl
#endif
				break;
     421:	e9 27 01 00 00       	jmp    54d <depacker_hrum+0x241>

			default: // %010 or %011

				if( (bits&3)==2 ) // %010 - 3 bytes
     426:	83 f8 02             	cmp    $0x2,%eax
     429:	bb 03 00 00 00       	mov    $0x3,%ebx
     42e:	0f 84 b0 00 00 00    	je     4e4 <depacker_hrum+0x1d8>
				{
					length = 3;
				}
				else // %011 - varlen
				{
					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     434:	51                   	push   %ecx
     435:	51                   	push   %ecx
     436:	6a 02                	push   $0x2
     438:	6a 02                	push   $0x2
     43a:	e8 fc ff ff ff       	call   43b <depacker_hrum+0x12f>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
					//  fetch len
					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop
     43f:	83 c4 10             	add    $0x10,%esp
     442:	85 c0                	test   %eax,%eax
     444:	75 23                	jne    469 <depacker_hrum+0x15d>
					{
						length = depack_getbyte(DEPACK_GETBYTE_NEXT);
     446:	83 ec 0c             	sub    $0xc,%esp
     449:	6a 01                	push   $0x1
     44b:	e8 fc ff ff ff       	call   44c <depacker_hrum+0x140>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;
#endif
						if( length == 0 )
     450:	83 c4 10             	add    $0x10,%esp
     453:	85 c0                	test   %eax,%eax
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
					//  fetch len
					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop
					{
						length = depack_getbyte(DEPACK_GETBYTE_NEXT);
     455:	89 c3                	mov    %eax,%ebx
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;
#endif
						if( length == 0 )
     457:	0f 85 87 00 00 00    	jne    4e4 <depacker_hrum+0x1d8>
     45d:	b3 01                	mov    $0x1,%bl
     45f:	be 01 00 00 00       	mov    $0x1,%esi
     464:	e9 e4 00 00 00       	jmp    54d <depacker_hrum+0x241>
							stop = 1;
					}
					else if( bits == 0x01 ) // %01101 - len=4
     469:	83 f8 01             	cmp    $0x1,%eax
     46c:	bb 04 00 00 00       	mov    $0x4,%ebx
     471:	74 71                	je     4e4 <depacker_hrum+0x1d8>
					{
						length = 4;
					}
					else if( bits == 0x02 ) // %01110 - len=5
     473:	83 f8 02             	cmp    $0x2,%eax
     476:	b3 05                	mov    $0x5,%bl
     478:	74 6a                	je     4e4 <depacker_hrum+0x1d8>
					{
						length = 5;
					}
					else // %01111
					{
						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     47a:	52                   	push   %edx
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
						if( bits == 0x00 ) // %0111100
     47b:	b3 06                	mov    $0x6,%bl
					{
						length = 5;
					}
					else // %01111
					{
						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     47d:	52                   	push   %edx
     47e:	6a 02                	push   $0x2
     480:	6a 02                	push   $0x2
     482:	e8 fc ff ff ff       	call   483 <depacker_hrum+0x177>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
						if( bits == 0x00 ) // %0111100
     487:	83 c4 10             	add    $0x10,%esp
     48a:	85 c0                	test   %eax,%eax
     48c:	74 56                	je     4e4 <depacker_hrum+0x1d8>
						{
							length = 6;
						}
						else if( bits == 0x01 ) // %0111101
     48e:	83 f8 01             	cmp    $0x1,%eax
     491:	b3 07                	mov    $0x7,%bl
     493:	74 4f                	je     4e4 <depacker_hrum+0x1d8>
						{
							length = 7;
						}
						else if( bits == 0x02 ) // %0111110
     495:	83 f8 02             	cmp    $0x2,%eax
     498:	b3 08                	mov    $0x8,%bl
     49a:	74 48                	je     4e4 <depacker_hrum+0x1d8>
						{
							length = 8;
						}
						else // %0111111
						{
							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     49c:	50                   	push   %eax
#ifdef DPK_CHECK
							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
							if( bits == 0x00 ) // %011111100
     49d:	b3 09                	mov    $0x9,%bl
						{
							length = 8;
						}
						else // %0111111
						{
							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     49f:	50                   	push   %eax
     4a0:	6a 02                	push   $0x2
     4a2:	6a 02                	push   $0x2
     4a4:	e8 fc ff ff ff       	call   4a5 <depacker_hrum+0x199>
#ifdef DPK_CHECK
							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
							if( bits == 0x00 ) // %011111100
     4a9:	83 c4 10             	add    $0x10,%esp
     4ac:	85 c0                	test   %eax,%eax
     4ae:	74 34                	je     4e4 <depacker_hrum+0x1d8>
							{
								length = 9;
							}
							else if( bits == 0x01 ) // %011111101
     4b0:	83 f8 01             	cmp    $0x1,%eax
     4b3:	b3 0a                	mov    $0xa,%bl
     4b5:	74 2d                	je     4e4 <depacker_hrum+0x1d8>
							{
								length = 10;
							}
							else if( bits == 0x02 ) // %011111110
     4b7:	83 f8 02             	cmp    $0x2,%eax
     4ba:	b3 0b                	mov    $0xb,%bl
     4bc:	74 26                	je     4e4 <depacker_hrum+0x1d8>
							{
								length = 11;
							}
							else // %011111111
							{
								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     4be:	56                   	push   %esi
#ifdef DPK_CHECK
								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
								if( bits == 0x00 ) // %01111111100
     4bf:	b3 0c                	mov    $0xc,%bl
							{
								length = 11;
							}
							else // %011111111
							{
								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     4c1:	56                   	push   %esi
     4c2:	6a 02                	push   $0x2
     4c4:	6a 02                	push   $0x2
     4c6:	e8 fc ff ff ff       	call   4c7 <depacker_hrum+0x1bb>
#ifdef DPK_CHECK
								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
								if( bits == 0x00 ) // %01111111100
     4cb:	83 c4 10             	add    $0x10,%esp
     4ce:	85 c0                	test   %eax,%eax
     4d0:	74 12                	je     4e4 <depacker_hrum+0x1d8>
								{
									length = 12;
								}
								else if( bits == 0x01 ) // %01111111101
     4d2:	83 f8 01             	cmp    $0x1,%eax
     4d5:	b3 0d                	mov    $0xd,%bl
     4d7:	74 0b                	je     4e4 <depacker_hrum+0x1d8>
								{
									length = 13;
								}
								else if( bits == 0x02 ) // %01111111110
     4d9:	31 db                	xor    %ebx,%ebx
     4db:	83 f8 02             	cmp    $0x2,%eax
     4de:	0f 95 c3             	setne  %bl
     4e1:	83 c3 0e             	add    $0xe,%ebx


				// fetch disp and depack
				if( !stop )
				{
					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     4e4:	51                   	push   %ecx
     4e5:	51                   	push   %ecx
     4e6:	6a 02                	push   $0x2
     4e8:	6a 01                	push   $0x1
     4ea:	e8 fc ff ff ff       	call   4eb <depacker_hrum+0x1df>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
					if( bits == 0x00 ) // %0<disp>
     4ef:	83 c4 10             	add    $0x10,%esp
     4f2:	85 c0                	test   %eax,%eax
     4f4:	75 14                	jne    50a <depacker_hrum+0x1fe>
					{
						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     4f6:	83 ec 0c             	sub    $0xc,%esp
     4f9:	6a 01                	push   $0x1
     4fb:	e8 fc ff ff ff       	call   4fc <depacker_hrum+0x1f0>
						disp = (-256) | (0x00FF&byte); // -1..-256
#ifdef DPK_CHECK
						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
#endif
#ifdef DPK_DEPACK
						success = success && depack_repeat(disp,length);
     500:	5e                   	pop    %esi
     501:	5a                   	pop    %edx
     502:	53                   	push   %ebx
     503:	0d 00 ff ff ff       	or     $0xffffff00,%eax
     508:	eb 31                	jmp    53b <depacker_hrum+0x22f>
#endif
					}
					else // %1abcd<disp>
					{
						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     50a:	51                   	push   %ecx
     50b:	51                   	push   %ecx
     50c:	6a 02                	push   $0x2
     50e:	6a 04                	push   $0x4
     510:	e8 fc ff ff ff       	call   511 <depacker_hrum+0x205>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     515:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
						success = success && depack_repeat(disp,length);
#endif
					}
					else // %1abcd<disp>
					{
						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     51c:	89 c6                	mov    %eax,%esi
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
#endif
						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     51e:	e8 fc ff ff ff       	call   51f <depacker_hrum+0x213>
						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096
#ifdef DPK_CHECK
						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
#endif
#ifdef DPK_DEPACK
						success = success && depack_repeat(disp,length);
     523:	c1 e6 08             	shl    $0x8,%esi
     526:	59                   	pop    %ecx
     527:	81 e6 00 0f 00 00    	and    $0xf00,%esi
     52d:	5a                   	pop    %edx
     52e:	53                   	push   %ebx
     52f:	25 ff 00 00 00       	and    $0xff,%eax
     534:	0d 00 f0 ff ff       	or     $0xfffff000,%eax
     539:	09 f0                	or     %esi,%eax
     53b:	50                   	push   %eax
     53c:	e8 fc ff ff ff       	call   53d <depacker_hrum+0x231>
     541:	31 db                	xor    %ebx,%ebx
     543:	83 c4 10             	add    $0x10,%esp
     546:	85 c0                	test   %eax,%eax
     548:	0f 95 c3             	setne  %bl
     54b:	31 f6                	xor    %esi,%esi


	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
     54d:	84 db                	test   %bl,%bl
     54f:	74 08                	je     559 <depacker_hrum+0x24d>
     551:	85 f6                	test   %esi,%esi
     553:	0f 84 4c fe ff ff    	je     3a5 <depacker_hrum+0x99>
		}
	}

	//manage zxheader again (copy to the end of output)
#ifdef DPK_DEPACK
	if( wrk.zxheader )
     559:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     560:	74 41                	je     5a3 <depacker_hrum+0x297>
	{
		check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     562:	83 ec 0c             	sub    $0xc,%esp
     565:	31 f6                	xor    %esi,%esi
     567:	6a 00                	push   $0x0
     569:	e8 fc ff ff ff       	call   56a <depacker_hrum+0x25e>
     56e:	83 c4 10             	add    $0x10,%esp
 #endif

		// place 5 bytes of header to the end
		for(i=0;i<5;i++)
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     571:	83 ec 0c             	sub    $0xc,%esp
     574:	6a 01                	push   $0x1
     576:	e8 fc ff ff ff       	call   577 <depacker_hrum+0x26b>
 #ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
 #endif
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     57b:	83 c4 10             	add    $0x10,%esp
     57e:	85 db                	test   %ebx,%ebx
     580:	74 19                	je     59b <depacker_hrum+0x28f>
     582:	52                   	push   %edx
     583:	0f b6 c0             	movzbl %al,%eax
     586:	52                   	push   %edx
     587:	bb 01 00 00 00       	mov    $0x1,%ebx
     58c:	6a 02                	push   $0x2
     58e:	50                   	push   %eax
     58f:	e8 fc ff ff ff       	call   590 <depacker_hrum+0x284>
     594:	83 c4 10             	add    $0x10,%esp
     597:	85 c0                	test   %eax,%eax
     599:	75 02                	jne    59d <depacker_hrum+0x291>
     59b:	31 db                	xor    %ebx,%ebx
			return 0;
		}
 #endif

		// place 5 bytes of header to the end
		for(i=0;i<5;i++)
     59d:	46                   	inc    %esi
     59e:	83 fe 05             	cmp    $0x5,%esi
     5a1:	75 ce                	jne    571 <depacker_hrum+0x265>
		}
	}
#endif

	return success;
}
     5a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
     5a6:	89 d8                	mov    %ebx,%eax
     5a8:	5b                   	pop    %ebx
     5a9:	5e                   	pop    %esi
     5aa:	5d                   	pop    %ebp
     5ab:	c3                   	ret    

000005ac <depacker_megalz>:
//
//                   // example defines:
//#define DPK_CHECK  // check input stream for consistency
//#define DPK_DEPACK // do depacking
//#define DPK_REPERR // report errors via printf
{
     5ac:	55                   	push   %ebp
     5ad:	89 e5                	mov    %esp,%ebp
     5af:	56                   	push   %esi
     5b0:	53                   	push   %ebx
	ULONG success = 1;


	// rewind input stream
	//
	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     5b1:	83 ec 0c             	sub    $0xc,%esp
     5b4:	6a 00                	push   $0x0
     5b6:	e8 fc ff ff ff       	call   5b7 <depacker_megalz+0xb>
#endif


	// first byte of input stream goes to the output unchanged
	//
	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     5bb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     5c2:	e8 fc ff ff ff       	call   5c3 <depacker_megalz+0x17>
		return 0;
	}
#endif

#ifdef DPK_DEPACK
	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     5c7:	59                   	pop    %ecx
     5c8:	5b                   	pop    %ebx
     5c9:	31 db                	xor    %ebx,%ebx
     5cb:	6a 02                	push   $0x2
     5cd:	0f b6 c0             	movzbl %al,%eax
     5d0:	50                   	push   %eax
     5d1:	e8 fc ff ff ff       	call   5d2 <depacker_megalz+0x26>
     5d6:	5e                   	pop    %esi
     5d7:	5a                   	pop    %edx
 #ifdef DPK_REPERR
 #endif
#endif
	// next is byte to the bitstream
	//
	check = depack_getbits(8,DEPACK_GETBITS_FORCE);
     5d8:	6a 01                	push   $0x1
		return 0;
	}
#endif

#ifdef DPK_DEPACK
	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     5da:	85 c0                	test   %eax,%eax
 #ifdef DPK_REPERR
 #endif
#endif
	// next is byte to the bitstream
	//
	check = depack_getbits(8,DEPACK_GETBITS_FORCE);
     5dc:	6a 08                	push   $0x8
		return 0;
	}
#endif

#ifdef DPK_DEPACK
	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     5de:	0f 95 c3             	setne  %bl
 #ifdef DPK_REPERR
 #endif
#endif
	// next is byte to the bitstream
	//
	check = depack_getbits(8,DEPACK_GETBITS_FORCE);
     5e1:	e8 fc ff ff ff       	call   5e2 <depacker_megalz+0x36>
     5e6:	31 f6                	xor    %esi,%esi


	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
     5e8:	83 c4 10             	add    $0x10,%esp
     5eb:	e9 39 01 00 00       	jmp    729 <depacker_megalz+0x17d>
 	{
		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     5f0:	53                   	push   %ebx
     5f1:	53                   	push   %ebx
     5f2:	6a 02                	push   $0x2
     5f4:	6a 01                	push   $0x1
     5f6:	e8 fc ff ff ff       	call   5f7 <depacker_megalz+0x4b>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif

		if( 1&bits ) // %1<byte>
     5fb:	83 c4 10             	add    $0x10,%esp
     5fe:	a8 01                	test   $0x1,%al
     600:	74 19                	je     61b <depacker_megalz+0x6f>
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     602:	83 ec 0c             	sub    $0xc,%esp
     605:	6a 01                	push   $0x1
     607:	e8 fc ff ff ff       	call   608 <depacker_megalz+0x5c>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == byte ) goto NO_BYTE;
#endif

#ifdef DPK_DEPACK
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     60c:	5a                   	pop    %edx
     60d:	59                   	pop    %ecx
     60e:	6a 02                	push   $0x2
     610:	0f b6 c0             	movzbl %al,%eax
     613:	50                   	push   %eax
     614:	e8 fc ff ff ff       	call   615 <depacker_megalz+0x69>
     619:	eb 3a                	jmp    655 <depacker_megalz+0xa9>
#endif
		}
		else // %0xx
		{
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     61b:	53                   	push   %ebx
     61c:	53                   	push   %ebx
     61d:	6a 02                	push   $0x2
     61f:	6a 02                	push   $0x2
     621:	e8 fc ff ff ff       	call   622 <depacker_megalz+0x76>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif

			switch( 0x03 & bits )
     626:	83 c4 10             	add    $0x10,%esp
     629:	83 e0 03             	and    $0x3,%eax
     62c:	83 f8 02             	cmp    $0x2,%eax
     62f:	74 48                	je     679 <depacker_megalz+0xcd>
     631:	83 f8 03             	cmp    $0x3,%eax
     634:	0f 84 a7 00 00 00    	je     6e1 <depacker_megalz+0x135>
     63a:	48                   	dec    %eax
     63b:	74 27                	je     664 <depacker_megalz+0xb8>
			{
			case 0x00: // %000xxx

				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);
     63d:	51                   	push   %ecx
     63e:	51                   	push   %ecx
     63f:	6a 02                	push   $0x2
     641:	6a 03                	push   $0x3
     643:	e8 fc ff ff ff       	call   644 <depacker_megalz+0x98>
					return 0;
				}
#endif

#ifdef DPK_DEPACK
				success = success && depack_repeat(disp,1);
     648:	5b                   	pop    %ebx
     649:	5a                   	pop    %edx
     64a:	6a 01                	push   $0x1
     64c:	83 c8 f8             	or     $0xfffffff8,%eax
     64f:	50                   	push   %eax
     650:	e8 fc ff ff ff       	call   651 <depacker_megalz+0xa5>
     655:	31 db                	xor    %ebx,%ebx
     657:	83 c4 10             	add    $0x10,%esp
     65a:	85 c0                	test   %eax,%eax
     65c:	0f 95 c3             	setne  %bl
#endif
				break;
     65f:	e9 c5 00 00 00       	jmp    729 <depacker_megalz+0x17d>


			case 0x01: // %001

				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     664:	83 ec 0c             	sub    $0xc,%esp
     667:	6a 01                	push   $0x1
     669:	e8 fc ff ff ff       	call   66a <depacker_megalz+0xbe>
#ifdef DPK_CHECK
				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
#endif

#ifdef DPK_DEPACK
				success = success && depack_repeat(disp,2);
     66e:	5a                   	pop    %edx
     66f:	59                   	pop    %ecx
     670:	6a 02                	push   $0x2
     672:	0d 00 ff ff ff       	or     $0xffffff00,%eax
     677:	eb d6                	jmp    64f <depacker_megalz+0xa3>
#endif
				break;
     679:	bb 03 00 00 00       	mov    $0x3,%ebx

			case 0x02: // %010

				length = 3;
FAR_DISP:
				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     67e:	56                   	push   %esi
     67f:	56                   	push   %esi
     680:	6a 02                	push   $0x2
     682:	6a 01                	push   $0x1
     684:	e8 fc ff ff ff       	call   685 <depacker_megalz+0xd9>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
				if( !(1&bits) ) // -1..-256
     689:	83 c4 10             	add    $0x10,%esp
     68c:	a8 01                	test   $0x1,%al
     68e:	75 14                	jne    6a4 <depacker_megalz+0xf8>
				{
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     690:	83 ec 0c             	sub    $0xc,%esp
     693:	6a 01                	push   $0x1
     695:	e8 fc ff ff ff       	call   696 <depacker_megalz+0xea>
#ifdef DPK_CHECK
					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
#endif

#ifdef DPK_DEPACK
					success = success && depack_repeat(disp,length);
     69a:	5a                   	pop    %edx
     69b:	59                   	pop    %ecx
     69c:	53                   	push   %ebx
     69d:	0d 00 ff ff ff       	or     $0xffffff00,%eax
     6a2:	eb 29                	jmp    6cd <depacker_megalz+0x121>
#endif
				}
				else // -257..-4352
				{
					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     6a4:	56                   	push   %esi
     6a5:	56                   	push   %esi
     6a6:	6a 02                	push   $0x2
     6a8:	6a 04                	push   $0x4
     6aa:	e8 fc ff ff ff       	call   6ab <depacker_megalz+0xff>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     6af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
					success = success && depack_repeat(disp,length);
#endif
				}
				else // -257..-4352
				{
					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     6b6:	89 c6                	mov    %eax,%esi
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     6b8:	e8 fc ff ff ff       	call   6b9 <depacker_megalz+0x10d>
#ifdef DPK_CHECK
					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
#endif

#ifdef DPK_DEPACK
					success = success && depack_repeat(disp,length);
     6bd:	83 ce f0             	or     $0xfffffff0,%esi
     6c0:	5a                   	pop    %edx
     6c1:	59                   	pop    %ecx
     6c2:	c1 e6 08             	shl    $0x8,%esi
     6c5:	53                   	push   %ebx
     6c6:	8d 84 30 00 ff ff ff 	lea    -0x100(%eax,%esi,1),%eax
     6cd:	50                   	push   %eax
     6ce:	31 db                	xor    %ebx,%ebx
     6d0:	e8 fc ff ff ff       	call   6d1 <depacker_megalz+0x125>
     6d5:	83 c4 10             	add    $0x10,%esp
     6d8:	85 c0                	test   %eax,%eax
     6da:	0f 95 c3             	setne  %bl
     6dd:	31 f6                	xor    %esi,%esi
     6df:	eb 48                	jmp    729 <depacker_megalz+0x17d>
     6e1:	31 db                	xor    %ebx,%ebx
			case 0x03: // %011 - variable length

				bitlen = 0;
				do
				{
					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     6e3:	50                   	push   %eax
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
					bitlen++;
     6e4:	43                   	inc    %ebx
			case 0x03: // %011 - variable length

				bitlen = 0;
				do
				{
					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     6e5:	50                   	push   %eax
     6e6:	6a 02                	push   $0x2
     6e8:	6a 01                	push   $0x1
     6ea:	e8 fc ff ff ff       	call   6eb <depacker_megalz+0x13f>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
					bitlen++;

				} while ( !(1&bits) );
     6ef:	83 c4 10             	add    $0x10,%esp
     6f2:	a8 01                	test   $0x1,%al
     6f4:	74 ed                	je     6e3 <depacker_megalz+0x137>

				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!
     6f6:	83 fb 09             	cmp    $0x9,%ebx
     6f9:	74 24                	je     71f <depacker_megalz+0x173>
					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
 #endif
					return 0;
				}
#endif
				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);
     6fb:	56                   	push   %esi
     6fc:	56                   	push   %esi
     6fd:	6a 02                	push   $0x2
     6ff:	53                   	push   %ebx
     700:	e8 fc ff ff ff       	call   701 <depacker_megalz+0x155>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );
     705:	88 d9                	mov    %bl,%cl
     707:	ba 01 00 00 00       	mov    $0x1,%edx
     70c:	d3 e2                	shl    %cl,%edx
					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
 #endif
					return 0;
				}
#endif
				goto FAR_DISP;
     70e:	83 c4 10             	add    $0x10,%esp
#endif
				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );
     711:	8d 4a ff             	lea    -0x1(%edx),%ecx
     714:	21 c8                	and    %ecx,%eax
     716:	8d 5c 02 02          	lea    0x2(%edx,%eax,1),%ebx
					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
 #endif
					return 0;
				}
#endif
				goto FAR_DISP;
     71a:	e9 5f ff ff ff       	jmp    67e <depacker_megalz+0xd2>
     71f:	bb 01 00 00 00       	mov    $0x1,%ebx
     724:	be 01 00 00 00       	mov    $0x1,%esi


	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
     729:	85 db                	test   %ebx,%ebx
     72b:	74 08                	je     735 <depacker_megalz+0x189>
     72d:	85 f6                	test   %esi,%esi
     72f:	0f 84 bb fe ff ff    	je     5f0 <depacker_megalz+0x44>
		}

	}

	return success;
}
     735:	8d 65 f8             	lea    -0x8(%ebp),%esp
     738:	89 d8                	mov    %ebx,%eax
     73a:	5b                   	pop    %ebx
     73b:	5e                   	pop    %esi
     73c:	5d                   	pop    %ebp
     73d:	c3                   	ret    

0000073e <depacker_hrust>:
//
//                   // example defines:
//#define DPK_CHECK  // check input stream for consistency
//#define DPK_DEPACK // do depacking
//#define DPK_REPERR // report errors via printf
{
     73e:	55                   	push   %ebp
     73f:	89 e5                	mov    %esp,%ebp
     741:	57                   	push   %edi
     742:	56                   	push   %esi
     743:	53                   	push   %ebx
     744:	83 ec 28             	sub    $0x28,%esp



	// rewind input stream
	//
	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     747:	6a 00                	push   $0x0
     749:	e8 fc ff ff ff       	call   74a <depacker_hrust+0xc>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
     74e:	83 c4 10             	add    $0x10,%esp
     751:	40                   	inc    %eax
     752:	0f 84 0c 06 00 00    	je     d64 <depacker_hrust+0x626>
	}
#endif


	// manage zx header if needed
	if( wrk.zxheader )
     758:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     75f:	74 5d                	je     7be <depacker_hrust+0x80>
	{
		// check for "HR" in beginning
		check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     761:	83 ec 0c             	sub    $0xc,%esp
     764:	6a 01                	push   $0x1
     766:	e8 fc ff ff ff       	call   767 <depacker_hrust+0x29>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
     76b:	83 c4 10             	add    $0x10,%esp
     76e:	83 f8 ff             	cmp    $0xffffffff,%eax
     771:	74 78                	je     7eb <depacker_hrust+0xad>
		if( check != 'H' )
     773:	83 f8 48             	cmp    $0x48,%eax
     776:	74 17                	je     78f <depacker_hrust+0x51>
		{
 #ifdef DPK_REPERR
			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");
     778:	83 ec 0c             	sub    $0xc,%esp
     77b:	68 cb 01 00 00       	push   $0x1cb
     780:	e8 fc ff ff ff       	call   781 <depacker_hrust+0x43>
     785:	31 f6                	xor    %esi,%esi
 #endif
			return 0;
     787:	83 c4 10             	add    $0x10,%esp
     78a:	e9 29 06 00 00       	jmp    db8 <depacker_hrust+0x67a>
		}
#endif
		check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     78f:	83 ec 0c             	sub    $0xc,%esp
     792:	6a 01                	push   $0x1
     794:	e8 fc ff ff ff       	call   795 <depacker_hrust+0x57>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
     799:	83 c4 10             	add    $0x10,%esp
     79c:	83 f8 ff             	cmp    $0xffffffff,%eax
     79f:	74 4a                	je     7eb <depacker_hrust+0xad>
		if( check != 'R' )
		{
 #ifdef DPK_REPERR
			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");
 #endif
			return 0;
     7a1:	31 db                	xor    %ebx,%ebx
		}
#endif
		check = depack_getbyte(DEPACK_GETBYTE_NEXT);
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
		if( check != 'R' )
     7a3:	83 f8 52             	cmp    $0x52,%eax
     7a6:	75 d0                	jne    778 <depacker_hrust+0x3a>
#endif

		// skip 10 bytes
		for(i=0;i<10;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     7a8:	83 ec 0c             	sub    $0xc,%esp
     7ab:	6a 01                	push   $0x1
     7ad:	e8 fc ff ff ff       	call   7ae <depacker_hrust+0x70>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
     7b2:	83 c4 10             	add    $0x10,%esp
     7b5:	40                   	inc    %eax
     7b6:	74 33                	je     7eb <depacker_hrust+0xad>
			return 0;
		}
#endif

		// skip 10 bytes
		for(i=0;i<10;i++)
     7b8:	43                   	inc    %ebx
     7b9:	83 fb 0a             	cmp    $0xa,%ebx
     7bc:	75 ea                	jne    7a8 <depacker_hrust+0x6a>



	// initialize bitstream first
	//
	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...
     7be:	56                   	push   %esi
     7bf:	56                   	push   %esi
     7c0:	6a 01                	push   $0x1
     7c2:	6a 10                	push   $0x10
     7c4:	e8 fc ff ff ff       	call   7c5 <depacker_hrust+0x87>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
     7c9:	83 c4 10             	add    $0x10,%esp
     7cc:	40                   	inc    %eax
     7cd:	75 0a                	jne    7d9 <depacker_hrust+0x9b>
	{
NO_BITS_HST:
 #ifdef DPK_REPERR
		printf("mhmt-depack-hrust.c:{} - Can't get bits from input stream!\n");
     7cf:	83 ec 0c             	sub    $0xc,%esp
     7d2:	68 f3 01 00 00       	push   $0x1f3
     7d7:	eb a7                	jmp    780 <depacker_hrust+0x42>



	// then byte of input stream goes to the output unchanged
	//
	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     7d9:	83 ec 0c             	sub    $0xc,%esp
     7dc:	6a 01                	push   $0x1
     7de:	e8 fc ff ff ff       	call   7df <depacker_hrust+0xa1>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == byte )
     7e3:	83 c4 10             	add    $0x10,%esp
     7e6:	83 f8 ff             	cmp    $0xffffffff,%eax
     7e9:	75 0a                	jne    7f5 <depacker_hrust+0xb7>
	{
NO_BYTE_HST:
 #ifdef DPK_REPERR
		printf("mhmt-depack-hrust.c:{} - Can't get byte from input stream!\n");
     7eb:	83 ec 0c             	sub    $0xc,%esp
     7ee:	68 2e 02 00 00       	push   $0x22e
     7f3:	eb 8b                	jmp    780 <depacker_hrust+0x42>
		return 0;
	}
#endif

#ifdef DPK_DEPACK
	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     7f5:	53                   	push   %ebx
     7f6:	0f b6 c0             	movzbl %al,%eax
     7f9:	53                   	push   %ebx
     7fa:	6a 02                	push   $0x2
     7fc:	50                   	push   %eax
     7fd:	e8 fc ff ff ff       	call   7fe <depacker_hrust+0xc0>
     802:	83 c4 10             	add    $0x10,%esp
     805:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
     80c:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
     813:	85 c0                	test   %eax,%eax
     815:	0f 95 c0             	setne  %al
     818:	0f b6 f0             	movzbl %al,%esi


	// now normal depacking loop
	//
  	stop = 0;
	while( (!stop) && success )
     81b:	e9 19 05 00 00       	jmp    d39 <depacker_hrust+0x5fb>
		skiplen  = 0;
		skipdisp = 0;
		disptype = DISP_PLUSBYTE;
		docopy = 0;

		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     820:	51                   	push   %ecx
     821:	51                   	push   %ecx
     822:	6a 02                	push   $0x2
     824:	6a 01                	push   $0x1
     826:	e8 fc ff ff ff       	call   827 <depacker_hrust+0xe9>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     82b:	83 c4 10             	add    $0x10,%esp
     82e:	83 f8 ff             	cmp    $0xffffffff,%eax
     831:	74 9c                	je     7cf <depacker_hrust+0x91>
#endif

		if( 1&bits ) // %1<byte>
     833:	a8 01                	test   $0x1,%al
     835:	74 13                	je     84a <depacker_hrust+0x10c>
     837:	be 01 00 00 00       	mov    $0x1,%esi
     83c:	31 d2                	xor    %edx,%edx
     83e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     845:	e9 8d 00 00 00       	jmp    8d7 <depacker_hrust+0x199>
			docopy = 1;
			length = 1;
		}
		else // %0xx
		{
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     84a:	52                   	push   %edx
     84b:	52                   	push   %edx
     84c:	6a 02                	push   $0x2
     84e:	6a 02                	push   $0x2
     850:	e8 fc ff ff ff       	call   851 <depacker_hrust+0x113>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     855:	83 c4 10             	add    $0x10,%esp
     858:	83 f8 ff             	cmp    $0xffffffff,%eax
     85b:	0f 84 6e ff ff ff    	je     7cf <depacker_hrust+0x91>
#endif

			switch( bits&3 )
     861:	83 e0 03             	and    $0x3,%eax
     864:	83 f8 02             	cmp    $0x2,%eax
     867:	74 2f                	je     898 <depacker_hrust+0x15a>
     869:	83 f8 03             	cmp    $0x3,%eax
     86c:	74 05                	je     873 <depacker_hrust+0x135>
     86e:	48                   	dec    %eax
     86f:	75 3c                	jne    8ad <depacker_hrust+0x16f>
     871:	eb 6e                	jmp    8e1 <depacker_hrust+0x1a3>
		}

			if( (!stop) && (!skiplen) && (!docopy) )
			{
				// read variable length
				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     873:	50                   	push   %eax
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
#endif

			switch( bits&3 )
     874:	31 f6                	xor    %esi,%esi
		}

			if( (!stop) && (!skiplen) && (!docopy) )
			{
				// read variable length
				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     876:	50                   	push   %eax
     877:	6a 02                	push   $0x2
     879:	6a 02                	push   $0x2
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
#endif

			switch( bits&3 )
     87b:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
		}

			if( (!stop) && (!skiplen) && (!docopy) )
			{
				// read variable length
				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     882:	e8 fc ff ff ff       	call   883 <depacker_hrust+0x145>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     887:	83 c4 10             	add    $0x10,%esp
     88a:	83 f8 ff             	cmp    $0xffffffff,%eax
     88d:	0f 85 5b 01 00 00    	jne    9ee <depacker_hrust+0x2b0>
     893:	e9 37 ff ff ff       	jmp    7cf <depacker_hrust+0x91>
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
#endif

			switch( bits&3 )
     898:	31 f6                	xor    %esi,%esi
     89a:	31 d2                	xor    %edx,%edx
     89c:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
     8a3:	bb 03 00 00 00       	mov    $0x3,%ebx
     8a8:	e9 2d 01 00 00       	jmp    9da <depacker_hrust+0x29c>
			{
			case 0: // %000xxx

				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);
     8ad:	56                   	push   %esi
     8ae:	56                   	push   %esi
     8af:	6a 02                	push   $0x2
     8b1:	6a 03                	push   $0x3
     8b3:	e8 fc ff ff ff       	call   8b4 <depacker_hrust+0x176>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     8b8:	83 c4 10             	add    $0x10,%esp
     8bb:	83 f8 ff             	cmp    $0xffffffff,%eax
     8be:	0f 84 0b ff ff ff    	je     7cf <depacker_hrust+0x91>
#endif

				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)
     8c4:	89 c7                	mov    %eax,%edi
     8c6:	31 f6                	xor    %esi,%esi
     8c8:	83 cf f8             	or     $0xfffffff8,%edi
     8cb:	ba 01 00 00 00       	mov    $0x1,%edx
     8d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     8d7:	bb 01 00 00 00       	mov    $0x1,%ebx
				length = 1;

				skiplen  = 1;
				skipdisp = 1;

				break;
     8dc:	e9 f9 00 00 00       	jmp    9da <depacker_hrust+0x29c>
			case 1: // %001 - 2 bytes or insertion match part 1

				length = 2;
				skiplen = 1;

				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     8e1:	53                   	push   %ebx
     8e2:	53                   	push   %ebx
     8e3:	6a 02                	push   $0x2
     8e5:	6a 02                	push   $0x2
     8e7:	e8 fc ff ff ff       	call   8e8 <depacker_hrust+0x1aa>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     8ec:	83 c4 10             	add    $0x10,%esp
     8ef:	83 f8 ff             	cmp    $0xffffffff,%eax
     8f2:	0f 84 d7 fe ff ff    	je     7cf <depacker_hrust+0x91>
#endif

				switch( bits&3 )
     8f8:	83 e0 03             	and    $0x3,%eax
     8fb:	83 f8 02             	cmp    $0x2,%eax
     8fe:	74 32                	je     932 <depacker_hrust+0x1f4>
     900:	83 f8 03             	cmp    $0x3,%eax
     903:	0f 84 c1 00 00 00    	je     9ca <depacker_hrust+0x28c>
     909:	31 f6                	xor    %esi,%esi
     90b:	31 d2                	xor    %edx,%edx
     90d:	48                   	dec    %eax
     90e:	bb 02 00 00 00       	mov    $0x2,%ebx
     913:	0f 94 c0             	sete   %al
     916:	0f b6 f8             	movzbl %al,%edi
     919:	4f                   	dec    %edi
     91a:	81 e7 00 ff ff ff    	and    $0xffffff00,%edi
     920:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     927:	81 ef 00 02 00 00    	sub    $0x200,%edi
     92d:	e9 a8 00 00 00       	jmp    9da <depacker_hrust+0x29c>

					break;

				case 2: // %001 10 - ff00..ffdf or insertion match

					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     932:	83 ec 0c             	sub    $0xc,%esp
     935:	6a 01                	push   $0x1
     937:	e8 fc ff ff ff       	call   938 <depacker_hrust+0x1fa>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     93c:	83 c4 10             	add    $0x10,%esp
     93f:	83 f8 ff             	cmp    $0xffffffff,%eax
     942:	0f 84 a3 fe ff ff    	je     7eb <depacker_hrust+0xad>
#endif
					skipdisp = 1;

					if( byte<0x00E0 ) // ff00..ffdf
     948:	3d df 00 00 00       	cmp    $0xdf,%eax
     94d:	77 18                	ja     967 <depacker_hrust+0x229>
					{
						disp = (-256) | (byte&0x00FF);
     94f:	89 c7                	mov    %eax,%edi
     951:	31 f6                	xor    %esi,%esi
     953:	81 cf 00 ff ff ff    	or     $0xffffff00,%edi
     959:	ba 01 00 00 00       	mov    $0x1,%edx
     95e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     965:	eb 6e                	jmp    9d5 <depacker_hrust+0x297>
					}
					else if( byte==0x00FE ) // expand bitlen of expandable displacement
     967:	3d fe 00 00 00       	cmp    $0xfe,%eax
     96c:	75 28                	jne    996 <depacker_hrust+0x258>
						#ifdef DBG
							printf("expansion\n");
						#endif

						length = 0; // nothing to do
						expbitlen++;
     96e:	ff 45 dc             	incl   -0x24(%ebp)
#ifdef DPK_CHECK
						if( expbitlen>8 )
     971:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
     975:	77 12                	ja     989 <depacker_hrust+0x24b>
     977:	31 f6                	xor    %esi,%esi
     979:	ba 01 00 00 00       	mov    $0x1,%edx
     97e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     985:	31 db                	xor    %ebx,%ebx
     987:	eb 51                	jmp    9da <depacker_hrust+0x29c>
						{
 #ifdef DPK_REPERR
							printf("mhmt-depack-hrust.c:{} - bitlen of expandable displacement expanded more than 16 bits!\n");
     989:	83 ec 0c             	sub    $0xc,%esp
     98c:	68 69 02 00 00       	push   $0x269
     991:	e9 ea fd ff ff       	jmp    780 <depacker_hrust+0x42>
					}
					else // insertion match - xor 2
					{
						length = (-3); // mark insertion match

						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
     996:	89 c7                	mov    %eax,%edi
						byte ^= 0x02;
						byte -= 15;

						disp = (-256) | (byte&0x00FF);
     998:	31 f6                	xor    %esi,%esi
					}
					else // insertion match - xor 2
					{
						length = (-3); // mark insertion match

						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
     99a:	8d 14 00             	lea    (%eax,%eax,1),%edx
						byte ^= 0x02;
						byte -= 15;

						disp = (-256) | (byte&0x00FF);
     99d:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
					}
					else // insertion match - xor 2
					{
						length = (-3); // mark insertion match

						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
     9a2:	c1 ef 07             	shr    $0x7,%edi
     9a5:	81 e2 ff 00 00 00    	and    $0xff,%edx
     9ab:	83 e7 01             	and    $0x1,%edi
     9ae:	09 d7                	or     %edx,%edi
						byte ^= 0x02;
						byte -= 15;

						disp = (-256) | (byte&0x00FF);
     9b0:	ba 01 00 00 00       	mov    $0x1,%edx
					else // insertion match - xor 2
					{
						length = (-3); // mark insertion match

						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
						byte ^= 0x02;
     9b5:	83 f7 02             	xor    $0x2,%edi
						byte -= 15;

						disp = (-256) | (byte&0x00FF);
     9b8:	83 ef 0f             	sub    $0xf,%edi
     9bb:	81 cf 00 ff ff ff    	or     $0xffffff00,%edi
     9c1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     9c8:	eb 10                	jmp    9da <depacker_hrust+0x29c>
     9ca:	31 f6                	xor    %esi,%esi
     9cc:	31 d2                	xor    %edx,%edx
     9ce:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
     9d5:	bb 02 00 00 00       	mov    $0x2,%ebx
					} while( (bits==3) && (length<15) );
					break;
				}
			}

			if( (!stop) && (!skipdisp) && (!docopy) )
     9da:	85 f6                	test   %esi,%esi

				break;
			}
		}

			if( (!stop) && (!skiplen) && (!docopy) )
     9dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
					} while( (bits==3) && (length<15) );
					break;
				}
			}

			if( (!stop) && (!skipdisp) && (!docopy) )
     9e3:	0f 85 6e 02 00 00    	jne    c57 <depacker_hrust+0x519>
     9e9:	e9 45 01 00 00       	jmp    b33 <depacker_hrust+0x3f5>
				// read variable length
				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
#endif                                                                                 
				switch( bits&3 )
     9ee:	83 e0 03             	and    $0x3,%eax
     9f1:	83 f8 02             	cmp    $0x2,%eax
     9f4:	74 0e                	je     a04 <depacker_hrust+0x2c6>
     9f6:	83 f8 03             	cmp    $0x3,%eax
     9f9:	0f 84 07 01 00 00    	je     b06 <depacker_hrust+0x3c8>
     9ff:	48                   	dec    %eax
     a00:	75 1d                	jne    a1f <depacker_hrust+0x2e1>
     a02:	eb 0a                	jmp    a0e <depacker_hrust+0x2d0>
     a04:	bb 05 00 00 00       	mov    $0x5,%ebx
     a09:	e9 3d 01 00 00       	jmp    b4b <depacker_hrust+0x40d>
     a0e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
     a15:	bb 04 00 00 00       	mov    $0x4,%ebx
     a1a:	e9 2c 01 00 00       	jmp    b4b <depacker_hrust+0x40d>
				{
				case 0: // special cases

					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     a1f:	51                   	push   %ecx
     a20:	51                   	push   %ecx
     a21:	6a 02                	push   $0x2
     a23:	6a 01                	push   $0x1
     a25:	e8 fc ff ff ff       	call   a26 <depacker_hrust+0x2e8>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     a2a:	83 c4 10             	add    $0x10,%esp
     a2d:	83 f8 ff             	cmp    $0xffffffff,%eax
     a30:	0f 84 99 fd ff ff    	je     7cf <depacker_hrust+0x91>
#endif
					if( bits&1 ) // %011 001abcd<byte> - insertion match, displacements -1..-16
     a36:	a8 01                	test   $0x1,%al
     a38:	74 28                	je     a62 <depacker_hrust+0x324>
					{
						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     a3a:	52                   	push   %edx
     a3b:	52                   	push   %edx
     a3c:	6a 02                	push   $0x2
     a3e:	6a 04                	push   $0x4
     a40:	e8 fc ff ff ff       	call   a41 <depacker_hrust+0x303>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     a45:	83 c4 10             	add    $0x10,%esp
     a48:	83 f8 ff             	cmp    $0xffffffff,%eax
     a4b:	0f 84 7e fd ff ff    	je     7cf <depacker_hrust+0x91>
#endif
						length = (-3); // mark insertion match

						skipdisp = 1; // prepare displacement
						disp = (-16) | (bits&15);
     a51:	89 c7                	mov    %eax,%edi
     a53:	83 cf f0             	or     $0xfffffff0,%edi
     a56:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
     a5d:	e9 a2 01 00 00       	jmp    c04 <depacker_hrust+0x4c6>
					}
					else
					{
						bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     a62:	50                   	push   %eax
     a63:	50                   	push   %eax
     a64:	6a 02                	push   $0x2
     a66:	6a 01                	push   $0x1
     a68:	e8 fc ff ff ff       	call   a69 <depacker_hrust+0x32b>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     a6d:	83 c4 10             	add    $0x10,%esp
     a70:	83 f8 ff             	cmp    $0xffffffff,%eax
     a73:	0f 84 56 fd ff ff    	je     7cf <depacker_hrust+0x91>
#endif
						if( bits&1 ) // %011 0001abcd - copy-many-bytes
     a79:	a8 01                	test   $0x1,%al
     a7b:	74 2f                	je     aac <depacker_hrust+0x36e>
						{
							bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     a7d:	56                   	push   %esi
     a7e:	56                   	push   %esi
     a7f:	6a 02                	push   $0x2
     a81:	6a 04                	push   $0x4
     a83:	e8 fc ff ff ff       	call   a84 <depacker_hrust+0x346>
#ifdef DPK_CHECK
							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     a88:	83 c4 10             	add    $0x10,%esp
     a8b:	83 f8 ff             	cmp    $0xffffffff,%eax
     a8e:	0f 84 3b fd ff ff    	je     7cf <depacker_hrust+0x91>
#endif
							length = ((bits&15)+6)<<1;
     a94:	83 e0 0f             	and    $0xf,%eax
     a97:	be 01 00 00 00       	mov    $0x1,%esi
     a9c:	8d 5c 00 0c          	lea    0xc(%eax,%eax,1),%ebx
     aa0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
     aa7:	e9 ab 01 00 00       	jmp    c57 <depacker_hrust+0x519>
							skipdisp = 1;
							docopy = 1;
						}
						else // %011 0000abcdefg[<byte>] - longer lengthes
						{
							bits = depack_getbits(7,DEPACK_GETBITS_NEXT);
     aac:	53                   	push   %ebx
     aad:	53                   	push   %ebx
     aae:	6a 02                	push   $0x2
     ab0:	6a 07                	push   $0x7
     ab2:	e8 fc ff ff ff       	call   ab3 <depacker_hrust+0x375>
#ifdef DPK_CHECK
							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     ab7:	83 c4 10             	add    $0x10,%esp
     aba:	83 f8 ff             	cmp    $0xffffffff,%eax
     abd:	0f 84 0c fd ff ff    	je     7cf <depacker_hrust+0x91>
#endif
							bits &= 127;
     ac3:	89 c3                	mov    %eax,%ebx
     ac5:	83 e3 7f             	and    $0x7f,%ebx

							if( bits==15 ) // stop depack
     ac8:	83 fb 0f             	cmp    $0xf,%ebx
     acb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
     ad2:	0f 84 d7 01 00 00    	je     caf <depacker_hrust+0x571>
							{
								stop=1;
							}
							else if( bits>15 ) // 16..127
     ad8:	77 21                	ja     afb <depacker_hrust+0x3bd>
							{
								length = bits;
							}
							else // 0..14: longer lengthes
							{
								byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     ada:	83 ec 0c             	sub    $0xc,%esp
     add:	6a 01                	push   $0x1
     adf:	e8 fc ff ff ff       	call   ae0 <depacker_hrust+0x3a2>
#ifdef DPK_CHECK
								if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     ae4:	83 c4 10             	add    $0x10,%esp
     ae7:	83 f8 ff             	cmp    $0xffffffff,%eax
     aea:	0f 84 fb fc ff ff    	je     7eb <depacker_hrust+0xad>
#endif
								length = (bits<<8) + (byte&0x00FF);
     af0:	25 ff 00 00 00       	and    $0xff,%eax
     af5:	c1 e3 08             	shl    $0x8,%ebx
     af8:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
     afb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
     b02:	31 f6                	xor    %esi,%esi
     b04:	eb 45                	jmp    b4b <depacker_hrust+0x40d>
     b06:	bb 06 00 00 00       	mov    $0x6,%ebx
				case 3: // variable length (6-15), %01111...

					length = 6;
					do
					{
						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     b0b:	51                   	push   %ecx
     b0c:	51                   	push   %ecx
     b0d:	6a 02                	push   $0x2
     b0f:	6a 02                	push   $0x2
     b11:	e8 fc ff ff ff       	call   b12 <depacker_hrust+0x3d4>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     b16:	83 c4 10             	add    $0x10,%esp
     b19:	83 f8 ff             	cmp    $0xffffffff,%eax
     b1c:	0f 84 ad fc ff ff    	je     7cf <depacker_hrust+0x91>
#endif                                                                                  
						bits &= 3;
     b22:	83 e0 03             	and    $0x3,%eax
						length += bits;
     b25:	01 c3                	add    %eax,%ebx

					} while( (bits==3) && (length<15) );
     b27:	83 fb 0e             	cmp    $0xe,%ebx
     b2a:	7f cf                	jg     afb <depacker_hrust+0x3bd>
     b2c:	83 f8 03             	cmp    $0x3,%eax
     b2f:	75 ca                	jne    afb <depacker_hrust+0x3bd>
     b31:	eb d8                	jmp    b0b <depacker_hrust+0x3cd>
					break;
				}
			}

			if( (!stop) && (!skipdisp) && (!docopy) )
     b33:	85 d2                	test   %edx,%edx
     b35:	0f 85 f8 00 00 00    	jne    c33 <depacker_hrust+0x4f5>
			{
				// extract displacement

				switch( disptype )
     b3b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
     b3f:	0f 84 d0 00 00 00    	je     c15 <depacker_hrust+0x4d7>
     b45:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
     b49:	75 68                	jne    bb3 <depacker_hrust+0x475>
				{
				case DISP_COMMON:

					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     b4b:	52                   	push   %edx
     b4c:	52                   	push   %edx
     b4d:	6a 02                	push   $0x2
     b4f:	6a 02                	push   $0x2
     b51:	e8 fc ff ff ff       	call   b52 <depacker_hrust+0x414>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     b56:	83 c4 10             	add    $0x10,%esp
     b59:	83 f8 ff             	cmp    $0xffffffff,%eax
     b5c:	0f 84 6d fc ff ff    	je     7cf <depacker_hrust+0x91>
#endif                                                                                  
					bits &= 3;
					if( !bits ) // %00<byte> - fe00..feff
     b62:	83 e0 03             	and    $0x3,%eax
     b65:	75 0e                	jne    b75 <depacker_hrust+0x437>
     b67:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     b6e:	bf 00 fe ff ff       	mov    $0xfffffe00,%edi
     b73:	eb 45                	jmp    bba <depacker_hrust+0x47c>
					{
						disp = (-512);
						disptype=DISP_PLUSBYTE; // we fall in next section and there is check
						// NO break!
					}
					else if( bits==1 ) // %01<byte> - ff00..ffdf
     b75:	83 f8 01             	cmp    $0x1,%eax
     b78:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
     b7d:	74 3b                	je     bba <depacker_hrust+0x47c>
					{
						disp = (-256);
						// NO break!
						// no check for byte in range e0..ff here - but in next switch section!
					}
					else if( bits==2 ) // %10abcde - ffe0..ffff
     b7f:	83 f8 02             	cmp    $0x2,%eax
     b82:	0f 84 8d 00 00 00    	je     c15 <depacker_hrust+0x4d7>

						break;
					}
					else // %11... - expanding displacement
					{
						bits = depack_getbits(expbitlen,DEPACK_GETBITS_NEXT);
     b88:	50                   	push   %eax
     b89:	50                   	push   %eax
     b8a:	6a 02                	push   $0x2
     b8c:	ff 75 dc             	pushl  -0x24(%ebp)
     b8f:	e8 fc ff ff ff       	call   b90 <depacker_hrust+0x452>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     b94:	83 c4 10             	add    $0x10,%esp
     b97:	83 f8 ff             	cmp    $0xffffffff,%eax
     b9a:	0f 84 2f fc ff ff    	je     7cf <depacker_hrust+0x91>
#endif                                                                                  
						disp = (-1)<<expbitlen;
     ba0:	8a 4d dc             	mov    -0x24(%ebp),%cl
     ba3:	83 ca ff             	or     $0xffffffff,%edx
     ba6:	d3 e2                	shl    %cl,%edx
						disp |= (bits&(~disp));
     ba8:	89 d7                	mov    %edx,%edi
     baa:	f7 d7                	not    %edi
     bac:	21 c7                	and    %eax,%edi
     bae:	09 d7                	or     %edx,%edi

						disp <<= 8;
     bb0:	c1 e7 08             	shl    $0x8,%edi
     bb3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
						disptype = DISP_PLUSBYTE;
						// NO break!
					}

				case DISP_PLUSBYTE:
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     bba:	83 ec 0c             	sub    $0xc,%esp
     bbd:	6a 01                	push   $0x1
     bbf:	e8 fc ff ff ff       	call   bc0 <depacker_hrust+0x482>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     bc4:	83 c4 10             	add    $0x10,%esp
     bc7:	83 f8 ff             	cmp    $0xffffffff,%eax
     bca:	0f 84 1b fc ff ff    	je     7eb <depacker_hrust+0xad>
#endif
					if( disptype==DISP_COMMON ) // if we here from previous section of switch()
     bd0:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
     bd4:	75 35                	jne    c0b <depacker_hrust+0x4cd>
					{                           // we must check for insertion match!

						if( byte<0x00E0 ) // ff00..ffdf
     bd6:	3d df 00 00 00       	cmp    $0xdf,%eax
     bdb:	77 0a                	ja     be7 <depacker_hrust+0x4a9>
						{
							disp = (-256) | (byte&0x00FF);
     bdd:	89 c7                	mov    %eax,%edi
     bdf:	81 cf 00 ff ff ff    	or     $0xffffff00,%edi
     be5:	eb 52                	jmp    c39 <depacker_hrust+0x4fb>
						}
						else // insertion match - xor 3
						{
							length = (-3); // mark insertion match

							byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
     be7:	8d 14 00             	lea    (%eax,%eax,1),%edx
     bea:	c1 e8 07             	shr    $0x7,%eax
     bed:	81 e2 ff 00 00 00    	and    $0xff,%edx
     bf3:	83 e0 01             	and    $0x1,%eax
     bf6:	09 d0                	or     %edx,%eax
							byte ^= 0x03;
     bf8:	83 f0 03             	xor    $0x3,%eax
							byte -= 15;

							disp = (-256) | (byte&0x00FF);
     bfb:	8d 78 f1             	lea    -0xf(%eax),%edi
     bfe:	81 cf 00 ff ff ff    	or     $0xffffff00,%edi
     c04:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
     c09:	eb 2e                	jmp    c39 <depacker_hrust+0x4fb>
						}
					}
					else
					{
 						disp = disp + (byte&0x00FF);
     c0b:	25 ff 00 00 00       	and    $0xff,%eax
     c10:	8d 3c 38             	lea    (%eax,%edi,1),%edi
     c13:	eb 24                	jmp    c39 <depacker_hrust+0x4fb>
					}

					break;

				case DISP_ABCDE:
					bits = depack_getbits(5,DEPACK_GETBITS_NEXT);
     c15:	57                   	push   %edi
     c16:	57                   	push   %edi
     c17:	6a 02                	push   $0x2
     c19:	6a 05                	push   $0x5
     c1b:	e8 fc ff ff ff       	call   c1c <depacker_hrust+0x4de>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;
     c20:	83 c4 10             	add    $0x10,%esp
     c23:	83 f8 ff             	cmp    $0xffffffff,%eax
     c26:	0f 84 a3 fb ff ff    	je     7cf <depacker_hrust+0x91>
#endif
					disp = (-32) | (bits&31);
     c2c:	89 c7                	mov    %eax,%edi
     c2e:	83 cf e0             	or     $0xffffffe0,%edi

					break;
     c31:	eb 06                	jmp    c39 <depacker_hrust+0x4fb>
				}
			}


#ifdef DPK_CHECK
			if( success && (!docopy) && (!stop) && ((ULONG)(-disp)>wrk.maxwin) )
     c33:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     c37:	75 76                	jne    caf <depacker_hrust+0x571>
     c39:	89 f8                	mov    %edi,%eax
     c3b:	f7 d8                	neg    %eax
     c3d:	3b 05 1c 00 00 00    	cmp    0x1c,%eax
     c43:	76 12                	jbe    c57 <depacker_hrust+0x519>
			{
WRONG_DISP_HST:
 #ifdef DPK_REPERR
				printf("mhmt-depack-hrust.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
     c45:	51                   	push   %ecx
     c46:	51                   	push   %ecx
     c47:	50                   	push   %eax
     c48:	68 c0 02 00 00       	push   $0x2c0
     c4d:	e8 fc ff ff ff       	call   c4e <depacker_hrust+0x510>
     c52:	e9 2e fb ff ff       	jmp    785 <depacker_hrust+0x47>
				return 0;
			}
#endif


			if( docopy && (!stop) )
     c57:	85 f6                	test   %esi,%esi
     c59:	74 50                	je     cab <depacker_hrust+0x56d>
     c5b:	be 01 00 00 00       	mov    $0x1,%esi
     c60:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     c67:	eb 38                	jmp    ca1 <depacker_hrust+0x563>
				#ifdef DBG
					printf("copy.len=%d\n",length);
				#endif
				for(i=0;i<length;i++)
				{
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     c69:	83 ec 0c             	sub    $0xc,%esp
     c6c:	6a 01                	push   $0x1
     c6e:	e8 fc ff ff ff       	call   c6f <depacker_hrust+0x531>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     c73:	83 c4 10             	add    $0x10,%esp
     c76:	83 f8 ff             	cmp    $0xffffffff,%eax
     c79:	0f 84 6c fb ff ff    	je     7eb <depacker_hrust+0xad>
#endif


#ifdef DPK_DEPACK
					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     c7f:	85 f6                	test   %esi,%esi
     c81:	74 19                	je     c9c <depacker_hrust+0x55e>
     c83:	52                   	push   %edx
     c84:	0f b6 c0             	movzbl %al,%eax
     c87:	52                   	push   %edx
     c88:	be 01 00 00 00       	mov    $0x1,%esi
     c8d:	6a 02                	push   $0x2
     c8f:	50                   	push   %eax
     c90:	e8 fc ff ff ff       	call   c91 <depacker_hrust+0x553>
     c95:	83 c4 10             	add    $0x10,%esp
     c98:	85 c0                	test   %eax,%eax
     c9a:	75 02                	jne    c9e <depacker_hrust+0x560>
     c9c:	31 f6                	xor    %esi,%esi
			if( docopy && (!stop) )
			{
				#ifdef DBG
					printf("copy.len=%d\n",length);
				#endif
				for(i=0;i<length;i++)
     c9e:	ff 45 e4             	incl   -0x1c(%ebp)
     ca1:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
     ca4:	7c c3                	jl     c69 <depacker_hrust+0x52b>
     ca6:	e9 87 00 00 00       	jmp    d32 <depacker_hrust+0x5f4>
#ifdef DPK_DEPACK
					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
#endif
				}
			}
			else if( (!docopy) && (!stop) )// not do-copy
     cab:	85 f6                	test   %esi,%esi
     cad:	74 0a                	je     cb9 <depacker_hrust+0x57b>
     caf:	be 01 00 00 00       	mov    $0x1,%esi
     cb4:	e9 80 00 00 00       	jmp    d39 <depacker_hrust+0x5fb>
			{
				if( length!=(-3) )
     cb9:	83 fb fd             	cmp    $0xfffffffd,%ebx
     cbc:	74 1f                	je     cdd <depacker_hrust+0x59f>
					#ifdef DBG
						printf("match.len=%d,disp=%d\n",length,disp);
					#endif

#ifdef DPK_DEPACK
					if( length )
     cbe:	85 db                	test   %ebx,%ebx
     cc0:	be 01 00 00 00       	mov    $0x1,%esi
     cc5:	74 6b                	je     d32 <depacker_hrust+0x5f4>
						success = success && depack_repeat(disp,length);
     cc7:	56                   	push   %esi
     cc8:	56                   	push   %esi
     cc9:	53                   	push   %ebx
     cca:	57                   	push   %edi
     ccb:	e8 fc ff ff ff       	call   ccc <depacker_hrust+0x58e>
     cd0:	83 c4 10             	add    $0x10,%esp
     cd3:	85 c0                	test   %eax,%eax
     cd5:	0f 95 c0             	setne  %al
     cd8:	0f b6 f0             	movzbl %al,%esi
     cdb:	eb 5c                	jmp    d39 <depacker_hrust+0x5fb>
#endif
				}
				else // (-3)
				{
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     cdd:	83 ec 0c             	sub    $0xc,%esp
     ce0:	6a 01                	push   $0x1
     ce2:	e8 fc ff ff ff       	call   ce3 <depacker_hrust+0x5a5>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     ce7:	83 c4 10             	add    $0x10,%esp
     cea:	83 f8 ff             	cmp    $0xffffffff,%eax
						success = success && depack_repeat(disp,length);
#endif
				}
				else // (-3)
				{
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     ced:	89 c3                	mov    %eax,%ebx
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;
     cef:	0f 84 f6 fa ff ff    	je     7eb <depacker_hrust+0xad>
						printf("insert-match.len=%d,disp=%d\n",(-length),disp);
					#endif


#ifdef DPK_DEPACK
					success = success && depack_repeat(disp,1);
     cf5:	51                   	push   %ecx
     cf6:	51                   	push   %ecx
     cf7:	6a 01                	push   $0x1
     cf9:	57                   	push   %edi
     cfa:	e8 fc ff ff ff       	call   cfb <depacker_hrust+0x5bd>
     cff:	83 c4 10             	add    $0x10,%esp
     d02:	85 c0                	test   %eax,%eax
     d04:	74 2a                	je     d30 <depacker_hrust+0x5f2>
					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     d06:	52                   	push   %edx
     d07:	0f b6 db             	movzbl %bl,%ebx
     d0a:	52                   	push   %edx
     d0b:	6a 02                	push   $0x2
     d0d:	53                   	push   %ebx
     d0e:	e8 fc ff ff ff       	call   d0f <depacker_hrust+0x5d1>
     d13:	83 c4 10             	add    $0x10,%esp
     d16:	85 c0                	test   %eax,%eax
     d18:	74 16                	je     d30 <depacker_hrust+0x5f2>
					success = success && depack_repeat(disp,1);
     d1a:	50                   	push   %eax
     d1b:	be 01 00 00 00       	mov    $0x1,%esi
     d20:	50                   	push   %eax
     d21:	6a 01                	push   $0x1
     d23:	57                   	push   %edi
     d24:	e8 fc ff ff ff       	call   d25 <depacker_hrust+0x5e7>
     d29:	83 c4 10             	add    $0x10,%esp
     d2c:	85 c0                	test   %eax,%eax
     d2e:	75 02                	jne    d32 <depacker_hrust+0x5f4>
     d30:	31 f6                	xor    %esi,%esi
     d32:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)


	// now normal depacking loop
	//
  	stop = 0;
	while( (!stop) && success )
     d39:	89 f0                	mov    %esi,%eax
     d3b:	84 c0                	test   %al,%al
     d3d:	74 0a                	je     d49 <depacker_hrust+0x60b>
     d3f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     d43:	0f 84 d7 fa ff ff    	je     820 <depacker_hrust+0xe2>
			}
	}

	//manage zxheader again (copy to the end of output)
#ifdef DPK_DEPACK
	if( wrk.zxheader )
     d49:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     d50:	74 66                	je     db8 <depacker_hrust+0x67a>
	{
		check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     d52:	83 ec 0c             	sub    $0xc,%esp
		if( 0xFFFFFFFF == check )
		{
  #ifdef DPK_REPERR
			printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");
  #endif
			return 0;
     d55:	31 db                	xor    %ebx,%ebx

	//manage zxheader again (copy to the end of output)
#ifdef DPK_DEPACK
	if( wrk.zxheader )
	{
		check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     d57:	6a 00                	push   $0x0
     d59:	e8 fc ff ff ff       	call   d5a <depacker_hrust+0x61c>
 #ifdef DPK_CHECK
		if( 0xFFFFFFFF == check )
     d5e:	83 c4 10             	add    $0x10,%esp
     d61:	40                   	inc    %eax
     d62:	75 0d                	jne    d71 <depacker_hrust+0x633>
		{
  #ifdef DPK_REPERR
			printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");
     d64:	83 ec 0c             	sub    $0xc,%esp
     d67:	68 97 01 00 00       	push   $0x197
     d6c:	e9 0f fa ff ff       	jmp    780 <depacker_hrust+0x42>
		}
 #endif

		for(i=0;i<6;i++) // skip bytes
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     d71:	83 ec 0c             	sub    $0xc,%esp
  #endif
			return 0;
		}
 #endif

		for(i=0;i<6;i++) // skip bytes
     d74:	43                   	inc    %ebx
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     d75:	6a 01                	push   $0x1
     d77:	e8 fc ff ff ff       	call   d78 <depacker_hrust+0x63a>
  #endif
			return 0;
		}
 #endif

		for(i=0;i<6;i++) // skip bytes
     d7c:	83 c4 10             	add    $0x10,%esp
     d7f:	83 fb 06             	cmp    $0x6,%ebx
     d82:	75 ed                	jne    d71 <depacker_hrust+0x633>
     d84:	30 db                	xor    %bl,%bl
 #endif
		}
		// place 6 bytes of header to the end
		for(i=0;i<6;i++)
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     d86:	83 ec 0c             	sub    $0xc,%esp
     d89:	6a 01                	push   $0x1
     d8b:	e8 fc ff ff ff       	call   d8c <depacker_hrust+0x64e>
 #ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
 #endif
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
     d90:	83 c4 10             	add    $0x10,%esp
     d93:	85 f6                	test   %esi,%esi
     d95:	74 19                	je     db0 <depacker_hrust+0x672>
     d97:	56                   	push   %esi
     d98:	0f b6 c0             	movzbl %al,%eax
     d9b:	56                   	push   %esi
     d9c:	be 01 00 00 00       	mov    $0x1,%esi
     da1:	6a 02                	push   $0x2
     da3:	50                   	push   %eax
     da4:	e8 fc ff ff ff       	call   da5 <depacker_hrust+0x667>
     da9:	83 c4 10             	add    $0x10,%esp
     dac:	85 c0                	test   %eax,%eax
     dae:	75 02                	jne    db2 <depacker_hrust+0x674>
     db0:	31 f6                	xor    %esi,%esi
 #ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
 #endif
		}
		// place 6 bytes of header to the end
		for(i=0;i<6;i++)
     db2:	43                   	inc    %ebx
     db3:	83 fb 06             	cmp    $0x6,%ebx
     db6:	75 ce                	jne    d86 <depacker_hrust+0x648>
		}
	}
#endif

	return success;
}
     db8:	8d 65 f4             	lea    -0xc(%ebp),%esp
     dbb:	89 f0                	mov    %esi,%eax
     dbd:	5b                   	pop    %ebx
     dbe:	5e                   	pop    %esi
     dbf:	5f                   	pop    %edi
     dc0:	5d                   	pop    %ebp
     dc1:	c3                   	ret    

00000dc2 <checker_hrum>:
//
//                   // example defines:
//#define DPK_CHECK  // check input stream for consistency
//#define DPK_DEPACK // do depacking
//#define DPK_REPERR // report errors via printf
{
     dc2:	55                   	push   %ebp
     dc3:	89 e5                	mov    %esp,%ebp
     dc5:	53                   	push   %ebx
     dc6:	83 ec 10             	sub    $0x10,%esp
	ULONG success = 1;


	// rewind input stream
	//
	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
     dc9:	6a 00                	push   $0x0
     dcb:	e8 fc ff ff ff       	call   dcc <checker_hrum+0xa>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
     dd0:	83 c4 10             	add    $0x10,%esp
     dd3:	40                   	inc    %eax
     dd4:	75 0a                	jne    de0 <checker_hrum+0x1e>
	{
 #ifdef DPK_REPERR
		printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
     dd6:	83 ec 0c             	sub    $0xc,%esp
     dd9:	68 11 03 00 00       	push   $0x311
     dde:	eb 57                	jmp    e37 <checker_hrum+0x75>
	}
#endif


	// manage zx header if needed
	if( wrk.zxheader )
     de0:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
     de7:	74 5d                	je     e46 <checker_hrum+0x84>
     de9:	31 db                	xor    %ebx,%ebx
	{
		// skip 5 bytes (they will go to the end of output file)
		for(i=0;i<5;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     deb:	83 ec 0c             	sub    $0xc,%esp
     dee:	6a 01                	push   $0x1
     df0:	e8 fc ff ff ff       	call   df1 <checker_hrum+0x2f>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
     df5:	83 c4 10             	add    $0x10,%esp
     df8:	40                   	inc    %eax
     df9:	74 76                	je     e71 <checker_hrum+0xaf>

	// manage zx header if needed
	if( wrk.zxheader )
	{
		// skip 5 bytes (they will go to the end of output file)
		for(i=0;i<5;i++)
     dfb:	43                   	inc    %ebx
     dfc:	83 fb 05             	cmp    $0x5,%ebx
     dff:	75 ea                	jne    deb <checker_hrum+0x29>
		}

		// next 2 bytes must be 0x10
		for(i=0;i<2;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     e01:	83 ec 0c             	sub    $0xc,%esp
     e04:	6a 01                	push   $0x1
     e06:	e8 fc ff ff ff       	call   e07 <checker_hrum+0x45>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
     e0b:	83 c4 10             	add    $0x10,%esp
     e0e:	83 f8 ff             	cmp    $0xffffffff,%eax
     e11:	74 5e                	je     e71 <checker_hrum+0xaf>
			if( check != 0x0010 )
     e13:	83 f8 10             	cmp    $0x10,%eax
     e16:	75 17                	jne    e2f <checker_hrum+0x6d>
		}

		// next 2 bytes must be 0x10
		for(i=0;i<2;i++)
		{
			check = depack_getbyte(DEPACK_GETBYTE_NEXT);
     e18:	83 ec 0c             	sub    $0xc,%esp
     e1b:	6a 01                	push   $0x1
     e1d:	e8 fc ff ff ff       	call   e1e <checker_hrum+0x5c>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
     e22:	83 c4 10             	add    $0x10,%esp
     e25:	83 f8 ff             	cmp    $0xffffffff,%eax
     e28:	74 47                	je     e71 <checker_hrum+0xaf>
			if( check != 0x0010 )
     e2a:	83 f8 10             	cmp    $0x10,%eax
     e2d:	74 17                	je     e46 <checker_hrum+0x84>
			{
 #ifdef DPK_REPERR
				printf("mhmt-depack-hrum.c:{} - Wrong ZX-header!\n");
     e2f:	83 ec 0c             	sub    $0xc,%esp
     e32:	68 44 03 00 00       	push   $0x344
     e37:	e8 fc ff ff ff       	call   e38 <checker_hrum+0x76>
     e3c:	31 c0                	xor    %eax,%eax
 #endif
				return 0;
     e3e:	83 c4 10             	add    $0x10,%esp
     e41:	e9 e0 01 00 00       	jmp    1026 <checker_hrum+0x264>



	// initialize bitstream first
	//
	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...
     e46:	51                   	push   %ecx
     e47:	51                   	push   %ecx
     e48:	6a 01                	push   $0x1
     e4a:	6a 10                	push   $0x10
     e4c:	e8 fc ff ff ff       	call   e4d <checker_hrum+0x8b>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
     e51:	83 c4 10             	add    $0x10,%esp
     e54:	40                   	inc    %eax
     e55:	75 0a                	jne    e61 <checker_hrum+0x9f>
	{
NO_BITS_HRM:
 #ifdef DPK_REPERR
		printf("mhmt-depack-hrum.c:{} - Can't get bits from input stream!\n");
     e57:	83 ec 0c             	sub    $0xc,%esp
     e5a:	68 6d 03 00 00       	push   $0x36d
     e5f:	eb d6                	jmp    e37 <checker_hrum+0x75>



	// then byte of input stream goes to the output unchanged
	//
	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     e61:	83 ec 0c             	sub    $0xc,%esp
     e64:	6a 01                	push   $0x1
     e66:	e8 fc ff ff ff       	call   e67 <checker_hrum+0xa5>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == byte )
     e6b:	83 c4 10             	add    $0x10,%esp
     e6e:	40                   	inc    %eax
     e6f:	75 0a                	jne    e7b <checker_hrum+0xb9>
	{
NO_BYTE_HRM:
 #ifdef DPK_REPERR
		printf("mhmt-depack-hrum.c:{} - Can't get byte from input stream!\n");
     e71:	83 ec 0c             	sub    $0xc,%esp
     e74:	68 a7 03 00 00       	push   $0x3a7
     e79:	eb bc                	jmp    e37 <checker_hrum+0x75>
	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
 	{
		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     e7b:	52                   	push   %edx
     e7c:	52                   	push   %edx
     e7d:	6a 02                	push   $0x2
     e7f:	6a 01                	push   $0x1
     e81:	e8 fc ff ff ff       	call   e82 <checker_hrum+0xc0>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     e86:	83 c4 10             	add    $0x10,%esp
     e89:	83 f8 ff             	cmp    $0xffffffff,%eax
     e8c:	74 c9                	je     e57 <checker_hrum+0x95>
#endif

		if( 1&bits ) // %1<byte>
     e8e:	a8 01                	test   $0x1,%al
     e90:	75 cf                	jne    e61 <checker_hrum+0x9f>
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
#endif
		}
		else // %0xx
		{
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     e92:	50                   	push   %eax
     e93:	50                   	push   %eax
     e94:	6a 02                	push   $0x2
     e96:	6a 02                	push   $0x2
     e98:	e8 fc ff ff ff       	call   e99 <checker_hrum+0xd7>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     e9d:	83 c4 10             	add    $0x10,%esp
     ea0:	83 f8 ff             	cmp    $0xffffffff,%eax
     ea3:	74 b2                	je     e57 <checker_hrum+0x95>
#endif

			switch( 0x03 & bits )
     ea5:	83 e0 03             	and    $0x3,%eax
     ea8:	74 0a                	je     eb4 <checker_hrum+0xf2>
     eaa:	83 f8 01             	cmp    $0x1,%eax
     ead:	75 3d                	jne    eec <checker_hrum+0x12a>
     eaf:	e9 00 01 00 00       	jmp    fb4 <checker_hrum+0x1f2>
			{
			case 0x00: // %000xxx

				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);
     eb4:	53                   	push   %ebx
     eb5:	53                   	push   %ebx
     eb6:	6a 02                	push   $0x2
     eb8:	6a 03                	push   $0x3
     eba:	e8 fc ff ff ff       	call   ebb <checker_hrum+0xf9>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     ebf:	83 c4 10             	add    $0x10,%esp
     ec2:	83 f8 ff             	cmp    $0xffffffff,%eax
     ec5:	74 90                	je     e57 <checker_hrum+0x95>
#endif

				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)
     ec7:	89 c3                	mov    %eax,%ebx
     ec9:	83 cb f8             	or     $0xfffffff8,%ebx
#ifdef DPK_CHECK
				if( (ULONG)(-disp) > wrk.maxwin )
     ecc:	89 d8                	mov    %ebx,%eax
     ece:	f7 d8                	neg    %eax
     ed0:	3b 05 1c 00 00 00    	cmp    0x1c,%eax
     ed6:	76 a3                	jbe    e7b <checker_hrum+0xb9>
				{
WRONG_DISP_HRM:
 #ifdef DPK_REPERR
					printf("mhmt-depack-hrum.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
     ed8:	51                   	push   %ecx
     ed9:	f7 db                	neg    %ebx
     edb:	51                   	push   %ecx
     edc:	53                   	push   %ebx
     edd:	68 e1 03 00 00       	push   $0x3e1
     ee2:	e8 fc ff ff ff       	call   ee3 <checker_hrum+0x121>
     ee7:	e9 50 ff ff ff       	jmp    e3c <checker_hrum+0x7a>
#endif
				break;

			default: // %010 or %011

				if( (bits&3)==2 ) // %010 - 3 bytes
     eec:	83 f8 02             	cmp    $0x2,%eax
     eef:	0f 84 a4 00 00 00    	je     f99 <checker_hrum+0x1d7>
				{
					length = 3;
				}
				else // %011 - varlen
				{
					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     ef5:	52                   	push   %edx
     ef6:	52                   	push   %edx
     ef7:	6a 02                	push   $0x2
     ef9:	6a 02                	push   $0x2
     efb:	e8 fc ff ff ff       	call   efc <checker_hrum+0x13a>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     f00:	83 c4 10             	add    $0x10,%esp
     f03:	83 f8 ff             	cmp    $0xffffffff,%eax
     f06:	0f 84 4b ff ff ff    	je     e57 <checker_hrum+0x95>
#endif
					//  fetch len
					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop
     f0c:	85 c0                	test   %eax,%eax
     f0e:	75 20                	jne    f30 <checker_hrum+0x16e>
					{
						length = depack_getbyte(DEPACK_GETBYTE_NEXT);
     f10:	83 ec 0c             	sub    $0xc,%esp
     f13:	6a 01                	push   $0x1
     f15:	e8 fc ff ff ff       	call   f16 <checker_hrum+0x154>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;
     f1a:	83 c4 10             	add    $0x10,%esp
     f1d:	83 f8 ff             	cmp    $0xffffffff,%eax
     f20:	0f 84 4b ff ff ff    	je     e71 <checker_hrum+0xaf>
#endif
						if( length == 0 )
     f26:	85 c0                	test   %eax,%eax
     f28:	0f 84 f3 00 00 00    	je     1021 <checker_hrum+0x25f>
     f2e:	eb 69                	jmp    f99 <checker_hrum+0x1d7>
							stop = 1;
					}
					else if( bits == 0x01 ) // %01101 - len=4
     f30:	83 f8 01             	cmp    $0x1,%eax
     f33:	74 64                	je     f99 <checker_hrum+0x1d7>
					{
						length = 4;
					}
					else if( bits == 0x02 ) // %01110 - len=5
     f35:	83 f8 02             	cmp    $0x2,%eax
     f38:	74 5f                	je     f99 <checker_hrum+0x1d7>
					{
						length = 5;
					}
					else // %01111
					{
						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     f3a:	50                   	push   %eax
     f3b:	50                   	push   %eax
     f3c:	6a 02                	push   $0x2
     f3e:	6a 02                	push   $0x2
     f40:	e8 fc ff ff ff       	call   f41 <checker_hrum+0x17f>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     f45:	83 c4 10             	add    $0x10,%esp
     f48:	83 f8 ff             	cmp    $0xffffffff,%eax
     f4b:	0f 84 06 ff ff ff    	je     e57 <checker_hrum+0x95>
#endif
						if( bits == 0x00 ) // %0111100
     f51:	85 c0                	test   %eax,%eax
     f53:	74 44                	je     f99 <checker_hrum+0x1d7>
						{
							length = 6;
						}
						else if( bits == 0x01 ) // %0111101
     f55:	83 f8 01             	cmp    $0x1,%eax
     f58:	74 3f                	je     f99 <checker_hrum+0x1d7>
						{
							length = 7;
						}
						else if( bits == 0x02 ) // %0111110
     f5a:	83 f8 02             	cmp    $0x2,%eax
     f5d:	74 3a                	je     f99 <checker_hrum+0x1d7>
						{
							length = 8;
						}
						else // %0111111
						{
							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     f5f:	53                   	push   %ebx
     f60:	53                   	push   %ebx
     f61:	6a 02                	push   $0x2
     f63:	6a 02                	push   $0x2
     f65:	e8 fc ff ff ff       	call   f66 <checker_hrum+0x1a4>
#ifdef DPK_CHECK
							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     f6a:	83 c4 10             	add    $0x10,%esp
     f6d:	83 f8 ff             	cmp    $0xffffffff,%eax
     f70:	0f 84 e1 fe ff ff    	je     e57 <checker_hrum+0x95>
#endif
							if( bits == 0x00 ) // %011111100
     f76:	85 c0                	test   %eax,%eax
     f78:	74 1f                	je     f99 <checker_hrum+0x1d7>
							{
								length = 9;
							}
							else if( bits == 0x01 ) // %011111101
     f7a:	83 f8 01             	cmp    $0x1,%eax
     f7d:	74 1a                	je     f99 <checker_hrum+0x1d7>
							{
								length = 10;
							}
							else if( bits == 0x02 ) // %011111110
     f7f:	83 f8 02             	cmp    $0x2,%eax
     f82:	74 15                	je     f99 <checker_hrum+0x1d7>
							{
								length = 11;
							}
							else // %011111111
							{
								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
     f84:	51                   	push   %ecx
     f85:	51                   	push   %ecx
     f86:	6a 02                	push   $0x2
     f88:	6a 02                	push   $0x2
     f8a:	e8 fc ff ff ff       	call   f8b <checker_hrum+0x1c9>
#ifdef DPK_CHECK
								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     f8f:	83 c4 10             	add    $0x10,%esp
     f92:	40                   	inc    %eax
     f93:	0f 84 be fe ff ff    	je     e57 <checker_hrum+0x95>


				// fetch disp and depack
				if( !stop )
				{
					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
     f99:	52                   	push   %edx
     f9a:	52                   	push   %edx
     f9b:	6a 02                	push   $0x2
     f9d:	6a 01                	push   $0x1
     f9f:	e8 fc ff ff ff       	call   fa0 <checker_hrum+0x1de>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     fa4:	83 c4 10             	add    $0x10,%esp
     fa7:	83 f8 ff             	cmp    $0xffffffff,%eax
     faa:	0f 84 a7 fe ff ff    	je     e57 <checker_hrum+0x95>
#endif
					if( bits == 0x00 ) // %0<disp>
     fb0:	85 c0                	test   %eax,%eax
     fb2:	75 23                	jne    fd7 <checker_hrum+0x215>
					{
						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     fb4:	83 ec 0c             	sub    $0xc,%esp
     fb7:	6a 01                	push   $0x1
     fb9:	e8 fc ff ff ff       	call   fba <checker_hrum+0x1f8>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
     fbe:	83 c4 10             	add    $0x10,%esp
     fc1:	83 f8 ff             	cmp    $0xffffffff,%eax
     fc4:	0f 84 a7 fe ff ff    	je     e71 <checker_hrum+0xaf>
#endif
						disp = (-256) | (0x00FF&byte); // -1..-256
     fca:	89 c3                	mov    %eax,%ebx
     fcc:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
     fd2:	e9 f5 fe ff ff       	jmp    ecc <checker_hrum+0x10a>
						success = success && depack_repeat(disp,length);
#endif
					}
					else // %1abcd<disp>
					{
						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     fd7:	50                   	push   %eax
     fd8:	50                   	push   %eax
     fd9:	6a 02                	push   $0x2
     fdb:	6a 04                	push   $0x4
     fdd:	e8 fc ff ff ff       	call   fde <checker_hrum+0x21c>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     fe2:	83 c4 10             	add    $0x10,%esp
     fe5:	83 f8 ff             	cmp    $0xffffffff,%eax
						success = success && depack_repeat(disp,length);
#endif
					}
					else // %1abcd<disp>
					{
						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
     fe8:	89 c3                	mov    %eax,%ebx
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
     fea:	0f 84 67 fe ff ff    	je     e57 <checker_hrum+0x95>
#endif
						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
     ff0:	83 ec 0c             	sub    $0xc,%esp
     ff3:	6a 01                	push   $0x1
     ff5:	e8 fc ff ff ff       	call   ff6 <checker_hrum+0x234>
#ifdef DPK_CHECK
						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
     ffa:	83 c4 10             	add    $0x10,%esp
     ffd:	83 f8 ff             	cmp    $0xffffffff,%eax
    1000:	0f 84 6b fe ff ff    	je     e71 <checker_hrum+0xaf>
#endif
						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096
    1006:	c1 e3 08             	shl    $0x8,%ebx
    1009:	25 ff 00 00 00       	and    $0xff,%eax
    100e:	81 e3 00 0f 00 00    	and    $0xf00,%ebx
    1014:	81 cb 00 f0 ff ff    	or     $0xfffff000,%ebx
    101a:	09 c3                	or     %eax,%ebx
    101c:	e9 ab fe ff ff       	jmp    ecc <checker_hrum+0x10a>
#ifdef DPK_CHECK
						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
    1021:	b8 01 00 00 00       	mov    $0x1,%eax
		}
	}
#endif

	return success;
}
    1026:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1029:	c9                   	leave  
    102a:	c3                   	ret    

0000102b <checker_megalz>:
//
//                   // example defines:
//#define DPK_CHECK  // check input stream for consistency
//#define DPK_DEPACK // do depacking
//#define DPK_REPERR // report errors via printf
{
    102b:	55                   	push   %ebp
    102c:	89 e5                	mov    %esp,%ebp
    102e:	56                   	push   %esi
    102f:	53                   	push   %ebx
	ULONG success = 1;


	// rewind input stream
	//
	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
    1030:	83 ec 0c             	sub    $0xc,%esp
    1033:	6a 00                	push   $0x0
    1035:	e8 fc ff ff ff       	call   1036 <checker_megalz+0xb>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
    103a:	83 c4 10             	add    $0x10,%esp
    103d:	40                   	inc    %eax
    103e:	75 0a                	jne    104a <checker_megalz+0x1f>
	{
 #ifdef DPK_REPERR
		printf("mhmt-depack-megalz.c:{} - Can't rewind input stream!\n");
    1040:	83 ec 0c             	sub    $0xc,%esp
    1043:	68 31 04 00 00       	push   $0x431
    1048:	eb 18                	jmp    1062 <checker_megalz+0x37>
#endif


	// first byte of input stream goes to the output unchanged
	//
	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
    104a:	83 ec 0c             	sub    $0xc,%esp
    104d:	6a 01                	push   $0x1
    104f:	e8 fc ff ff ff       	call   1050 <checker_megalz+0x25>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == byte )
    1054:	83 c4 10             	add    $0x10,%esp
    1057:	40                   	inc    %eax
    1058:	75 17                	jne    1071 <checker_megalz+0x46>
	{
NO_BYTE:
 #ifdef DPK_REPERR
		printf("mhmt-depack-megalz.c:{} - Can't get byte from input stream!\n");
    105a:	83 ec 0c             	sub    $0xc,%esp
    105d:	68 66 04 00 00       	push   $0x466
    1062:	e8 fc ff ff ff       	call   1063 <checker_megalz+0x38>
    1067:	31 c0                	xor    %eax,%eax
 #endif
		return 0;
    1069:	83 c4 10             	add    $0x10,%esp
    106c:	e9 8b 01 00 00       	jmp    11fc <checker_megalz+0x1d1>
 #ifdef DPK_REPERR
 #endif
#endif
	// next is byte to the bitstream
	//
	check = depack_getbits(8,DEPACK_GETBITS_FORCE);
    1071:	52                   	push   %edx
#endif
				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
#endif
				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );
    1072:	bb 01 00 00 00       	mov    $0x1,%ebx
 #ifdef DPK_REPERR
 #endif
#endif
	// next is byte to the bitstream
	//
	check = depack_getbits(8,DEPACK_GETBITS_FORCE);
    1077:	52                   	push   %edx
    1078:	6a 01                	push   $0x1
    107a:	6a 08                	push   $0x8
    107c:	e8 fc ff ff ff       	call   107d <checker_megalz+0x52>
#ifdef DPK_CHECK
	if( 0xFFFFFFFF == check )
    1081:	83 c4 10             	add    $0x10,%esp
    1084:	40                   	inc    %eax
    1085:	75 0a                	jne    1091 <checker_megalz+0x66>
	{
NO_BITS:
 #ifdef DPK_REPERR
		printf("mhmt-depack-megalz.c:{} - Can't get bits from input stream!\n");
    1087:	83 ec 0c             	sub    $0xc,%esp
    108a:	68 a2 04 00 00       	push   $0x4a2
    108f:	eb d1                	jmp    1062 <checker_megalz+0x37>
	// now normal depacking loop
	//
	stop = 0;
	while( (!stop) && success )
 	{
		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
    1091:	50                   	push   %eax
    1092:	50                   	push   %eax
    1093:	6a 02                	push   $0x2
    1095:	6a 01                	push   $0x1
    1097:	e8 fc ff ff ff       	call   1098 <checker_megalz+0x6d>
#ifdef DPK_CHECK
		if( 0xFFFFFFFF == bits ) goto NO_BITS;
    109c:	83 c4 10             	add    $0x10,%esp
    109f:	83 f8 ff             	cmp    $0xffffffff,%eax
    10a2:	74 e3                	je     1087 <checker_megalz+0x5c>
#endif

		if( 1&bits ) // %1<byte>
    10a4:	a8 01                	test   $0x1,%al
    10a6:	74 12                	je     10ba <checker_megalz+0x8f>
		{
			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
    10a8:	83 ec 0c             	sub    $0xc,%esp
    10ab:	6a 01                	push   $0x1
    10ad:	e8 fc ff ff ff       	call   10ae <checker_megalz+0x83>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == byte ) goto NO_BYTE;
    10b2:	83 c4 10             	add    $0x10,%esp
    10b5:	40                   	inc    %eax
    10b6:	75 d9                	jne    1091 <checker_megalz+0x66>
    10b8:	eb a0                	jmp    105a <checker_megalz+0x2f>
			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
#endif
		}
		else // %0xx
		{
			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);
    10ba:	56                   	push   %esi
    10bb:	56                   	push   %esi
    10bc:	6a 02                	push   $0x2
    10be:	6a 02                	push   $0x2
    10c0:	e8 fc ff ff ff       	call   10c1 <checker_megalz+0x96>
#ifdef DPK_CHECK
			if( 0xFFFFFFFF == bits ) goto NO_BITS;
    10c5:	83 c4 10             	add    $0x10,%esp
    10c8:	83 f8 ff             	cmp    $0xffffffff,%eax
    10cb:	74 ba                	je     1087 <checker_megalz+0x5c>
#endif

			switch( 0x03 & bits )
    10cd:	83 e0 03             	and    $0x3,%eax
    10d0:	83 f8 02             	cmp    $0x2,%eax
    10d3:	74 42                	je     1117 <checker_megalz+0xec>
    10d5:	83 f8 03             	cmp    $0x3,%eax
    10d8:	0f 84 b2 00 00 00    	je     1190 <checker_megalz+0x165>
    10de:	48                   	dec    %eax
    10df:	74 51                	je     1132 <checker_megalz+0x107>
			{
			case 0x00: // %000xxx

				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);
    10e1:	51                   	push   %ecx
    10e2:	51                   	push   %ecx
    10e3:	6a 02                	push   $0x2
    10e5:	6a 03                	push   $0x3
    10e7:	e8 fc ff ff ff       	call   10e8 <checker_megalz+0xbd>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
    10ec:	83 c4 10             	add    $0x10,%esp
    10ef:	83 f8 ff             	cmp    $0xffffffff,%eax
    10f2:	74 93                	je     1087 <checker_megalz+0x5c>
#endif

				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)
    10f4:	83 c8 f8             	or     $0xfffffff8,%eax
#ifdef DPK_CHECK
				if( (ULONG)(-disp) > wrk.maxwin )
    10f7:	89 c2                	mov    %eax,%edx
    10f9:	f7 da                	neg    %edx
    10fb:	3b 15 1c 00 00 00    	cmp    0x1c,%edx
    1101:	76 8e                	jbe    1091 <checker_megalz+0x66>
				{
WRONG_DISP:
 #ifdef DPK_REPERR
					printf("mhmt-depack-megalz.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
    1103:	52                   	push   %edx
    1104:	f7 d8                	neg    %eax
    1106:	52                   	push   %edx
    1107:	50                   	push   %eax
    1108:	68 de 04 00 00       	push   $0x4de
    110d:	e8 fc ff ff ff       	call   110e <checker_megalz+0xe3>
    1112:	e9 50 ff ff ff       	jmp    1067 <checker_megalz+0x3c>

			case 0x02: // %010

				length = 3;
FAR_DISP:
				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
    1117:	56                   	push   %esi
    1118:	56                   	push   %esi
    1119:	6a 02                	push   $0x2
    111b:	6a 01                	push   $0x1
    111d:	e8 fc ff ff ff       	call   111e <checker_megalz+0xf3>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
    1122:	83 c4 10             	add    $0x10,%esp
    1125:	83 f8 ff             	cmp    $0xffffffff,%eax
    1128:	0f 84 59 ff ff ff    	je     1087 <checker_megalz+0x5c>
#endif
				if( !(1&bits) ) // -1..-256
    112e:	a8 01                	test   $0x1,%al
    1130:	75 1d                	jne    114f <checker_megalz+0x124>
				{
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
    1132:	83 ec 0c             	sub    $0xc,%esp
    1135:	6a 01                	push   $0x1
    1137:	e8 fc ff ff ff       	call   1138 <checker_megalz+0x10d>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
    113c:	83 c4 10             	add    $0x10,%esp
    113f:	83 f8 ff             	cmp    $0xffffffff,%eax
    1142:	0f 84 12 ff ff ff    	je     105a <checker_megalz+0x2f>
#endif
					disp = (-256) | (0x00FF&byte); // -1..-256
    1148:	0d 00 ff ff ff       	or     $0xffffff00,%eax
    114d:	eb a8                	jmp    10f7 <checker_megalz+0xcc>
					success = success && depack_repeat(disp,length);
#endif
				}
				else // -257..-4352
				{
					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
    114f:	51                   	push   %ecx
    1150:	51                   	push   %ecx
    1151:	6a 02                	push   $0x2
    1153:	6a 04                	push   $0x4
    1155:	e8 fc ff ff ff       	call   1156 <checker_megalz+0x12b>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
    115a:	83 c4 10             	add    $0x10,%esp
    115d:	83 f8 ff             	cmp    $0xffffffff,%eax
					success = success && depack_repeat(disp,length);
#endif
				}
				else // -257..-4352
				{
					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);
    1160:	89 c6                	mov    %eax,%esi
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
    1162:	0f 84 1f ff ff ff    	je     1087 <checker_megalz+0x5c>
#endif
					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
    1168:	83 ec 0c             	sub    $0xc,%esp
    116b:	6a 01                	push   $0x1
    116d:	e8 fc ff ff ff       	call   116e <checker_megalz+0x143>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
    1172:	83 c4 10             	add    $0x10,%esp
    1175:	83 f8 ff             	cmp    $0xffffffff,%eax
    1178:	0f 84 dc fe ff ff    	je     105a <checker_megalz+0x2f>
#endif
					disp = ( ((-16)|(15&bits)) - 1 )*0x100 + byte;
    117e:	83 ce f0             	or     $0xfffffff0,%esi
    1181:	c1 e6 08             	shl    $0x8,%esi
    1184:	8d 84 30 00 ff ff ff 	lea    -0x100(%eax,%esi,1),%eax
    118b:	e9 67 ff ff ff       	jmp    10f7 <checker_megalz+0xcc>
#ifdef DPK_CHECK
					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
    1190:	31 f6                	xor    %esi,%esi
			case 0x03: // %011 - variable length

				bitlen = 0;
				do
				{
					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
    1192:	52                   	push   %edx
    1193:	52                   	push   %edx
    1194:	6a 02                	push   $0x2
    1196:	6a 01                	push   $0x1
    1198:	e8 fc ff ff ff       	call   1199 <checker_megalz+0x16e>
#ifdef DPK_CHECK
					if( 0xFFFFFFFF == bits ) goto NO_BITS;
    119d:	83 c4 10             	add    $0x10,%esp
    11a0:	83 f8 ff             	cmp    $0xffffffff,%eax
    11a3:	0f 84 de fe ff ff    	je     1087 <checker_megalz+0x5c>
#endif
					bitlen++;
    11a9:	46                   	inc    %esi

				} while ( !(1&bits) );
    11aa:	a8 01                	test   $0x1,%al
    11ac:	74 e4                	je     1192 <checker_megalz+0x167>

				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!
    11ae:	83 fe 09             	cmp    $0x9,%esi
    11b1:	74 44                	je     11f7 <checker_megalz+0x1cc>
				{
					stop = 1;
					break; // exit switch(){}
				}
#ifdef DPK_CHECK
				if( bitlen>7 )
    11b3:	83 fe 07             	cmp    $0x7,%esi
    11b6:	77 32                	ja     11ea <checker_megalz+0x1bf>
					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
 #endif
					return 0;
				}
#endif
				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);
    11b8:	50                   	push   %eax
    11b9:	50                   	push   %eax
    11ba:	6a 02                	push   $0x2
    11bc:	56                   	push   %esi
    11bd:	e8 fc ff ff ff       	call   11be <checker_megalz+0x193>
#ifdef DPK_CHECK
				if( 0xFFFFFFFF == bits ) goto NO_BITS;
    11c2:	83 c4 10             	add    $0x10,%esp
    11c5:	83 f8 ff             	cmp    $0xffffffff,%eax
    11c8:	0f 84 b9 fe ff ff    	je     1087 <checker_megalz+0x5c>
#endif
				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );
    11ce:	89 f1                	mov    %esi,%ecx
    11d0:	89 da                	mov    %ebx,%edx
    11d2:	d3 e2                	shl    %cl,%edx
    11d4:	89 d6                	mov    %edx,%esi
#ifdef DPK_CHECK
				if( length>255 )
    11d6:	8d 52 ff             	lea    -0x1(%edx),%edx
    11d9:	21 c2                	and    %eax,%edx
    11db:	8d 44 16 02          	lea    0x2(%esi,%edx,1),%eax
    11df:	3d ff 00 00 00       	cmp    $0xff,%eax
    11e4:	0f 86 2d ff ff ff    	jbe    1117 <checker_megalz+0xec>
				{
 #ifdef DPK_REPERR
					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
    11ea:	83 ec 0c             	sub    $0xc,%esp
    11ed:	68 30 05 00 00       	push   $0x530
    11f2:	e9 6b fe ff ff       	jmp    1062 <checker_megalz+0x37>
 #endif
					return 0;
    11f7:	b8 01 00 00 00       	mov    $0x1,%eax
		}

	}

	return success;
}
    11fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
    11ff:	5b                   	pop    %ebx
    1200:	5e                   	pop    %esi
    1201:	5d                   	pop    %ebp
    1202:	c3                   	ret    

00001203 <depack>:
ULONG buf_ptr=0;
UBYTE * buffer=NULL;


ULONG depack(void)
{
    1203:	55                   	push   %ebp
    1204:	89 e5                	mov    %esp,%ebp
    1206:	53                   	push   %ebx
    1207:	83 ec 04             	sub    $0x4,%esp
	ULONG success=1;


	// some preparations
	//
	if( wrk.packtype==PK_MLZ )
    120a:	a1 00 00 00 00       	mov    0x0,%eax
    120f:	83 f8 01             	cmp    $0x1,%eax
    1212:	74 1e                	je     1232 <depack+0x2f>
	{
		checker  = &checker_megalz;
		depacker = &depacker_megalz;
	}
	else if( wrk.packtype==PK_HRM )
    1214:	83 f8 02             	cmp    $0x2,%eax
    1217:	bb 00 00 00 00       	mov    $0x0,%ebx
    121c:	74 19                	je     1237 <depack+0x34>
	{
		checker  = &checker_hrum;
		depacker = &depacker_hrum;
	}
	else if( wrk.packtype==PK_HST )
    121e:	83 f8 03             	cmp    $0x3,%eax
    1221:	bb 00 00 00 00       	mov    $0x0,%ebx
    1226:	74 0f                	je     1237 <depack+0x34>
//		checker  = &checker_hrust;
		depacker = &depacker_hrust;
	}
	else
	{
		printf("mhmt-depack.c:depack() - format unsupported!\n");
    1228:	83 ec 0c             	sub    $0xc,%esp
    122b:	68 58 05 00 00       	push   $0x558
    1230:	eb 37                	jmp    1269 <depack+0x66>
		return 0;
    1232:	bb 00 00 00 00       	mov    $0x0,%ebx



	// allocate buffer used for depacking
	//
	buf_size = ( wrk.maxwin==4352 ) ? 8192 : wrk.maxwin; // provided there are no other non-2^n sizes
    1237:	a1 1c 00 00 00       	mov    0x1c,%eax
    123c:	3d 00 11 00 00       	cmp    $0x1100,%eax
    1241:	75 04                	jne    1247 <depack+0x44>
    1243:	66 b8 00 20          	mov    $0x2000,%ax

	buffer=(UBYTE*)malloc(buf_size);
    1247:	83 ec 0c             	sub    $0xc,%esp
    124a:	50                   	push   %eax



	// allocate buffer used for depacking
	//
	buf_size = ( wrk.maxwin==4352 ) ? 8192 : wrk.maxwin; // provided there are no other non-2^n sizes
    124b:	a3 00 00 00 00       	mov    %eax,0x0

	buffer=(UBYTE*)malloc(buf_size);
    1250:	e8 fc ff ff ff       	call   1251 <depack+0x4e>
	if( !buffer )
    1255:	83 c4 10             	add    $0x10,%esp
    1258:	85 c0                	test   %eax,%eax

	// allocate buffer used for depacking
	//
	buf_size = ( wrk.maxwin==4352 ) ? 8192 : wrk.maxwin; // provided there are no other non-2^n sizes

	buffer=(UBYTE*)malloc(buf_size);
    125a:	a3 00 00 00 00       	mov    %eax,0x0
	if( !buffer )
    125f:	75 11                	jne    1272 <depack+0x6f>
	{
		printf("mhmt-depack.c:depack() cannot allocate memory for depack buffer!\n");
    1261:	83 ec 0c             	sub    $0xc,%esp
    1264:	68 85 05 00 00       	push   $0x585
    1269:	e8 fc ff ff ff       	call   126a <depack+0x67>
    126e:	31 db                	xor    %ebx,%ebx
    1270:	eb 54                	jmp    12c6 <depack+0xc3>
	}

	buf_ptr=0;


	success = success && emit_file(NULL,EMIT_FILE_INIT);
    1272:	51                   	push   %ecx
    1273:	51                   	push   %ecx
    1274:	6a ff                	push   $0xffffffff
    1276:	6a 00                	push   $0x0
	{
		printf("mhmt-depack.c:depack() cannot allocate memory for depack buffer!\n");
		return 0;
	}

	buf_ptr=0;
    1278:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
    127f:	00 00 00 


	success = success && emit_file(NULL,EMIT_FILE_INIT);
    1282:	e8 fc ff ff ff       	call   1283 <depack+0x80>
    1287:	83 c4 10             	add    $0x10,%esp
    128a:	85 c0                	test   %eax,%eax
    128c:	74 0b                	je     1299 <depack+0x96>
//	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
//#endif



	success = success && (*depacker)();
    128e:	ff d3                	call   *%ebx
    1290:	bb 01 00 00 00       	mov    $0x1,%ebx
    1295:	85 c0                	test   %eax,%eax
    1297:	75 02                	jne    129b <depack+0x98>
    1299:	31 db                	xor    %ebx,%ebx

	/*success = success && */depack_outbyte( 0, DEPACK_OUTBYTE_FLUSH );
    129b:	52                   	push   %edx
    129c:	52                   	push   %edx
    129d:	6a 01                	push   $0x1
    129f:	6a 00                	push   $0x0
    12a1:	e8 fc ff ff ff       	call   12a2 <depack+0x9f>

	/*success = success && */emit_file(NULL,EMIT_FILE_FINISH);
    12a6:	59                   	pop    %ecx
    12a7:	58                   	pop    %eax
    12a8:	6a 00                	push   $0x0
    12aa:	6a 00                	push   $0x0
    12ac:	e8 fc ff ff ff       	call   12ad <depack+0xaa>




	if( buffer )
    12b1:	a1 00 00 00 00       	mov    0x0,%eax
    12b6:	83 c4 10             	add    $0x10,%esp
    12b9:	85 c0                	test   %eax,%eax
    12bb:	74 0c                	je     12c9 <depack+0xc6>
		free(buffer);
    12bd:	83 ec 0c             	sub    $0xc,%esp
    12c0:	50                   	push   %eax
    12c1:	e8 fc ff ff ff       	call   12c2 <depack+0xbf>
    12c6:	83 c4 10             	add    $0x10,%esp

	return success;
}
    12c9:	89 d8                	mov    %ebx,%eax
    12cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    12ce:	c9                   	leave  
    12cf:	c3                   	ret    

mhmt-emit.o:     file format elf32-i386


Disassembly of section .text:

00000000 <emit_file>:
// When length=EMIT_FILE_FINISH (0), flushes tail to file
// When length=EMIT_FILE_INIT (-1), initializes.
//
// returns zero in case of any problems (fails to write buffer to file), otherwise non-zero
ULONG emit_file(UBYTE * bytes, LONG length)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	57                   	push   %edi
       4:	56                   	push   %esi
       5:	53                   	push   %ebx
       6:	83 ec 0c             	sub    $0xc,%esp
       9:	8b 45 0c             	mov    0xc(%ebp),%eax
       c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	static UBYTE buffer[EMIT_FILEBUF_SIZE];

	static ULONG position;


	if( length==EMIT_FILE_INIT )
       f:	83 f8 ff             	cmp    $0xffffffff,%eax
      12:	75 0f                	jne    23 <emit_file+0x23>
	{
		position = 0;
      14:	c7 05 10 01 00 00 00 	movl   $0x0,0x110
      1b:	00 00 00 
      1e:	e9 c5 00 00 00       	jmp    e8 <emit_file+0xe8>

		return 1;
	}
	else if( length>0 )
      23:	83 f8 00             	cmp    $0x0,%eax
      26:	7f 48                	jg     70 <emit_file+0x70>
      28:	eb 7a                	jmp    a4 <emit_file+0xa4>
		{
			length -= (EMIT_FILEBUF_SIZE-position);

			while( position < EMIT_FILEBUF_SIZE ) // fill buffer to the end, if possible
			{
                                buffer[position++] = *(bytes++);
      2a:	8a 03                	mov    (%ebx),%al
      2c:	42                   	inc    %edx
      2d:	43                   	inc    %ebx
      2e:	88 01                	mov    %al,(%ecx)
      30:	41                   	inc    %ecx
	{
		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer
		{
			length -= (EMIT_FILEBUF_SIZE-position);

			while( position < EMIT_FILEBUF_SIZE ) // fill buffer to the end, if possible
      31:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
      37:	76 f1                	jbe    2a <emit_file+0x2a>
			{
                                buffer[position++] = *(bytes++);
			}

			if( EMIT_FILEBUF_SIZE!=fwrite(buffer, 1, EMIT_FILEBUF_SIZE, wrk.file_out) )
      39:	ff 35 2c 00 00 00    	pushl  0x2c
	{
		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer
		{
			length -= (EMIT_FILEBUF_SIZE-position);

			while( position < EMIT_FILEBUF_SIZE ) // fill buffer to the end, if possible
      3f:	89 15 10 01 00 00    	mov    %edx,0x110
			{
                                buffer[position++] = *(bytes++);
			}

			if( EMIT_FILEBUF_SIZE!=fwrite(buffer, 1, EMIT_FILEBUF_SIZE, wrk.file_out) )
      45:	68 00 10 00 00       	push   $0x1000
      4a:	6a 01                	push   $0x1
      4c:	68 14 01 00 00       	push   $0x114
      51:	e8 fc ff ff ff       	call   52 <emit_file+0x52>
      56:	83 c4 10             	add    $0x10,%esp
      59:	3d 00 10 00 00       	cmp    $0x1000,%eax
      5e:	75 6a                	jne    ca <emit_file+0xca>
	}
	else if( length>0 )
	{
		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer
		{
			length -= (EMIT_FILEBUF_SIZE-position);
      60:	8d 86 00 f0 ff ff    	lea    -0x1000(%esi),%eax
			{
				printf("mhmt-emit.c:emit_file() can't write to file!\n");
				return 0;
			}

			position=0;
      66:	c7 05 10 01 00 00 00 	movl   $0x0,0x110
      6d:	00 00 00 

		return 1;
	}
	else if( length>0 )
	{
		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer
      70:	8b 15 10 01 00 00    	mov    0x110,%edx
      76:	8d 34 10             	lea    (%eax,%edx,1),%esi
      79:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
      7f:	8d 8a 14 01 00 00    	lea    0x114(%edx),%ecx
      85:	77 aa                	ja     31 <emit_file+0x31>
      87:	89 c6                	mov    %eax,%esi
      89:	89 cf                	mov    %ecx,%edi
      8b:	eb 06                	jmp    93 <emit_file+0x93>
			position=0;
		}

		while( length-- ) // if something left that does not need flushing
		{
			buffer[position++] = *(bytes++);
      8d:	8a 0b                	mov    (%ebx),%cl
      8f:	43                   	inc    %ebx
      90:	88 0f                	mov    %cl,(%edi)
      92:	47                   	inc    %edi
			}

			position=0;
		}

		while( length-- ) // if something left that does not need flushing
      93:	48                   	dec    %eax
      94:	83 f8 ff             	cmp    $0xffffffff,%eax
      97:	75 f4                	jne    8d <emit_file+0x8d>
      99:	8d 14 16             	lea    (%esi,%edx,1),%edx
      9c:	89 15 10 01 00 00    	mov    %edx,0x110
      a2:	eb 44                	jmp    e8 <emit_file+0xe8>
			buffer[position++] = *(bytes++);
		}

		return 1;
	}
	else if( length==EMIT_FILE_FINISH )
      a4:	75 2e                	jne    d4 <emit_file+0xd4>
	{
		if( position>0 ) // do we have anything to flush?
      a6:	8b 1d 10 01 00 00    	mov    0x110,%ebx
      ac:	85 db                	test   %ebx,%ebx
      ae:	74 38                	je     e8 <emit_file+0xe8>
		{
			if( position!=fwrite(buffer, 1, position, wrk.file_out) )
      b0:	ff 35 2c 00 00 00    	pushl  0x2c
      b6:	53                   	push   %ebx
      b7:	6a 01                	push   $0x1
      b9:	68 14 01 00 00       	push   $0x114
      be:	e8 fc ff ff ff       	call   bf <emit_file+0xbf>
      c3:	83 c4 10             	add    $0x10,%esp
      c6:	39 c3                	cmp    %eax,%ebx
      c8:	74 1e                	je     e8 <emit_file+0xe8>
			{
				printf("mhmt-emit.c:emit_file() can't write to file!\n");
      ca:	83 ec 0c             	sub    $0xc,%esp
      cd:	68 00 00 00 00       	push   $0x0
      d2:	eb 08                	jmp    dc <emit_file+0xdc>

		return 1;
	}
	else
	{
		printf("mhmt-emit.c:emit_file() encountered invalid arguments!\n");
      d4:	83 ec 0c             	sub    $0xc,%esp
      d7:	68 2d 00 00 00       	push   $0x2d
      dc:	e8 fc ff ff ff       	call   dd <emit_file+0xdd>
      e1:	31 c0                	xor    %eax,%eax
		return 0;
      e3:	83 c4 10             	add    $0x10,%esp
      e6:	eb 05                	jmp    ed <emit_file+0xed>
      e8:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
      ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
      f0:	5b                   	pop    %ebx
      f1:	5e                   	pop    %esi
      f2:	5f                   	pop    %edi
      f3:	5d                   	pop    %ebp
      f4:	c3                   	ret    

000000f5 <emit_bits_flush>:
}

// flushes either word or byte from given bits
//
ULONG emit_bits_flush(ULONG bits)
{
      f5:	55                   	push   %ebp
      f6:	89 e5                	mov    %esp,%ebp
      f8:	56                   	push   %esi
      f9:	53                   	push   %ebx
      fa:	83 ec 10             	sub    $0x10,%esp
      fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	UBYTE store_byte;

	ULONG success = 1;

	if( wrk.wordbit ) // 16bits
     100:	83 3d 10 00 00 00 00 	cmpl   $0x0,0x10
     107:	74 50                	je     159 <emit_bits_flush+0x64>
	{
		if( wrk.bigend ) // big endian
     109:	83 3d 14 00 00 00 00 	cmpl   $0x0,0x14
     110:	8d 75 f7             	lea    -0x9(%ebp),%esi
     113:	74 1f                	je     134 <emit_bits_flush+0x3f>
		{
			store_byte = 0x00FF & (bits >> 8);
     115:	89 d8                	mov    %ebx,%eax
     117:	c1 e8 08             	shr    $0x8,%eax
     11a:	88 45 f7             	mov    %al,-0x9(%ebp)
			success = success && emit_file( &store_byte, 1);
     11d:	50                   	push   %eax
     11e:	50                   	push   %eax
     11f:	6a 01                	push   $0x1
     121:	56                   	push   %esi
     122:	e8 fc ff ff ff       	call   123 <emit_bits_flush+0x2e>

			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);
     127:	83 c4 10             	add    $0x10,%esp
	if( wrk.wordbit ) // 16bits
	{
		if( wrk.bigend ) // big endian
		{
			store_byte = 0x00FF & (bits >> 8);
			success = success && emit_file( &store_byte, 1);
     12a:	89 c2                	mov    %eax,%edx

			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);
     12c:	31 c0                	xor    %eax,%eax
     12e:	85 d2                	test   %edx,%edx
     130:	74 42                	je     174 <emit_bits_flush+0x7f>
     132:	eb 1b                	jmp    14f <emit_bits_flush+0x5a>
		}
		else // little endian
		{
			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);
     134:	51                   	push   %ecx
     135:	51                   	push   %ecx
     136:	6a 01                	push   $0x1
     138:	56                   	push   %esi
			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);
		}
		else // little endian
		{
			store_byte = 0x00FF & bits;
     139:	88 5d f7             	mov    %bl,-0x9(%ebp)
			success = success && emit_file( &store_byte, 1);
     13c:	e8 fc ff ff ff       	call   13d <emit_bits_flush+0x48>

			store_byte = 0x00FF & (bits >> 8);
			success = success && emit_file( &store_byte, 1);
     141:	83 c4 10             	add    $0x10,%esp
			success = success && emit_file( &store_byte, 1);
		}
		else // little endian
		{
			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);
     144:	89 c2                	mov    %eax,%edx

			store_byte = 0x00FF & (bits >> 8);
			success = success && emit_file( &store_byte, 1);
     146:	31 c0                	xor    %eax,%eax
     148:	85 d2                	test   %edx,%edx
     14a:	74 28                	je     174 <emit_bits_flush+0x7f>
		else // little endian
		{
			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);

			store_byte = 0x00FF & (bits >> 8);
     14c:	c1 eb 08             	shr    $0x8,%ebx
			success = success && emit_file( &store_byte, 1);
     14f:	52                   	push   %edx
     150:	52                   	push   %edx
     151:	6a 01                	push   $0x1
     153:	56                   	push   %esi
		else // little endian
		{
			store_byte = 0x00FF & bits;
			success = success && emit_file( &store_byte, 1);

			store_byte = 0x00FF & (bits >> 8);
     154:	88 5d f7             	mov    %bl,-0x9(%ebp)
     157:	eb 0b                	jmp    164 <emit_bits_flush+0x6f>
		}
	}
	else // 8bits
	{
		store_byte = 0x00FF & bits;
		success = success && emit_file( &store_byte, 1);
     159:	50                   	push   %eax
     15a:	50                   	push   %eax
     15b:	6a 01                	push   $0x1
     15d:	8d 45 f7             	lea    -0x9(%ebp),%eax
			success = success && emit_file( &store_byte, 1);
		}
	}
	else // 8bits
	{
		store_byte = 0x00FF & bits;
     160:	88 5d f7             	mov    %bl,-0x9(%ebp)
		success = success && emit_file( &store_byte, 1);
     163:	50                   	push   %eax
     164:	e8 fc ff ff ff       	call   165 <emit_bits_flush+0x70>
     169:	83 c4 10             	add    $0x10,%esp
     16c:	85 c0                	test   %eax,%eax
     16e:	0f 95 c0             	setne  %al
     171:	0f b6 c0             	movzbl %al,%eax
	}

	return success;
}
     174:	8d 65 f8             	lea    -0x8(%ebp),%esp
     177:	5b                   	pop    %ebx
     178:	5e                   	pop    %esi
     179:	5d                   	pop    %ebp
     17a:	c3                   	ret    

0000017b <emit_byte>:

// store emitted bytes in special buffer, because emitted bits go earlier than corresponding bytes.
// then, when bits are flushed to the file, bytes are flushed just after.
// returns zero if any problems. "operation" dictates what to do (see *.h)
ULONG emit_byte(UBYTE byte, ULONG operation)
{
     17b:	55                   	push   %ebp
     17c:	89 e5                	mov    %esp,%ebp
     17e:	83 ec 08             	sub    $0x8,%esp
     181:	8b 45 0c             	mov    0xc(%ebp),%eax
     184:	8b 55 08             	mov    0x8(%ebp),%edx
	static ULONG in_pos, out_pos;

	ULONG success;


	switch( operation )
     187:	83 f8 01             	cmp    $0x1,%eax
     18a:	74 52                	je     1de <emit_byte+0x63>
     18c:	72 0b                	jb     199 <emit_byte+0x1e>
     18e:	83 f8 02             	cmp    $0x2,%eax
     191:	0f 85 bb 00 00 00    	jne    252 <emit_byte+0xd7>
     197:	eb 19                	jmp    1b2 <emit_byte+0x37>
	{
	case EMIT_BYTE_INIT:

		in_pos  = 0;
     199:	c7 05 0c 00 00 00 00 	movl   $0x0,0xc
     1a0:	00 00 00 
		out_pos = 0;
     1a3:	c7 05 08 00 00 00 00 	movl   $0x0,0x8
     1aa:	00 00 00 
     1ad:	e9 b4 00 00 00       	jmp    266 <emit_byte+0xeb>

		#ifdef DBG
			printf("<%02x>",byte&0x00FF);
		#endif

		buffer[in_pos] = byte;
     1b2:	a1 0c 00 00 00       	mov    0xc,%eax
     1b7:	88 90 10 00 00 00    	mov    %dl,0x10(%eax)

		in_pos = (in_pos+1) & (EMIT_BYTEBUF_SIZE-1);
     1bd:	40                   	inc    %eax
     1be:	25 ff 00 00 00       	and    $0xff,%eax


		if( in_pos==out_pos ) // overflow!
     1c3:	3b 05 08 00 00 00    	cmp    0x8,%eax
			printf("<%02x>",byte&0x00FF);
		#endif

		buffer[in_pos] = byte;

		in_pos = (in_pos+1) & (EMIT_BYTEBUF_SIZE-1);
     1c9:	a3 0c 00 00 00       	mov    %eax,0xc


		if( in_pos==out_pos ) // overflow!
     1ce:	0f 85 92 00 00 00    	jne    266 <emit_byte+0xeb>
		{
			printf("mhmt-emit.c:emit_byte() buffer overflow!\n");
     1d4:	83 ec 0c             	sub    $0xc,%esp
     1d7:	68 64 00 00 00       	push   $0x64
     1dc:	eb 7c                	jmp    25a <emit_byte+0xdf>
		return 1;


	case EMIT_BYTE_FLUSH:

		if( in_pos==out_pos ) // nothing to do?
     1de:	8b 15 0c 00 00 00    	mov    0xc,%edx
     1e4:	a1 08 00 00 00       	mov    0x8,%eax
     1e9:	39 c2                	cmp    %eax,%edx
     1eb:	74 79                	je     266 <emit_byte+0xeb>
     1ed:	8d 88 10 00 00 00    	lea    0x10(%eax),%ecx
			return 1;
		else if( in_pos>out_pos ) // no index wraparound
     1f3:	76 11                	jbe    206 <emit_byte+0x8b>
		{
			success = emit_file( &buffer[out_pos], in_pos-out_pos );
     1f5:	83 ec 08             	sub    $0x8,%esp
     1f8:	29 c2                	sub    %eax,%edx
     1fa:	52                   	push   %edx
     1fb:	51                   	push   %ecx
     1fc:	e8 fc ff ff ff       	call   1fd <emit_byte+0x82>
     201:	83 c4 10             	add    $0x10,%esp
     204:	eb 3e                	jmp    244 <emit_byte+0xc9>
		}
		else // in_pos<out_pos - wraparound
		{
			success = emit_file( &buffer[out_pos], EMIT_BYTEBUF_SIZE-out_pos );
     206:	52                   	push   %edx
     207:	52                   	push   %edx
     208:	ba 00 01 00 00       	mov    $0x100,%edx
     20d:	29 c2                	sub    %eax,%edx
     20f:	52                   	push   %edx
     210:	51                   	push   %ecx
     211:	e8 fc ff ff ff       	call   212 <emit_byte+0x97>

			if( in_pos )
     216:	8b 15 0c 00 00 00    	mov    0xc,%edx
     21c:	83 c4 10             	add    $0x10,%esp
     21f:	85 d2                	test   %edx,%edx
     221:	74 21                	je     244 <emit_byte+0xc9>
				success = success && emit_file( &buffer[0], in_pos );
     223:	85 c0                	test   %eax,%eax
     225:	74 1b                	je     242 <emit_byte+0xc7>
     227:	51                   	push   %ecx
     228:	51                   	push   %ecx
     229:	52                   	push   %edx
     22a:	68 10 00 00 00       	push   $0x10
     22f:	e8 fc ff ff ff       	call   230 <emit_byte+0xb5>
     234:	83 c4 10             	add    $0x10,%esp
     237:	89 c2                	mov    %eax,%edx
     239:	b8 01 00 00 00       	mov    $0x1,%eax
     23e:	85 d2                	test   %edx,%edx
     240:	75 02                	jne    244 <emit_byte+0xc9>
     242:	31 c0                	xor    %eax,%eax
		}

		out_pos=in_pos;
     244:	8b 15 0c 00 00 00    	mov    0xc,%edx
     24a:	89 15 08 00 00 00    	mov    %edx,0x8
		return success;
     250:	eb 19                	jmp    26b <emit_byte+0xf0>

	default:
		printf("mhmt-emit.c:emit_byte() encountered invalid arguments!\n");
     252:	83 ec 0c             	sub    $0xc,%esp
     255:	68 8d 00 00 00       	push   $0x8d
     25a:	e8 fc ff ff ff       	call   25b <emit_byte+0xe0>
     25f:	31 c0                	xor    %eax,%eax
		return 0;
     261:	83 c4 10             	add    $0x10,%esp
     264:	eb 05                	jmp    26b <emit_byte+0xf0>
     266:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
     26b:	c9                   	leave  
     26c:	c3                   	ret    

0000026d <emit_bits>:

// collects bits, emit to output stream when needed. accounts for word or byte mode, little-big endian, empty or full bits
// length is either positive number of bits or one of two special cases (see *.h)
//
ULONG emit_bits(ULONG msb_aligned_bits, LONG length)
{
     26d:	55                   	push   %ebp
     26e:	89 e5                	mov    %esp,%ebp
     270:	57                   	push   %edi
     271:	56                   	push   %esi
     272:	53                   	push   %ebx
     273:	83 ec 0c             	sub    $0xc,%esp
     276:	8b 75 0c             	mov    0xc(%ebp),%esi
	ULONG max_bits;

	ULONG success = 1;


	max_bits = wrk.wordbit ? 16 : 8;
     279:	83 3d 10 00 00 00 01 	cmpl   $0x1,0x10

// collects bits, emit to output stream when needed. accounts for word or byte mode, little-big endian, empty or full bits
// length is either positive number of bits or one of two special cases (see *.h)
//
ULONG emit_bits(ULONG msb_aligned_bits, LONG length)
{
     280:	8b 7d 08             	mov    0x8(%ebp),%edi
	ULONG max_bits;

	ULONG success = 1;


	max_bits = wrk.wordbit ? 16 : 8;
     283:	19 db                	sbb    %ebx,%ebx
     285:	83 e3 f8             	and    $0xfffffff8,%ebx
     288:	83 c3 10             	add    $0x10,%ebx

	if( length==EMIT_BITS_INIT )
     28b:	83 fe ff             	cmp    $0xffffffff,%esi
     28e:	75 1e                	jne    2ae <emit_bits+0x41>
	{
		bit_store = 0;
     290:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
     297:	00 00 00 
		bit_count = 0;
     29a:	b8 01 00 00 00       	mov    $0x1,%eax
     29f:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     2a6:	00 00 00 
		return 1;
     2a9:	e9 3c 01 00 00       	jmp    3ea <emit_bits+0x17d>
	}
	else if( length==EMIT_BITS_FINISH )
     2ae:	83 fe 00             	cmp    $0x0,%esi
     2b1:	75 59                	jne    30c <emit_bits+0x9f>
	{
		if( bit_count ) // some bits to flush
     2b3:	a1 00 00 00 00       	mov    0x0,%eax
     2b8:	85 c0                	test   %eax,%eax
     2ba:	74 35                	je     2f1 <emit_bits+0x84>
     2bc:	8b 15 04 00 00 00    	mov    0x4,%edx
     2c2:	eb 02                	jmp    2c6 <emit_bits+0x59>
		{
			while( (bit_count++)<max_bits )
				bit_store <<= 1;
     2c4:	01 d2                	add    %edx,%edx
     2c6:	40                   	inc    %eax
	}
	else if( length==EMIT_BITS_FINISH )
	{
		if( bit_count ) // some bits to flush
		{
			while( (bit_count++)<max_bits )
     2c7:	8d 48 ff             	lea    -0x1(%eax),%ecx
     2ca:	39 d9                	cmp    %ebx,%ecx
     2cc:	72 f6                	jb     2c4 <emit_bits+0x57>
				bit_store <<= 1;

			success = success && emit_bits_flush(bit_store);
     2ce:	83 ec 0c             	sub    $0xc,%esp
     2d1:	52                   	push   %edx
	}
	else if( length==EMIT_BITS_FINISH )
	{
		if( bit_count ) // some bits to flush
		{
			while( (bit_count++)<max_bits )
     2d2:	89 15 04 00 00 00    	mov    %edx,0x4
     2d8:	a3 00 00 00 00       	mov    %eax,0x0
				bit_store <<= 1;

			success = success && emit_bits_flush(bit_store);
     2dd:	e8 fc ff ff ff       	call   2de <emit_bits+0x71>
		}

		success = success && emit_byte(0, EMIT_BYTE_FLUSH);
     2e2:	83 c4 10             	add    $0x10,%esp
		if( bit_count ) // some bits to flush
		{
			while( (bit_count++)<max_bits )
				bit_store <<= 1;

			success = success && emit_bits_flush(bit_store);
     2e5:	89 c2                	mov    %eax,%edx
		}

		success = success && emit_byte(0, EMIT_BYTE_FLUSH);
     2e7:	31 c0                	xor    %eax,%eax
     2e9:	85 d2                	test   %edx,%edx
     2eb:	0f 84 f9 00 00 00    	je     3ea <emit_bits+0x17d>
     2f1:	51                   	push   %ecx
     2f2:	51                   	push   %ecx
     2f3:	6a 01                	push   $0x1
     2f5:	6a 00                	push   $0x0
     2f7:	e8 fc ff ff ff       	call   2f8 <emit_bits+0x8b>
     2fc:	83 c4 10             	add    $0x10,%esp
     2ff:	85 c0                	test   %eax,%eax
     301:	0f 95 c0             	setne  %al
     304:	0f b6 c0             	movzbl %al,%eax

		return success;
     307:	e9 de 00 00 00       	jmp    3ea <emit_bits+0x17d>
	}
	else if( length>0 ) // add bits
     30c:	0f 8e c6 00 00 00    	jle    3d8 <emit_bits+0x16b>
     312:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		do
		{
			if( !wrk.fullbits ) // empty bits - check for flushing before shiftin
     317:	83 3d 18 00 00 00 00 	cmpl   $0x0,0x18
     31e:	75 46                	jne    366 <emit_bits+0xf9>
			{
				if( bit_count==max_bits )
     320:	39 1d 00 00 00 00    	cmp    %ebx,0x0
     326:	75 3e                	jne    366 <emit_bits+0xf9>
				{
					success = success && emit_bits_flush(bit_store);
     328:	85 c0                	test   %eax,%eax
     32a:	74 2e                	je     35a <emit_bits+0xed>
     32c:	83 ec 0c             	sub    $0xc,%esp
     32f:	ff 35 04 00 00 00    	pushl  0x4
     335:	e8 fc ff ff ff       	call   336 <emit_bits+0xc9>
     33a:	83 c4 10             	add    $0x10,%esp
     33d:	85 c0                	test   %eax,%eax
     33f:	74 19                	je     35a <emit_bits+0xed>
					success = success && emit_byte(0, EMIT_BYTE_FLUSH);
     341:	52                   	push   %edx
     342:	52                   	push   %edx
     343:	6a 01                	push   $0x1
     345:	6a 00                	push   $0x0
     347:	e8 fc ff ff ff       	call   348 <emit_bits+0xdb>
     34c:	83 c4 10             	add    $0x10,%esp
     34f:	89 c2                	mov    %eax,%edx
     351:	b8 01 00 00 00       	mov    $0x1,%eax
     356:	85 d2                	test   %edx,%edx
     358:	75 02                	jne    35c <emit_bits+0xef>
     35a:	31 c0                	xor    %eax,%eax

					bit_count = 0;
     35c:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     363:	00 00 00 
			}

			#ifdef DBG
				printf("%d",1&(msb_aligned_bits>>31));
			#endif
			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );
     366:	8b 0d 04 00 00 00    	mov    0x4,%ecx
     36c:	89 fa                	mov    %edi,%edx
     36e:	c1 ea 1f             	shr    $0x1f,%edx
     371:	01 c9                	add    %ecx,%ecx
     373:	09 ca                	or     %ecx,%edx
			msb_aligned_bits <<= 1;
			bit_count++;
     375:	8b 0d 00 00 00 00    	mov    0x0,%ecx
			}

			#ifdef DBG
				printf("%d",1&(msb_aligned_bits>>31));
			#endif
			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );
     37b:	89 15 04 00 00 00    	mov    %edx,0x4
			msb_aligned_bits <<= 1;
			bit_count++;
     381:	41                   	inc    %ecx

			if( wrk.fullbits ) // full bits - check for flushing after bit shiftin
     382:	83 3d 18 00 00 00 00 	cmpl   $0x0,0x18
			#ifdef DBG
				printf("%d",1&(msb_aligned_bits>>31));
			#endif
			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );
			msb_aligned_bits <<= 1;
			bit_count++;
     389:	89 0d 00 00 00 00    	mov    %ecx,0x0

			if( wrk.fullbits ) // full bits - check for flushing after bit shiftin
     38f:	74 3d                	je     3ce <emit_bits+0x161>
			{
				if( bit_count==max_bits )
     391:	39 d9                	cmp    %ebx,%ecx
     393:	75 39                	jne    3ce <emit_bits+0x161>
				{
					success = success && emit_bits_flush(bit_store);
     395:	85 c0                	test   %eax,%eax
     397:	74 29                	je     3c2 <emit_bits+0x155>
     399:	83 ec 0c             	sub    $0xc,%esp
     39c:	52                   	push   %edx
     39d:	e8 fc ff ff ff       	call   39e <emit_bits+0x131>
     3a2:	83 c4 10             	add    $0x10,%esp
     3a5:	85 c0                	test   %eax,%eax
     3a7:	74 19                	je     3c2 <emit_bits+0x155>
					success = success && emit_byte(0, EMIT_BYTE_FLUSH);
     3a9:	50                   	push   %eax
     3aa:	50                   	push   %eax
     3ab:	6a 01                	push   $0x1
     3ad:	6a 00                	push   $0x0
     3af:	e8 fc ff ff ff       	call   3b0 <emit_bits+0x143>
     3b4:	83 c4 10             	add    $0x10,%esp
     3b7:	89 c2                	mov    %eax,%edx
     3b9:	b8 01 00 00 00       	mov    $0x1,%eax
     3be:	85 d2                	test   %edx,%edx
     3c0:	75 02                	jne    3c4 <emit_bits+0x157>
     3c2:	31 c0                	xor    %eax,%eax

					bit_count = 0;
     3c4:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
     3cb:	00 00 00 
				}
			}

		} while( --length );
     3ce:	4e                   	dec    %esi
     3cf:	74 19                	je     3ea <emit_bits+0x17d>

			#ifdef DBG
				printf("%d",1&(msb_aligned_bits>>31));
			#endif
			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );
			msb_aligned_bits <<= 1;
     3d1:	01 ff                	add    %edi,%edi
     3d3:	e9 3f ff ff ff       	jmp    317 <emit_bits+0xaa>

		return success;
	}
	else
	{
		printf("mhmt-emit.c:emit_bits() encountered invalid arguments!\n");
     3d8:	83 ec 0c             	sub    $0xc,%esp
     3db:	68 c4 00 00 00       	push   $0xc4
     3e0:	e8 fc ff ff ff       	call   3e1 <emit_bits+0x174>
     3e5:	31 c0                	xor    %eax,%eax
		return 0;
     3e7:	83 c4 10             	add    $0x10,%esp
	}
}
     3ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
     3ed:	5b                   	pop    %ebx
     3ee:	5e                   	pop    %esi
     3ef:	5f                   	pop    %edi
     3f0:	5d                   	pop    %ebp
     3f1:	c3                   	ret    

000003f2 <emit_hrust>:




ULONG emit_hrust(struct optchain * optch, ULONG actual_len)
{
     3f2:	55                   	push   %ebp
     3f3:	89 e5                	mov    %esp,%ebp
     3f5:	57                   	push   %edi
     3f6:	56                   	push   %esi
     3f7:	53                   	push   %ebx
     3f8:	83 ec 2c             	sub    $0x2c,%esp

	max_disp = 0;


	// some checks
	if( !optch )
     3fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
     3ff:	75 0d                	jne    40e <emit_hrust+0x1c>
	{
		printf("mhmt-emit.c:emit_hrust() - NULL passed!\n");
     401:	83 ec 0c             	sub    $0xc,%esp
     404:	68 fb 00 00 00       	push   $0xfb
     409:	e9 1e 01 00 00       	jmp    52c <emit_hrust+0x13a>
		return 0;
	}

	// initialize
	success = success && emit_file(NULL, EMIT_FILE_INIT);
     40e:	53                   	push   %ebx
     40f:	53                   	push   %ebx
     410:	6a ff                	push   $0xffffffff
     412:	6a 00                	push   $0x0
     414:	e8 fc ff ff ff       	call   415 <emit_hrust+0x23>
     419:	83 c4 10             	add    $0x10,%esp
     41c:	85 c0                	test   %eax,%eax
     41e:	74 29                	je     449 <emit_hrust+0x57>

	success = success && emit_byte(0, EMIT_BYTE_INIT);
     420:	51                   	push   %ecx
     421:	51                   	push   %ecx
     422:	6a 00                	push   $0x0
     424:	6a 00                	push   $0x0
     426:	e8 fc ff ff ff       	call   427 <emit_hrust+0x35>
     42b:	83 c4 10             	add    $0x10,%esp
     42e:	85 c0                	test   %eax,%eax
     430:	74 17                	je     449 <emit_hrust+0x57>

	success = success && emit_bits(0, EMIT_BITS_INIT);
     432:	52                   	push   %edx
     433:	52                   	push   %edx
     434:	6a ff                	push   $0xffffffff
     436:	6a 00                	push   $0x0
     438:	e8 fc ff ff ff       	call   439 <emit_hrust+0x47>
     43d:	83 c4 10             	add    $0x10,%esp
     440:	ba 01 00 00 00       	mov    $0x1,%edx
     445:	85 c0                	test   %eax,%eax
     447:	75 02                	jne    44b <emit_hrust+0x59>
     449:	31 d2                	xor    %edx,%edx


	// manage zx header info
	if( wrk.zxheader )
     44b:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
	// initialize
	success = success && emit_file(NULL, EMIT_FILE_INIT);

	success = success && emit_byte(0, EMIT_BYTE_INIT);

	success = success && emit_bits(0, EMIT_BITS_INIT);
     452:	89 d0                	mov    %edx,%eax


	// manage zx header info
	if( wrk.zxheader )
     454:	74 7f                	je     4d5 <emit_hrust+0xe3>
	{
		success = success && emit_file( (UBYTE*)"HR", 2);
     456:	85 d2                	test   %edx,%edx
     458:	74 1a                	je     474 <emit_hrust+0x82>
     45a:	50                   	push   %eax
     45b:	50                   	push   %eax
     45c:	6a 02                	push   $0x2
     45e:	68 23 01 00 00       	push   $0x123
     463:	e8 fc ff ff ff       	call   464 <emit_hrust+0x72>
     468:	83 c4 10             	add    $0x10,%esp
     46b:	ba 01 00 00 00       	mov    $0x1,%edx
     470:	85 c0                	test   %eax,%eax
     472:	75 02                	jne    476 <emit_hrust+0x84>
     474:	31 d2                	xor    %edx,%edx

		wrlen[0] = wrk.inlen&0x00FF;
     476:	a1 34 00 00 00       	mov    0x34,%eax
     47b:	88 45 e6             	mov    %al,-0x1a(%ebp)
		wrlen[1] = (wrk.inlen>>8)&0x00FF;
     47e:	c1 e8 08             	shr    $0x8,%eax
		success = success && emit_file( wrlen, 2); // unpacked length mod 65536
     481:	85 d2                	test   %edx,%edx
	if( wrk.zxheader )
	{
		success = success && emit_file( (UBYTE*)"HR", 2);

		wrlen[0] = wrk.inlen&0x00FF;
		wrlen[1] = (wrk.inlen>>8)&0x00FF;
     483:	88 45 e7             	mov    %al,-0x19(%ebp)
		success = success && emit_file( wrlen, 2); // unpacked length mod 65536
     486:	74 4b                	je     4d3 <emit_hrust+0xe1>
     488:	57                   	push   %edi
     489:	57                   	push   %edi
     48a:	6a 02                	push   $0x2
     48c:	8d 5d e6             	lea    -0x1a(%ebp),%ebx
     48f:	53                   	push   %ebx
     490:	e8 fc ff ff ff       	call   491 <emit_hrust+0x9f>
     495:	83 c4 10             	add    $0x10,%esp
     498:	85 c0                	test   %eax,%eax
     49a:	74 37                	je     4d3 <emit_hrust+0xe1>

		success = success && emit_file( wrlen, 2); // packed length - !to be filled later!
     49c:	56                   	push   %esi
     49d:	56                   	push   %esi
     49e:	6a 02                	push   $0x2
     4a0:	53                   	push   %ebx
     4a1:	e8 fc ff ff ff       	call   4a2 <emit_hrust+0xb0>
     4a6:	83 c4 10             	add    $0x10,%esp
     4a9:	85 c0                	test   %eax,%eax
     4ab:	74 26                	je     4d3 <emit_hrust+0xe1>

        success = success && emit_file( &wrk.indata[wrk.inlen-6], 6); // last bytes
     4ad:	a1 34 00 00 00       	mov    0x34,%eax
     4b2:	53                   	push   %ebx
     4b3:	53                   	push   %ebx
     4b4:	6a 06                	push   $0x6
     4b6:	83 e8 06             	sub    $0x6,%eax
     4b9:	03 05 30 00 00 00    	add    0x30,%eax
     4bf:	50                   	push   %eax
     4c0:	e8 fc ff ff ff       	call   4c1 <emit_hrust+0xcf>
     4c5:	83 c4 10             	add    $0x10,%esp
     4c8:	89 c2                	mov    %eax,%edx
     4ca:	b8 01 00 00 00       	mov    $0x1,%eax
     4cf:	85 d2                	test   %edx,%edx
     4d1:	75 02                	jne    4d5 <emit_hrust+0xe3>
     4d3:	31 c0                	xor    %eax,%eax
	}

	// schedule first byte to be placed just after first bitstream word
	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);
     4d5:	85 c0                	test   %eax,%eax
     4d7:	74 20                	je     4f9 <emit_hrust+0x107>
     4d9:	a1 30 00 00 00       	mov    0x30,%eax
     4de:	51                   	push   %ecx
     4df:	51                   	push   %ecx
     4e0:	6a 02                	push   $0x2
     4e2:	0f b6 00             	movzbl (%eax),%eax
     4e5:	50                   	push   %eax
     4e6:	e8 fc ff ff ff       	call   4e7 <emit_hrust+0xf5>
     4eb:	83 c4 10             	add    $0x10,%esp
     4ee:	89 c2                	mov    %eax,%edx
     4f0:	b8 01 00 00 00       	mov    $0x1,%eax
     4f5:	85 d2                	test   %edx,%edx
     4f7:	75 02                	jne    4fb <emit_hrust+0x109>
     4f9:	31 c0                	xor    %eax,%eax
     4fb:	c7 45 d4 02 00 00 00 	movl   $0x2,-0x2c(%ebp)
     502:	bf 01 00 00 00       	mov    $0x1,%edi
     507:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
     50e:	e9 32 05 00 00       	jmp    a45 <emit_hrust+0x653>
	{
		#ifdef DBG
			printf("%04x:",position);
		#endif

		length = optch[position].code.length;
     513:	89 f8                	mov    %edi,%eax
     515:	c1 e0 04             	shl    $0x4,%eax
     518:	03 45 08             	add    0x8(%ebp),%eax
     51b:	8b 30                	mov    (%eax),%esi
		disp   = optch[position].code.disp;
     51d:	8b 58 04             	mov    0x4(%eax),%ebx

		if( length==0 )
     520:	85 f6                	test   %esi,%esi
     522:	75 12                	jne    536 <emit_hrust+0x144>
		{
			printf("mhmt-emit.c:emit_hrust() - encountered stop-code in optimal chain before emitting all data!\n");
     524:	83 ec 0c             	sub    $0xc,%esp
     527:	68 26 01 00 00       	push   $0x126
     52c:	e8 fc ff ff ff       	call   52d <emit_hrust+0x13b>
     531:	e9 f9 04 00 00       	jmp    a2f <emit_hrust+0x63d>
			return 0;
		}
		else if( disp==0 ) // copy-bytes
     536:	85 db                	test   %ebx,%ebx
     538:	0f 85 bc 00 00 00    	jne    5fa <emit_hrust+0x208>
		{
			if( length==1 ) // 1 byte: %1<byte>
     53e:	83 fe 01             	cmp    $0x1,%esi
     541:	75 2b                	jne    56e <emit_hrust+0x17c>
			{
				success = success && emit_bits( 0x80000000, 1 );
     543:	52                   	push   %edx
     544:	52                   	push   %edx
     545:	6a 01                	push   $0x1
     547:	68 00 00 00 80       	push   $0x80000000
     54c:	e8 fc ff ff ff       	call   54d <emit_hrust+0x15b>
     551:	83 c4 10             	add    $0x10,%esp
     554:	85 c0                	test   %eax,%eax
     556:	0f 84 65 02 00 00    	je     7c1 <emit_hrust+0x3cf>
				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );
     55c:	50                   	push   %eax
     55d:	50                   	push   %eax
     55e:	a1 30 00 00 00       	mov    0x30,%eax
     563:	6a 02                	push   $0x2
     565:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
     569:	e9 3b 02 00 00       	jmp    7a9 <emit_hrust+0x3b7>
			}
			else if( (12<=length) && (length<=42) && ( !(length&1) ) ) // %0110001abcd<byte,byte,...>
     56e:	8d 56 f4             	lea    -0xc(%esi),%edx
     571:	83 fa 1e             	cmp    $0x1e,%edx
     574:	0f 87 a8 04 00 00    	ja     a22 <emit_hrust+0x630>
     57a:	f7 c6 01 00 00 00    	test   $0x1,%esi
     580:	0f 85 9c 04 00 00    	jne    a22 <emit_hrust+0x630>
			{
				varbits = (length-12)<<27;
				success = success && emit_bits( 0x62000000, 7 );
     586:	51                   	push   %ecx
     587:	51                   	push   %ecx
     588:	6a 07                	push   $0x7
     58a:	68 00 00 00 62       	push   $0x62000000
     58f:	89 55 c8             	mov    %edx,-0x38(%ebp)
     592:	e8 fc ff ff ff       	call   593 <emit_hrust+0x1a1>
     597:	83 c4 10             	add    $0x10,%esp
     59a:	8b 55 c8             	mov    -0x38(%ebp),%edx
     59d:	85 c0                	test   %eax,%eax
     59f:	74 1b                	je     5bc <emit_hrust+0x1ca>

				success = success && emit_bits( varbits, 4 );
     5a1:	50                   	push   %eax
     5a2:	50                   	push   %eax
     5a3:	c1 e2 1b             	shl    $0x1b,%edx
     5a6:	6a 04                	push   $0x4
     5a8:	52                   	push   %edx
     5a9:	e8 fc ff ff ff       	call   5aa <emit_hrust+0x1b8>
     5ae:	83 c4 10             	add    $0x10,%esp
     5b1:	89 c2                	mov    %eax,%edx
     5b3:	b8 01 00 00 00       	mov    $0x1,%eax
     5b8:	85 d2                	test   %edx,%edx
     5ba:	75 02                	jne    5be <emit_hrust+0x1cc>
     5bc:	31 c0                	xor    %eax,%eax
     5be:	31 d2                	xor    %edx,%edx

				varlen = 0;
				while( success && (varlen<(ULONG)length) )
     5c0:	eb 27                	jmp    5e9 <emit_hrust+0x1f7>
				{
					success = success && emit_byte( wrk.indata[position+varlen], EMIT_BYTE_ADD );
     5c2:	a1 30 00 00 00       	mov    0x30,%eax
     5c7:	51                   	push   %ecx
     5c8:	51                   	push   %ecx
     5c9:	6a 02                	push   $0x2
     5cb:	01 d0                	add    %edx,%eax
     5cd:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
     5d1:	89 55 c8             	mov    %edx,-0x38(%ebp)
     5d4:	50                   	push   %eax
     5d5:	e8 fc ff ff ff       	call   5d6 <emit_hrust+0x1e4>
					varlen++;
     5da:	8b 55 c8             	mov    -0x38(%ebp),%edx
				success = success && emit_bits( varbits, 4 );

				varlen = 0;
				while( success && (varlen<(ULONG)length) )
				{
					success = success && emit_byte( wrk.indata[position+varlen], EMIT_BYTE_ADD );
     5dd:	83 c4 10             	add    $0x10,%esp
     5e0:	85 c0                	test   %eax,%eax
     5e2:	0f 95 c0             	setne  %al
					varlen++;
     5e5:	42                   	inc    %edx
				success = success && emit_bits( varbits, 4 );

				varlen = 0;
				while( success && (varlen<(ULONG)length) )
				{
					success = success && emit_byte( wrk.indata[position+varlen], EMIT_BYTE_ADD );
     5e6:	0f b6 c0             	movzbl %al,%eax
				success = success && emit_bits( 0x62000000, 7 );

				success = success && emit_bits( varbits, 4 );

				varlen = 0;
				while( success && (varlen<(ULONG)length) )
     5e9:	39 f2                	cmp    %esi,%edx
     5eb:	0f 83 42 04 00 00    	jae    a33 <emit_hrust+0x641>
     5f1:	84 c0                	test   %al,%al
     5f3:	75 cd                	jne    5c2 <emit_hrust+0x1d0>
     5f5:	e9 39 04 00 00       	jmp    a33 <emit_hrust+0x641>
				}
			}
			else
				goto INVALID_CODE_HRUST;
		}
		else if( length==(-3) ) // insertion code
     5fa:	83 fe fd             	cmp    $0xfffffffd,%esi
     5fd:	0f 85 dc 00 00 00    	jne    6df <emit_hrust+0x2ed>
		{
			if( (-16)<=disp && disp<=(-1) ) // %011001abcd<byte>
     603:	8d 43 10             	lea    0x10(%ebx),%eax
     606:	83 f8 0f             	cmp    $0xf,%eax
     609:	77 2a                	ja     635 <emit_hrust+0x243>
			{
				success = success && emit_bits( 0x64000000, 6 );
     60b:	50                   	push   %eax
     60c:	50                   	push   %eax
     60d:	6a 06                	push   $0x6
     60f:	68 00 00 00 64       	push   $0x64000000
     614:	e8 fc ff ff ff       	call   615 <emit_hrust+0x223>
     619:	83 c4 10             	add    $0x10,%esp
     61c:	85 c0                	test   %eax,%eax
     61e:	0f 84 88 00 00 00    	je     6ac <emit_hrust+0x2ba>
				success = success && emit_bits( disp<<(32-4), 4 );
     624:	51                   	push   %ecx
     625:	89 d8                	mov    %ebx,%eax
     627:	51                   	push   %ecx
     628:	6a 04                	push   $0x4
     62a:	c1 e0 1c             	shl    $0x1c,%eax
     62d:	50                   	push   %eax
     62e:	e8 fc ff ff ff       	call   62f <emit_hrust+0x23d>
     633:	eb 6b                	jmp    6a0 <emit_hrust+0x2ae>
			}
			else if( (-79)<=disp && disp<(-16) )
     635:	8d 43 4f             	lea    0x4f(%ebx),%eax
     638:	83 f8 3e             	cmp    $0x3e,%eax
     63b:	0f 87 e1 03 00 00    	ja     a22 <emit_hrust+0x630>
			{
				if( disp&1 ) // ffb1..ffef: %01001<byte><byte>
     641:	f6 c3 01             	test   $0x1,%bl
     644:	74 20                	je     666 <emit_hrust+0x274>
				{
					success = success && emit_bits( 0x48000000, 5 );
     646:	52                   	push   %edx
     647:	52                   	push   %edx
     648:	6a 05                	push   $0x5
     64a:	68 00 00 00 48       	push   $0x48000000
     64f:	e8 fc ff ff ff       	call   650 <emit_hrust+0x25e>
					varbits = disp&0x00FF;
					varbits += 15;
					varbits ^= 3;
					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
     654:	83 c4 10             	add    $0x10,%esp
     657:	85 c0                	test   %eax,%eax
     659:	74 51                	je     6ac <emit_hrust+0x2ba>
			{
				if( disp&1 ) // ffb1..ffef: %01001<byte><byte>
				{
					success = success && emit_bits( 0x48000000, 5 );

					varbits = disp&0x00FF;
     65b:	0f b6 c3             	movzbl %bl,%eax
					varbits += 15;
     65e:	83 c0 0f             	add    $0xf,%eax
					varbits ^= 3;
     661:	83 f0 03             	xor    $0x3,%eax
     664:	eb 1e                	jmp    684 <emit_hrust+0x292>

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
				}
				else // ffb2..ffee: %00110<byte><byte>
				{
					success = success && emit_bits( 0x30000000, 5 );
     666:	50                   	push   %eax
     667:	50                   	push   %eax
     668:	6a 05                	push   $0x5
     66a:	68 00 00 00 30       	push   $0x30000000
     66f:	e8 fc ff ff ff       	call   670 <emit_hrust+0x27e>
					varbits = disp&0x00FF;
					varbits += 15;
					varbits ^= 2;
					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
     674:	83 c4 10             	add    $0x10,%esp
     677:	85 c0                	test   %eax,%eax
     679:	74 31                	je     6ac <emit_hrust+0x2ba>
				}
				else // ffb2..ffee: %00110<byte><byte>
				{
					success = success && emit_bits( 0x30000000, 5 );

					varbits = disp&0x00FF;
     67b:	0f b6 c3             	movzbl %bl,%eax
					varbits += 15;
     67e:	83 c0 0f             	add    $0xf,%eax
					varbits ^= 2;
     681:	83 f0 02             	xor    $0x2,%eax
					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );
     684:	89 c2                	mov    %eax,%edx
     686:	c1 e2 07             	shl    $0x7,%edx

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
     689:	51                   	push   %ecx
					success = success && emit_bits( 0x30000000, 5 );

					varbits = disp&0x00FF;
					varbits += 15;
					varbits ^= 2;
					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );
     68a:	81 e2 ff 00 00 00    	and    $0xff,%edx
     690:	d1 e8                	shr    %eax

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
     692:	51                   	push   %ecx
					success = success && emit_bits( 0x30000000, 5 );

					varbits = disp&0x00FF;
					varbits += 15;
					varbits ^= 2;
					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );
     693:	83 e0 7f             	and    $0x7f,%eax

					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
     696:	6a 02                	push   $0x2
     698:	09 c2                	or     %eax,%edx
     69a:	52                   	push   %edx
     69b:	e8 fc ff ff ff       	call   69c <emit_hrust+0x2aa>
     6a0:	83 c4 10             	add    $0x10,%esp
     6a3:	85 c0                	test   %eax,%eax
     6a5:	ba 01 00 00 00       	mov    $0x1,%edx
     6aa:	75 02                	jne    6ae <emit_hrust+0x2bc>
     6ac:	31 d2                	xor    %edx,%edx
				}
			}
			else
				goto INVALID_CODE_HRUST;

			success = success && emit_byte( wrk.indata[position+1], EMIT_BYTE_ADD );
     6ae:	85 d2                	test   %edx,%edx
     6b0:	74 26                	je     6d8 <emit_hrust+0x2e6>
     6b2:	a1 30 00 00 00       	mov    0x30,%eax
     6b7:	52                   	push   %edx
     6b8:	52                   	push   %edx
     6b9:	6a 02                	push   $0x2
     6bb:	0f b6 44 38 01       	movzbl 0x1(%eax,%edi,1),%eax
     6c0:	50                   	push   %eax
     6c1:	e8 fc ff ff ff       	call   6c2 <emit_hrust+0x2d0>
     6c6:	83 c4 10             	add    $0x10,%esp
     6c9:	89 c2                	mov    %eax,%edx
     6cb:	b8 01 00 00 00       	mov    $0x1,%eax
     6d0:	85 d2                	test   %edx,%edx
     6d2:	0f 85 63 03 00 00    	jne    a3b <emit_hrust+0x649>
     6d8:	31 c0                	xor    %eax,%eax
     6da:	e9 5c 03 00 00       	jmp    a3b <emit_hrust+0x649>
		}
		else if( length==1 ) // %000abc
     6df:	83 fe 01             	cmp    $0x1,%esi
     6e2:	75 2d                	jne    711 <emit_hrust+0x31f>
		{
			if( (-8)<=disp && disp<=(-1) )
     6e4:	8d 43 08             	lea    0x8(%ebx),%eax
     6e7:	83 f8 07             	cmp    $0x7,%eax
     6ea:	0f 87 32 03 00 00    	ja     a22 <emit_hrust+0x630>
			{
				success = success && emit_bits( 0x00000000, 3 );
     6f0:	50                   	push   %eax
     6f1:	50                   	push   %eax
     6f2:	6a 03                	push   $0x3
     6f4:	6a 00                	push   $0x0
     6f6:	e8 fc ff ff ff       	call   6f7 <emit_hrust+0x305>
     6fb:	83 c4 10             	add    $0x10,%esp
     6fe:	85 c0                	test   %eax,%eax
     700:	0f 84 bb 00 00 00    	je     7c1 <emit_hrust+0x3cf>
				success = success && emit_bits( disp<<(32-3), 3 );
     706:	51                   	push   %ecx
     707:	89 d8                	mov    %ebx,%eax
     709:	51                   	push   %ecx
     70a:	6a 03                	push   $0x3
     70c:	c1 e0 1d             	shl    $0x1d,%eax
     70f:	eb 33                	jmp    744 <emit_hrust+0x352>
			}
			else
				goto INVALID_CODE_HRUST;
		}
		else if( length==2 )
     711:	83 fe 02             	cmp    $0x2,%esi
     714:	0f 85 ae 00 00 00    	jne    7c8 <emit_hrust+0x3d6>
		{
			if( (-32)<=disp && disp<=(-1) ) // %00111abcde
     71a:	8d 43 20             	lea    0x20(%ebx),%eax
     71d:	83 f8 1f             	cmp    $0x1f,%eax
     720:	77 2a                	ja     74c <emit_hrust+0x35a>
			{
				success = success && emit_bits( 0x38000000, 5 );
     722:	52                   	push   %edx
     723:	52                   	push   %edx
     724:	6a 05                	push   $0x5
     726:	68 00 00 00 38       	push   $0x38000000
     72b:	e8 fc ff ff ff       	call   72c <emit_hrust+0x33a>
     730:	83 c4 10             	add    $0x10,%esp
     733:	85 c0                	test   %eax,%eax
     735:	0f 84 86 00 00 00    	je     7c1 <emit_hrust+0x3cf>
				success = success && emit_bits( disp<<(32-5), 5 );
     73b:	50                   	push   %eax
     73c:	50                   	push   %eax
     73d:	89 d8                	mov    %ebx,%eax
     73f:	6a 05                	push   $0x5
     741:	c1 e0 1b             	shl    $0x1b,%eax
     744:	50                   	push   %eax
     745:	e8 fc ff ff ff       	call   746 <emit_hrust+0x354>
     74a:	eb 63                	jmp    7af <emit_hrust+0x3bd>
			}
			else if( (-256)<=disp && disp<(-32) ) // %00110<byte>
     74c:	8d 83 00 01 00 00    	lea    0x100(%ebx),%eax
     752:	3d df 00 00 00       	cmp    $0xdf,%eax
     757:	77 0b                	ja     764 <emit_hrust+0x372>
			{
				success = success && emit_bits( 0x30000000, 5 );
     759:	51                   	push   %ecx
     75a:	51                   	push   %ecx
     75b:	6a 05                	push   $0x5
     75d:	68 00 00 00 30       	push   $0x30000000
     762:	eb 32                	jmp    796 <emit_hrust+0x3a4>
				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
			}
			else if( (-512)<=disp && disp<(-256) ) // %00101<byte>
     764:	8d 83 00 02 00 00    	lea    0x200(%ebx),%eax
     76a:	3d ff 00 00 00       	cmp    $0xff,%eax
     76f:	77 0b                	ja     77c <emit_hrust+0x38a>
			{
				success = success && emit_bits( 0x28000000, 5 );
     771:	52                   	push   %edx
     772:	52                   	push   %edx
     773:	6a 05                	push   $0x5
     775:	68 00 00 00 28       	push   $0x28000000
     77a:	eb 1a                	jmp    796 <emit_hrust+0x3a4>
				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
			}
			else if( (-768)<=disp && disp<(-512) ) // %00100<byte>
     77c:	8d 83 00 03 00 00    	lea    0x300(%ebx),%eax
     782:	3d ff 00 00 00       	cmp    $0xff,%eax
     787:	0f 87 95 02 00 00    	ja     a22 <emit_hrust+0x630>
			{
				success = success && emit_bits( 0x20000000, 5 );
     78d:	50                   	push   %eax
     78e:	50                   	push   %eax
     78f:	6a 05                	push   $0x5
     791:	68 00 00 00 20       	push   $0x20000000
     796:	e8 fc ff ff ff       	call   797 <emit_hrust+0x3a5>
     79b:	83 c4 10             	add    $0x10,%esp
     79e:	85 c0                	test   %eax,%eax
     7a0:	74 1f                	je     7c1 <emit_hrust+0x3cf>
				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
     7a2:	51                   	push   %ecx
     7a3:	0f b6 c3             	movzbl %bl,%eax
     7a6:	51                   	push   %ecx
     7a7:	6a 02                	push   $0x2
     7a9:	50                   	push   %eax
     7aa:	e8 fc ff ff ff       	call   7ab <emit_hrust+0x3b9>
     7af:	89 c2                	mov    %eax,%edx
     7b1:	83 c4 10             	add    $0x10,%esp
     7b4:	85 d2                	test   %edx,%edx
     7b6:	b8 01 00 00 00       	mov    $0x1,%eax
     7bb:	0f 85 76 02 00 00    	jne    a37 <emit_hrust+0x645>
     7c1:	31 c0                	xor    %eax,%eax
     7c3:	e9 6f 02 00 00       	jmp    a37 <emit_hrust+0x645>
			}
			else
				goto INVALID_CODE_HRUST;
		}
		else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )
     7c8:	8d 46 fd             	lea    -0x3(%esi),%eax
     7cb:	3d fc 0e 00 00       	cmp    $0xefc,%eax
     7d0:	0f 87 4c 02 00 00    	ja     a22 <emit_hrust+0x630>
     7d6:	81 fb 00 00 ff ff    	cmp    $0xffff0000,%ebx
     7dc:	0f 8c 40 02 00 00    	jl     a22 <emit_hrust+0x630>
     7e2:	85 db                	test   %ebx,%ebx
     7e4:	0f 89 38 02 00 00    	jns    a22 <emit_hrust+0x630>
				//  -2049..-4096  (F7FF..F000) - 4
				//  -4097..-8192  (EFFF..E000) - 5
				//  -8193..-16384 (DFFF..C000) - 6
				// -16385..-32768 (BFFF..8000) - 7
				// -32769..-65536 (7FFF..0000) - 8
			if( disp<(-512) )
     7ea:	81 fb 00 fe ff ff    	cmp    $0xfffffe00,%ebx
     7f0:	ba 01 00 00 00       	mov    $0x1,%edx
     7f5:	7d 62                	jge    859 <emit_hrust+0x467>
			{
				varbits = 1024;
				varlen  = 2;
				while( (ULONG)(-disp) > varbits )
     7f7:	89 da                	mov    %ebx,%edx
				//  -2049..-4096  (F7FF..F000) - 4
				//  -4097..-8192  (EFFF..E000) - 5
				//  -8193..-16384 (DFFF..C000) - 6
				// -16385..-32768 (BFFF..8000) - 7
				// -32769..-65536 (7FFF..0000) - 8
			if( disp<(-512) )
     7f9:	b8 00 04 00 00       	mov    $0x400,%eax
     7fe:	c7 45 d0 02 00 00 00 	movl   $0x2,-0x30(%ebp)
			{
				varbits = 1024;
				varlen  = 2;
				while( (ULONG)(-disp) > varbits )
     805:	f7 da                	neg    %edx
     807:	eb 05                	jmp    80e <emit_hrust+0x41c>
				{
					varbits <<= 1;
					varlen++;
     809:	ff 45 d0             	incl   -0x30(%ebp)
			{
				varbits = 1024;
				varlen  = 2;
				while( (ULONG)(-disp) > varbits )
				{
					varbits <<= 1;
     80c:	01 c0                	add    %eax,%eax
				// -32769..-65536 (7FFF..0000) - 8
			if( disp<(-512) )
			{
				varbits = 1024;
				varlen  = 2;
				while( (ULONG)(-disp) > varbits )
     80e:	39 c2                	cmp    %eax,%edx
     810:	77 f7                	ja     809 <emit_hrust+0x417>
     812:	ba 01 00 00 00       	mov    $0x1,%edx
     817:	eb 38                	jmp    851 <emit_hrust+0x45f>
				}

				// emit expansion codes, if necessary: %00110<FE>
				while( varlen>expbitlen )
				{
					success = success && emit_bits( 0x30000000, 5 );
     819:	85 d2                	test   %edx,%edx
     81b:	74 2f                	je     84c <emit_hrust+0x45a>
     81d:	52                   	push   %edx
     81e:	52                   	push   %edx
     81f:	6a 05                	push   $0x5
     821:	68 00 00 00 30       	push   $0x30000000
     826:	e8 fc ff ff ff       	call   827 <emit_hrust+0x435>
     82b:	83 c4 10             	add    $0x10,%esp
     82e:	85 c0                	test   %eax,%eax
     830:	74 1a                	je     84c <emit_hrust+0x45a>
					success = success && emit_byte( 0x00FE, EMIT_BYTE_ADD );
     832:	50                   	push   %eax
     833:	50                   	push   %eax
     834:	6a 02                	push   $0x2
     836:	68 fe 00 00 00       	push   $0xfe
     83b:	e8 fc ff ff ff       	call   83c <emit_hrust+0x44a>
     840:	83 c4 10             	add    $0x10,%esp
     843:	ba 01 00 00 00       	mov    $0x1,%edx
     848:	85 c0                	test   %eax,%eax
     84a:	75 02                	jne    84e <emit_hrust+0x45c>
     84c:	31 d2                	xor    %edx,%edx
					#ifdef DBG
						printf("expansion\n");
					#endif

					expbitlen++;
     84e:	ff 45 d4             	incl   -0x2c(%ebp)
					varbits <<= 1;
					varlen++;
				}

				// emit expansion codes, if necessary: %00110<FE>
				while( varlen>expbitlen )
     851:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     854:	39 45 d0             	cmp    %eax,-0x30(%ebp)
     857:	77 c0                	ja     819 <emit_hrust+0x427>



			// emit length

			if( length<=15 ) // 3..15
     859:	83 fe 0f             	cmp    $0xf,%esi
     85c:	0f 8f 8b 00 00 00    	jg     8ed <emit_hrust+0x4fb>
			{
				success = success && emit_bits( 0, 1 );
     862:	85 d2                	test   %edx,%edx
     864:	74 17                	je     87d <emit_hrust+0x48b>
     866:	51                   	push   %ecx
     867:	51                   	push   %ecx
     868:	6a 01                	push   $0x1
     86a:	6a 00                	push   $0x0
     86c:	e8 fc ff ff ff       	call   86d <emit_hrust+0x47b>
     871:	83 c4 10             	add    $0x10,%esp
     874:	ba 01 00 00 00       	mov    $0x1,%edx
     879:	85 c0                	test   %eax,%eax
     87b:	75 02                	jne    87f <emit_hrust+0x48d>
     87d:	31 d2                	xor    %edx,%edx

				if( length==3 )
     87f:	83 fe 03             	cmp    $0x3,%esi
     882:	75 13                	jne    897 <emit_hrust+0x4a5>
				{
					success = success && emit_bits( 0x80000000, 2 ); // %010
     884:	85 d2                	test   %edx,%edx
     886:	0f 84 dc 00 00 00    	je     968 <emit_hrust+0x576>
     88c:	52                   	push   %edx
     88d:	52                   	push   %edx
     88e:	6a 02                	push   $0x2
     890:	68 00 00 00 80       	push   $0x80000000
     895:	eb 7e                	jmp    915 <emit_hrust+0x523>
				else
				{
					varlen  = length/3;
					varbits = length%3;

					success = success && emit_bits( 0xFFFFFFFF, varlen<<1 );
     897:	85 d2                	test   %edx,%edx
     899:	74 27                	je     8c2 <emit_hrust+0x4d0>
     89b:	50                   	push   %eax
     89c:	ba 03 00 00 00       	mov    $0x3,%edx
     8a1:	50                   	push   %eax
     8a2:	89 f0                	mov    %esi,%eax
     8a4:	89 d1                	mov    %edx,%ecx
     8a6:	99                   	cltd   
     8a7:	f7 f9                	idiv   %ecx
     8a9:	89 45 d0             	mov    %eax,-0x30(%ebp)
     8ac:	01 c0                	add    %eax,%eax
     8ae:	50                   	push   %eax
     8af:	6a ff                	push   $0xffffffff
     8b1:	e8 fc ff ff ff       	call   8b2 <emit_hrust+0x4c0>
     8b6:	83 c4 10             	add    $0x10,%esp
     8b9:	ba 01 00 00 00       	mov    $0x1,%edx
     8be:	85 c0                	test   %eax,%eax
     8c0:	75 02                	jne    8c4 <emit_hrust+0x4d2>
     8c2:	31 d2                	xor    %edx,%edx

					if( length!=15 )
     8c4:	83 fe 0f             	cmp    $0xf,%esi
				else
				{
					varlen  = length/3;
					varbits = length%3;

					success = success && emit_bits( 0xFFFFFFFF, varlen<<1 );
     8c7:	89 d0                	mov    %edx,%eax

					if( length!=15 )
     8c9:	0f 84 9b 00 00 00    	je     96a <emit_hrust+0x578>
						success = success && emit_bits( varbits<<(32-2), 2 );
     8cf:	85 d2                	test   %edx,%edx
     8d1:	0f 84 91 00 00 00    	je     968 <emit_hrust+0x576>
     8d7:	ba 03 00 00 00       	mov    $0x3,%edx
     8dc:	89 f0                	mov    %esi,%eax
     8de:	51                   	push   %ecx
     8df:	51                   	push   %ecx
     8e0:	89 d1                	mov    %edx,%ecx
     8e2:	99                   	cltd   
     8e3:	f7 f9                	idiv   %ecx
     8e5:	6a 02                	push   $0x2
     8e7:	c1 e2 1e             	shl    $0x1e,%edx
     8ea:	52                   	push   %edx
     8eb:	eb 28                	jmp    915 <emit_hrust+0x523>
				}
			}
			else if( length<=127 ) // 16..127: %0110000abcdefg
     8ed:	83 fe 7f             	cmp    $0x7f,%esi
     8f0:	7f 2a                	jg     91c <emit_hrust+0x52a>
			{
				success = success && emit_bits( 0x60000000, 7 );
     8f2:	85 d2                	test   %edx,%edx
     8f4:	74 72                	je     968 <emit_hrust+0x576>
     8f6:	52                   	push   %edx
     8f7:	52                   	push   %edx
     8f8:	6a 07                	push   $0x7
     8fa:	68 00 00 00 60       	push   $0x60000000
     8ff:	e8 fc ff ff ff       	call   900 <emit_hrust+0x50e>
     904:	83 c4 10             	add    $0x10,%esp
     907:	85 c0                	test   %eax,%eax
     909:	74 5d                	je     968 <emit_hrust+0x576>
				success = success && emit_bits( length<<(32-7), 7 );
     90b:	50                   	push   %eax
     90c:	50                   	push   %eax
     90d:	89 f0                	mov    %esi,%eax
     90f:	6a 07                	push   $0x7
     911:	c1 e0 19             	shl    $0x19,%eax
     914:	50                   	push   %eax
     915:	e8 fc ff ff ff       	call   916 <emit_hrust+0x524>
     91a:	eb 3e                	jmp    95a <emit_hrust+0x568>
			}
			else // 128..3839
			{
				success = success && emit_bits( 0x60000000, 7 );
     91c:	85 d2                	test   %edx,%edx
     91e:	74 48                	je     968 <emit_hrust+0x576>
     920:	51                   	push   %ecx
     921:	51                   	push   %ecx
     922:	6a 07                	push   $0x7
     924:	68 00 00 00 60       	push   $0x60000000
     929:	e8 fc ff ff ff       	call   92a <emit_hrust+0x538>
     92e:	83 c4 10             	add    $0x10,%esp
     931:	85 c0                	test   %eax,%eax
     933:	74 33                	je     968 <emit_hrust+0x576>
				success = success && emit_bits( length<<(32-15), 7 );
     935:	52                   	push   %edx
     936:	89 f0                	mov    %esi,%eax
     938:	52                   	push   %edx
     939:	6a 07                	push   $0x7
     93b:	c1 e0 11             	shl    $0x11,%eax
     93e:	50                   	push   %eax
     93f:	e8 fc ff ff ff       	call   940 <emit_hrust+0x54e>
     944:	83 c4 10             	add    $0x10,%esp
     947:	85 c0                	test   %eax,%eax
     949:	74 1d                	je     968 <emit_hrust+0x576>
				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );
     94b:	50                   	push   %eax
     94c:	89 f2                	mov    %esi,%edx
     94e:	50                   	push   %eax
     94f:	0f b6 c2             	movzbl %dl,%eax
     952:	6a 02                	push   $0x2
     954:	50                   	push   %eax
     955:	e8 fc ff ff ff       	call   956 <emit_hrust+0x564>
     95a:	89 c2                	mov    %eax,%edx
     95c:	83 c4 10             	add    $0x10,%esp
     95f:	85 d2                	test   %edx,%edx
     961:	b8 01 00 00 00       	mov    $0x1,%eax
     966:	75 02                	jne    96a <emit_hrust+0x578>
     968:	31 c0                	xor    %eax,%eax
			}


			// emit displacement
			if( (-32)<=disp ) // ffe0..ffff: %10abcde
     96a:	83 fb e0             	cmp    $0xffffffe0,%ebx
     96d:	7c 32                	jl     9a1 <emit_hrust+0x5af>
			{
				success = success && emit_bits( 0x80000000, 2 );
     96f:	85 c0                	test   %eax,%eax
     971:	0f 84 a7 00 00 00    	je     a1e <emit_hrust+0x62c>
     977:	51                   	push   %ecx
     978:	51                   	push   %ecx
     979:	6a 02                	push   $0x2
     97b:	68 00 00 00 80       	push   $0x80000000
     980:	e8 fc ff ff ff       	call   981 <emit_hrust+0x58f>
     985:	83 c4 10             	add    $0x10,%esp
     988:	85 c0                	test   %eax,%eax
     98a:	0f 84 8e 00 00 00    	je     a1e <emit_hrust+0x62c>
				success = success && emit_bits( disp<<(32-5), 5 );
     990:	52                   	push   %edx
     991:	89 d8                	mov    %ebx,%eax
     993:	52                   	push   %edx
     994:	6a 05                	push   $0x5
     996:	c1 e0 1b             	shl    $0x1b,%eax
     999:	50                   	push   %eax
     99a:	e8 fc ff ff ff       	call   99b <emit_hrust+0x5a9>
     99f:	eb 6f                	jmp    a10 <emit_hrust+0x61e>
			}
			else if( (-256)<=disp ) // ff00..ffdf: %01<byte>
     9a1:	81 fb 00 ff ff ff    	cmp    $0xffffff00,%ebx
     9a7:	7c 0f                	jl     9b8 <emit_hrust+0x5c6>
			{
				success = success && emit_bits( 0x40000000, 2 );
     9a9:	85 c0                	test   %eax,%eax
     9ab:	74 71                	je     a1e <emit_hrust+0x62c>
     9ad:	50                   	push   %eax
     9ae:	50                   	push   %eax
     9af:	6a 02                	push   $0x2
     9b1:	68 00 00 00 40       	push   $0x40000000
     9b6:	eb 3f                	jmp    9f7 <emit_hrust+0x605>
				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );
			}
			else if( (-512)<=disp ) // fe00..feff: %00<byte>
     9b8:	81 fb 00 fe ff ff    	cmp    $0xfffffe00,%ebx
     9be:	7c 0c                	jl     9cc <emit_hrust+0x5da>
			{
				success = success && emit_bits( 0x00000000, 2 );
     9c0:	85 c0                	test   %eax,%eax
     9c2:	74 5a                	je     a1e <emit_hrust+0x62c>
     9c4:	51                   	push   %ecx
     9c5:	51                   	push   %ecx
     9c6:	6a 02                	push   $0x2
     9c8:	6a 00                	push   $0x0
     9ca:	eb 2b                	jmp    9f7 <emit_hrust+0x605>
			}
			else // variable code length: [-65536..-512)
			{

				// displacement itself: %11ab[cdefgh]<byte>
				success = success && emit_bits( 0xC0000000, 2 );
     9cc:	85 c0                	test   %eax,%eax
     9ce:	74 4e                	je     a1e <emit_hrust+0x62c>
     9d0:	52                   	push   %edx
     9d1:	52                   	push   %edx
     9d2:	6a 02                	push   $0x2
     9d4:	68 00 00 00 c0       	push   $0xc0000000
     9d9:	e8 fc ff ff ff       	call   9da <emit_hrust+0x5e8>
     9de:	83 c4 10             	add    $0x10,%esp
     9e1:	85 c0                	test   %eax,%eax
     9e3:	74 39                	je     a1e <emit_hrust+0x62c>
				success = success && emit_bits( disp<<(24-expbitlen), expbitlen );
     9e5:	50                   	push   %eax
     9e6:	b9 18 00 00 00       	mov    $0x18,%ecx
     9eb:	50                   	push   %eax
     9ec:	89 d8                	mov    %ebx,%eax
     9ee:	ff 75 d4             	pushl  -0x2c(%ebp)
     9f1:	2b 4d d4             	sub    -0x2c(%ebp),%ecx
     9f4:	d3 e0                	shl    %cl,%eax
     9f6:	50                   	push   %eax
     9f7:	e8 fc ff ff ff       	call   9f8 <emit_hrust+0x606>
     9fc:	83 c4 10             	add    $0x10,%esp
     9ff:	85 c0                	test   %eax,%eax
     a01:	74 1b                	je     a1e <emit_hrust+0x62c>
				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );
     a03:	51                   	push   %ecx
     a04:	0f b6 c3             	movzbl %bl,%eax
     a07:	51                   	push   %ecx
     a08:	6a 02                	push   $0x2
     a0a:	50                   	push   %eax
     a0b:	e8 fc ff ff ff       	call   a0c <emit_hrust+0x61a>
     a10:	89 c2                	mov    %eax,%edx
     a12:	83 c4 10             	add    $0x10,%esp
     a15:	85 d2                	test   %edx,%edx
     a17:	b8 01 00 00 00       	mov    $0x1,%eax
     a1c:	75 15                	jne    a33 <emit_hrust+0x641>
     a1e:	31 c0                	xor    %eax,%eax
     a20:	eb 11                	jmp    a33 <emit_hrust+0x641>
			}
		}
		else
		{
INVALID_CODE_HRUST:
			printf("mhmt-emit.c:emit_hrust() - invalid code: length=%d, displacement=%d\n",length,disp);
     a22:	52                   	push   %edx
     a23:	53                   	push   %ebx
     a24:	56                   	push   %esi
     a25:	68 82 01 00 00       	push   $0x182
     a2a:	e8 fc ff ff ff       	call   a2b <emit_hrust+0x639>
     a2f:	31 c0                	xor    %eax,%eax
     a31:	eb 73                	jmp    aa6 <emit_hrust+0x6b4>
		#endif


		if( max_disp > disp ) max_disp = disp;

		if( length>0 ) // account for negative length
     a33:	85 f6                	test   %esi,%esi
     a35:	7e 04                	jle    a3b <emit_hrust+0x649>
			position += length;
     a37:	01 f7                	add    %esi,%edi
     a39:	eb 02                	jmp    a3d <emit_hrust+0x64b>
		else
			position -= length;
     a3b:	29 f7                	sub    %esi,%edi
     a3d:	39 5d cc             	cmp    %ebx,-0x34(%ebp)
     a40:	7e 03                	jle    a45 <emit_hrust+0x653>
     a42:	89 5d cc             	mov    %ebx,-0x34(%ebp)
	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
     a45:	84 c0                	test   %al,%al
     a47:	74 09                	je     a52 <emit_hrust+0x660>
     a49:	3b 7d 0c             	cmp    0xc(%ebp),%edi
     a4c:	0f 82 c1 fa ff ff    	jb     513 <emit_hrust+0x121>
		else
			position -= length;
	}

	// stop-code: %0110_0000_0011_11
	success = success && emit_bits( 0x603C0000, 14 );
     a52:	85 c0                	test   %eax,%eax
     a54:	74 57                	je     aad <emit_hrust+0x6bb>
     a56:	50                   	push   %eax
     a57:	50                   	push   %eax
     a58:	6a 0e                	push   $0xe
     a5a:	68 00 00 3c 60       	push   $0x603c0000
     a5f:	e8 fc ff ff ff       	call   a60 <emit_hrust+0x66e>
     a64:	83 c4 10             	add    $0x10,%esp
     a67:	85 c0                	test   %eax,%eax
     a69:	74 40                	je     aab <emit_hrust+0x6b9>

	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()
     a6b:	57                   	push   %edi
     a6c:	57                   	push   %edi
     a6d:	6a 00                	push   $0x0
     a6f:	6a 00                	push   $0x0
     a71:	e8 fc ff ff ff       	call   a72 <emit_hrust+0x680>
     a76:	83 c4 10             	add    $0x10,%esp
     a79:	85 c0                	test   %eax,%eax
     a7b:	74 2e                	je     aab <emit_hrust+0x6b9>
	success = success && emit_file( NULL, EMIT_FILE_FINISH );
     a7d:	56                   	push   %esi
     a7e:	56                   	push   %esi
     a7f:	6a 00                	push   $0x0
     a81:	6a 00                	push   $0x0
     a83:	e8 fc ff ff ff       	call   a84 <emit_hrust+0x692>
     a88:	83 c4 10             	add    $0x10,%esp
     a8b:	85 c0                	test   %eax,%eax
     a8d:	74 1c                	je     aab <emit_hrust+0x6b9>

	if( success )
	{
		printf("Maximum displacement actually used is %d.\n",-max_disp);
     a8f:	8b 45 cc             	mov    -0x34(%ebp),%eax
     a92:	53                   	push   %ebx
     a93:	53                   	push   %ebx
     a94:	f7 d8                	neg    %eax
     a96:	50                   	push   %eax
     a97:	68 c7 01 00 00       	push   $0x1c7
     a9c:	e8 fc ff ff ff       	call   a9d <emit_hrust+0x6ab>
     aa1:	b8 01 00 00 00       	mov    $0x1,%eax
     aa6:	83 c4 10             	add    $0x10,%esp
     aa9:	eb 02                	jmp    aad <emit_hrust+0x6bb>
     aab:	31 c0                	xor    %eax,%eax
		// TODO: patch packed length in file, if zx header
	}


	return success;
}
     aad:	8d 65 f4             	lea    -0xc(%ebp),%esp
     ab0:	5b                   	pop    %ebx
     ab1:	5e                   	pop    %esi
     ab2:	5f                   	pop    %edi
     ab3:	5d                   	pop    %ebp
     ab4:	c3                   	ret    

00000ab5 <emit_hrum>:



// actually generate output file from optimal chain - hrum version
ULONG emit_hrum(struct optchain * optch, ULONG actual_len)
{
     ab5:	55                   	push   %ebp
     ab6:	89 e5                	mov    %esp,%ebp
     ab8:	57                   	push   %edi
     ab9:	56                   	push   %esi
     aba:	53                   	push   %ebx
     abb:	83 ec 1c             	sub    $0x1c,%esp

	max_disp = 0;


	// some checks
	if( !optch )
     abe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
     ac2:	75 0d                	jne    ad1 <emit_hrum+0x1c>
	{
		printf("mhmt-emit.c:emit_hrum() - NULL passed!\n");
     ac4:	83 ec 0c             	sub    $0xc,%esp
     ac7:	68 f2 01 00 00       	push   $0x1f2
     acc:	e9 da 00 00 00       	jmp    bab <emit_hrum+0xf6>
		return 0;
	}

	// initialize
	success = success && emit_file(NULL, EMIT_FILE_INIT);
     ad1:	51                   	push   %ecx
     ad2:	51                   	push   %ecx
     ad3:	6a ff                	push   $0xffffffff
     ad5:	6a 00                	push   $0x0
     ad7:	e8 fc ff ff ff       	call   ad8 <emit_hrum+0x23>
     adc:	83 c4 10             	add    $0x10,%esp
     adf:	85 c0                	test   %eax,%eax
     ae1:	74 29                	je     b0c <emit_hrum+0x57>

	success = success && emit_byte(0, EMIT_BYTE_INIT);
     ae3:	52                   	push   %edx
     ae4:	52                   	push   %edx
     ae5:	6a 00                	push   $0x0
     ae7:	6a 00                	push   $0x0
     ae9:	e8 fc ff ff ff       	call   aea <emit_hrum+0x35>
     aee:	83 c4 10             	add    $0x10,%esp
     af1:	85 c0                	test   %eax,%eax
     af3:	74 17                	je     b0c <emit_hrum+0x57>

	success = success && emit_bits(0, EMIT_BITS_INIT);
     af5:	50                   	push   %eax
     af6:	50                   	push   %eax
     af7:	6a ff                	push   $0xffffffff
     af9:	6a 00                	push   $0x0
     afb:	e8 fc ff ff ff       	call   afc <emit_hrum+0x47>
     b00:	83 c4 10             	add    $0x10,%esp
     b03:	ba 01 00 00 00       	mov    $0x1,%edx
     b08:	85 c0                	test   %eax,%eax
     b0a:	75 02                	jne    b0e <emit_hrum+0x59>
     b0c:	31 d2                	xor    %edx,%edx


	// manage zx header info
	if( wrk.zxheader )
     b0e:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
	// initialize
	success = success && emit_file(NULL, EMIT_FILE_INIT);

	success = success && emit_byte(0, EMIT_BYTE_INIT);

	success = success && emit_bits(0, EMIT_BITS_INIT);
     b15:	89 d0                	mov    %edx,%eax


	// manage zx header info
	if( wrk.zxheader )
     b17:	74 41                	je     b5a <emit_hrum+0xa5>
	{
        success = success && emit_file( &wrk.indata[wrk.inlen-5], 5);
     b19:	85 d2                	test   %edx,%edx
     b1b:	74 3b                	je     b58 <emit_hrum+0xa3>
     b1d:	a1 34 00 00 00       	mov    0x34,%eax
     b22:	57                   	push   %edi
     b23:	57                   	push   %edi
     b24:	6a 05                	push   $0x5
     b26:	83 e8 05             	sub    $0x5,%eax
     b29:	03 05 30 00 00 00    	add    0x30,%eax
     b2f:	50                   	push   %eax
     b30:	e8 fc ff ff ff       	call   b31 <emit_hrum+0x7c>
     b35:	83 c4 10             	add    $0x10,%esp
     b38:	85 c0                	test   %eax,%eax
     b3a:	74 1c                	je     b58 <emit_hrum+0xa3>
		success = success && emit_file( (UBYTE*)"\020\020", 2); // 0x10, 0x10
     b3c:	56                   	push   %esi
     b3d:	56                   	push   %esi
     b3e:	6a 02                	push   $0x2
     b40:	68 19 02 00 00       	push   $0x219
     b45:	e8 fc ff ff ff       	call   b46 <emit_hrum+0x91>
     b4a:	83 c4 10             	add    $0x10,%esp
     b4d:	89 c2                	mov    %eax,%edx
     b4f:	b8 01 00 00 00       	mov    $0x1,%eax
     b54:	85 d2                	test   %edx,%edx
     b56:	75 02                	jne    b5a <emit_hrum+0xa5>
     b58:	31 c0                	xor    %eax,%eax
	}

	// schedule first byte to be placed just after first bitstream word
	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);
     b5a:	85 c0                	test   %eax,%eax
     b5c:	74 1e                	je     b7c <emit_hrum+0xc7>
     b5e:	a1 30 00 00 00       	mov    0x30,%eax
     b63:	53                   	push   %ebx
     b64:	53                   	push   %ebx
     b65:	6a 02                	push   $0x2
     b67:	0f b6 00             	movzbl (%eax),%eax
     b6a:	50                   	push   %eax
     b6b:	e8 fc ff ff ff       	call   b6c <emit_hrum+0xb7>
     b70:	83 c4 10             	add    $0x10,%esp
     b73:	ba 01 00 00 00       	mov    $0x1,%edx
     b78:	85 c0                	test   %eax,%eax
     b7a:	75 02                	jne    b7e <emit_hrum+0xc9>
     b7c:	31 d2                	xor    %edx,%edx
     b7e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     b85:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
     b8c:	e9 3e 02 00 00       	jmp    dcf <emit_hrum+0x31a>
	{
		length = optch[position].code.length;
     b91:	8b 45 e0             	mov    -0x20(%ebp),%eax
     b94:	c1 e0 04             	shl    $0x4,%eax
     b97:	03 45 08             	add    0x8(%ebp),%eax
     b9a:	8b 30                	mov    (%eax),%esi
		disp   = optch[position].code.disp;
     b9c:	8b 58 04             	mov    0x4(%eax),%ebx

		if( length==0 )
     b9f:	85 f6                	test   %esi,%esi
     ba1:	75 12                	jne    bb5 <emit_hrum+0x100>
		{
			printf("mhmt-emit.c:emit_hrum() - encountered stop-code in optimal chain before emitting all data!\n");
     ba3:	83 ec 0c             	sub    $0xc,%esp
     ba6:	68 1c 02 00 00       	push   $0x21c
     bab:	e8 fc ff ff ff       	call   bac <emit_hrum+0xf7>
     bb0:	e9 10 02 00 00       	jmp    dc5 <emit_hrum+0x310>
			return 0;
		}
		else if( length==1 ) // either copy-byte or len=1 code
     bb5:	83 fe 01             	cmp    $0x1,%esi
     bb8:	75 7c                	jne    c36 <emit_hrum+0x181>
		{
			if( disp==0 ) // copy-byte (%1<byte>)
     bba:	85 db                	test   %ebx,%ebx
     bbc:	75 42                	jne    c00 <emit_hrum+0x14b>
			{
				success = success && emit_bits( 0x80000000, 1 );
     bbe:	51                   	push   %ecx
     bbf:	51                   	push   %ecx
     bc0:	6a 01                	push   $0x1
     bc2:	68 00 00 00 80       	push   $0x80000000
     bc7:	e8 fc ff ff ff       	call   bc8 <emit_hrum+0x113>
     bcc:	83 c4 10             	add    $0x10,%esp
     bcf:	85 c0                	test   %eax,%eax
     bd1:	74 26                	je     bf9 <emit_hrum+0x144>
				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );
     bd3:	52                   	push   %edx
     bd4:	a1 30 00 00 00       	mov    0x30,%eax
     bd9:	52                   	push   %edx
     bda:	8b 55 e0             	mov    -0x20(%ebp),%edx
     bdd:	6a 02                	push   $0x2
     bdf:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
     be3:	50                   	push   %eax
     be4:	e8 fc ff ff ff       	call   be5 <emit_hrum+0x130>
     be9:	83 c4 10             	add    $0x10,%esp
     bec:	ba 01 00 00 00       	mov    $0x1,%edx
     bf1:	85 c0                	test   %eax,%eax
     bf3:	0f 85 d3 01 00 00    	jne    dcc <emit_hrum+0x317>
     bf9:	31 d2                	xor    %edx,%edx
     bfb:	e9 cc 01 00 00       	jmp    dcc <emit_hrum+0x317>
			}
			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)
     c00:	8d 43 08             	lea    0x8(%ebx),%eax
     c03:	83 f8 07             	cmp    $0x7,%eax
     c06:	0f 87 ac 01 00 00    	ja     db8 <emit_hrum+0x303>
			{
				success = success && emit_bits( 0x00000000,   3 );
     c0c:	50                   	push   %eax
     c0d:	50                   	push   %eax
     c0e:	6a 03                	push   $0x3
     c10:	6a 00                	push   $0x0
     c12:	e8 fc ff ff ff       	call   c13 <emit_hrum+0x15e>
     c17:	83 c4 10             	add    $0x10,%esp
     c1a:	85 c0                	test   %eax,%eax
     c1c:	0f 84 8d 01 00 00    	je     daf <emit_hrum+0x2fa>
				success = success && emit_bits( disp<<(32-3), 3 );
     c22:	57                   	push   %edi
     c23:	89 d8                	mov    %ebx,%eax
     c25:	57                   	push   %edi
     c26:	6a 03                	push   $0x3
     c28:	c1 e0 1d             	shl    $0x1d,%eax
     c2b:	50                   	push   %eax
     c2c:	e8 fc ff ff ff       	call   c2d <emit_hrum+0x178>
     c31:	e9 6d 01 00 00       	jmp    da3 <emit_hrum+0x2ee>
				if( max_disp > disp ) max_disp = disp;
			}
			else
				goto INVALID_CODE_HRUM;
		}
		else if( length==2 )
     c36:	83 fe 02             	cmp    $0x2,%esi
     c39:	75 1f                	jne    c5a <emit_hrum+0x1a5>
		{
			if( (-256)<=disp && disp<=(-1) ) // %001<byte>
     c3b:	8d 83 00 01 00 00    	lea    0x100(%ebx),%eax
     c41:	3d ff 00 00 00       	cmp    $0xff,%eax
     c46:	0f 87 6c 01 00 00    	ja     db8 <emit_hrum+0x303>
			{
				success = success && emit_bits( 0x20000000, 3 );
     c4c:	51                   	push   %ecx
     c4d:	51                   	push   %ecx
     c4e:	6a 03                	push   $0x3
     c50:	68 00 00 00 20       	push   $0x20000000
     c55:	e9 30 01 00 00       	jmp    d8a <emit_hrum+0x2d5>
				if( max_disp > disp ) max_disp = disp;
			}
			else
				goto INVALID_CODE_HRUM;
		}
		else if( 3<=length && length<=255 )
     c5a:	8d 46 fd             	lea    -0x3(%esi),%eax
     c5d:	3d fc 00 00 00       	cmp    $0xfc,%eax
     c62:	0f 87 50 01 00 00    	ja     db8 <emit_hrum+0x303>
		{
			// length coding
			if( length==3 )
     c68:	83 fe 03             	cmp    $0x3,%esi
     c6b:	75 1e                	jne    c8b <emit_hrum+0x1d6>
			{
				success = success && emit_bits( 0x40000000, 3 );
     c6d:	52                   	push   %edx
     c6e:	52                   	push   %edx
     c6f:	6a 03                	push   $0x3
     c71:	68 00 00 00 40       	push   $0x40000000
     c76:	e8 fc ff ff ff       	call   c77 <emit_hrum+0x1c2>
     c7b:	83 c4 10             	add    $0x10,%esp
     c7e:	85 c0                	test   %eax,%eax
     c80:	0f 95 c0             	setne  %al
     c83:	0f b6 c0             	movzbl %al,%eax
     c86:	e9 af 00 00 00       	jmp    d3a <emit_hrum+0x285>
			}
			else if( length<=15 )
     c8b:	83 fe 0f             	cmp    $0xf,%esi
     c8e:	7f 76                	jg     d06 <emit_hrum+0x251>
			{
				varlen=2;

				varbits = (length % 3)<<30; // low 2 bits (except for length==15)
				if( length==15 ) varbits = 0xC0000000;
     c90:	75 07                	jne    c99 <emit_hrum+0x1e4>
     c92:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
     c97:	eb 19                	jmp    cb2 <emit_hrum+0x1fd>
			}
			else if( length<=15 )
			{
				varlen=2;

				varbits = (length % 3)<<30; // low 2 bits (except for length==15)
     c99:	89 f0                	mov    %esi,%eax
     c9b:	bf 03 00 00 00       	mov    $0x3,%edi
     ca0:	99                   	cltd   
     ca1:	f7 ff                	idiv   %edi
     ca3:	89 d7                	mov    %edx,%edi

	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()
	success = success && emit_file( NULL, EMIT_FILE_FINISH );

	if( success )
		printf("Maximum displacement actually used is %d.\n",-max_disp);
     ca5:	ba 02 00 00 00       	mov    $0x2,%edx
			}
			else if( length<=15 )
			{
				varlen=2;

				varbits = (length % 3)<<30; // low 2 bits (except for length==15)
     caa:	c1 e7 1e             	shl    $0x1e,%edi
				if( length==15 ) varbits = 0xC0000000;

				if( length>=6 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cad:	83 fe 05             	cmp    $0x5,%esi
     cb0:	7e 2e                	jle    ce0 <emit_hrum+0x22b>
     cb2:	c1 ef 02             	shr    $0x2,%edi
				if( length>=9 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cb5:	ba 04 00 00 00       	mov    $0x4,%edx
				varlen=2;

				varbits = (length % 3)<<30; // low 2 bits (except for length==15)
				if( length==15 ) varbits = 0xC0000000;

				if( length>=6 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cba:	81 cf 00 00 00 c0    	or     $0xc0000000,%edi
				if( length>=9 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cc0:	83 fe 08             	cmp    $0x8,%esi
     cc3:	7e 1b                	jle    ce0 <emit_hrum+0x22b>
     cc5:	c1 ef 02             	shr    $0x2,%edi
				if( length>=12) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cc8:	b2 06                	mov    $0x6,%dl

				varbits = (length % 3)<<30; // low 2 bits (except for length==15)
				if( length==15 ) varbits = 0xC0000000;

				if( length>=6 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
				if( length>=9 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cca:	81 cf 00 00 00 c0    	or     $0xc0000000,%edi
				if( length>=12) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }
     cd0:	83 fe 0b             	cmp    $0xb,%esi
     cd3:	7e 0b                	jle    ce0 <emit_hrum+0x22b>
     cd5:	c1 ef 02             	shr    $0x2,%edi
     cd8:	b2 08                	mov    $0x8,%dl
     cda:	81 cf 00 00 00 c0    	or     $0xc0000000,%edi

				success = success && emit_bits( 0x60000000, 3 );
     ce0:	50                   	push   %eax
     ce1:	50                   	push   %eax
     ce2:	6a 03                	push   $0x3
     ce4:	68 00 00 00 60       	push   $0x60000000
     ce9:	89 55 dc             	mov    %edx,-0x24(%ebp)
     cec:	e8 fc ff ff ff       	call   ced <emit_hrum+0x238>
     cf1:	83 c4 10             	add    $0x10,%esp
     cf4:	8b 55 dc             	mov    -0x24(%ebp),%edx
     cf7:	85 c0                	test   %eax,%eax
     cf9:	74 3d                	je     d38 <emit_hrum+0x283>
				success = success && emit_bits( varbits, varlen );
     cfb:	51                   	push   %ecx
     cfc:	51                   	push   %ecx
     cfd:	52                   	push   %edx
     cfe:	57                   	push   %edi
     cff:	e8 fc ff ff ff       	call   d00 <emit_hrum+0x24b>
     d04:	eb 24                	jmp    d2a <emit_hrum+0x275>
			}
			else // 15<length<=255: %01100<len>
			{
				success = success && emit_bits( 0x60000000, 5 );
     d06:	52                   	push   %edx
     d07:	52                   	push   %edx
     d08:	6a 05                	push   $0x5
     d0a:	68 00 00 00 60       	push   $0x60000000
     d0f:	e8 fc ff ff ff       	call   d10 <emit_hrum+0x25b>
     d14:	83 c4 10             	add    $0x10,%esp
     d17:	85 c0                	test   %eax,%eax
     d19:	74 1d                	je     d38 <emit_hrum+0x283>
				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );
     d1b:	50                   	push   %eax
     d1c:	89 f2                	mov    %esi,%edx
     d1e:	50                   	push   %eax
     d1f:	0f b6 c2             	movzbl %dl,%eax
     d22:	6a 02                	push   $0x2
     d24:	50                   	push   %eax
     d25:	e8 fc ff ff ff       	call   d26 <emit_hrum+0x271>
     d2a:	89 c2                	mov    %eax,%edx
     d2c:	83 c4 10             	add    $0x10,%esp
     d2f:	85 d2                	test   %edx,%edx
     d31:	b8 01 00 00 00       	mov    $0x1,%eax
     d36:	75 02                	jne    d3a <emit_hrum+0x285>
     d38:	31 c0                	xor    %eax,%eax
			}

			// displacement coding
			if( (-256)<=disp && disp<=(-1) ) // %0<disp>
     d3a:	8d 93 00 01 00 00    	lea    0x100(%ebx),%edx
     d40:	81 fa ff 00 00 00    	cmp    $0xff,%edx
     d46:	77 0c                	ja     d54 <emit_hrum+0x29f>
			{
				success = success && emit_bits( 0x00000000, 1 );
     d48:	85 c0                	test   %eax,%eax
     d4a:	74 63                	je     daf <emit_hrum+0x2fa>
     d4c:	57                   	push   %edi
     d4d:	57                   	push   %edi
     d4e:	6a 01                	push   $0x1
     d50:	6a 00                	push   $0x0
     d52:	eb 36                	jmp    d8a <emit_hrum+0x2d5>
				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

				if( max_disp > disp ) max_disp = disp;
			}
			else if( (-4096)<=disp && disp<(-256) ) //%1abcd<disp>
     d54:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
     d5a:	81 fa ff 0e 00 00    	cmp    $0xeff,%edx
     d60:	77 56                	ja     db8 <emit_hrum+0x303>
			{
				success = success && emit_bits( 0x80000000, 1 );
     d62:	85 c0                	test   %eax,%eax
     d64:	74 49                	je     daf <emit_hrum+0x2fa>
     d66:	51                   	push   %ecx
     d67:	51                   	push   %ecx
     d68:	6a 01                	push   $0x1
     d6a:	68 00 00 00 80       	push   $0x80000000
     d6f:	e8 fc ff ff ff       	call   d70 <emit_hrum+0x2bb>
     d74:	83 c4 10             	add    $0x10,%esp
     d77:	85 c0                	test   %eax,%eax
     d79:	74 34                	je     daf <emit_hrum+0x2fa>
				success = success && emit_bits( (0x0F00&disp)<<20, 4 );
     d7b:	89 d8                	mov    %ebx,%eax
     d7d:	52                   	push   %edx
     d7e:	25 00 0f 00 00       	and    $0xf00,%eax
     d83:	52                   	push   %edx
     d84:	6a 04                	push   $0x4
     d86:	c1 e0 14             	shl    $0x14,%eax
     d89:	50                   	push   %eax
     d8a:	e8 fc ff ff ff       	call   d8b <emit_hrum+0x2d6>
     d8f:	83 c4 10             	add    $0x10,%esp
     d92:	85 c0                	test   %eax,%eax
     d94:	74 19                	je     daf <emit_hrum+0x2fa>
				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
     d96:	50                   	push   %eax
     d97:	50                   	push   %eax
     d98:	0f b6 c3             	movzbl %bl,%eax
     d9b:	6a 02                	push   $0x2
     d9d:	50                   	push   %eax
     d9e:	e8 fc ff ff ff       	call   d9f <emit_hrum+0x2ea>
     da3:	83 c4 10             	add    $0x10,%esp
     da6:	85 c0                	test   %eax,%eax
     da8:	ba 01 00 00 00       	mov    $0x1,%edx
     dad:	75 02                	jne    db1 <emit_hrum+0x2fc>
     daf:	31 d2                	xor    %edx,%edx

				if( max_disp > disp ) max_disp = disp;
     db1:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
     db4:	7f 13                	jg     dc9 <emit_hrum+0x314>
     db6:	eb 14                	jmp    dcc <emit_hrum+0x317>
				goto INVALID_CODE_HRUM;
		}
		else
		{
INVALID_CODE_HRUM:
			printf("mhmt-emit.c:emit_hrum() - invalid code: length=%d, displacement=%d\n",length,disp);
     db8:	57                   	push   %edi
     db9:	53                   	push   %ebx
     dba:	56                   	push   %esi
     dbb:	68 77 02 00 00       	push   $0x277
     dc0:	e8 fc ff ff ff       	call   dc1 <emit_hrum+0x30c>
     dc5:	31 d2                	xor    %edx,%edx
     dc7:	eb 7c                	jmp    e45 <emit_hrum+0x390>
			return 0;
     dc9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}

		position += length;
     dcc:	01 75 e0             	add    %esi,-0x20(%ebp)
	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
     dcf:	84 d2                	test   %dl,%dl
     dd1:	74 0c                	je     ddf <emit_hrum+0x32a>
     dd3:	8b 45 0c             	mov    0xc(%ebp),%eax
     dd6:	39 45 e0             	cmp    %eax,-0x20(%ebp)
     dd9:	0f 82 b2 fd ff ff    	jb     b91 <emit_hrum+0xdc>

		position += length;
	}

	// stop-code: %01100<0>
	success = success && emit_bits( 0x60000000, 5 );
     ddf:	85 d2                	test   %edx,%edx
     de1:	74 69                	je     e4c <emit_hrum+0x397>
     de3:	51                   	push   %ecx
     de4:	51                   	push   %ecx
     de5:	6a 05                	push   $0x5
     de7:	68 00 00 00 60       	push   $0x60000000
     dec:	e8 fc ff ff ff       	call   ded <emit_hrum+0x338>
     df1:	83 c4 10             	add    $0x10,%esp
     df4:	85 c0                	test   %eax,%eax
     df6:	74 52                	je     e4a <emit_hrum+0x395>
	success = success && emit_byte( 0x00, EMIT_BYTE_ADD );
     df8:	52                   	push   %edx
     df9:	52                   	push   %edx
     dfa:	6a 02                	push   $0x2
     dfc:	6a 00                	push   $0x0
     dfe:	e8 fc ff ff ff       	call   dff <emit_hrum+0x34a>
     e03:	83 c4 10             	add    $0x10,%esp
     e06:	85 c0                	test   %eax,%eax
     e08:	74 40                	je     e4a <emit_hrum+0x395>

	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()
     e0a:	50                   	push   %eax
     e0b:	50                   	push   %eax
     e0c:	6a 00                	push   $0x0
     e0e:	6a 00                	push   $0x0
     e10:	e8 fc ff ff ff       	call   e11 <emit_hrum+0x35c>
     e15:	83 c4 10             	add    $0x10,%esp
     e18:	85 c0                	test   %eax,%eax
     e1a:	74 2e                	je     e4a <emit_hrum+0x395>
	success = success && emit_file( NULL, EMIT_FILE_FINISH );
     e1c:	57                   	push   %edi
     e1d:	57                   	push   %edi
     e1e:	6a 00                	push   $0x0
     e20:	6a 00                	push   $0x0
     e22:	e8 fc ff ff ff       	call   e23 <emit_hrum+0x36e>
     e27:	83 c4 10             	add    $0x10,%esp
     e2a:	85 c0                	test   %eax,%eax
     e2c:	74 1c                	je     e4a <emit_hrum+0x395>

	if( success )
		printf("Maximum displacement actually used is %d.\n",-max_disp);
     e2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     e31:	56                   	push   %esi
     e32:	56                   	push   %esi
     e33:	f7 d8                	neg    %eax
     e35:	50                   	push   %eax
     e36:	68 c7 01 00 00       	push   $0x1c7
     e3b:	e8 fc ff ff ff       	call   e3c <emit_hrum+0x387>
     e40:	ba 01 00 00 00       	mov    $0x1,%edx
     e45:	83 c4 10             	add    $0x10,%esp
     e48:	eb 02                	jmp    e4c <emit_hrum+0x397>
     e4a:	31 d2                	xor    %edx,%edx

	return success;
}
     e4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
     e4f:	89 d0                	mov    %edx,%eax
     e51:	5b                   	pop    %ebx
     e52:	5e                   	pop    %esi
     e53:	5f                   	pop    %edi
     e54:	5d                   	pop    %ebp
     e55:	c3                   	ret    

00000e56 <emit_megalz>:



// actually generate output file from optimal chain - MegaLZ version
ULONG emit_megalz(struct optchain * optch, ULONG actual_len)
{
     e56:	55                   	push   %ebp
     e57:	89 e5                	mov    %esp,%ebp
     e59:	57                   	push   %edi
     e5a:	56                   	push   %esi
     e5b:	53                   	push   %ebx
     e5c:	83 ec 1c             	sub    $0x1c,%esp

	max_disp = 0;


	// some checks
	if( !optch )
     e5f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
     e63:	75 0d                	jne    e72 <emit_megalz+0x1c>
	{
		printf("mhmt-emit.c:emit_megalz() - NULL passed!\n");
     e65:	83 ec 0c             	sub    $0xc,%esp
     e68:	68 bb 02 00 00       	push   $0x2bb
     e6d:	e9 80 00 00 00       	jmp    ef2 <emit_megalz+0x9c>
		return 0;
	}

	// initialize
	success = success && emit_file(NULL, EMIT_FILE_INIT);
     e72:	57                   	push   %edi
     e73:	57                   	push   %edi
     e74:	6a ff                	push   $0xffffffff
     e76:	6a 00                	push   $0x0
     e78:	e8 fc ff ff ff       	call   e79 <emit_megalz+0x23>
     e7d:	83 c4 10             	add    $0x10,%esp
     e80:	85 c0                	test   %eax,%eax
     e82:	74 3f                	je     ec3 <emit_megalz+0x6d>

	success = success && emit_byte(0, EMIT_BYTE_INIT);
     e84:	56                   	push   %esi
     e85:	56                   	push   %esi
     e86:	6a 00                	push   $0x0
     e88:	6a 00                	push   $0x0
     e8a:	e8 fc ff ff ff       	call   e8b <emit_megalz+0x35>
     e8f:	83 c4 10             	add    $0x10,%esp
     e92:	85 c0                	test   %eax,%eax
     e94:	74 2d                	je     ec3 <emit_megalz+0x6d>

	success = success && emit_bits(0, EMIT_BITS_INIT);
     e96:	53                   	push   %ebx
     e97:	53                   	push   %ebx
     e98:	6a ff                	push   $0xffffffff
     e9a:	6a 00                	push   $0x0
     e9c:	e8 fc ff ff ff       	call   e9d <emit_megalz+0x47>
     ea1:	83 c4 10             	add    $0x10,%esp
     ea4:	85 c0                	test   %eax,%eax
     ea6:	74 1b                	je     ec3 <emit_megalz+0x6d>


	// copy first byte as-is
	success = success && emit_file( wrk.indata, 1);
     ea8:	51                   	push   %ecx
     ea9:	51                   	push   %ecx
     eaa:	6a 01                	push   $0x1
     eac:	ff 35 30 00 00 00    	pushl  0x30
     eb2:	e8 fc ff ff ff       	call   eb3 <emit_megalz+0x5d>
     eb7:	83 c4 10             	add    $0x10,%esp
     eba:	ba 01 00 00 00       	mov    $0x1,%edx
     ebf:	85 c0                	test   %eax,%eax
     ec1:	75 02                	jne    ec5 <emit_megalz+0x6f>
     ec3:	31 d2                	xor    %edx,%edx
     ec5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     ecc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
     ed3:	e9 01 02 00 00       	jmp    10d9 <emit_megalz+0x283>
	{
		length = optch[position].code.length;
     ed8:	8b 45 e0             	mov    -0x20(%ebp),%eax
     edb:	c1 e0 04             	shl    $0x4,%eax
     ede:	03 45 08             	add    0x8(%ebp),%eax
     ee1:	8b 30                	mov    (%eax),%esi
		disp   = optch[position].code.disp;
     ee3:	8b 58 04             	mov    0x4(%eax),%ebx

		if( length==0 )
     ee6:	85 f6                	test   %esi,%esi
     ee8:	75 12                	jne    efc <emit_megalz+0xa6>
		{
			printf("mhmt-emit.c:emit_megalz() - encountered stop-code in optimal chain before emitting all data!\n");
     eea:	83 ec 0c             	sub    $0xc,%esp
     eed:	68 e4 02 00 00       	push   $0x2e4
     ef2:	e8 fc ff ff ff       	call   ef3 <emit_megalz+0x9d>
     ef7:	e9 d3 01 00 00       	jmp    10cf <emit_megalz+0x279>
			return 0;
		}
		else if( length==1 ) // either copy-byte or len=1 code
     efc:	83 fe 01             	cmp    $0x1,%esi
     eff:	75 7c                	jne    f7d <emit_megalz+0x127>
		{
			if( disp==0 ) // copy-byte (%1<byte>)
     f01:	85 db                	test   %ebx,%ebx
     f03:	75 42                	jne    f47 <emit_megalz+0xf1>
			{
				success = success && emit_bits( 0x80000000, 1 );
     f05:	52                   	push   %edx
     f06:	52                   	push   %edx
     f07:	6a 01                	push   $0x1
     f09:	68 00 00 00 80       	push   $0x80000000
     f0e:	e8 fc ff ff ff       	call   f0f <emit_megalz+0xb9>
     f13:	83 c4 10             	add    $0x10,%esp
     f16:	85 c0                	test   %eax,%eax
     f18:	74 26                	je     f40 <emit_megalz+0xea>
				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );
     f1a:	50                   	push   %eax
     f1b:	8b 55 e0             	mov    -0x20(%ebp),%edx
     f1e:	50                   	push   %eax
     f1f:	a1 30 00 00 00       	mov    0x30,%eax
     f24:	6a 02                	push   $0x2
     f26:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
     f2a:	50                   	push   %eax
     f2b:	e8 fc ff ff ff       	call   f2c <emit_megalz+0xd6>
     f30:	83 c4 10             	add    $0x10,%esp
     f33:	ba 01 00 00 00       	mov    $0x1,%edx
     f38:	85 c0                	test   %eax,%eax
     f3a:	0f 85 96 01 00 00    	jne    10d6 <emit_megalz+0x280>
     f40:	31 d2                	xor    %edx,%edx
     f42:	e9 8f 01 00 00       	jmp    10d6 <emit_megalz+0x280>
			}
			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)
     f47:	8d 43 08             	lea    0x8(%ebx),%eax
     f4a:	83 f8 07             	cmp    $0x7,%eax
     f4d:	0f 87 6f 01 00 00    	ja     10c2 <emit_megalz+0x26c>
			{
				success = success && emit_bits( 0x00000000,   3 );
     f53:	57                   	push   %edi
     f54:	57                   	push   %edi
     f55:	6a 03                	push   $0x3
     f57:	6a 00                	push   $0x0
     f59:	e8 fc ff ff ff       	call   f5a <emit_megalz+0x104>
     f5e:	83 c4 10             	add    $0x10,%esp
     f61:	85 c0                	test   %eax,%eax
     f63:	0f 84 50 01 00 00    	je     10b9 <emit_megalz+0x263>
				success = success && emit_bits( disp<<(32-3), 3 );
     f69:	51                   	push   %ecx
     f6a:	89 d8                	mov    %ebx,%eax
     f6c:	51                   	push   %ecx
     f6d:	6a 03                	push   $0x3
     f6f:	c1 e0 1d             	shl    $0x1d,%eax
     f72:	50                   	push   %eax
     f73:	e8 fc ff ff ff       	call   f74 <emit_megalz+0x11e>
     f78:	e9 30 01 00 00       	jmp    10ad <emit_megalz+0x257>
				if( max_disp > disp ) max_disp = disp;
			}
			else
				goto INVALID_CODE_MEGALZ;
		}
		else if( length==2 )
     f7d:	83 fe 02             	cmp    $0x2,%esi
     f80:	75 1f                	jne    fa1 <emit_megalz+0x14b>
		{
			if( (-256)<=disp && disp<=(-1) ) // %001<byte>
     f82:	8d 83 00 01 00 00    	lea    0x100(%ebx),%eax
     f88:	3d ff 00 00 00       	cmp    $0xff,%eax
     f8d:	0f 87 2f 01 00 00    	ja     10c2 <emit_megalz+0x26c>
			{
				success = success && emit_bits( 0x20000000, 3 );
     f93:	52                   	push   %edx
     f94:	52                   	push   %edx
     f95:	6a 03                	push   $0x3
     f97:	68 00 00 00 20       	push   $0x20000000
     f9c:	e9 f3 00 00 00       	jmp    1094 <emit_megalz+0x23e>
				if( max_disp > disp ) max_disp = disp;
			}
			else
				goto INVALID_CODE_MEGALZ;
		}
		else if( 3<=length && length<=255 )
     fa1:	8d 46 fd             	lea    -0x3(%esi),%eax
     fa4:	3d fc 00 00 00       	cmp    $0xfc,%eax
     fa9:	0f 87 13 01 00 00    	ja     10c2 <emit_megalz+0x26c>
		{
			// length coding
			if( length==3 ) // %010
     faf:	83 fe 03             	cmp    $0x3,%esi
     fb2:	75 1b                	jne    fcf <emit_megalz+0x179>
			{
				success = success && emit_bits( 0x40000000, 3 );
     fb4:	50                   	push   %eax
     fb5:	50                   	push   %eax
     fb6:	6a 03                	push   $0x3
     fb8:	68 00 00 00 40       	push   $0x40000000
     fbd:	e8 fc ff ff ff       	call   fbe <emit_megalz+0x168>
     fc2:	83 c4 10             	add    $0x10,%esp
     fc5:	85 c0                	test   %eax,%eax
     fc7:	0f 95 c0             	setne  %al
     fca:	0f b6 c0             	movzbl %al,%eax
     fcd:	eb 76                	jmp    1045 <emit_megalz+0x1ef>
			}
			else // length==4..255, %011
			{
				success = success && emit_bits( 0x60000000, 3 );
     fcf:	57                   	push   %edi
     fd0:	57                   	push   %edi

				// calculate size of variable bits
				varlen = 0;
				varbits = (length-2)>>1;
     fd1:	31 ff                	xor    %edi,%edi
			{
				success = success && emit_bits( 0x40000000, 3 );
			}
			else // length==4..255, %011
			{
				success = success && emit_bits( 0x60000000, 3 );
     fd3:	6a 03                	push   $0x3
     fd5:	68 00 00 00 60       	push   $0x60000000
     fda:	e8 fc ff ff ff       	call   fdb <emit_megalz+0x185>

				// calculate size of variable bits
				varlen = 0;
				varbits = (length-2)>>1;
     fdf:	8d 56 fe             	lea    -0x2(%esi),%edx
     fe2:	83 c4 10             	add    $0x10,%esp
     fe5:	89 d1                	mov    %edx,%ecx
     fe7:	d1 f9                	sar    %ecx
				while( varbits )
				{
					varbits >>= 1;
					varlen++;
     fe9:	47                   	inc    %edi
				success = success && emit_bits( 0x60000000, 3 );

				// calculate size of variable bits
				varlen = 0;
				varbits = (length-2)>>1;
				while( varbits )
     fea:	d1 e9                	shr    %ecx
     fec:	75 fb                	jne    fe9 <emit_megalz+0x193>
					varlen++;
				}

				varbits = length-2-(1<<varlen); // prepare length coding

				success = success && emit_bits(       1<<(32-varlen), varlen );
     fee:	85 c0                	test   %eax,%eax
     ff0:	74 51                	je     1043 <emit_megalz+0x1ed>
     ff2:	c7 45 dc 20 00 00 00 	movl   $0x20,-0x24(%ebp)
     ff9:	b8 01 00 00 00       	mov    $0x1,%eax
     ffe:	51                   	push   %ecx
     fff:	29 7d dc             	sub    %edi,-0x24(%ebp)
    1002:	51                   	push   %ecx
    1003:	8a 4d dc             	mov    -0x24(%ebp),%cl
    1006:	57                   	push   %edi
    1007:	89 55 d8             	mov    %edx,-0x28(%ebp)
    100a:	d3 e0                	shl    %cl,%eax
    100c:	50                   	push   %eax
    100d:	e8 fc ff ff ff       	call   100e <emit_megalz+0x1b8>
    1012:	83 c4 10             	add    $0x10,%esp
    1015:	8b 55 d8             	mov    -0x28(%ebp),%edx
    1018:	85 c0                	test   %eax,%eax
    101a:	74 27                	je     1043 <emit_megalz+0x1ed>
				success = success && emit_bits( varbits<<(32-varlen), varlen );
    101c:	50                   	push   %eax
    101d:	89 f9                	mov    %edi,%ecx
    101f:	50                   	push   %eax
    1020:	b8 01 00 00 00       	mov    $0x1,%eax
    1025:	d3 e0                	shl    %cl,%eax
    1027:	8a 4d dc             	mov    -0x24(%ebp),%cl
    102a:	29 c2                	sub    %eax,%edx
    102c:	57                   	push   %edi
    102d:	d3 e2                	shl    %cl,%edx
    102f:	52                   	push   %edx
    1030:	e8 fc ff ff ff       	call   1031 <emit_megalz+0x1db>
    1035:	83 c4 10             	add    $0x10,%esp
    1038:	89 c2                	mov    %eax,%edx
    103a:	b8 01 00 00 00       	mov    $0x1,%eax
    103f:	85 d2                	test   %edx,%edx
    1041:	75 02                	jne    1045 <emit_megalz+0x1ef>
    1043:	31 c0                	xor    %eax,%eax
			}

			// displacement coding
			if( (-256)<=disp && disp<=(-1) )
    1045:	8d bb 00 01 00 00    	lea    0x100(%ebx),%edi
    104b:	81 ff ff 00 00 00    	cmp    $0xff,%edi
    1051:	77 0c                	ja     105f <emit_megalz+0x209>
			{
				success = success && emit_bits( 0, 1 );
    1053:	85 c0                	test   %eax,%eax
    1055:	74 62                	je     10b9 <emit_megalz+0x263>
    1057:	51                   	push   %ecx
    1058:	51                   	push   %ecx
    1059:	6a 01                	push   $0x1
    105b:	6a 00                	push   $0x0
    105d:	eb 35                	jmp    1094 <emit_megalz+0x23e>
				success = success && emit_byte( (UBYTE)(0x00ff & disp), EMIT_BYTE_ADD );

				if( max_disp > disp ) max_disp = disp;
			}
			else if( (-4352)<=disp && disp<(-256) )
    105f:	8d 93 00 11 00 00    	lea    0x1100(%ebx),%edx
    1065:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
    106b:	77 55                	ja     10c2 <emit_megalz+0x26c>
			{
				success = success && emit_bits( 0x80000000, 1 );
    106d:	85 c0                	test   %eax,%eax
    106f:	74 48                	je     10b9 <emit_megalz+0x263>
    1071:	52                   	push   %edx
    1072:	52                   	push   %edx
    1073:	6a 01                	push   $0x1
    1075:	68 00 00 00 80       	push   $0x80000000
    107a:	e8 fc ff ff ff       	call   107b <emit_megalz+0x225>
    107f:	83 c4 10             	add    $0x10,%esp
    1082:	85 c0                	test   %eax,%eax
    1084:	74 33                	je     10b9 <emit_megalz+0x263>

				success = success && emit_bits( (0x0F00&(disp+0x0100))<<20, 4 );
    1086:	50                   	push   %eax
    1087:	81 e7 00 0f 00 00    	and    $0xf00,%edi
    108d:	50                   	push   %eax
    108e:	6a 04                	push   $0x4
    1090:	c1 e7 14             	shl    $0x14,%edi
    1093:	57                   	push   %edi
    1094:	e8 fc ff ff ff       	call   1095 <emit_megalz+0x23f>
    1099:	83 c4 10             	add    $0x10,%esp
    109c:	85 c0                	test   %eax,%eax
    109e:	74 19                	je     10b9 <emit_megalz+0x263>

				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
    10a0:	51                   	push   %ecx
    10a1:	0f b6 c3             	movzbl %bl,%eax
    10a4:	51                   	push   %ecx
    10a5:	6a 02                	push   $0x2
    10a7:	50                   	push   %eax
    10a8:	e8 fc ff ff ff       	call   10a9 <emit_megalz+0x253>
    10ad:	83 c4 10             	add    $0x10,%esp
    10b0:	85 c0                	test   %eax,%eax
    10b2:	ba 01 00 00 00       	mov    $0x1,%edx
    10b7:	75 02                	jne    10bb <emit_megalz+0x265>
    10b9:	31 d2                	xor    %edx,%edx

				if( max_disp > disp ) max_disp = disp;
    10bb:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
    10be:	7f 13                	jg     10d3 <emit_megalz+0x27d>
    10c0:	eb 14                	jmp    10d6 <emit_megalz+0x280>
				goto INVALID_CODE_MEGALZ;
		}
		else
		{
INVALID_CODE_MEGALZ:
			printf("mhmt-emit.c:emit_megalz() - invalid code: length=%d, displacement=%d\n",length,disp);
    10c2:	52                   	push   %edx
    10c3:	53                   	push   %ebx
    10c4:	56                   	push   %esi
    10c5:	68 41 03 00 00       	push   $0x341
    10ca:	e8 fc ff ff ff       	call   10cb <emit_megalz+0x275>
    10cf:	31 d2                	xor    %edx,%edx
    10d1:	eb 6a                	jmp    113d <emit_megalz+0x2e7>
			return 0;
    10d3:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}

		position += length;
    10d6:	01 75 e0             	add    %esi,-0x20(%ebp)
	success = success && emit_file( wrk.indata, 1);

	// go emitting codes
	position = 1;

	while( (position<actual_len) && success )
    10d9:	84 d2                	test   %dl,%dl
    10db:	74 0c                	je     10e9 <emit_megalz+0x293>
    10dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    10e0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    10e3:	0f 82 ef fd ff ff    	jb     ed8 <emit_megalz+0x82>

		position += length;
	}

	// stop-code
	success = success && emit_bits( 0x60100000, 12 );
    10e9:	85 d2                	test   %edx,%edx
    10eb:	74 57                	je     1144 <emit_megalz+0x2ee>
    10ed:	50                   	push   %eax
    10ee:	50                   	push   %eax
    10ef:	6a 0c                	push   $0xc
    10f1:	68 00 00 10 60       	push   $0x60100000
    10f6:	e8 fc ff ff ff       	call   10f7 <emit_megalz+0x2a1>
    10fb:	83 c4 10             	add    $0x10,%esp
    10fe:	85 c0                	test   %eax,%eax
    1100:	74 40                	je     1142 <emit_megalz+0x2ec>
	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()
    1102:	57                   	push   %edi
    1103:	57                   	push   %edi
    1104:	6a 00                	push   $0x0
    1106:	6a 00                	push   $0x0
    1108:	e8 fc ff ff ff       	call   1109 <emit_megalz+0x2b3>
    110d:	83 c4 10             	add    $0x10,%esp
    1110:	85 c0                	test   %eax,%eax
    1112:	74 2e                	je     1142 <emit_megalz+0x2ec>

	success = success && emit_file( NULL, EMIT_FILE_FINISH );
    1114:	56                   	push   %esi
    1115:	56                   	push   %esi
    1116:	6a 00                	push   $0x0
    1118:	6a 00                	push   $0x0
    111a:	e8 fc ff ff ff       	call   111b <emit_megalz+0x2c5>
    111f:	83 c4 10             	add    $0x10,%esp
    1122:	85 c0                	test   %eax,%eax
    1124:	74 1c                	je     1142 <emit_megalz+0x2ec>

	if( success )
		printf("Maximum displacement actually used is %d.\n",-max_disp);
    1126:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1129:	53                   	push   %ebx
    112a:	53                   	push   %ebx
    112b:	f7 d8                	neg    %eax
    112d:	50                   	push   %eax
    112e:	68 c7 01 00 00       	push   $0x1c7
    1133:	e8 fc ff ff ff       	call   1134 <emit_megalz+0x2de>
    1138:	ba 01 00 00 00       	mov    $0x1,%edx
    113d:	83 c4 10             	add    $0x10,%esp
    1140:	eb 02                	jmp    1144 <emit_megalz+0x2ee>
    1142:	31 d2                	xor    %edx,%edx

	return success;
}
    1144:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1147:	89 d0                	mov    %edx,%eax
    1149:	5b                   	pop    %ebx
    114a:	5e                   	pop    %esi
    114b:	5f                   	pop    %edi
    114c:	5d                   	pop    %ebp
    114d:	c3                   	ret    

mhmt-globals.o:     file format elf32-i386


Disassembly of section .text:

00000000 <init_globals>:

struct globals wrk;

// init wrk container
void init_globals(void)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
	wrk.packtype = PK_MLZ;
   3:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
   a:	00 00 00 
	wrk.greedy   = 0;
   d:	c7 05 04 00 00 00 00 	movl   $0x0,0x4
  14:	00 00 00 
	wrk.mode     = 0;
  17:	c7 05 08 00 00 00 00 	movl   $0x0,0x8
  1e:	00 00 00 
	wrk.zxheader = 0;
  21:	c7 05 0c 00 00 00 00 	movl   $0x0,0xc
  28:	00 00 00 
	wrk.wordbit  = 0;
  2b:	c7 05 10 00 00 00 00 	movl   $0x0,0x10
  32:	00 00 00 
	wrk.bigend   = 0;
  35:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
  3c:	00 00 00 
	wrk.fullbits = 0;
  3f:	c7 05 18 00 00 00 00 	movl   $0x0,0x18
  46:	00 00 00 
	wrk.maxwin   = 4352;
  49:	c7 05 1c 00 00 00 00 	movl   $0x1100,0x1c
  50:	11 00 00 

	wrk.fname_in  = NULL;
  53:	c7 05 20 00 00 00 00 	movl   $0x0,0x20
  5a:	00 00 00 
	wrk.fname_out = NULL;
  5d:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
  64:	00 00 00 

	wrk.file_in  = NULL;
  67:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
  6e:	00 00 00 
	wrk.file_out = NULL;
  71:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
  78:	00 00 00 

	wrk.indata = NULL;
  7b:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
  82:	00 00 00 
	wrk.inlen = 0;
  85:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
  8c:	00 00 00 
}
  8f:	5d                   	pop    %ebp
  90:	c3                   	ret    

00000091 <free_globals>:



// free all stuff from wrk container
void free_globals(void)
{
  91:	55                   	push   %ebp
  92:	89 e5                	mov    %esp,%ebp
  94:	83 ec 08             	sub    $0x8,%esp
	if( wrk.indata ) free( wrk.indata );
  97:	a1 30 00 00 00       	mov    0x30,%eax
  9c:	85 c0                	test   %eax,%eax
  9e:	74 0c                	je     ac <free_globals+0x1b>
  a0:	83 ec 0c             	sub    $0xc,%esp
  a3:	50                   	push   %eax
  a4:	e8 fc ff ff ff       	call   a5 <free_globals+0x14>
  a9:	83 c4 10             	add    $0x10,%esp

	if( wrk.file_out ) fclose( wrk.file_out );
  ac:	a1 2c 00 00 00       	mov    0x2c,%eax
  b1:	85 c0                	test   %eax,%eax
  b3:	74 0c                	je     c1 <free_globals+0x30>
  b5:	83 ec 0c             	sub    $0xc,%esp
  b8:	50                   	push   %eax
  b9:	e8 fc ff ff ff       	call   ba <free_globals+0x29>
  be:	83 c4 10             	add    $0x10,%esp
	if( wrk.file_in )  fclose( wrk.file_in );
  c1:	a1 28 00 00 00       	mov    0x28,%eax
  c6:	85 c0                	test   %eax,%eax
  c8:	74 0c                	je     d6 <free_globals+0x45>
  ca:	83 ec 0c             	sub    $0xc,%esp
  cd:	50                   	push   %eax
  ce:	e8 fc ff ff ff       	call   cf <free_globals+0x3e>
  d3:	83 c4 10             	add    $0x10,%esp

	if( wrk.fname_out ) free( wrk.fname_out );
  d6:	a1 24 00 00 00       	mov    0x24,%eax
  db:	85 c0                	test   %eax,%eax
  dd:	74 0c                	je     eb <free_globals+0x5a>
  df:	83 ec 0c             	sub    $0xc,%esp
  e2:	50                   	push   %eax
  e3:	e8 fc ff ff ff       	call   e4 <free_globals+0x53>
  e8:	83 c4 10             	add    $0x10,%esp
	if( wrk.fname_in )  free( wrk.fname_in );
  eb:	a1 20 00 00 00       	mov    0x20,%eax
  f0:	85 c0                	test   %eax,%eax
  f2:	74 0c                	je     100 <free_globals+0x6f>
  f4:	83 ec 0c             	sub    $0xc,%esp
  f7:	50                   	push   %eax
  f8:	e8 fc ff ff ff       	call   f9 <free_globals+0x68>
  fd:	83 c4 10             	add    $0x10,%esp
}
 100:	c9                   	leave  
 101:	c3                   	ret    

mhmt-hash.o:     file format elf32-i386


Disassembly of section .text:

00000000 <destroy_hash>:



// free hash
void destroy_hash(UBYTE * hash)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
   6:	8b 45 08             	mov    0x8(%ebp),%eax
	if( hash ) free(hash);
   9:	85 c0                	test   %eax,%eax
   b:	74 06                	je     13 <destroy_hash+0x13>
}
   d:	c9                   	leave  


// free hash
void destroy_hash(UBYTE * hash)
{
	if( hash ) free(hash);
   e:	e9 fc ff ff ff       	jmp    f <destroy_hash+0xf>
}
  13:	c9                   	leave  
  14:	c3                   	ret    

00000015 <build_hash>:
#include "mhmt-hash.h"

// allocate mem for hash (length) and build it from data
// length must be at least 3 bytes, since hash[0] and hash[1] are not valid hashes
UBYTE * build_hash(UBYTE * data, ULONG length)
{
  15:	55                   	push   %ebp
  16:	89 e5                	mov    %esp,%ebp
  18:	57                   	push   %edi
	UBYTE * hash;

	ULONG i; UBYTE *src,*dst;
	UBYTE curr,prev,prev2;

	if( !length )
  19:	31 ff                	xor    %edi,%edi
#include "mhmt-hash.h"

// allocate mem for hash (length) and build it from data
// length must be at least 3 bytes, since hash[0] and hash[1] are not valid hashes
UBYTE * build_hash(UBYTE * data, ULONG length)
{
  1b:	56                   	push   %esi
  1c:	53                   	push   %ebx
  1d:	83 ec 1c             	sub    $0x1c,%esp
	UBYTE * hash;

	ULONG i; UBYTE *src,*dst;
	UBYTE curr,prev,prev2;

	if( !length )
  20:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  24:	74 3f                	je     65 <build_hash+0x50>
		return NULL;

	hash=(UBYTE *)malloc( length );
  26:	83 ec 0c             	sub    $0xc,%esp
  29:	ff 75 0c             	pushl  0xc(%ebp)
  2c:	e8 fc ff ff ff       	call   2d <build_hash+0x18>
        if( !hash )
  31:	83 c4 10             	add    $0x10,%esp
  34:	85 c0                	test   %eax,%eax
	UBYTE curr,prev,prev2;

	if( !length )
		return NULL;

	hash=(UBYTE *)malloc( length );
  36:	89 c6                	mov    %eax,%esi
  38:	89 c7                	mov    %eax,%edi
        if( !hash )
  3a:	74 29                	je     65 <build_hash+0x50>
  3c:	31 d2                	xor    %edx,%edx
  3e:	31 c0                	xor    %eax,%eax
  40:	31 db                	xor    %ebx,%ebx
  42:	89 75 e4             	mov    %esi,-0x1c(%ebp)

	do
	{
		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );
		prev  = (UBYTE)( (curr>>1) | (curr<<7) );
		curr  = *(src++);
  45:	8b 75 08             	mov    0x8(%ebp),%esi
	src = data;
	dst = hash;

	do
	{
		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );
  48:	88 c1                	mov    %al,%cl
		prev  = (UBYTE)( (curr>>1) | (curr<<7) );
  4a:	88 d8                	mov    %bl,%al
	src = data;
	dst = hash;

	do
	{
		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );
  4c:	c0 c1 07             	rol    $0x7,%cl
		prev  = (UBYTE)( (curr>>1) | (curr<<7) );
  4f:	c0 c0 07             	rol    $0x7,%al
		curr  = *(src++);

		*(dst++) = curr^prev^prev2;
  52:	31 c1                	xor    %eax,%ecx

	do
	{
		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );
		prev  = (UBYTE)( (curr>>1) | (curr<<7) );
		curr  = *(src++);
  54:	8a 1c 16             	mov    (%esi,%edx,1),%bl

		*(dst++) = curr^prev^prev2;
  57:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  5a:	31 d9                	xor    %ebx,%ecx
  5c:	88 0c 16             	mov    %cl,(%esi,%edx,1)
  5f:	42                   	inc    %edx

	} while( --i );
  60:	39 55 0c             	cmp    %edx,0xc(%ebp)
  63:	75 e0                	jne    45 <build_hash+0x30>



	return hash;
}
  65:	8d 65 f4             	lea    -0xc(%ebp),%esp
  68:	89 f8                	mov    %edi,%eax
  6a:	5b                   	pop    %ebx
  6b:	5e                   	pop    %esi
  6c:	5f                   	pop    %edi
  6d:	5d                   	pop    %ebp
  6e:	c3                   	ret    

mhmt-lz.o:     file format elf32-i386


Disassembly of section .text:

00000000 <get_lz_price_hrust>:




ULONG get_lz_price_hrust(ULONG position, struct lzcode * lzcode)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	8b 55 0c             	mov    0xc(%ebp),%edx
   6:	56                   	push   %esi
   7:	53                   	push   %ebx
   8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ULONG varbits,varlen;
	LONG length,disp,tmp;

	length = lzcode->length;
	disp   = lzcode->disp;
   b:	8b 4a 04             	mov    0x4(%edx),%ecx
ULONG get_lz_price_hrust(ULONG position, struct lzcode * lzcode)
{
	ULONG varbits,varlen;
	LONG length,disp,tmp;

	length = lzcode->length;
   e:	8b 02                	mov    (%edx),%eax
	disp   = lzcode->disp;


	if( disp==0 )
  10:	85 c9                	test   %ecx,%ecx
  12:	75 2e                	jne    42 <get_lz_price_hrust+0x42>
	{
		if( length==1 )
  14:	83 f8 01             	cmp    $0x1,%eax
  17:	ba 09 00 00 00       	mov    $0x9,%edx
  1c:	0f 84 13 01 00 00    	je     135 <get_lz_price_hrust+0x135>
		{
			return 9; // copy-1-byte
		}
		else if( (12<=length) && (length<=42) && ( !(length&1) ) )
  22:	8d 50 f4             	lea    -0xc(%eax),%edx
  25:	83 fa 1e             	cmp    $0x1e,%edx
  28:	0f 87 f5 00 00 00    	ja     123 <get_lz_price_hrust+0x123>
  2e:	a8 01                	test   $0x1,%al
		{
			return 11 + 8*length;
  30:	8d 14 c5 0b 00 00 00 	lea    0xb(,%eax,8),%edx
	{
		if( length==1 )
		{
			return 9; // copy-1-byte
		}
		else if( (12<=length) && (length<=42) && ( !(length&1) ) )
  37:	0f 85 e6 00 00 00    	jne    123 <get_lz_price_hrust+0x123>
  3d:	e9 f3 00 00 00       	jmp    135 <get_lz_price_hrust+0x135>
			return 11 + 8*length;
		}
		else
			goto INVALID_CODE_HRUST;
	}
	else if( length==(-3) ) // insertion match!
  42:	83 f8 fd             	cmp    $0xfffffffd,%eax
  45:	75 1b                	jne    62 <get_lz_price_hrust+0x62>
	{
		if( (-16)<=disp && disp<=(-1) )
  47:	8d 59 10             	lea    0x10(%ecx),%ebx
  4a:	ba 12 00 00 00       	mov    $0x12,%edx
  4f:	83 fb 0f             	cmp    $0xf,%ebx
  52:	0f 86 dd 00 00 00    	jbe    135 <get_lz_price_hrust+0x135>
		{
			return 10+8;
		}
		else if( (-79)<=disp && disp<(-16) )
  58:	8d 59 4f             	lea    0x4f(%ecx),%ebx
  5b:	b2 15                	mov    $0x15,%dl
  5d:	83 fb 3e             	cmp    $0x3e,%ebx
  60:	eb 36                	jmp    98 <get_lz_price_hrust+0x98>
			return 5+8+8;
		}
		else
			goto INVALID_CODE_HRUST;
	}
	else if( length==1 )
  62:	83 f8 01             	cmp    $0x1,%eax
  65:	75 0d                	jne    74 <get_lz_price_hrust+0x74>
	{
		if( (-8)<=disp && disp<=(-1) )
  67:	8d 59 08             	lea    0x8(%ecx),%ebx
  6a:	ba 06 00 00 00       	mov    $0x6,%edx
  6f:	83 fb 07             	cmp    $0x7,%ebx
  72:	eb 24                	jmp    98 <get_lz_price_hrust+0x98>
			return 6;
		else
			goto INVALID_CODE_HRUST;
	}
	else if( length==2 )
  74:	83 f8 02             	cmp    $0x2,%eax
  77:	75 2a                	jne    a3 <get_lz_price_hrust+0xa3>
	{
		if( (-32)<=disp && disp<=(-1) )
  79:	8d 59 20             	lea    0x20(%ecx),%ebx
  7c:	ba 0a 00 00 00       	mov    $0xa,%edx
  81:	83 fb 1f             	cmp    $0x1f,%ebx
  84:	0f 86 ab 00 00 00    	jbe    135 <get_lz_price_hrust+0x135>
		{
			return 10;
		}
		else if( (-768)<=disp && disp<(-32) )
  8a:	8d 99 00 03 00 00    	lea    0x300(%ecx),%ebx
  90:	b2 0d                	mov    $0xd,%dl
  92:	81 fb df 02 00 00    	cmp    $0x2df,%ebx
  98:	0f 87 85 00 00 00    	ja     123 <get_lz_price_hrust+0x123>
  9e:	e9 92 00 00 00       	jmp    135 <get_lz_price_hrust+0x135>
			return 13;
		}
		else
			goto INVALID_CODE_HRUST;
	}
	else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )
  a3:	8d 50 fd             	lea    -0x3(%eax),%edx
  a6:	81 fa fc 0e 00 00    	cmp    $0xefc,%edx
  ac:	77 75                	ja     123 <get_lz_price_hrust+0x123>
  ae:	81 f9 00 00 ff ff    	cmp    $0xffff0000,%ecx
  b4:	7c 6d                	jl     123 <get_lz_price_hrust+0x123>
  b6:	85 c9                	test   %ecx,%ecx
  b8:	79 69                	jns    123 <get_lz_price_hrust+0x123>
	{
		// first, calc influence of length
		if( length<=15 ) // 3..15
  ba:	83 f8 0f             	cmp    $0xf,%eax
  bd:	7f 23                	jg     e2 <get_lz_price_hrust+0xe2>
		{
			varlen = 3 + ( (length/3)<<1 );

			if( length==3 )  varlen = 3;
  bf:	83 f8 03             	cmp    $0x3,%eax
  c2:	be 03 00 00 00       	mov    $0x3,%esi
  c7:	74 29                	je     f2 <get_lz_price_hrust+0xf2>

			if( length==15 ) varlen = 11;
  c9:	83 f8 0f             	cmp    $0xf,%eax
  cc:	66 be 0b 00          	mov    $0xb,%si
  d0:	74 20                	je     f2 <get_lz_price_hrust+0xf2>
	else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )
	{
		// first, calc influence of length
		if( length<=15 ) // 3..15
		{
			varlen = 3 + ( (length/3)<<1 );
  d2:	ba 03 00 00 00       	mov    $0x3,%edx
  d7:	89 d6                	mov    %edx,%esi
  d9:	99                   	cltd   
  da:	f7 fe                	idiv   %esi
  dc:	8d 74 00 03          	lea    0x3(%eax,%eax,1),%esi
  e0:	eb 10                	jmp    f2 <get_lz_price_hrust+0xf2>

			if( length==3 )  varlen = 3;

			if( length==15 ) varlen = 11;
		}
		else if( length<=127 ) // 16..127
  e2:	83 c0 80             	add    $0xffffff80,%eax
  e5:	0f 9d c0             	setge  %al
  e8:	0f b6 f0             	movzbl %al,%esi
  eb:	8d 34 f5 0e 00 00 00 	lea    0xe(,%esi,8),%esi
			varlen = 14+8;
		}


		// add displacement length
		if( (-32)<=disp ) // ffe0..ffff
  f2:	83 f9 e0             	cmp    $0xffffffe0,%ecx
		{
			varlen += 7;
  f5:	8d 56 07             	lea    0x7(%esi),%edx
			varlen = 14+8;
		}


		// add displacement length
		if( (-32)<=disp ) // ffe0..ffff
  f8:	7d 3b                	jge    135 <get_lz_price_hrust+0x135>
		{
			varlen += 7;
		}
		else if( (-512)<=disp ) // fe00..ffdf
  fa:	81 f9 00 fe ff ff    	cmp    $0xfffffe00,%ecx
		{
			varlen += 10;
 100:	8d 56 0a             	lea    0xa(%esi),%edx
		// add displacement length
		if( (-32)<=disp ) // ffe0..ffff
		{
			varlen += 7;
		}
		else if( (-512)<=disp ) // fe00..ffdf
 103:	7d 30                	jge    135 <get_lz_price_hrust+0x135>
		else // 0000(-65536)..fdff: -513:-1024, -1025:-2048, -2049:-4096, ... ,-32769:-65536
		{    // bits:                   12           13           14               18

			varlen += 12;

			if( position>32768 )
 105:	81 fb 00 80 00 00    	cmp    $0x8000,%ebx
 10b:	b8 00 04 00 00       	mov    $0x400,%eax
			varlen += 10;
		}
		else // 0000(-65536)..fdff: -513:-1024, -1025:-2048, -2049:-4096, ... ,-32769:-65536
		{    // bits:                   12           13           14               18

			varlen += 12;
 110:	8d 56 0c             	lea    0xc(%esi),%edx

			if( position>32768 )
 113:	76 08                	jbe    11d <get_lz_price_hrust+0x11d>
			{
				varlen += 6; // 8bits
 115:	8d 56 12             	lea    0x12(%esi),%edx
 118:	eb 1b                	jmp    135 <get_lz_price_hrust+0x135>
			{
				tmp = 1024;

				while( position>(ULONG)tmp )
				{
					varlen++;
 11a:	42                   	inc    %edx

					tmp <<= 1;
 11b:	01 c0                	add    %eax,%eax
			}
			else
			{
				tmp = 1024;

				while( position>(ULONG)tmp )
 11d:	39 c3                	cmp    %eax,%ebx
 11f:	77 f9                	ja     11a <get_lz_price_hrust+0x11a>
 121:	eb 12                	jmp    135 <get_lz_price_hrust+0x135>
		return varlen;
	}
	else
	{
INVALID_CODE_HRUST:
		printf("mhmt-lz.c:get_lz_price_hrust(): Found invalid code length=%d, displacement=%d\n",length, disp);
 123:	52                   	push   %edx
 124:	51                   	push   %ecx
 125:	50                   	push   %eax
 126:	68 00 00 00 00       	push   $0x0
 12b:	e8 fc ff ff ff       	call   12c <get_lz_price_hrust+0x12c>
 130:	31 d2                	xor    %edx,%edx
		return 0;
 132:	83 c4 10             	add    $0x10,%esp
	}
}
 135:	8d 65 f8             	lea    -0x8(%ebp),%esp
 138:	89 d0                	mov    %edx,%eax
 13a:	5b                   	pop    %ebx
 13b:	5e                   	pop    %esi
 13c:	5d                   	pop    %ebp
 13d:	c3                   	ret    

0000013e <get_lz_price_hrum>:
	}
}


ULONG get_lz_price_hrum(ULONG position, struct lzcode * lzcode)
{
 13e:	55                   	push   %ebp
 13f:	89 e5                	mov    %esp,%ebp
 141:	53                   	push   %ebx
 142:	83 ec 04             	sub    $0x4,%esp
 145:	8b 45 0c             	mov    0xc(%ebp),%eax
	ULONG varlen;
	LONG length,disp;

	length = lzcode->length;
 148:	8b 10                	mov    (%eax),%edx
	disp   = lzcode->disp;
 14a:	8b 48 04             	mov    0x4(%eax),%ecx

	if( length==1 )
 14d:	83 fa 01             	cmp    $0x1,%edx
 150:	75 17                	jne    169 <get_lz_price_hrum+0x2b>
	{
		if( disp==0 )
 152:	85 c9                	test   %ecx,%ecx
 154:	b8 09 00 00 00       	mov    $0x9,%eax
 159:	0f 84 9d 00 00 00    	je     1fc <get_lz_price_hrum+0xbe>
			return 9;
		else if( (-8)<=disp && disp<=(-1) )
 15f:	8d 59 08             	lea    0x8(%ecx),%ebx
 162:	b0 06                	mov    $0x6,%al
 164:	83 fb 07             	cmp    $0x7,%ebx
 167:	eb 16                	jmp    17f <get_lz_price_hrum+0x41>
			return 6;
		else
			goto INVALID_CODE_HRUM;
	}
	else if( length==2 )
 169:	83 fa 02             	cmp    $0x2,%edx
 16c:	75 15                	jne    183 <get_lz_price_hrum+0x45>
	{
		if( (-256)<=disp && disp<=(-1) )
 16e:	8d 99 00 01 00 00    	lea    0x100(%ecx),%ebx
 174:	b8 0b 00 00 00       	mov    $0xb,%eax
 179:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
 17f:	77 69                	ja     1ea <get_lz_price_hrum+0xac>
 181:	eb 79                	jmp    1fc <get_lz_price_hrum+0xbe>
			return 11;
		else
			goto INVALID_CODE_HRUM;
	}
	else if (3<=length && length<=255)
 183:	8d 42 fd             	lea    -0x3(%edx),%eax
 186:	3d fc 00 00 00       	cmp    $0xfc,%eax
 18b:	77 5d                	ja     1ea <get_lz_price_hrum+0xac>
	{
		varlen = 3;

		if( 4<=length && length<=15 )
 18d:	8d 42 fc             	lea    -0x4(%edx),%eax
 190:	83 f8 0b             	cmp    $0xb,%eax
 193:	77 1f                	ja     1b4 <get_lz_price_hrum+0x76>
		{
			varlen = 5;
			if( length>=6 ) varlen += 2;
 195:	83 fa 05             	cmp    $0x5,%edx
	}
	else
	{
INVALID_CODE_HRUM:
		printf("mhmt-lz.c:get_lz_price_hrum(): Found invalid code length=%d, displacement=%d\n",length, disp);
		return 0;
 198:	b8 05 00 00 00       	mov    $0x5,%eax
		varlen = 3;

		if( 4<=length && length<=15 )
		{
			varlen = 5;
			if( length>=6 ) varlen += 2;
 19d:	7e 25                	jle    1c4 <get_lz_price_hrum+0x86>
			if( length>=9 ) varlen += 2;
 19f:	83 fa 08             	cmp    $0x8,%edx
 1a2:	b0 07                	mov    $0x7,%al
 1a4:	7e 1e                	jle    1c4 <get_lz_price_hrum+0x86>
			if( length>=12) varlen += 2;
 1a6:	31 c0                	xor    %eax,%eax
 1a8:	83 fa 0b             	cmp    $0xb,%edx
 1ab:	0f 9f c0             	setg   %al
 1ae:	8d 44 00 09          	lea    0x9(%eax,%eax,1),%eax
 1b2:	eb 10                	jmp    1c4 <get_lz_price_hrum+0x86>
		}
		else if( 15<length && length<=255 )
 1b4:	8d 42 f0             	lea    -0x10(%edx),%eax
 1b7:	3d f0 00 00 00       	cmp    $0xf0,%eax
 1bc:	19 c0                	sbb    %eax,%eax
 1be:	83 e0 0a             	and    $0xa,%eax
 1c1:	83 c0 03             	add    $0x3,%eax
		{
			varlen = 13;
		}

		if( (-256)<=disp && disp<=(-1) )
 1c4:	8d 99 00 01 00 00    	lea    0x100(%ecx),%ebx
 1ca:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
 1d0:	77 05                	ja     1d7 <get_lz_price_hrum+0x99>
			varlen += 9;
 1d2:	83 c0 09             	add    $0x9,%eax
 1d5:	eb 25                	jmp    1fc <get_lz_price_hrum+0xbe>
		else if( (-4096)<=disp && disp<(-256) )
 1d7:	8d 99 00 10 00 00    	lea    0x1000(%ecx),%ebx
 1dd:	81 fb ff 0e 00 00    	cmp    $0xeff,%ebx
 1e3:	77 05                	ja     1ea <get_lz_price_hrum+0xac>
			varlen += 13;
 1e5:	83 c0 0d             	add    $0xd,%eax
 1e8:	eb 12                	jmp    1fc <get_lz_price_hrum+0xbe>
		return varlen;
	}
	else
	{
INVALID_CODE_HRUM:
		printf("mhmt-lz.c:get_lz_price_hrum(): Found invalid code length=%d, displacement=%d\n",length, disp);
 1ea:	53                   	push   %ebx
 1eb:	51                   	push   %ecx
 1ec:	52                   	push   %edx
 1ed:	68 4f 00 00 00       	push   $0x4f
 1f2:	e8 fc ff ff ff       	call   1f3 <get_lz_price_hrum+0xb5>
 1f7:	31 c0                	xor    %eax,%eax
		return 0;
 1f9:	83 c4 10             	add    $0x10,%esp
	}
}
 1fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 1ff:	c9                   	leave  
 200:	c3                   	ret    

00000201 <get_lz_price_megalz>:


// returns price in bits or zero if error
//
ULONG get_lz_price_megalz(ULONG position, struct lzcode * lzcode)
{
 201:	55                   	push   %ebp
 202:	89 e5                	mov    %esp,%ebp
 204:	53                   	push   %ebx
 205:	83 ec 04             	sub    $0x4,%esp
 208:	8b 45 0c             	mov    0xc(%ebp),%eax
	ULONG varbits,varlen;
	LONG length,disp;

	length = lzcode->length;
 20b:	8b 08                	mov    (%eax),%ecx
	disp   = lzcode->disp;
 20d:	8b 50 04             	mov    0x4(%eax),%edx

	if( length==1 )
 210:	83 f9 01             	cmp    $0x1,%ecx
 213:	75 17                	jne    22c <get_lz_price_megalz+0x2b>
	{
		if( disp==0 )
 215:	85 d2                	test   %edx,%edx
 217:	b8 09 00 00 00       	mov    $0x9,%eax
 21c:	0f 84 9f 00 00 00    	je     2c1 <get_lz_price_megalz+0xc0>
			return 9;
		else if( (-8)<=disp && disp<=(-1) )
 222:	8d 5a 08             	lea    0x8(%edx),%ebx
 225:	b0 06                	mov    $0x6,%al
 227:	83 fb 07             	cmp    $0x7,%ebx
 22a:	eb 3e                	jmp    26a <get_lz_price_megalz+0x69>
			return 6;
		else
			goto INVALID_CODE_MEGALZ;
	}
	else if( length==2 )
 22c:	83 f9 02             	cmp    $0x2,%ecx
 22f:	75 13                	jne    244 <get_lz_price_megalz+0x43>
	{
		if( (-256)<=disp && disp<=(-1) )
 231:	8d 9a 00 01 00 00    	lea    0x100(%edx),%ebx
 237:	b8 0b 00 00 00       	mov    $0xb,%eax
 23c:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
 242:	eb 26                	jmp    26a <get_lz_price_megalz+0x69>
			return 11;
		else
			goto INVALID_CODE_MEGALZ;
	}
	else if( length==3 )
 244:	83 f9 03             	cmp    $0x3,%ecx
 247:	75 25                	jne    26e <get_lz_price_megalz+0x6d>
	{
		if( (-256)<=disp && disp<=(-1) )
 249:	8d 9a 00 01 00 00    	lea    0x100(%edx),%ebx
 24f:	b8 0c 00 00 00       	mov    $0xc,%eax
 254:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
 25a:	76 65                	jbe    2c1 <get_lz_price_megalz+0xc0>
			return 12;
		else if( (-4352)<=disp && disp<(-256) )
 25c:	8d 9a 00 11 00 00    	lea    0x1100(%edx),%ebx
 262:	b0 10                	mov    $0x10,%al
 264:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 26a:	77 43                	ja     2af <get_lz_price_megalz+0xae>
 26c:	eb 53                	jmp    2c1 <get_lz_price_megalz+0xc0>
			return 16;
		else
			goto INVALID_CODE_MEGALZ;
	}
	else if( 4<=length && length<=255 )
 26e:	8d 41 fc             	lea    -0x4(%ecx),%eax
 271:	3d fb 00 00 00       	cmp    $0xfb,%eax
 276:	77 37                	ja     2af <get_lz_price_megalz+0xae>
	{
		varlen = 0;
		varbits = (length-2)>>1;
 278:	8d 59 fe             	lea    -0x2(%ecx),%ebx
 27b:	31 c0                	xor    %eax,%eax
 27d:	d1 fb                	sar    %ebx
		while( varbits )
		{
			varbits >>= 1;
			varlen+=2;
 27f:	83 c0 02             	add    $0x2,%eax
	}
	else if( 4<=length && length<=255 )
	{
		varlen = 0;
		varbits = (length-2)>>1;
		while( varbits )
 282:	d1 eb                	shr    %ebx
 284:	75 f9                	jne    27f <get_lz_price_megalz+0x7e>
		{
			varbits >>= 1;
			varlen+=2;
		}

		if( (-256)<=disp && disp<=(-1) )
 286:	8d 9a 00 01 00 00    	lea    0x100(%edx),%ebx
 28c:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
 292:	77 05                	ja     299 <get_lz_price_megalz+0x98>
			varlen += 9;
 294:	83 c0 09             	add    $0x9,%eax
 297:	eb 11                	jmp    2aa <get_lz_price_megalz+0xa9>
		else if( (-4352)<=disp && disp<(-256) )
 299:	8d 9a 00 11 00 00    	lea    0x1100(%edx),%ebx
 29f:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 2a5:	77 08                	ja     2af <get_lz_price_megalz+0xae>
			varlen += 13;
 2a7:	83 c0 0d             	add    $0xd,%eax
		else
			goto INVALID_CODE_MEGALZ;

		return varlen+3;
 2aa:	83 c0 03             	add    $0x3,%eax
 2ad:	eb 12                	jmp    2c1 <get_lz_price_megalz+0xc0>
	}
	else
	{
INVALID_CODE_MEGALZ:
		printf("mhmt-lz.c:get_lz_price_megalz(): Found invalid code length=%d, displacement=%d\n",length, disp);
 2af:	50                   	push   %eax
 2b0:	52                   	push   %edx
 2b1:	51                   	push   %ecx
 2b2:	68 9d 00 00 00       	push   $0x9d
 2b7:	e8 fc ff ff ff       	call   2b8 <get_lz_price_megalz+0xb7>
 2bc:	31 c0                	xor    %eax,%eax
		return 0;
 2be:	83 c4 10             	add    $0x10,%esp
	}
}
 2c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 2c4:	c9                   	leave  
 2c5:	c3                   	ret    

000002c6 <make_lz_codes>:


// Universal search function
//
void make_lz_codes(ULONG position, ULONG actual_len, UBYTE * hash, struct lzcode * codes)
{
 2c6:	55                   	push   %ebp
 2c7:	89 e5                	mov    %esp,%ebp
 2c9:	57                   	push   %edi
 2ca:	56                   	push   %esi
 2cb:	53                   	push   %ebx
	// start more filling of codes[] from that position
	codepos = 1;


	
	if( wrk.packtype==PK_HST ) // for hrust only,
 2cc:	bb 01 00 00 00       	mov    $0x1,%ebx


// Universal search function
//
void make_lz_codes(ULONG position, ULONG actual_len, UBYTE * hash, struct lzcode * codes)
{
 2d1:	83 ec 6c             	sub    $0x6c,%esp
 2d4:	8b 4d 14             	mov    0x14(%ebp),%ecx
 2d7:	8b 75 08             	mov    0x8(%ebp),%esi
	struct tb_chain * curr_tb;
	UWORD index;
	ULONG max_lookback,max_length,max_tbdisp;

	// copy-byte code is always present
	codes[0].length = 1;
 2da:	c7 01 01 00 00 00    	movl   $0x1,(%ecx)
	codes[0].disp   = 0;
 2e0:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	// start more filling of codes[] from that position
	codepos = 1;


	
	if( wrk.packtype==PK_HST ) // for hrust only,
 2e7:	a1 00 00 00 00       	mov    0x0,%eax
 2ec:	83 f8 03             	cmp    $0x3,%eax
 2ef:	89 45 d8             	mov    %eax,-0x28(%ebp)
 2f2:	75 22                	jne    316 <make_lz_codes+0x50>
 2f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 2f7:	83 e8 0c             	sub    $0xc,%eax
	{                          // add 12,14,16,...,40,42 bytes copies, if possible
		for(codelen=12;codelen<=42;codelen+=2)
		{
			if( position <= (actual_len-codelen) )
 2fa:	39 c6                	cmp    %eax,%esi
 2fc:	77 18                	ja     316 <make_lz_codes+0x50>
			{
				codes[codepos].length = codelen;
 2fe:	8d 54 1b 0a          	lea    0xa(%ebx,%ebx,1),%edx
				codes[codepos].disp   = 0;
				codepos++;
 302:	83 e8 02             	sub    $0x2,%eax
	{                          // add 12,14,16,...,40,42 bytes copies, if possible
		for(codelen=12;codelen<=42;codelen+=2)
		{
			if( position <= (actual_len-codelen) )
			{
				codes[codepos].length = codelen;
 305:	89 14 d9             	mov    %edx,(%ecx,%ebx,8)
				codes[codepos].disp   = 0;
 308:	c7 44 d9 04 00 00 00 	movl   $0x0,0x4(%ecx,%ebx,8)
 30f:	00 
				codepos++;
 310:	43                   	inc    %ebx


	
	if( wrk.packtype==PK_HST ) // for hrust only,
	{                          // add 12,14,16,...,40,42 bytes copies, if possible
		for(codelen=12;codelen<=42;codelen+=2)
 311:	83 fb 11             	cmp    $0x11,%ebx
 314:	75 e4                	jne    2fa <make_lz_codes+0x34>



	// check for one-byter (-1..-8)
	//
	curr_byte=wrk.indata[position];
 316:	8b 3d 30 00 00 00    	mov    0x30,%edi
	//
	i = (position>8) ? position-8 : 0;
 31c:	31 c0                	xor    %eax,%eax



	// check for one-byter (-1..-8)
	//
	curr_byte=wrk.indata[position];
 31e:	89 7d dc             	mov    %edi,-0x24(%ebp)
 321:	01 f7                	add    %esi,%edi
	//
	i = (position>8) ? position-8 : 0;
 323:	83 fe 08             	cmp    $0x8,%esi



	// check for one-byter (-1..-8)
	//
	curr_byte=wrk.indata[position];
 326:	89 7d cc             	mov    %edi,-0x34(%ebp)
 329:	8a 17                	mov    (%edi),%dl
	//
	i = (position>8) ? position-8 : 0;
 32b:	76 03                	jbe    330 <make_lz_codes+0x6a>
 32d:	8d 46 f8             	lea    -0x8(%esi),%eax
 330:	8b 7d dc             	mov    -0x24(%ebp),%edi
 333:	01 c7                	add    %eax,%edi
	do
	{
		if( wrk.indata[i] == curr_byte )
 335:	38 17                	cmp    %dl,(%edi)
 337:	75 11                	jne    34a <make_lz_codes+0x84>
		{
			codes[codepos].length = 1;
 339:	8d 3c d9             	lea    (%ecx,%ebx,8),%edi
			codes[codepos].disp   = -(LONG)(position-i);
 33c:	29 f0                	sub    %esi,%eax
	i = (position>8) ? position-8 : 0;
	do
	{
		if( wrk.indata[i] == curr_byte )
		{
			codes[codepos].length = 1;
 33e:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
			codes[codepos].disp   = -(LONG)(position-i);
			codepos++;
 344:	43                   	inc    %ebx
	do
	{
		if( wrk.indata[i] == curr_byte )
		{
			codes[codepos].length = 1;
			codes[codepos].disp   = -(LONG)(position-i);
 345:	89 47 04             	mov    %eax,0x4(%edi)
			codepos++;
			break;
 348:	eb 06                	jmp    350 <make_lz_codes+0x8a>
		}
	} while( (++i)<position );
 34a:	40                   	inc    %eax
 34b:	47                   	inc    %edi
 34c:	39 f0                	cmp    %esi,%eax
 34e:	72 e5                	jb     335 <make_lz_codes+0x6f>




	// for hrust, check 3-byte insertion code (-1..-79)
	if( (wrk.packtype==PK_HST) && (position < (actual_len-2)) )
 350:	83 7d d8 03          	cmpl   $0x3,-0x28(%ebp)
 354:	75 58                	jne    3ae <make_lz_codes+0xe8>
 356:	8b 45 0c             	mov    0xc(%ebp),%eax
 359:	83 e8 02             	sub    $0x2,%eax
 35c:	39 c6                	cmp    %eax,%esi
 35e:	0f 83 9a 00 00 00    	jae    3fe <make_lz_codes+0x138>
	{
		i = (position>79) ? position-79 : 0;
 364:	31 c0                	xor    %eax,%eax
 366:	83 fe 4f             	cmp    $0x4f,%esi
 369:	76 03                	jbe    36e <make_lz_codes+0xa8>
 36b:	8d 46 b1             	lea    -0x4f(%esi),%eax
 36e:	8b 7d dc             	mov    -0x24(%ebp),%edi
 371:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
 374:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 377:	01 c7                	add    %eax,%edi
		do
		{
			if( (wrk.indata[i]==curr_byte) && (wrk.indata[i+2]==wrk.indata[position+2]) )
 379:	38 17                	cmp    %dl,(%edi)
 37b:	75 23                	jne    3a0 <make_lz_codes+0xda>
 37d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
 380:	8a 4f 02             	mov    0x2(%edi),%cl
 383:	3a 4c 33 02          	cmp    0x2(%ebx,%esi,1),%cl
 387:	75 17                	jne    3a0 <make_lz_codes+0xda>
 389:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			{
				codes[codepos].length = (-3);
				codes[codepos].disp   = -(LONG)(position-i);
 38c:	29 f0                	sub    %esi,%eax
 38e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		i = (position>79) ? position-79 : 0;
		do
		{
			if( (wrk.indata[i]==curr_byte) && (wrk.indata[i+2]==wrk.indata[position+2]) )
			{
				codes[codepos].length = (-3);
 391:	8d 3c d9             	lea    (%ecx,%ebx,8),%edi
				codes[codepos].disp   = -(LONG)(position-i);
				codepos++;
 394:	43                   	inc    %ebx
		i = (position>79) ? position-79 : 0;
		do
		{
			if( (wrk.indata[i]==curr_byte) && (wrk.indata[i+2]==wrk.indata[position+2]) )
			{
				codes[codepos].length = (-3);
 395:	c7 07 fd ff ff ff    	movl   $0xfffffffd,(%edi)
				codes[codepos].disp   = -(LONG)(position-i);
 39b:	89 47 04             	mov    %eax,0x4(%edi)
				codepos++;
				break;
 39e:	eb 5e                	jmp    3fe <make_lz_codes+0x138>
			}
		} while( (++i)<position );
 3a0:	40                   	inc    %eax
 3a1:	47                   	inc    %edi
 3a2:	39 f0                	cmp    %esi,%eax
 3a4:	72 d3                	jb     379 <make_lz_codes+0xb3>
 3a6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 3a9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 3ac:	eb 50                	jmp    3fe <make_lz_codes+0x138>
	}



	
	switch( wrk.packtype ) // set maximum lookback and length
 3ae:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
 3b2:	74 26                	je     3da <make_lz_codes+0x114>
 3b4:	83 7d d8 03          	cmpl   $0x3,-0x28(%ebp)
 3b8:	74 44                	je     3fe <make_lz_codes+0x138>
 3ba:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
 3be:	75 64                	jne    424 <make_lz_codes+0x15e>
	{
	case PK_MLZ:
		max_lookback = (wrk.maxwin<4352) ? wrk.maxwin : 4352;
 3c0:	8b 3d 1c 00 00 00    	mov    0x1c,%edi
 3c6:	81 ff 00 11 00 00    	cmp    $0x1100,%edi
 3cc:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 3cf:	76 1f                	jbe    3f0 <make_lz_codes+0x12a>
 3d1:	c7 45 e4 00 11 00 00 	movl   $0x1100,-0x1c(%ebp)
 3d8:	eb 16                	jmp    3f0 <make_lz_codes+0x12a>
		max_length = 255;
		max_tbdisp = 256;
		break;
	case PK_HRM:
		max_lookback = (wrk.maxwin<4096) ? wrk.maxwin : 4096;
 3da:	a1 1c 00 00 00       	mov    0x1c,%eax
 3df:	3d 00 10 00 00       	cmp    $0x1000,%eax
 3e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 3e7:	76 07                	jbe    3f0 <make_lz_codes+0x12a>
 3e9:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
 3f0:	b8 00 01 00 00       	mov    $0x100,%eax
 3f5:	c7 45 d4 ff 00 00 00 	movl   $0xff,-0x2c(%ebp)
		max_length = 255;
		max_tbdisp = 256;
		break;
 3fc:	eb 33                	jmp    431 <make_lz_codes+0x16b>
	case PK_HST:
		max_lookback = (wrk.maxwin<65536) ? wrk.maxwin : 65536;
 3fe:	8b 3d 1c 00 00 00    	mov    0x1c,%edi
 404:	81 ff 00 00 01 00    	cmp    $0x10000,%edi
 40a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 40d:	76 07                	jbe    416 <make_lz_codes+0x150>
 40f:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
 416:	b8 00 03 00 00       	mov    $0x300,%eax
 41b:	c7 45 d4 ff 0e 00 00 	movl   $0xeff,-0x2c(%ebp)
		max_length = 3839;
		max_tbdisp = 768;
		break;
 422:	eb 0d                	jmp    431 <make_lz_codes+0x16b>
	default:
		printf("mhmt-lz.c:make_lz_codes() - wrong packer type!\n");
 424:	83 ec 0c             	sub    $0xc,%esp
 427:	68 ed 00 00 00       	push   $0xed
 42c:	e9 41 01 00 00       	jmp    572 <make_lz_codes+0x2ac>

	// check for two-byter (-1..-max_tbdisp)
	//
	curr_tb = NULL;
	//
	if( position<(actual_len-1) ) // don't try two-byter if we are at the byte before last one
 431:	8b 7d 0c             	mov    0xc(%ebp),%edi
 434:	4f                   	dec    %edi
 435:	39 fe                	cmp    %edi,%esi
 437:	0f 83 15 01 00 00    	jae    552 <make_lz_codes+0x28c>
	{
		next_byte = wrk.indata[position+1];
		index=(curr_byte<<8) + next_byte;
		curr_tb = tb_entry[index];
 43d:	8b 7d dc             	mov    -0x24(%ebp),%edi
 440:	c1 e2 08             	shl    $0x8,%edx
 443:	0f b6 7c 37 01       	movzbl 0x1(%edi,%esi,1),%edi
 448:	01 fa                	add    %edi,%edx
 44a:	0f b7 d2             	movzwl %dx,%edx
 44d:	8b 14 95 00 00 00 00 	mov    0x0(,%edx,4),%edx

		// there are two-byters!
		if( curr_tb )
 454:	85 d2                	test   %edx,%edx
 456:	0f 84 f6 00 00 00    	je     552 <make_lz_codes+0x28c>
		{
			if( ((position-curr_tb->pos)<=max_tbdisp) && ((position-curr_tb->pos)<=max_lookback) )
 45c:	89 f7                	mov    %esi,%edi
 45e:	2b 3a                	sub    (%edx),%edi
 460:	39 c7                	cmp    %eax,%edi
 462:	0f 87 33 01 00 00    	ja     59b <make_lz_codes+0x2d5>
 468:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
 46b:	0f 87 2a 01 00 00    	ja     59b <make_lz_codes+0x2d5>
			{
				codes[codepos].length = 2;
 471:	8d 3c d9             	lea    (%ecx,%ebx,8),%edi
				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);
				codepos++;
 474:	43                   	inc    %ebx
		// there are two-byters!
		if( curr_tb )
		{
			if( ((position-curr_tb->pos)<=max_tbdisp) && ((position-curr_tb->pos)<=max_lookback) )
			{
				codes[codepos].length = 2;
 475:	c7 07 02 00 00 00    	movl   $0x2,(%edi)
				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);
 47b:	8b 02                	mov    (%edx),%eax
 47d:	29 f0                	sub    %esi,%eax
 47f:	89 47 04             	mov    %eax,0x4(%edi)
 482:	e9 14 01 00 00       	jmp    59b <make_lz_codes+0x2d5>
		}
	}


	// at last, check for lengths=3..max_length up to max_lookback 
	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all
 487:	8b 45 0c             	mov    0xc(%ebp),%eax
 48a:	83 e8 02             	sub    $0x2,%eax
 48d:	39 c6                	cmp    %eax,%esi
 48f:	0f 83 bd 00 00 00    	jae    552 <make_lz_codes+0x28c>
	{
		was_match = 1; // there was match at codelen-1

		for( codelen=3; ( codelen<=max_length )&&( position<(actual_len-codelen+1) ); /*nothing*/ )
 495:	8b 45 0c             	mov    0xc(%ebp),%eax
		}
	}


	// at last, check for lengths=3..max_length up to max_lookback 
	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all
 498:	bf 03 00 00 00       	mov    $0x3,%edi
 49d:	89 75 94             	mov    %esi,-0x6c(%ebp)
 4a0:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	{
		was_match = 1; // there was match at codelen-1

		for( codelen=3; ( codelen<=max_length )&&( position<(actual_len-codelen+1) ); /*nothing*/ )
 4a3:	40                   	inc    %eax
 4a4:	89 45 c8             	mov    %eax,-0x38(%ebp)
 4a7:	b8 01 00 00 00       	mov    $0x1,%eax
 4ac:	e9 90 00 00 00       	jmp    541 <make_lz_codes+0x27b>
 4b1:	8b 0a                	mov    (%edx),%ecx
		{
			if( was_match ) // for codelen-1
 4b3:	85 c0                	test   %eax,%eax
 4b5:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 4b8:	74 36                	je     4f0 <make_lz_codes+0x22a>
			{
				// codelen-1 bytes are matched, compare one more byte
				if( wrk.indata[position+codelen-1] == wrk.indata[curr_tb->pos+codelen-1] )
 4ba:	8b 75 dc             	mov    -0x24(%ebp),%esi
 4bd:	8b 45 94             	mov    -0x6c(%ebp),%eax
 4c0:	01 fe                	add    %edi,%esi
 4c2:	8a 44 30 ff          	mov    -0x1(%eax,%esi,1),%al
 4c6:	3a 44 0e ff          	cmp    -0x1(%esi,%ecx,1),%al
 4ca:	75 0f                	jne    4db <make_lz_codes+0x215>
				{
					// add code to the table
					codes[codepos].length = codelen;
 4cc:	8b 75 e0             	mov    -0x20(%ebp),%esi
 4cf:	8d 0c de             	lea    (%esi,%ebx,8),%ecx
 4d2:	89 39                	mov    %edi,(%ecx)
					codes[codepos].disp   = -(LONG)(position - curr_tb->pos);
 4d4:	8b 02                	mov    (%edx),%eax
 4d6:	2b 45 94             	sub    -0x6c(%ebp),%eax
 4d9:	eb 57                	jmp    532 <make_lz_codes+0x26c>
				{

MATCH_FAIL: // entrance for failed matches here: used 3-fold so we set "goto" here

					// go for older twobyter
					curr_tb = curr_tb->next;
 4db:	8b 52 04             	mov    0x4(%edx),%edx

					// no more twobyters or they are too far - stop search at all
					if( !curr_tb ) break;
 4de:	85 d2                	test   %edx,%edx
 4e0:	74 6d                	je     54f <make_lz_codes+0x289>
					if( (position - curr_tb->pos)>max_lookback ) break;
 4e2:	8b 45 94             	mov    -0x6c(%ebp),%eax
 4e5:	2b 02                	sub    (%edx),%eax
 4e7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 4ea:	77 63                	ja     54f <make_lz_codes+0x289>
 4ec:	31 c0                	xor    %eax,%eax
 4ee:	eb 4c                	jmp    53c <make_lz_codes+0x276>
			}
			else // there were no matches for previous codelen
			{
				// next twobyter is already taken, but no comparision is done for codelen bytes
				// first we check if we need to do such comparision at all by seeing to the hashes of the ends of strings
				if( hash[position+codelen-1] == hash[curr_tb->pos+codelen-1] )
 4f0:	8b 4d 10             	mov    0x10(%ebp),%ecx
 4f3:	8b 75 94             	mov    -0x6c(%ebp),%esi
 4f6:	8b 45 10             	mov    0x10(%ebp),%eax
 4f9:	03 45 b4             	add    -0x4c(%ebp),%eax
 4fc:	01 f9                	add    %edi,%ecx
 4fe:	8a 4c 0e ff          	mov    -0x1(%esi,%ecx,1),%cl
 502:	3a 4c 07 ff          	cmp    -0x1(%edi,%eax,1),%cl
 506:	75 d3                	jne    4db <make_lz_codes+0x215>
				{	// hashes match, so try matching complete string
					if( !memcmp( &wrk.indata[position], &wrk.indata[curr_tb->pos], codelen ) )
 508:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 50b:	03 45 dc             	add    -0x24(%ebp),%eax
 50e:	51                   	push   %ecx
 50f:	57                   	push   %edi
 510:	50                   	push   %eax
 511:	ff 75 cc             	pushl  -0x34(%ebp)
 514:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 517:	e8 fc ff ff ff       	call   518 <make_lz_codes+0x252>
 51c:	83 c4 10             	add    $0x10,%esp
 51f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 522:	85 c0                	test   %eax,%eax
 524:	75 b5                	jne    4db <make_lz_codes+0x215>
					{
						was_match = 1;
						codes[codepos].length = codelen;
 526:	8b 45 e0             	mov    -0x20(%ebp),%eax
 529:	8d 0c d8             	lea    (%eax,%ebx,8),%ecx
 52c:	89 39                	mov    %edi,(%ecx)
						codes[codepos].disp   = -(LONG)(position - curr_tb->pos);
 52e:	8b 02                	mov    (%edx),%eax
 530:	29 f0                	sub    %esi,%eax
 532:	89 41 04             	mov    %eax,0x4(%ecx)
						codepos++;
 535:	43                   	inc    %ebx

						codelen++;
 536:	47                   	inc    %edi
 537:	b8 01 00 00 00       	mov    $0x1,%eax
	// at last, check for lengths=3..max_length up to max_lookback 
	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all
	{
		was_match = 1; // there was match at codelen-1

		for( codelen=3; ( codelen<=max_length )&&( position<(actual_len-codelen+1) ); /*nothing*/ )
 53c:	3b 7d d4             	cmp    -0x2c(%ebp),%edi
 53f:	77 0e                	ja     54f <make_lz_codes+0x289>
 541:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 544:	29 f9                	sub    %edi,%ecx
 546:	39 4d 94             	cmp    %ecx,-0x6c(%ebp)
 549:	0f 82 62 ff ff ff    	jb     4b1 <make_lz_codes+0x1eb>
 54f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		}
	}

	// here we assume to have found all possible matches. check for codes[] table overflow:
	// there could be matches for length 1..3839, and there is copy-1-byte, 16 copymanybyters, 1 insertion match, total 3857 entries for hrust, 256 for megalz & hrum
	if(   codepos > ( (wrk.packtype==PK_HST) ? 3857 : 256 )   ) // this should not happen!
 552:	31 c0                	xor    %eax,%eax
 554:	83 7d d8 03          	cmpl   $0x3,-0x28(%ebp)
 558:	0f 94 c0             	sete   %al
 55b:	48                   	dec    %eax
 55c:	25 ef f1 ff ff       	and    $0xfffff1ef,%eax
 561:	05 11 0f 00 00       	add    $0xf11,%eax
 566:	39 c3                	cmp    %eax,%ebx
 568:	76 19                	jbe    583 <make_lz_codes+0x2bd>
	{
		printf("mhmt-lz.c:make_lz_codes_hrust() encountered too many entries in codes[] table. Fatal error.\n");
 56a:	83 ec 0c             	sub    $0xc,%esp
 56d:	68 1c 01 00 00       	push   $0x11c
 572:	e8 fc ff ff ff       	call   573 <make_lz_codes+0x2ad>
		exit(1);
 577:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 57e:	e8 fc ff ff ff       	call   57f <make_lz_codes+0x2b9>
	}

	// mark end-of-records in codes[]
	codes[codepos].length = 0;
 583:	8d 04 d9             	lea    (%ecx,%ebx,8),%eax
 586:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	codes[codepos].disp   = 0;
 58c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
 593:	8d 65 f4             	lea    -0xc(%ebp),%esp
 596:	5b                   	pop    %ebx
 597:	5e                   	pop    %esi
 598:	5f                   	pop    %edi
 599:	5d                   	pop    %ebp
 59a:	c3                   	ret    
		}
	}


	// at last, check for lengths=3..max_length up to max_lookback 
	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all
 59b:	89 f0                	mov    %esi,%eax
 59d:	2b 02                	sub    (%edx),%eax
 59f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 5a2:	0f 86 df fe ff ff    	jbe    487 <make_lz_codes+0x1c1>
 5a8:	eb a8                	jmp    552 <make_lz_codes+0x28c>

mhmt-main.o:     file format elf32-i386


Disassembly of section .text:

00000000 <do_files>:
}

// create output filename, open files, load input file in memory
// returns 1 if no errors, otherwise zero
ULONG do_files(void)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 0c             	sub    $0xc,%esp
	char * depk_ext;
	LONG ext_pos;


	// if there is no output filename, create it
	if( !wrk.fname_out )
   9:	83 3d 24 00 00 00 00 	cmpl   $0x0,0x24
  10:	0f 85 ce 00 00 00    	jne    e4 <do_files+0xe4>
	{
		depk_ext = ".dpk";

		if( wrk.packtype==PK_MLZ )
  16:	a1 00 00 00 00       	mov    0x0,%eax
  1b:	bb 00 00 00 00       	mov    $0x0,%ebx
  20:	83 f8 01             	cmp    $0x1,%eax
  23:	74 19                	je     3e <do_files+0x3e>
			pack_ext = ".mlz";
		else if( wrk.packtype==PK_HRM )
  25:	83 f8 02             	cmp    $0x2,%eax
  28:	bb 05 00 00 00       	mov    $0x5,%ebx
  2d:	74 0f                	je     3e <do_files+0x3e>
			pack_ext = ".hrm";
		else if( wrk.packtype==PK_HST )
  2f:	83 f8 03             	cmp    $0x3,%eax
  32:	bb 0f 00 00 00       	mov    $0xf,%ebx
  37:	74 05                	je     3e <do_files+0x3e>
  39:	bb 0a 00 00 00       	mov    $0xa,%ebx
			pack_ext = ".hst";
		else
			pack_ext = ".pak"; // all have the same size, as well as depk_ext - 4 bytes!


		wrk.fname_out = (char *)malloc( 5 + strlen(wrk.fname_in) );
  3e:	8b 3d 20 00 00 00    	mov    0x20,%edi
  44:	31 c0                	xor    %eax,%eax
  46:	83 c9 ff             	or     $0xffffffff,%ecx
  49:	83 ec 0c             	sub    $0xc,%esp
  4c:	f2 ae                	repnz scas %es:(%edi),%al
  4e:	f7 d1                	not    %ecx
  50:	83 c1 04             	add    $0x4,%ecx
  53:	51                   	push   %ecx
  54:	e8 fc ff ff ff       	call   55 <do_files+0x55>
		if( !wrk.fname_out )
  59:	83 c4 10             	add    $0x10,%esp
  5c:	85 c0                	test   %eax,%eax
			pack_ext = ".hst";
		else
			pack_ext = ".pak"; // all have the same size, as well as depk_ext - 4 bytes!


		wrk.fname_out = (char *)malloc( 5 + strlen(wrk.fname_in) );
  5e:	a3 24 00 00 00       	mov    %eax,0x24
		if( !wrk.fname_out )
  63:	75 12                	jne    77 <do_files+0x77>
		{
			printf("Can't allocate memory for output filename!\n");
  65:	83 ec 0c             	sub    $0xc,%esp
  68:	68 14 00 00 00       	push   $0x14
  6d:	e8 fc ff ff ff       	call   6e <do_files+0x6e>
  72:	e9 c0 01 00 00       	jmp    237 <do_files+0x237>
			return 0;
		}

		strcpy(wrk.fname_out, wrk.fname_in);
  77:	56                   	push   %esi
  78:	56                   	push   %esi
  79:	ff 35 20 00 00 00    	pushl  0x20
  7f:	50                   	push   %eax
  80:	e8 fc ff ff ff       	call   81 <do_files+0x81>

		if( !wrk.mode ) // packing
  85:	83 c4 10             	add    $0x10,%esp
  88:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
  8f:	75 0b                	jne    9c <do_files+0x9c>
		{
			strcat(wrk.fname_out, pack_ext);
  91:	51                   	push   %ecx
  92:	51                   	push   %ecx
  93:	53                   	push   %ebx
  94:	ff 35 24 00 00 00    	pushl  0x24
  9a:	eb 40                	jmp    dc <do_files+0xdc>
		}
		else // depacking
		{
			ext_pos = strlen( wrk.fname_out ) - 4;
  9c:	8b 35 24 00 00 00    	mov    0x24,%esi
  a2:	83 c9 ff             	or     $0xffffffff,%ecx
  a5:	31 c0                	xor    %eax,%eax
  a7:	89 f7                	mov    %esi,%edi
  a9:	f2 ae                	repnz scas %es:(%edi),%al
  ab:	f7 d1                	not    %ecx

			if( (ext_pos>=0) && (!strcmp(&wrk.fname_out[ext_pos], pack_ext)) )
  ad:	83 e9 05             	sub    $0x5,%ecx
  b0:	78 22                	js     d4 <do_files+0xd4>
  b2:	52                   	push   %edx
  b3:	52                   	push   %edx
  b4:	53                   	push   %ebx
  b5:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
  b8:	57                   	push   %edi
  b9:	e8 fc ff ff ff       	call   ba <do_files+0xba>
  be:	83 c4 10             	add    $0x10,%esp
  c1:	85 c0                	test   %eax,%eax
  c3:	75 0f                	jne    d4 <do_files+0xd4>
				strcpy( &wrk.fname_out[ext_pos], depk_ext );
  c5:	50                   	push   %eax
  c6:	50                   	push   %eax
  c7:	68 3f 00 00 00       	push   $0x3f
  cc:	57                   	push   %edi
  cd:	e8 fc ff ff ff       	call   ce <do_files+0xce>
  d2:	eb 0d                	jmp    e1 <do_files+0xe1>
			else
				strcat( wrk.fname_out, depk_ext );
  d4:	57                   	push   %edi
  d5:	57                   	push   %edi
  d6:	68 3f 00 00 00       	push   $0x3f
  db:	56                   	push   %esi
  dc:	e8 fc ff ff ff       	call   dd <do_files+0xdd>
  e1:	83 c4 10             	add    $0x10,%esp
		}
	}


	//open files
	wrk.file_in=fopen(wrk.fname_in,"rb");
  e4:	56                   	push   %esi
  e5:	56                   	push   %esi
  e6:	68 44 00 00 00       	push   $0x44
  eb:	ff 35 20 00 00 00    	pushl  0x20
  f1:	e8 fc ff ff ff       	call   f2 <do_files+0xf2>

	if(!wrk.file_in)
  f6:	83 c4 10             	add    $0x10,%esp
  f9:	85 c0                	test   %eax,%eax
		}
	}


	//open files
	wrk.file_in=fopen(wrk.fname_in,"rb");
  fb:	a3 28 00 00 00       	mov    %eax,0x28

	if(!wrk.file_in)
 100:	75 12                	jne    114 <do_files+0x114>
	{
		printf("Cannot open input file \"%s\"!\n",wrk.fname_in);
 102:	53                   	push   %ebx
 103:	53                   	push   %ebx
 104:	ff 35 20 00 00 00    	pushl  0x20
 10a:	68 47 00 00 00       	push   $0x47
 10f:	e9 1e 01 00 00       	jmp    232 <do_files+0x232>
		return 0;
	}

	wrk.file_out=fopen(wrk.fname_out,"wb");
 114:	51                   	push   %ecx
 115:	51                   	push   %ecx
 116:	68 65 00 00 00       	push   $0x65
 11b:	ff 35 24 00 00 00    	pushl  0x24
 121:	e8 fc ff ff ff       	call   122 <do_files+0x122>
	if(!wrk.file_out)
 126:	83 c4 10             	add    $0x10,%esp
 129:	85 c0                	test   %eax,%eax
	{
		printf("Cannot open input file \"%s\"!\n",wrk.fname_in);
		return 0;
	}

	wrk.file_out=fopen(wrk.fname_out,"wb");
 12b:	a3 2c 00 00 00       	mov    %eax,0x2c
	if(!wrk.file_out)
 130:	75 12                	jne    144 <do_files+0x144>
	{
		printf("Cannot create output file \"%s\"!\n",wrk.fname_out);
 132:	52                   	push   %edx
 133:	52                   	push   %edx
 134:	ff 35 24 00 00 00    	pushl  0x24
 13a:	68 68 00 00 00       	push   $0x68
 13f:	e9 ee 00 00 00       	jmp    232 <do_files+0x232>
		return 0;
	}


	// get length of input file
	if( fseek(wrk.file_in,0,SEEK_END) )
 144:	50                   	push   %eax
 145:	6a 02                	push   $0x2
 147:	6a 00                	push   $0x0
 149:	ff 35 28 00 00 00    	pushl  0x28
 14f:	e8 fc ff ff ff       	call   150 <do_files+0x150>
 154:	83 c4 10             	add    $0x10,%esp
 157:	85 c0                	test   %eax,%eax
 159:	75 6a                	jne    1c5 <do_files+0x1c5>
	{
		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);
		return 0;
	}
	wrk.inlen=(ULONG)ftell(wrk.file_in);
 15b:	83 ec 0c             	sub    $0xc,%esp
 15e:	ff 35 28 00 00 00    	pushl  0x28
 164:	e8 fc ff ff ff       	call   165 <do_files+0x165>
	if( wrk.inlen==(ULONG)(-1L)  )
 169:	83 c4 10             	add    $0x10,%esp
 16c:	83 f8 ff             	cmp    $0xffffffff,%eax
	if( fseek(wrk.file_in,0,SEEK_END) )
	{
		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);
		return 0;
	}
	wrk.inlen=(ULONG)ftell(wrk.file_in);
 16f:	a3 34 00 00 00       	mov    %eax,0x34
	if( wrk.inlen==(ULONG)(-1L)  )
 174:	75 21                	jne    197 <do_files+0x197>
	{
		printf("Cannot ftell() length of input file \"%s\"!\n",wrk.fname_in);
 176:	57                   	push   %edi
 177:	57                   	push   %edi
 178:	ff 35 20 00 00 00    	pushl  0x20
 17e:	68 aa 00 00 00       	push   $0xaa
 183:	e8 fc ff ff ff       	call   184 <do_files+0x184>
		wrk.inlen=0;
 188:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
 18f:	00 00 00 
 192:	e9 a0 00 00 00       	jmp    237 <do_files+0x237>
		return 0;
	}
	else if( wrk.inlen<16 )
 197:	83 f8 0f             	cmp    $0xf,%eax
 19a:	77 12                	ja     1ae <do_files+0x1ae>
	{
		printf("Input file \"%s\" is smaller than 16 bytes - I won't process it!\n",wrk.fname_in);
 19c:	56                   	push   %esi
 19d:	56                   	push   %esi
 19e:	ff 35 20 00 00 00    	pushl  0x20
 1a4:	68 d5 00 00 00       	push   $0xd5
 1a9:	e9 84 00 00 00       	jmp    232 <do_files+0x232>
		return 0;
	}
	if( fseek(wrk.file_in,0,SEEK_SET) )
 1ae:	53                   	push   %ebx
 1af:	6a 00                	push   $0x0
 1b1:	6a 00                	push   $0x0
 1b3:	ff 35 28 00 00 00    	pushl  0x28
 1b9:	e8 fc ff ff ff       	call   1ba <do_files+0x1ba>
 1be:	83 c4 10             	add    $0x10,%esp
 1c1:	85 c0                	test   %eax,%eax
 1c3:	74 0f                	je     1d4 <do_files+0x1d4>
	{
		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);
 1c5:	51                   	push   %ecx
 1c6:	51                   	push   %ecx
 1c7:	ff 35 20 00 00 00    	pushl  0x20
 1cd:	68 89 00 00 00       	push   $0x89
 1d2:	eb 5e                	jmp    232 <do_files+0x232>
		return 0;
	}


	// load input file in mem
	wrk.indata=(UBYTE *)malloc(wrk.inlen);
 1d4:	83 ec 0c             	sub    $0xc,%esp
 1d7:	ff 35 34 00 00 00    	pushl  0x34
 1dd:	e8 fc ff ff ff       	call   1de <do_files+0x1de>
	if( !wrk.indata )
 1e2:	83 c4 10             	add    $0x10,%esp
 1e5:	85 c0                	test   %eax,%eax
		return 0;
	}


	// load input file in mem
	wrk.indata=(UBYTE *)malloc(wrk.inlen);
 1e7:	a3 30 00 00 00       	mov    %eax,0x30
	if( !wrk.indata )
 1ec:	75 14                	jne    202 <do_files+0x202>
	{
		printf("Cannot allocate %d bytes of memory for loading input file \"%s\"!\n", wrk.inlen, wrk.fname_in);
 1ee:	52                   	push   %edx
 1ef:	ff 35 20 00 00 00    	pushl  0x20
 1f5:	ff 35 34 00 00 00    	pushl  0x34
 1fb:	68 15 01 00 00       	push   $0x115
 200:	eb 30                	jmp    232 <do_files+0x232>
		return 0;
	}

	if( wrk.inlen!=fread(wrk.indata,1,wrk.inlen,wrk.file_in) )
 202:	ff 35 28 00 00 00    	pushl  0x28
 208:	8b 1d 34 00 00 00    	mov    0x34,%ebx
 20e:	53                   	push   %ebx
 20f:	6a 01                	push   $0x1
 211:	50                   	push   %eax
 212:	e8 fc ff ff ff       	call   213 <do_files+0x213>
 217:	83 c4 10             	add    $0x10,%esp
 21a:	89 c2                	mov    %eax,%edx
 21c:	b8 01 00 00 00       	mov    $0x1,%eax
 221:	39 d3                	cmp    %edx,%ebx
 223:	74 17                	je     23c <do_files+0x23c>
	{
		printf("Cannot successfully load input file \"%s\" in memory!\n",wrk.fname_in);
 225:	50                   	push   %eax
 226:	50                   	push   %eax
 227:	ff 35 20 00 00 00    	pushl  0x20
 22d:	68 56 01 00 00       	push   $0x156
 232:	e8 fc ff ff ff       	call   233 <do_files+0x233>
 237:	31 c0                	xor    %eax,%eax
		return 0;
 239:	83 c4 10             	add    $0x10,%esp
	}


	return 1;// no errors
}
 23c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 23f:	5b                   	pop    %ebx
 240:	5e                   	pop    %esi
 241:	5f                   	pop    %edi
 242:	5d                   	pop    %ebp
 243:	c3                   	ret    

00000244 <dump_config>:
	printf("====== mhmt help end ======\n");
	printf("\n");
}

void dump_config(void)
{
 244:	55                   	push   %ebp
 245:	89 e5                	mov    %esp,%ebp
 247:	83 ec 14             	sub    $0x14,%esp
	printf("Configuration review:\n");
 24a:	68 8b 01 00 00       	push   $0x18b
 24f:	e8 fc ff ff ff       	call   250 <dump_config+0xc>
	printf("\n");
 254:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 25b:	e8 fc ff ff ff       	call   25c <dump_config+0x18>

	printf("Pack format: ");
 260:	c7 04 24 a1 01 00 00 	movl   $0x1a1,(%esp)
 267:	e8 fc ff ff ff       	call   268 <dump_config+0x24>
	if( wrk.packtype==PK_MLZ )
 26c:	a1 00 00 00 00       	mov    0x0,%eax
 271:	83 c4 10             	add    $0x10,%esp
 274:	83 f8 01             	cmp    $0x1,%eax
 277:	75 0a                	jne    283 <dump_config+0x3f>
		printf("MegaLZ.\n");
 279:	83 ec 0c             	sub    $0xc,%esp
 27c:	68 af 01 00 00       	push   $0x1af
 281:	eb 26                	jmp    2a9 <dump_config+0x65>
	else if( wrk.packtype==PK_HRM )
 283:	83 f8 02             	cmp    $0x2,%eax
 286:	75 0a                	jne    292 <dump_config+0x4e>
		printf("Hrum3.5\n");
 288:	83 ec 0c             	sub    $0xc,%esp
 28b:	68 b7 01 00 00       	push   $0x1b7
 290:	eb 17                	jmp    2a9 <dump_config+0x65>
	else if( wrk.packtype==PK_HST )
 292:	83 f8 03             	cmp    $0x3,%eax
 295:	75 0a                	jne    2a1 <dump_config+0x5d>
		printf("Hrust1.x\n");
 297:	83 ec 0c             	sub    $0xc,%esp
 29a:	68 bf 01 00 00       	push   $0x1bf
 29f:	eb 08                	jmp    2a9 <dump_config+0x65>
	else
		printf("unknown.\n"); // this should be actually never displayed
 2a1:	83 ec 0c             	sub    $0xc,%esp
 2a4:	68 c8 01 00 00       	push   $0x1c8
 2a9:	e8 fc ff ff ff       	call   2aa <dump_config+0x66>

	printf("Mode:        ");
 2ae:	c7 04 24 d1 01 00 00 	movl   $0x1d1,(%esp)
 2b5:	e8 fc ff ff ff       	call   2b6 <dump_config+0x72>
	if( wrk.mode )
 2ba:	83 c4 10             	add    $0x10,%esp
 2bd:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
 2c4:	74 0a                	je     2d0 <dump_config+0x8c>
		printf("depacking.\n");
 2c6:	83 ec 0c             	sub    $0xc,%esp
 2c9:	68 df 01 00 00       	push   $0x1df
 2ce:	eb 08                	jmp    2d8 <dump_config+0x94>
	else
		printf("packing.\n");
 2d0:	83 ec 0c             	sub    $0xc,%esp
 2d3:	68 ea 01 00 00       	push   $0x1ea
 2d8:	e8 fc ff ff ff       	call   2d9 <dump_config+0x95>
 2dd:	83 c4 10             	add    $0x10,%esp

	if( !wrk.mode )
 2e0:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
 2e7:	75 33                	jne    31c <dump_config+0xd8>
	{
		printf("Pack coding: ");
 2e9:	83 ec 0c             	sub    $0xc,%esp
 2ec:	68 f3 01 00 00       	push   $0x1f3
 2f1:	e8 fc ff ff ff       	call   2f2 <dump_config+0xae>
		if( wrk.greedy )
 2f6:	83 c4 10             	add    $0x10,%esp
 2f9:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
 300:	74 0a                	je     30c <dump_config+0xc8>
			printf("greedy (sub-optimal but faster).\n");
 302:	83 ec 0c             	sub    $0xc,%esp
 305:	68 01 02 00 00       	push   $0x201
 30a:	eb 08                	jmp    314 <dump_config+0xd0>
		else
			printf("optimal (slower).\n");
 30c:	83 ec 0c             	sub    $0xc,%esp
 30f:	68 22 02 00 00       	push   $0x222
 314:	e8 fc ff ff ff       	call   315 <dump_config+0xd1>
 319:	83 c4 10             	add    $0x10,%esp
	}

	if( wrk.zxheader )
 31c:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
 323:	74 49                	je     36e <dump_config+0x12a>
	{
		printf("Header for old ZX ");
 325:	83 ec 0c             	sub    $0xc,%esp
 328:	68 34 02 00 00       	push   $0x234
 32d:	e8 fc ff ff ff       	call   32e <dump_config+0xea>
		if( wrk.packtype==PK_HRM )
 332:	a1 00 00 00 00       	mov    0x0,%eax
 337:	83 c4 10             	add    $0x10,%esp
 33a:	83 f8 02             	cmp    $0x2,%eax
 33d:	75 0a                	jne    349 <dump_config+0x105>
			printf("hrum3.5 ");
 33f:	83 ec 0c             	sub    $0xc,%esp
 342:	68 47 02 00 00       	push   $0x247
 347:	eb 0d                	jmp    356 <dump_config+0x112>
		else if( wrk.packtype==PK_HST )
 349:	83 f8 03             	cmp    $0x3,%eax
 34c:	75 10                	jne    35e <dump_config+0x11a>
			printf("hrust1.x ");
 34e:	83 ec 0c             	sub    $0xc,%esp
 351:	68 50 02 00 00       	push   $0x250
 356:	e8 fc ff ff ff       	call   357 <dump_config+0x113>
 35b:	83 c4 10             	add    $0x10,%esp

		printf("depackers is on.\n");
 35e:	83 ec 0c             	sub    $0xc,%esp
 361:	68 5a 02 00 00       	push   $0x25a
 366:	e8 fc ff ff ff       	call   367 <dump_config+0x123>
 36b:	83 c4 10             	add    $0x10,%esp
	}

	if( wrk.wordbit )
 36e:	83 3d 10 00 00 00 00 	cmpl   $0x0,0x10
 375:	74 5d                	je     3d4 <dump_config+0x190>
	{
		printf("Bitstream is grouped in words -\n");
 377:	83 ec 0c             	sub    $0xc,%esp
 37a:	68 6b 02 00 00       	push   $0x26b
 37f:	e8 fc ff ff ff       	call   380 <dump_config+0x13c>
		if( wrk.bigend )
 384:	83 c4 10             	add    $0x10,%esp
 387:	83 3d 14 00 00 00 00 	cmpl   $0x0,0x14
 38e:	74 13                	je     3a3 <dump_config+0x15f>
		{
			printf(" words are big-endian, %s","INCOMPATIBLE with old ZX depackers!\n");
 390:	52                   	push   %edx
 391:	52                   	push   %edx
 392:	68 8b 02 00 00       	push   $0x28b
 397:	68 b0 02 00 00       	push   $0x2b0
 39c:	e8 fc ff ff ff       	call   39d <dump_config+0x159>
 3a1:	eb 61                	jmp    404 <dump_config+0x1c0>
		}
		else
		{
			printf(" words are little-endian, ");
 3a3:	83 ec 0c             	sub    $0xc,%esp
 3a6:	68 ca 02 00 00       	push   $0x2ca
 3ab:	e8 fc ff ff ff       	call   3ac <dump_config+0x168>
			if( (wrk.packtype==PK_HRM) || (wrk.packtype==PK_HST) )
 3b0:	a1 00 00 00 00       	mov    0x0,%eax
 3b5:	83 c4 10             	add    $0x10,%esp
 3b8:	83 e8 02             	sub    $0x2,%eax
 3bb:	83 f8 01             	cmp    $0x1,%eax
 3be:	77 0a                	ja     3ca <dump_config+0x186>
				printf("compatible with old ZX depackers.\n");
 3c0:	83 ec 0c             	sub    $0xc,%esp
 3c3:	68 e5 02 00 00       	push   $0x2e5
 3c8:	eb 35                	jmp    3ff <dump_config+0x1bb>
			else
				printf("INCOMPATIBLE with old ZX depackers!\n");
 3ca:	83 ec 0c             	sub    $0xc,%esp
 3cd:	68 07 03 00 00       	push   $0x307
 3d2:	eb 2b                	jmp    3ff <dump_config+0x1bb>
		}
	}
	else
	{
		printf("Bitstream is grouped in bytes -\n");
 3d4:	83 ec 0c             	sub    $0xc,%esp
 3d7:	68 2b 03 00 00       	push   $0x32b
 3dc:	e8 fc ff ff ff       	call   3dd <dump_config+0x199>
		if( wrk.packtype==PK_MLZ )
 3e1:	83 c4 10             	add    $0x10,%esp
 3e4:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
 3eb:	75 0a                	jne    3f7 <dump_config+0x1b3>
			printf(" compatible with old ZX depackers.\n");
 3ed:	83 ec 0c             	sub    $0xc,%esp
 3f0:	68 4b 03 00 00       	push   $0x34b
 3f5:	eb 08                	jmp    3ff <dump_config+0x1bb>
		else
			printf(" INCOMPATIBLE with old ZX depackers!\n");
 3f7:	83 ec 0c             	sub    $0xc,%esp
 3fa:	68 6e 03 00 00       	push   $0x36e
 3ff:	e8 fc ff ff ff       	call   400 <dump_config+0x1bc>
 404:	59                   	pop    %ecx
 405:	58                   	pop    %eax
	}

	printf("Maximum lookback window size is %d bytes.\n\n",wrk.maxwin);
 406:	ff 35 1c 00 00 00    	pushl  0x1c
 40c:	68 93 03 00 00       	push   $0x393
 411:	e8 fc ff ff ff       	call   412 <dump_config+0x1ce>


	// files
	printf("Input file \"%s\" (%d bytes) successfully loaded.\n", wrk.fname_in, wrk.inlen);
 416:	83 c4 0c             	add    $0xc,%esp
 419:	ff 35 34 00 00 00    	pushl  0x34
 41f:	ff 35 20 00 00 00    	pushl  0x20
 425:	68 bf 03 00 00       	push   $0x3bf
 42a:	e8 fc ff ff ff       	call   42b <dump_config+0x1e7>
	printf("Output file \"%s\" created.\n", wrk.fname_out );
 42f:	58                   	pop    %eax
 430:	5a                   	pop    %edx
 431:	ff 35 24 00 00 00    	pushl  0x24
 437:	68 f0 03 00 00       	push   $0x3f0
 43c:	e8 fc ff ff ff       	call   43d <dump_config+0x1f9>
 441:	83 c4 10             	add    $0x10,%esp

//	...more info...?
}
 444:	c9                   	leave  
 445:	c3                   	ret    

00000446 <show_help>:

	return error;
}

void show_help(void)
{
 446:	55                   	push   %ebp
 447:	89 e5                	mov    %esp,%ebp
 449:	83 ec 14             	sub    $0x14,%esp
	printf("======== mhmt help ========\n");
 44c:	68 0b 04 00 00       	push   $0x40b
 451:	e8 fc ff ff ff       	call   452 <show_help+0xc>
	printf("parameters:\n");
 456:	c7 04 24 27 04 00 00 	movl   $0x427,(%esp)
 45d:	e8 fc ff ff ff       	call   45e <show_help+0x18>
	printf("-mlz, -hrm, -hst - use MegaLZ, hrum3.5 or hrust1.x format (default is MegaLZ)\n");
 462:	c7 04 24 33 04 00 00 	movl   $0x433,(%esp)
 469:	e8 fc ff ff ff       	call   46a <show_help+0x24>
	printf("-g - greedy coding (default is optimal coding)\n");
 46e:	c7 04 24 81 04 00 00 	movl   $0x481,(%esp)
 475:	e8 fc ff ff ff       	call   476 <show_help+0x30>
	printf("-d - depacking instead of packing (default is packing)\n");
 47a:	c7 04 24 b0 04 00 00 	movl   $0x4b0,(%esp)
 481:	e8 fc ff ff ff       	call   482 <show_help+0x3c>
	printf("\n");
 486:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 48d:	e8 fc ff ff ff       	call   48e <show_help+0x48>
	printf("-zxh - use zx-specific header for hrum or hrust. DEFAULT is NO HEADER!\n");
 492:	c7 04 24 e7 04 00 00 	movl   $0x4e7,(%esp)
 499:	e8 fc ff ff ff       	call   49a <show_help+0x54>
	printf("       Not applicable for MegaLZ. If -zxh is specified, -16, NO -bend and\n");
 49e:	c7 04 24 2e 05 00 00 	movl   $0x52e,(%esp)
 4a5:	e8 fc ff ff ff       	call   4a6 <show_help+0x60>
	printf("       NO -mlz is forced.\n");
 4aa:	c7 04 24 78 05 00 00 	movl   $0x578,(%esp)
 4b1:	e8 fc ff ff ff       	call   4b2 <show_help+0x6c>
	printf("\n");
 4b6:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 4bd:	e8 fc ff ff ff       	call   4be <show_help+0x78>
	printf("-8, -16 - bitstream is in bytes or words in packed file.\n");
 4c2:	c7 04 24 92 05 00 00 	movl   $0x592,(%esp)
 4c9:	e8 fc ff ff ff       	call   4ca <show_help+0x84>
	printf("          Default for MegaLZ is -8, for hrum and hrust is -16.\n");
 4ce:	c7 04 24 cb 05 00 00 	movl   $0x5cb,(%esp)
 4d5:	e8 fc ff ff ff       	call   4d6 <show_help+0x90>
	printf("\n");
 4da:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 4e1:	e8 fc ff ff ff       	call   4e2 <show_help+0x9c>
	printf("-bend - if -16 specified, this makes words big-endian. Default is little-endian.\n");
 4e6:	c7 04 24 0a 06 00 00 	movl   $0x60a,(%esp)
 4ed:	e8 fc ff ff ff       	call   4ee <show_help+0xa8>
	printf("\n");
 4f2:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 4f9:	e8 fc ff ff ff       	call   4fa <show_help+0xb4>
	printf("-maxwinN - maximum lookback window. N is decimal number, which can only be\n");
 4fe:	c7 04 24 5b 06 00 00 	movl   $0x65b,(%esp)
 505:	e8 fc ff ff ff       	call   506 <show_help+0xc0>
	printf("           256,512,1024,2048,4096,8192,16384,32768. Default is format-specific\n");
 50a:	c7 04 24 a6 06 00 00 	movl   $0x6a6,(%esp)
 511:	e8 fc ff ff ff       	call   512 <show_help+0xcc>
	printf("           maximum window: MegaLZ is 4352, hrum is 4096, hrust is 65536.\n");
 516:	c7 04 24 f5 06 00 00 	movl   $0x6f5,(%esp)
 51d:	e8 fc ff ff ff       	call   51e <show_help+0xd8>
	printf("           For given format, window can't be greater than default value\n");
 522:	c7 04 24 3e 07 00 00 	movl   $0x73e,(%esp)
 529:	e8 fc ff ff ff       	call   52a <show_help+0xe4>
	printf("\n");
 52e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 535:	e8 fc ff ff ff       	call   536 <show_help+0xf0>
	printf("usage:\n");
 53a:	c7 04 24 86 07 00 00 	movl   $0x786,(%esp)
 541:	e8 fc ff ff ff       	call   542 <show_help+0xfc>
	printf("mhmt [parameter list] <input filename> [<output filename>]\n");
 546:	c7 04 24 8d 07 00 00 	movl   $0x78d,(%esp)
 54d:	e8 fc ff ff ff       	call   54e <show_help+0x108>
	printf("\n");
 552:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 559:	e8 fc ff ff ff       	call   55a <show_help+0x114>
	printf("if no output filename given, filename is appended with \".mlz\", \".hrm\" or \".hst\"\n");
 55e:	c7 04 24 c8 07 00 00 	movl   $0x7c8,(%esp)
 565:	e8 fc ff ff ff       	call   566 <show_help+0x120>
	printf("in accordance with format chosen; for depacking \".dpk\" is appended\n");
 56a:	c7 04 24 18 08 00 00 	movl   $0x818,(%esp)
 571:	e8 fc ff ff ff       	call   572 <show_help+0x12c>
	printf("====== mhmt help end ======\n");
 576:	c7 04 24 5b 08 00 00 	movl   $0x85b,(%esp)
 57d:	e8 fc ff ff ff       	call   57e <show_help+0x138>
	printf("\n");
 582:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 589:	e8 fc ff ff ff       	call   58a <show_help+0x144>
 58e:	83 c4 10             	add    $0x10,%esp
}
 591:	c9                   	leave  
 592:	c3                   	ret    

00000593 <main>:
void show_help(void);
void dump_config(void);
ULONG do_files(void);

int main( int argc, char* argv[] )
{
 593:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 597:	83 e4 f0             	and    $0xfffffff0,%esp
 59a:	ff 71 fc             	pushl  -0x4(%ecx)
 59d:	55                   	push   %ebp
 59e:	89 e5                	mov    %esp,%ebp
 5a0:	56                   	push   %esi
 5a1:	53                   	push   %ebx
 5a2:	51                   	push   %ecx
 5a3:	83 ec 0c             	sub    $0xc,%esp
 5a6:	8b 19                	mov    (%ecx),%ebx
 5a8:	8b 71 04             	mov    0x4(%ecx),%esi
	int error=0;
	ULONG parse_result;


	init_globals();
 5ab:	e8 fc ff ff ff       	call   5ac <main+0x19>


	// printf short info
	printf("mhmt - MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc\n\n");
 5b0:	83 ec 0c             	sub    $0xc,%esp
 5b3:	68 77 08 00 00       	push   $0x877
 5b8:	e8 fc ff ff ff       	call   5b9 <main+0x26>

	// parse arguments
	parse_result = parse_args(argc, argv);
 5bd:	59                   	pop    %ecx
 5be:	58                   	pop    %eax
 5bf:	56                   	push   %esi
 5c0:	53                   	push   %ebx
 5c1:	e8 fc ff ff ff       	call   5c2 <main+0x2f>

	if( parse_result&ARG_PARSER_SHOWHELP )
 5c6:	83 c4 10             	add    $0x10,%esp
 5c9:	a8 01                	test   $0x1,%al

	// printf short info
	printf("mhmt - MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc\n\n");

	// parse arguments
	parse_result = parse_args(argc, argv);
 5cb:	89 c3                	mov    %eax,%ebx

	if( parse_result&ARG_PARSER_SHOWHELP )
 5cd:	74 17                	je     5e6 <main+0x53>
	{
		if( parse_result&ARG_PARSER_ERROR )
 5cf:	f6 c4 01             	test   $0x1,%ah
 5d2:	74 0d                	je     5e1 <main+0x4e>
			printf("\n");
 5d4:	83 ec 0c             	sub    $0xc,%esp
 5d7:	6a 0a                	push   $0xa
 5d9:	e8 fc ff ff ff       	call   5da <main+0x47>
 5de:	83 c4 10             	add    $0x10,%esp

		show_help();
 5e1:	e8 fc ff ff ff       	call   5e2 <main+0x4f>
	}

	if( parse_result&ARG_PARSER_ERROR )
 5e6:	f6 c7 01             	test   $0x1,%bh
 5e9:	74 17                	je     602 <main+0x6f>
	{
		printf("There were errors in arguments.\n");
 5eb:	83 ec 0c             	sub    $0xc,%esp
 5ee:	be 01 00 00 00       	mov    $0x1,%esi
 5f3:	68 b5 08 00 00       	push   $0x8b5
 5f8:	e8 fc ff ff ff       	call   5f9 <main+0x66>
 5fd:	83 c4 10             	add    $0x10,%esp
 600:	eb 36                	jmp    638 <main+0xa5>
		error++;
	}
	else if( parse_result&ARG_PARSER_GO )
 602:	31 f6                	xor    %esi,%esi
 604:	80 e3 02             	and    $0x2,%bl
 607:	74 2f                	je     638 <main+0xa5>
	{
		if( do_files() )
 609:	e8 fc ff ff ff       	call   60a <main+0x77>
 60e:	66 be 01 00          	mov    $0x1,%si
 612:	85 c0                	test   %eax,%eax
 614:	74 22                	je     638 <main+0xa5>
		{
			dump_config();
 616:	e8 fc ff ff ff       	call   617 <main+0x84>
			if( wrk.mode )
 61b:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
 622:	74 07                	je     62b <main+0x98>
			{
				error += depack() ? 0 : 1;
 624:	e8 fc ff ff ff       	call   625 <main+0x92>
 629:	eb 05                	jmp    630 <main+0x9d>
			}
			else
			{
				error += pack() ? 0 : 1;
 62b:	e8 fc ff ff ff       	call   62c <main+0x99>
 630:	85 c0                	test   %eax,%eax
 632:	0f 94 c0             	sete   %al
 635:	0f b6 f0             	movzbl %al,%esi
		}
	}



	free_globals();
 638:	e8 fc ff ff ff       	call   639 <main+0xa6>

	return error;
}
 63d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 640:	89 f0                	mov    %esi,%eax
 642:	59                   	pop    %ecx
 643:	5b                   	pop    %ebx
 644:	5e                   	pop    %esi
 645:	5d                   	pop    %ebp
 646:	8d 61 fc             	lea    -0x4(%ecx),%esp
 649:	c3                   	ret    

mhmt-optimal.o:     file format elf32-i386


Disassembly of section .text:

00000000 <reverse_optch>:


// reverses optimal chain making it ready for scanning (fetching optimal chain)
//
void reverse_optch(struct optchain * optch, ULONG actual_len)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	8b 45 0c             	mov    0xc(%ebp),%eax
   6:	57                   	push   %edi
   7:	56                   	push   %esi
   8:	53                   	push   %ebx
	ULONG position;
	LONG len;

	position = actual_len;

	temp = optch[position].code;
   9:	89 c2                	mov    %eax,%edx
   b:	c1 e2 04             	shl    $0x4,%edx
   e:	03 55 08             	add    0x8(%ebp),%edx
  11:	8b 5a 04             	mov    0x4(%edx),%ebx
  14:	8b 12                	mov    (%edx),%edx

	while(position>1)
  16:	eb 23                	jmp    3b <reverse_optch+0x3b>
	{
		len = temp.length;
		if( len<0 ) len=(-len);

		position -= len;
  18:	89 d6                	mov    %edx,%esi
  1a:	c1 fe 1f             	sar    $0x1f,%esi
  1d:	89 f1                	mov    %esi,%ecx
  1f:	31 d1                	xor    %edx,%ecx
  21:	29 f1                	sub    %esi,%ecx
  23:	29 c8                	sub    %ecx,%eax

		curr = temp;

		temp = optch[position].code;
  25:	89 c1                	mov    %eax,%ecx
  27:	c1 e1 04             	shl    $0x4,%ecx
  2a:	03 4d 08             	add    0x8(%ebp),%ecx
  2d:	8b 79 04             	mov    0x4(%ecx),%edi
  30:	8b 31                	mov    (%ecx),%esi
		optch[position].code = curr;
  32:	89 59 04             	mov    %ebx,0x4(%ecx)
  35:	89 11                	mov    %edx,(%ecx)
  37:	89 fb                	mov    %edi,%ebx
  39:	89 f2                	mov    %esi,%edx

	position = actual_len;

	temp = optch[position].code;

	while(position>1)
  3b:	83 f8 01             	cmp    $0x1,%eax
  3e:	77 d8                	ja     18 <reverse_optch+0x18>
		curr = temp;

		temp = optch[position].code;
		optch[position].code = curr;
	}
}
  40:	5b                   	pop    %ebx
  41:	5e                   	pop    %esi
  42:	5f                   	pop    %edi
  43:	5d                   	pop    %ebp
  44:	c3                   	ret    

00000045 <update_optch>:
}

// update prices at the position given all lzcodes.
// it also needs pointer to the function that calculates bit length of given LZ code
void update_optch(ULONG position, struct lzcode * codes, ULONG (*get_lz_price)(ULONG position, struct lzcode * lzcode), struct optchain * optch)
{
  45:	55                   	push   %ebp
  46:	89 e5                	mov    %esp,%ebp
  48:	57                   	push   %edi
  49:	56                   	push   %esi
  4a:	53                   	push   %ebx
  4b:	83 ec 1c             	sub    $0x1c,%esp
  4e:	8b 75 08             	mov    0x8(%ebp),%esi
		{
			if( len<0 ) len=(-len); // deal with negative lengths (special markers)

			newpos = position + len; // look where current lz code points to and take from there old price reaching that location

			if( optch[newpos].price > bitlen + optch[position].price ) // if oldprice is worse than with current lz code
  51:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  54:	89 f0                	mov    %esi,%eax
  56:	c1 e0 04             	shl    $0x4,%eax
  59:	03 45 14             	add    0x14(%ebp),%eax
  5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	ULONG codepos;
	ULONG bitlen;
	ULONG newpos;
	LONG len;

	for( codepos = 0; len=codes[codepos].length; codepos++ ) // loop through all existing lz codes
  5f:	eb 55                	jmp    b6 <update_optch+0x71>
	{
		bitlen = (*get_lz_price)(position, &codes[codepos]); // get bit length of given lz code
  61:	50                   	push   %eax
  62:	50                   	push   %eax
  63:	53                   	push   %ebx
  64:	56                   	push   %esi
  65:	ff 55 10             	call   *0x10(%ebp)
		if( !bitlen )
  68:	83 c4 10             	add    $0x10,%esp
  6b:	85 c0                	test   %eax,%eax
	ULONG newpos;
	LONG len;

	for( codepos = 0; len=codes[codepos].length; codepos++ ) // loop through all existing lz codes
	{
		bitlen = (*get_lz_price)(position, &codes[codepos]); // get bit length of given lz code
  6d:	89 c1                	mov    %eax,%ecx
		if( !bitlen )
  6f:	75 19                	jne    8a <update_optch+0x45>
		{
			printf("mhmt-optimal.c: update_optch() found zero bitlength of lz code. Fatal error.\n");
  71:	83 ec 0c             	sub    $0xc,%esp
  74:	68 00 00 00 00       	push   $0x0
  79:	e8 fc ff ff ff       	call   7a <update_optch+0x35>
			exit(1);
  7e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  85:	e8 fc ff ff ff       	call   86 <update_optch+0x41>
		{
			if( len<0 ) len=(-len); // deal with negative lengths (special markers)

			newpos = position + len; // look where current lz code points to and take from there old price reaching that location

			if( optch[newpos].price > bitlen + optch[position].price ) // if oldprice is worse than with current lz code
  8a:	89 f8                	mov    %edi,%eax
  8c:	99                   	cltd   
  8d:	89 c8                	mov    %ecx,%eax
  8f:	31 d7                	xor    %edx,%edi
  91:	29 d7                	sub    %edx,%edi
  93:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  96:	01 f7                	add    %esi,%edi
  98:	c1 e7 04             	shl    $0x4,%edi
  9b:	03 7d 14             	add    0x14(%ebp),%edi
  9e:	03 42 08             	add    0x8(%edx),%eax
  a1:	39 47 08             	cmp    %eax,0x8(%edi)
  a4:	76 0d                	jbe    b3 <update_optch+0x6e>
			{
				optch[newpos].price = bitlen + optch[position].price;
  a6:	89 47 08             	mov    %eax,0x8(%edi)
				optch[newpos].code  = codes[codepos];
  a9:	8b 03                	mov    (%ebx),%eax
  ab:	8b 53 04             	mov    0x4(%ebx),%edx
  ae:	89 07                	mov    %eax,(%edi)
  b0:	89 57 04             	mov    %edx,0x4(%edi)
  b3:	83 c3 08             	add    $0x8,%ebx
	ULONG codepos;
	ULONG bitlen;
	ULONG newpos;
	LONG len;

	for( codepos = 0; len=codes[codepos].length; codepos++ ) // loop through all existing lz codes
  b6:	8b 3b                	mov    (%ebx),%edi
  b8:	85 ff                	test   %edi,%edi
  ba:	75 a5                	jne    61 <update_optch+0x1c>
				optch[newpos].price = bitlen + optch[position].price;
				optch[newpos].code  = codes[codepos];
			}
		}
	}
}
  bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  bf:	5b                   	pop    %ebx
  c0:	5e                   	pop    %esi
  c1:	5f                   	pop    %edi
  c2:	5d                   	pop    %ebp
  c3:	c3                   	ret    

000000c4 <free_optch>:
	return optch;
}

// free optchain array
void free_optch(struct optchain * optch)
{
  c4:	55                   	push   %ebp
  c5:	89 e5                	mov    %esp,%ebp
  c7:	83 ec 08             	sub    $0x8,%esp
  ca:	8b 45 08             	mov    0x8(%ebp),%eax
	if( optch )
  cd:	85 c0                	test   %eax,%eax
  cf:	74 06                	je     d7 <free_optch+0x13>
		free( optch );
}
  d1:	c9                   	leave  

// free optchain array
void free_optch(struct optchain * optch)
{
	if( optch )
		free( optch );
  d2:	e9 fc ff ff ff       	jmp    d3 <free_optch+0xf>
}
  d7:	c9                   	leave  
  d8:	c3                   	ret    

000000d9 <make_optch>:
#include "mhmt-optimal.h"


// allocate place for optimal chain building amd initialize it
struct optchain * make_optch(ULONG actual_len)
{
  d9:	55                   	push   %ebp
  da:	89 e5                	mov    %esp,%ebp
  dc:	53                   	push   %ebx
  dd:	83 ec 10             	sub    $0x10,%esp

	ULONG i;

	// we allocate length+1 because all codes at the end of input stream will point
	// to the length+1 place. Also we'll start reversing from length+1 position in optch array
	optch = (struct optchain *)malloc( (actual_len+1)*sizeof(struct optchain) );
  e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  e3:	43                   	inc    %ebx
  e4:	89 d8                	mov    %ebx,%eax
  e6:	c1 e0 04             	shl    $0x4,%eax
  e9:	50                   	push   %eax
  ea:	e8 fc ff ff ff       	call   eb <make_optch+0x12>

	if( optch )
  ef:	83 c4 10             	add    $0x10,%esp
  f2:	85 c0                	test   %eax,%eax
  f4:	74 33                	je     129 <make_optch+0x50>
	{
		optch[0].code.length = 1; // 1st byte is always copied 'as-is', however, this is just filler,
  f6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		optch[0].code.disp   = 0; // not accounted elsewhere

		// init prices to absolute maximum for optimal chain build-up
		optch[0].price = 0;
		optch[1].price = 8;
  fc:	89 c1                	mov    %eax,%ecx
  fe:	ba 02 00 00 00       	mov    $0x2,%edx
	optch = (struct optchain *)malloc( (actual_len+1)*sizeof(struct optchain) );

	if( optch )
	{
		optch[0].code.length = 1; // 1st byte is always copied 'as-is', however, this is just filler,
		optch[0].code.disp   = 0; // not accounted elsewhere
 103:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

		// init prices to absolute maximum for optimal chain build-up
		optch[0].price = 0;
 10a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		optch[1].price = 8;
 111:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%eax)
		for(i=2;i<(actual_len+1);i++)
 118:	eb 08                	jmp    122 <make_optch+0x49>
			optch[i].price = 0xFFFFFFFF;
 11a:	c7 41 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ecx)
		optch[0].code.disp   = 0; // not accounted elsewhere

		// init prices to absolute maximum for optimal chain build-up
		optch[0].price = 0;
		optch[1].price = 8;
		for(i=2;i<(actual_len+1);i++)
 121:	42                   	inc    %edx
 122:	83 c1 10             	add    $0x10,%ecx
 125:	39 da                	cmp    %ebx,%edx
 127:	72 f1                	jb     11a <make_optch+0x41>
			optch[i].price = 0xFFFFFFFF;
	}

	return optch;
}
 129:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 12c:	c9                   	leave  
 12d:	c3                   	ret    

mhmt-pack.o:     file format elf32-i386


Disassembly of section .text:

00000000 <pack>:


// entry function to pack data
// returns zero if any error
ULONG pack(void)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 1c             	sub    $0x1c,%esp
	ULONG position;


	// some preparations
	//
	if( wrk.packtype==PK_MLZ )
   9:	a1 00 00 00 00       	mov    0x0,%eax
   e:	83 f8 01             	cmp    $0x1,%eax
  11:	74 34                	je     47 <pack+0x47>
	{
		get_lz_price  = &get_lz_price_megalz;
		emit          = &emit_megalz;
	}
	else if( wrk.packtype==PK_HRM )
  13:	83 f8 02             	cmp    $0x2,%eax
  16:	75 10                	jne    28 <pack+0x28>
  18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  1f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  26:	eb 2d                	jmp    55 <pack+0x55>
	{
		get_lz_price  = &get_lz_price_hrum;
		emit          = &emit_hrum;
	}
	else if( wrk.packtype==PK_HST )
  28:	83 f8 03             	cmp    $0x3,%eax
  2b:	75 10                	jne    3d <pack+0x3d>
  2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  34:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  3b:	eb 18                	jmp    55 <pack+0x55>
		get_lz_price  = &get_lz_price_hrust;
		emit          = &emit_hrust;
	}
	else
	{
		printf("mhmt-pack.c:pack() - format unsupported!\n");
  3d:	83 ec 0c             	sub    $0xc,%esp
  40:	68 00 00 00 00       	push   $0x0
  45:	eb 39                	jmp    80 <pack+0x80>
		return 0;
  47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  4e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}


	actual_len = wrk.inlen;
	if( wrk.zxheader )
  55:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
		printf("mhmt-pack.c:pack() - format unsupported!\n");
		return 0;
	}


	actual_len = wrk.inlen;
  5c:	8b 1d 34 00 00 00    	mov    0x34,%ebx
	if( wrk.zxheader )
  62:	74 28                	je     8c <pack+0x8c>
	{
		if( wrk.packtype==PK_HRM )
  64:	83 f8 02             	cmp    $0x2,%eax
  67:	75 05                	jne    6e <pack+0x6e>
		{
			actual_len -= 5;
  69:	83 eb 05             	sub    $0x5,%ebx
  6c:	eb 1e                	jmp    8c <pack+0x8c>
		}
		else if( wrk.packtype==PK_HST )
  6e:	83 f8 03             	cmp    $0x3,%eax
  71:	75 05                	jne    78 <pack+0x78>
		{
			actual_len -= 6;
  73:	83 eb 06             	sub    $0x6,%ebx
  76:	eb 14                	jmp    8c <pack+0x8c>
		}
		else
		{
			printf("mhmt-pack.c:pack() - there must be no zxheader for anything except hrust or hrum!\n");
  78:	83 ec 0c             	sub    $0xc,%esp
  7b:	68 29 00 00 00       	push   $0x29
  80:	e8 fc ff ff ff       	call   81 <pack+0x81>
  85:	31 db                	xor    %ebx,%ebx
  87:	e9 09 01 00 00       	jmp    195 <pack+0x195>
		}
	}


        // initializations and preparations
	init_tb();
  8c:	e8 fc ff ff ff       	call   8d <pack+0x8d>

	hash = build_hash(wrk.indata, actual_len);
  91:	52                   	push   %edx
  92:	52                   	push   %edx
  93:	53                   	push   %ebx
  94:	ff 35 30 00 00 00    	pushl  0x30
  9a:	e8 fc ff ff ff       	call   9b <pack+0x9b>
	if( !hash )
  9f:	83 c4 10             	add    $0x10,%esp
  a2:	85 c0                	test   %eax,%eax


        // initializations and preparations
	init_tb();

	hash = build_hash(wrk.indata, actual_len);
  a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if( !hash )
  a7:	75 0a                	jne    b3 <pack+0xb3>
	{
		printf("mhmt-pack.c:pack() - build_hash() failed!\n");
  a9:	83 ec 0c             	sub    $0xc,%esp
  ac:	68 7b 00 00 00       	push   $0x7b
  b1:	eb 1e                	jmp    d1 <pack+0xd1>
		success = 0;
	}

	if( success )
	{
		optch = make_optch(actual_len);
  b3:	83 ec 0c             	sub    $0xc,%esp
  b6:	53                   	push   %ebx
  b7:	e8 fc ff ff ff       	call   b8 <pack+0xb8>
		if( !optch )
  bc:	83 c4 10             	add    $0x10,%esp
  bf:	85 c0                	test   %eax,%eax
		success = 0;
	}

	if( success )
	{
		optch = make_optch(actual_len);
  c1:	89 c7                	mov    %eax,%edi
		if( !optch )
  c3:	0f 85 d9 00 00 00    	jne    1a2 <pack+0x1a2>
		{
			printf("mhmt-pack.c:pack() - can't make optchain array!\n");
  c9:	83 ec 0c             	sub    $0xc,%esp
  cc:	68 a5 00 00 00       	push   $0xa5
  d1:	e8 fc ff ff ff       	call   d2 <pack+0xd2>
  d6:	31 ff                	xor    %edi,%edi
  d8:	83 c4 10             	add    $0x10,%esp
  db:	31 db                	xor    %ebx,%ebx
  dd:	e9 a1 00 00 00       	jmp    183 <pack+0x183>
	{
		if( !wrk.greedy ) // default optimal coding
		{
			// go generating lzcodes byte-by-byte
			//
			curr_byte = wrk.indata[0];
  e2:	a1 30 00 00 00       	mov    0x30,%eax
  e7:	be 01 00 00 00       	mov    $0x1,%esi
  ec:	8a 10                	mov    (%eax),%dl
  ee:	89 7d d8             	mov    %edi,-0x28(%ebp)
  f1:	89 df                	mov    %ebx,%edi
			//
			for(position=1;position<actual_len;position++)
  f3:	eb 57                	jmp    14c <pack+0x14c>
			{
				last_byte = curr_byte;
				curr_byte = wrk.indata[position];
  f5:	a1 30 00 00 00       	mov    0x30,%eax

				// add current two-byter to the chains
				index = (last_byte<<8) + curr_byte;
				if( !add_tb(index,position) )
  fa:	c1 e2 08             	shl    $0x8,%edx
			curr_byte = wrk.indata[0];
			//
			for(position=1;position<actual_len;position++)
			{
				last_byte = curr_byte;
				curr_byte = wrk.indata[position];
  fd:	8a 1c 30             	mov    (%eax,%esi,1),%bl

				// add current two-byter to the chains
				index = (last_byte<<8) + curr_byte;
				if( !add_tb(index,position) )
 100:	50                   	push   %eax
 101:	50                   	push   %eax
 102:	56                   	push   %esi
 103:	0f b6 c3             	movzbl %bl,%eax
 106:	8d 14 10             	lea    (%eax,%edx,1),%edx
 109:	0f b7 d2             	movzwl %dx,%edx
 10c:	52                   	push   %edx
 10d:	e8 fc ff ff ff       	call   10e <pack+0x10e>
 112:	83 c4 10             	add    $0x10,%esp
 115:	85 c0                	test   %eax,%eax
 117:	75 0d                	jne    126 <pack+0x126>
				{
					printf("mhmt-pack.c:pack() - add_tb() failed!\n");
 119:	83 ec 0c             	sub    $0xc,%esp
 11c:	8b 7d d8             	mov    -0x28(%ebp),%edi
 11f:	68 d5 00 00 00       	push   $0xd5
 124:	eb 53                	jmp    179 <pack+0x179>
					success = 0;
					goto ERROR;
				}

				// search lzcodes for given position
				make_lz_codes(position, actual_len, hash, codes);
 126:	68 00 00 00 00       	push   $0x0
 12b:	ff 75 e4             	pushl  -0x1c(%ebp)
 12e:	57                   	push   %edi
 12f:	56                   	push   %esi
 130:	e8 fc ff ff ff       	call   131 <pack+0x131>

				// update optimal chain with lzcodes
				update_optch(position, codes, get_lz_price, optch);
 135:	ff 75 d8             	pushl  -0x28(%ebp)
 138:	ff 75 dc             	pushl  -0x24(%ebp)
 13b:	68 00 00 00 00       	push   $0x0
 140:	56                   	push   %esi
		{
			// go generating lzcodes byte-by-byte
			//
			curr_byte = wrk.indata[0];
			//
			for(position=1;position<actual_len;position++)
 141:	46                   	inc    %esi

				// search lzcodes for given position
				make_lz_codes(position, actual_len, hash, codes);

				// update optimal chain with lzcodes
				update_optch(position, codes, get_lz_price, optch);
 142:	e8 fc ff ff ff       	call   143 <pack+0x143>
		{
			// go generating lzcodes byte-by-byte
			//
			curr_byte = wrk.indata[0];
			//
			for(position=1;position<actual_len;position++)
 147:	88 da                	mov    %bl,%dl
 149:	83 c4 20             	add    $0x20,%esp
 14c:	39 fe                	cmp    %edi,%esi
 14e:	72 a5                	jb     f5 <pack+0xf5>
 150:	89 fb                	mov    %edi,%ebx
 152:	8b 7d d8             	mov    -0x28(%ebp),%edi
				update_optch(position, codes, get_lz_price, optch);
			}


			// all input bytes scanned, chain built, so now reverse it (prepare for scanning in output generation part)
			reverse_optch(optch, actual_len);
 155:	56                   	push   %esi
 156:	56                   	push   %esi
 157:	53                   	push   %ebx
 158:	57                   	push   %edi
 159:	e8 fc ff ff ff       	call   15a <pack+0x15a>
			printf("mhmt-pack.c:pack() - greedy coding not supported!\n");
			success = 0;
		}

		// data built, now emit packed file
		success = success && (*emit)(optch, actual_len);
 15e:	5a                   	pop    %edx
 15f:	59                   	pop    %ecx
 160:	53                   	push   %ebx
 161:	31 db                	xor    %ebx,%ebx
 163:	57                   	push   %edi
 164:	ff 55 e0             	call   *-0x20(%ebp)
 167:	83 c4 10             	add    $0x10,%esp
 16a:	85 c0                	test   %eax,%eax
 16c:	0f 95 c3             	setne  %bl
 16f:	eb 12                	jmp    183 <pack+0x183>
			// all input bytes scanned, chain built, so now reverse it (prepare for scanning in output generation part)
			reverse_optch(optch, actual_len);
		}
		else // greedy coding
		{
			printf("mhmt-pack.c:pack() - greedy coding not supported!\n");
 171:	83 ec 0c             	sub    $0xc,%esp
 174:	68 fb 00 00 00       	push   $0xfb
 179:	e8 fc ff ff ff       	call   17a <pack+0x17a>
 17e:	31 db                	xor    %ebx,%ebx
 180:	83 c4 10             	add    $0x10,%esp




ERROR:
	free_optch(optch);
 183:	83 ec 0c             	sub    $0xc,%esp
 186:	57                   	push   %edi
 187:	e8 fc ff ff ff       	call   188 <pack+0x188>

	destroy_hash(hash);
 18c:	58                   	pop    %eax
 18d:	ff 75 e4             	pushl  -0x1c(%ebp)
 190:	e8 fc ff ff ff       	call   191 <pack+0x191>

	return success;
}
 195:	89 d8                	mov    %ebx,%eax
ERROR:
	free_optch(optch);

	destroy_hash(hash);

	return success;
 197:	83 c4 10             	add    $0x10,%esp
}
 19a:	8d 65 f4             	lea    -0xc(%ebp),%esp
 19d:	5b                   	pop    %ebx
 19e:	5e                   	pop    %esi
 19f:	5f                   	pop    %edi
 1a0:	5d                   	pop    %ebp
 1a1:	c3                   	ret    


	// go packing!
	if( success )
	{
		if( !wrk.greedy ) // default optimal coding
 1a2:	83 3d 04 00 00 00 00 	cmpl   $0x0,0x4
 1a9:	0f 84 33 ff ff ff    	je     e2 <pack+0xe2>
 1af:	eb c0                	jmp    171 <pack+0x171>

mhmt-parsearg.o:     file format elf32-i386


Disassembly of section .text:

00000000 <sort_args>:
}


// sort arguments
void sort_args( struct argtbl * args, ULONG argsize )
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 04             	sub    $0x4,%esp
	struct argtbl temp;
	LONG i,j;

	// simple bubble sort since there are not too many arguments
	for( i=(argsize-2); i>=0; i-- )
   9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
}


// sort arguments
void sort_args( struct argtbl * args, ULONG argsize )
{
   c:	8b 55 08             	mov    0x8(%ebp),%edx
	struct argtbl temp;
	LONG i,j;

	// simple bubble sort since there are not too many arguments
	for( i=(argsize-2); i>=0; i-- )
   f:	83 e9 02             	sub    $0x2,%ecx
  12:	eb 32                	jmp    46 <sort_args+0x46>
  14:	31 c0                	xor    %eax,%eax
	{
		for( j=0; j<=i; j++ )
		{
			if( args[j].type > args[j+1].type )
  16:	8b 5c c2 04          	mov    0x4(%edx,%eax,8),%ebx
  1a:	3b 5c c2 0c          	cmp    0xc(%edx,%eax,8),%ebx
  1e:	76 20                	jbe    40 <sort_args+0x40>
			{
				temp      = args[j];
  20:	8b 34 c2             	mov    (%edx,%eax,8),%esi
				args[j]   = args[j+1];
  23:	8b 7c c2 0c          	mov    0xc(%edx,%eax,8),%edi
				args[j+1] = temp;
  27:	89 5c c2 0c          	mov    %ebx,0xc(%edx,%eax,8)
	{
		for( j=0; j<=i; j++ )
		{
			if( args[j].type > args[j+1].type )
			{
				temp      = args[j];
  2b:	89 75 f0             	mov    %esi,-0x10(%ebp)
				args[j]   = args[j+1];
  2e:	8b 74 c2 08          	mov    0x8(%edx,%eax,8),%esi
  32:	89 7c c2 04          	mov    %edi,0x4(%edx,%eax,8)
				args[j+1] = temp;
  36:	8b 7d f0             	mov    -0x10(%ebp),%edi
		for( j=0; j<=i; j++ )
		{
			if( args[j].type > args[j+1].type )
			{
				temp      = args[j];
				args[j]   = args[j+1];
  39:	89 34 c2             	mov    %esi,(%edx,%eax,8)
				args[j+1] = temp;
  3c:	89 7c c2 08          	mov    %edi,0x8(%edx,%eax,8)
	LONG i,j;

	// simple bubble sort since there are not too many arguments
	for( i=(argsize-2); i>=0; i-- )
	{
		for( j=0; j<=i; j++ )
  40:	40                   	inc    %eax
  41:	39 c8                	cmp    %ecx,%eax
  43:	7e d1                	jle    16 <sort_args+0x16>
{
	struct argtbl temp;
	LONG i,j;

	// simple bubble sort since there are not too many arguments
	for( i=(argsize-2); i>=0; i-- )
  45:	49                   	dec    %ecx
  46:	85 c9                	test   %ecx,%ecx
  48:	79 ca                	jns    14 <sort_args+0x14>
				args[j]   = args[j+1];
				args[j+1] = temp;
			}
		}
	}
}
  4a:	58                   	pop    %eax
  4b:	5b                   	pop    %ebx
  4c:	5e                   	pop    %esi
  4d:	5f                   	pop    %edi
  4e:	5d                   	pop    %ebp
  4f:	c3                   	ret    

00000050 <cmp_str_nocase>:


// compares two char strings, ignoring case (uppercase by default)
// returns 0, if equal, -1 if left lower than right, and +1 otherwise
LONG cmp_str_nocase(char * left, char * right)
{
  50:	55                   	push   %ebp
  51:	31 c9                	xor    %ecx,%ecx
  53:	89 e5                	mov    %esp,%ebp
  55:	57                   	push   %edi
  56:	56                   	push   %esi
  57:	53                   	push   %ebx
  58:	83 ec 04             	sub    $0x4,%esp
  5b:	8b 7d 08             	mov    0x8(%ebp),%edi
  5e:	8b 75 0c             	mov    0xc(%ebp),%esi
		rightadd = 0;

		left++;
		right++;

		if( leftchar  >= (UBYTE)'a' ) leftadd  = (UBYTE)('A'-'a');
  61:	80 3c 0f 61          	cmpb   $0x61,(%edi,%ecx,1)
  65:	19 d2                	sbb    %edx,%edx
  67:	f7 d2                	not    %edx
  69:	83 e2 e0             	and    $0xffffffe0,%edx
		if( rightchar >= (UBYTE)'a' ) rightadd = (UBYTE)('A'-'a');
  6c:	80 3c 0e 61          	cmpb   $0x61,(%esi,%ecx,1)
  70:	19 c0                	sbb    %eax,%eax
  72:	f7 d0                	not    %eax
  74:	83 e0 e0             	and    $0xffffffe0,%eax

		if( leftchar  > (UBYTE)'z' ) leftadd  = 0;
  77:	80 3c 0f 7b          	cmpb   $0x7b,(%edi,%ecx,1)
  7b:	0f 92 c3             	setb   %bl
  7e:	f7 db                	neg    %ebx
  80:	21 da                	and    %ebx,%edx
		if( rightchar > (UBYTE)'z' ) rightadd = 0;
  82:	80 3c 0e 7b          	cmpb   $0x7b,(%esi,%ecx,1)
  86:	0f 92 c3             	setb   %bl

		leftchar  += leftadd;
  89:	02 14 0f             	add    (%edi,%ecx,1),%dl

		if( leftchar  >= (UBYTE)'a' ) leftadd  = (UBYTE)('A'-'a');
		if( rightchar >= (UBYTE)'a' ) rightadd = (UBYTE)('A'-'a');

		if( leftchar  > (UBYTE)'z' ) leftadd  = 0;
		if( rightchar > (UBYTE)'z' ) rightadd = 0;
  8c:	f7 db                	neg    %ebx
  8e:	21 d8                	and    %ebx,%eax

		leftchar  += leftadd;
  90:	88 55 f3             	mov    %dl,-0xd(%ebp)
		rightchar += rightadd;
  93:	8a 14 0e             	mov    (%esi,%ecx,1),%dl
  96:	8d 1c 10             	lea    (%eax,%edx,1),%ebx

		if( leftchar<rightchar ) order = (-1);
  99:	38 5d f3             	cmp    %bl,-0xd(%ebp)
  9c:	19 c0                	sbb    %eax,%eax
		if( leftchar>rightchar ) order = (+1);
  9e:	38 5d f3             	cmp    %bl,-0xd(%ebp)
  a1:	76 07                	jbe    aa <cmp_str_nocase+0x5a>
  a3:	b8 01 00 00 00       	mov    $0x1,%eax
  a8:	eb 0f                	jmp    b9 <cmp_str_nocase+0x69>

	} while( (!order) && leftchar && rightchar );
  aa:	85 c0                	test   %eax,%eax
  ac:	75 0b                	jne    b9 <cmp_str_nocase+0x69>
  ae:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  b2:	74 05                	je     b9 <cmp_str_nocase+0x69>
  b4:	41                   	inc    %ecx
  b5:	84 db                	test   %bl,%bl
  b7:	75 a8                	jne    61 <cmp_str_nocase+0x11>

	return order;
}
  b9:	5a                   	pop    %edx
  ba:	5b                   	pop    %ebx
  bb:	5e                   	pop    %esi
  bc:	5f                   	pop    %edi
  bd:	5d                   	pop    %ebp
  be:	c3                   	ret    

000000bf <match_arg>:


// finds matching arg in default_arg_table,
// returns ptr to the found element or NULL if not found
struct argtbl * match_arg(char * argument)
{
  bf:	55                   	push   %ebp
  c0:	89 e5                	mov    %esp,%ebp
  c2:	56                   	push   %esi
  c3:	8b 75 08             	mov    0x8(%ebp),%esi
  c6:	53                   	push   %ebx
  c7:	bb 00 00 00 00       	mov    $0x0,%ebx
	struct argtbl * test_arg = default_arg_table;


	while( test_arg->name && cmp_str_nocase(test_arg->name,argument) )
  cc:	eb 03                	jmp    d1 <match_arg+0x12>
		test_arg++;
  ce:	83 c3 08             	add    $0x8,%ebx
struct argtbl * match_arg(char * argument)
{
	struct argtbl * test_arg = default_arg_table;


	while( test_arg->name && cmp_str_nocase(test_arg->name,argument) )
  d1:	8b 03                	mov    (%ebx),%eax
  d3:	85 c0                	test   %eax,%eax
  d5:	74 0d                	je     e4 <match_arg+0x25>
  d7:	56                   	push   %esi
  d8:	50                   	push   %eax
  d9:	e8 fc ff ff ff       	call   da <match_arg+0x1b>
  de:	59                   	pop    %ecx
  df:	5a                   	pop    %edx
  e0:	85 c0                	test   %eax,%eax
  e2:	75 ea                	jne    ce <match_arg+0xf>
		test_arg++;

	return (test_arg->name)?test_arg:NULL;
  e4:	31 c0                	xor    %eax,%eax
  e6:	83 3b 00             	cmpl   $0x0,(%ebx)
  e9:	0f 95 c0             	setne  %al
  ec:	f7 d8                	neg    %eax
  ee:	21 c3                	and    %eax,%ebx
}
  f0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  f3:	89 d8                	mov    %ebx,%eax
  f5:	5b                   	pop    %ebx
  f6:	5e                   	pop    %esi
  f7:	5d                   	pop    %ebp
  f8:	c3                   	ret    

000000f9 <get_maxwin>:
}


// get maxwin string into number, returns 0 if no match
LONG get_maxwin( char * txtmaxwin )
{
  f9:	55                   	push   %ebp
  fa:	89 e5                	mov    %esp,%ebp
  fc:	56                   	push   %esi
  fd:	8b 75 08             	mov    0x8(%ebp),%esi
 100:	53                   	push   %ebx
 101:	31 db                	xor    %ebx,%ebx

	ULONG i;


	i=0;
	while( strings[i] )
 103:	eb 17                	jmp    11c <get_maxwin+0x23>
	{
		if( !cmp_str_nocase( strings[i], txtmaxwin ) )
 105:	56                   	push   %esi
 106:	50                   	push   %eax
 107:	e8 fc ff ff ff       	call   108 <get_maxwin+0xf>
 10c:	59                   	pop    %ecx
 10d:	5a                   	pop    %edx
 10e:	85 c0                	test   %eax,%eax
 110:	75 09                	jne    11b <get_maxwin+0x22>
		{
			return sizes[i];
 112:	8b 04 9d 1c 00 00 00 	mov    0x1c(,%ebx,4),%eax
 119:	eb 0c                	jmp    127 <get_maxwin+0x2e>
		}

		i++;
 11b:	43                   	inc    %ebx

	ULONG i;


	i=0;
	while( strings[i] )
 11c:	8b 04 9d 48 00 00 00 	mov    0x48(,%ebx,4),%eax
 123:	85 c0                	test   %eax,%eax
 125:	75 de                	jne    105 <get_maxwin+0xc>

		i++;
	}

	return 0;
}
 127:	8d 65 f8             	lea    -0x8(%ebp),%esp
 12a:	5b                   	pop    %ebx
 12b:	5e                   	pop    %esi
 12c:	5d                   	pop    %ebp
 12d:	c3                   	ret    

0000012e <parse_args>:


// main argument parser, sets fields of "struct globals wrk",
// tries to detect all erroneous arguments.
ULONG parse_args(int argc, char* argv[])
{
 12e:	55                   	push   %ebp
 12f:	89 e5                	mov    %esp,%ebp
 131:	57                   	push   %edi
 132:	56                   	push   %esi
 133:	53                   	push   %ebx
 134:	81 ec ac 00 00 00    	sub    $0xac,%esp
 13a:	8b 75 0c             	mov    0xc(%ebp),%esi
 13d:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax



// main argument parser, sets fields of "struct globals wrk",
// tries to detect all erroneous arguments.
ULONG parse_args(int argc, char* argv[])
 143:	8d 55 e8             	lea    -0x18(%ebp),%edx


	ULONG i;
	for(i=0;i<ARG_STORE_SIZE+1;i++)
	{
		argstore[i].name = NULL;
 146:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		argstore[i].type = ARG_NOARG;
 14c:	c7 40 04 ff 00 00 00 	movl   $0xff,0x4(%eax)
 153:	83 c0 08             	add    $0x8,%eax

	ULONG maxwin;


	ULONG i;
	for(i=0;i<ARG_STORE_SIZE+1;i++)
 156:	39 d0                	cmp    %edx,%eax
 158:	75 ec                	jne    146 <parse_args+0x18>
		argstore[i].name = NULL;
		argstore[i].type = ARG_NOARG;
	}


	if( argc<2 )
 15a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 15e:	7f 14                	jg     174 <parse_args+0x46>
	{
		printf("No arguments! Use \"mhmt -h\" or \"mhmt -help\" for help!\n");
 160:	83 ec 0c             	sub    $0xc,%esp
 163:	68 00 00 00 00       	push   $0x0
 168:	e8 fc ff ff ff       	call   169 <parse_args+0x3b>
 16d:	31 c0                	xor    %eax,%eax
 16f:	e9 9e 03 00 00       	jmp    512 <parse_args+0x3e4>
		return 0L;
	}

	// shortcut for help request
	if( !cmp_str_nocase( argv[1]+1, "h" ) || !cmp_str_nocase( argv[1]+1, "help" ) )
 174:	51                   	push   %ecx
 175:	51                   	push   %ecx
 176:	68 36 00 00 00       	push   $0x36
 17b:	8b 46 04             	mov    0x4(%esi),%eax
 17e:	40                   	inc    %eax
 17f:	50                   	push   %eax
 180:	e8 fc ff ff ff       	call   181 <parse_args+0x53>
 185:	83 c4 10             	add    $0x10,%esp
 188:	85 c0                	test   %eax,%eax
 18a:	0f 84 9d 03 00 00    	je     52d <parse_args+0x3ff>
 190:	52                   	push   %edx
 191:	52                   	push   %edx
 192:	68 38 00 00 00       	push   $0x38
 197:	8b 46 04             	mov    0x4(%esi),%eax
 19a:	40                   	inc    %eax
 19b:	50                   	push   %eax
 19c:	e8 fc ff ff ff       	call   19d <parse_args+0x6f>
 1a1:	83 c4 10             	add    $0x10,%esp
 1a4:	85 c0                	test   %eax,%eax
 1a6:	75 4c                	jne    1f4 <parse_args+0xc6>
 1a8:	e9 80 03 00 00       	jmp    52d <parse_args+0x3ff>
	files_num = 0;

	// first find all arguments beginning with "-"
	while( inarg_pos<(ULONG)argc && *(argv[inarg_pos])=='-' )
	{
		arg=match_arg(argv[inarg_pos]+1); // search match...
 1ad:	83 ec 0c             	sub    $0xc,%esp
 1b0:	40                   	inc    %eax
 1b1:	50                   	push   %eax
 1b2:	e8 fc ff ff ff       	call   1b3 <parse_args+0x85>
		if( arg ) // match!
 1b7:	83 c4 10             	add    $0x10,%esp
 1ba:	85 c0                	test   %eax,%eax
 1bc:	74 1f                	je     1dd <parse_args+0xaf>
		{
			if( storearg_pos>=ARG_STORE_SIZE )
 1be:	83 fb 11             	cmp    $0x11,%ebx
 1c1:	75 0a                	jne    1cd <parse_args+0x9f>
			{
				printf("Too many arguments!\n");
 1c3:	83 ec 0c             	sub    $0xc,%esp
 1c6:	68 3d 00 00 00       	push   $0x3d
 1cb:	eb 18                	jmp    1e5 <parse_args+0xb7>
				return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
			}

			argstore[storearg_pos++] = *arg;
 1cd:	8b 50 04             	mov    0x4(%eax),%edx
 1d0:	8b 00                	mov    (%eax),%eax
 1d2:	89 54 df fc          	mov    %edx,-0x4(%edi,%ebx,8)
 1d6:	89 44 df f8          	mov    %eax,-0x8(%edi,%ebx,8)
		{
			printf("Wrong arguments!\n");
			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
		}

		inarg_pos++;
 1da:	43                   	inc    %ebx
 1db:	eb 22                	jmp    1ff <parse_args+0xd1>

			argstore[storearg_pos++] = *arg;
		}
		else // argument does not match predefined set
		{
			printf("Wrong arguments!\n");
 1dd:	83 ec 0c             	sub    $0xc,%esp
 1e0:	68 51 00 00 00       	push   $0x51
 1e5:	e8 fc ff ff ff       	call   1e6 <parse_args+0xb8>
 1ea:	b8 01 01 00 00       	mov    $0x101,%eax
 1ef:	e9 1e 03 00 00       	jmp    512 <parse_args+0x3e4>
			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
 1f4:	bb 01 00 00 00       	mov    $0x1,%ebx
			{
				printf("Too many arguments!\n");
				return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
			}

			argstore[storearg_pos++] = *arg;
 1f9:	8d bd 60 ff ff ff    	lea    -0xa0(%ebp),%edi
	inarg_pos = 1;
	storearg_pos = 0;
	files_num = 0;

	// first find all arguments beginning with "-"
	while( inarg_pos<(ULONG)argc && *(argv[inarg_pos])=='-' )
 1ff:	3b 5d 08             	cmp    0x8(%ebp),%ebx
 202:	72 0f                	jb     213 <parse_args+0xe5>
 204:	8d 14 9e             	lea    (%esi,%ebx,4),%edx
 207:	31 f6                	xor    %esi,%esi
 209:	89 9d 54 ff ff ff    	mov    %ebx,-0xac(%ebp)
 20f:	89 d3                	mov    %edx,%ebx
 211:	eb 66                	jmp    279 <parse_args+0x14b>
 213:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
 216:	80 38 2d             	cmpb   $0x2d,(%eax)
 219:	74 92                	je     1ad <parse_args+0x7f>
 21b:	eb e7                	jmp    204 <parse_args+0xd6>
	}

	// parse filenames then
	while( inarg_pos<(ULONG)argc )
	{
		if( files_num>=2 ) // there should be no more than two filenames
 21d:	83 fe 02             	cmp    $0x2,%esi
 220:	75 0a                	jne    22c <parse_args+0xfe>
		{
			printf("Too many filenames specified!\n");
 222:	83 ec 0c             	sub    $0xc,%esp
 225:	68 62 00 00 00       	push   $0x62
 22a:	eb b9                	jmp    1e5 <parse_args+0xb7>
			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
		}

		temp_filename = (char *)malloc( 1+strlen(argv[inarg_pos]) );
 22c:	8b 3b                	mov    (%ebx),%edi
 22e:	31 c0                	xor    %eax,%eax
 230:	83 c9 ff             	or     $0xffffffff,%ecx
 233:	83 ec 0c             	sub    $0xc,%esp
 236:	f2 ae                	repnz scas %es:(%edi),%al
 238:	f7 d1                	not    %ecx
 23a:	51                   	push   %ecx
 23b:	e8 fc ff ff ff       	call   23c <parse_args+0x10e>
		if( !temp_filename )
 240:	83 c4 10             	add    $0x10,%esp
 243:	85 c0                	test   %eax,%eax
		{
			printf("Too many filenames specified!\n");
			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
		}

		temp_filename = (char *)malloc( 1+strlen(argv[inarg_pos]) );
 245:	89 c7                	mov    %eax,%edi
		if( !temp_filename )
 247:	75 0d                	jne    256 <parse_args+0x128>
		{
			printf("Cannot allocate memory for filename string!\n");
 249:	83 ec 0c             	sub    $0xc,%esp
 24c:	68 80 00 00 00       	push   $0x80
 251:	e9 b2 02 00 00       	jmp    508 <parse_args+0x3da>
			return ARG_PARSER_ERROR;
		}

		strcpy( temp_filename, argv[inarg_pos] );
 256:	50                   	push   %eax
 257:	50                   	push   %eax
 258:	ff 33                	pushl  (%ebx)
 25a:	57                   	push   %edi
 25b:	e8 fc ff ff ff       	call   25c <parse_args+0x12e>

		if( files_num==0 )
 260:	83 c4 10             	add    $0x10,%esp
 263:	85 f6                	test   %esi,%esi
 265:	75 08                	jne    26f <parse_args+0x141>
			wrk.fname_in = temp_filename;
 267:	89 3d 20 00 00 00    	mov    %edi,0x20
 26d:	eb 06                	jmp    275 <parse_args+0x147>
		else // only files_num==1, because of condition in the beginning of current "while" cycle
			wrk.fname_out = temp_filename;
 26f:	89 3d 24 00 00 00    	mov    %edi,0x24

		files_num++;
 275:	46                   	inc    %esi
 276:	83 c3 04             	add    $0x4,%ebx

		inarg_pos++;
	}

	// parse filenames then
	while( inarg_pos<(ULONG)argc )
 279:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 27f:	8d 04 16             	lea    (%esi,%edx,1),%eax
 282:	3b 45 08             	cmp    0x8(%ebp),%eax
 285:	72 96                	jb     21d <parse_args+0xef>

		files_num++;
		inarg_pos++;
	}

	if( !files_num ) // there must be at least 1 filename specified
 287:	85 f6                	test   %esi,%esi
 289:	75 0d                	jne    298 <parse_args+0x16a>
	{
		printf("No filenames specified!\n");
 28b:	83 ec 0c             	sub    $0xc,%esp
 28e:	68 ac 00 00 00       	push   $0xac
 293:	e9 4d ff ff ff       	jmp    1e5 <parse_args+0xb7>
	// now optional arguments (starting with "-") are stored in argstore[],
	// all needed filenames are also copied, go proceed configuring with
	// optional arguments

	// sort argument array (in increasing .type order) to ensure correct parsing
	sort_args( argstore, ARG_STORE_SIZE );
 298:	51                   	push   %ecx
 299:	51                   	push   %ecx
 29a:	6a 10                	push   $0x10
 29c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
 2a2:	50                   	push   %eax
 2a3:	e8 fc ff ff ff       	call   2a4 <parse_args+0x176>
 2a8:	8d 9d 64 ff ff ff    	lea    -0x9c(%ebp),%ebx
 2ae:	31 d2                	xor    %edx,%edx

	storearg_pos = 0;
	last_arg_type = ARG_INIT; // there is no such value in argstore[].type
	while( argstore[storearg_pos].type != ARG_NOARG )
 2b0:	83 c4 10             	add    $0x10,%esp
 2b3:	e9 64 02 00 00       	jmp    51c <parse_args+0x3ee>
	{
		if( last_arg_type == argstore[storearg_pos].type )
 2b8:	39 c2                	cmp    %eax,%edx
 2ba:	75 0d                	jne    2c9 <parse_args+0x19b>
		{
			printf("Redundant arguments!\n");
 2bc:	83 ec 0c             	sub    $0xc,%esp
 2bf:	68 c4 00 00 00       	push   $0xc4
 2c4:	e9 1c ff ff ff       	jmp    1e5 <parse_args+0xb7>
			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;
		}

		switch( argstore[storearg_pos].type )
 2c9:	48                   	dec    %eax
 2ca:	83 f8 06             	cmp    $0x6,%eax
 2cd:	0f 87 2d 02 00 00    	ja     500 <parse_args+0x3d2>
 2d3:	ff 24 85 00 00 00 00 	jmp    *0x0(,%eax,4)
		{
		case ARG_MODE:
			wrk.mode = 1; // set depack mode
 2da:	c7 05 08 00 00 00 01 	movl   $0x1,0x8
 2e1:	00 00 00 
			break;
 2e4:	e9 2e 02 00 00       	jmp    517 <parse_args+0x3e9>

		case ARG_GREEDY:
			if( wrk.mode ) // since sorted, argument list causes parsing go from up to down in this "case" list
 2e9:	83 3d 08 00 00 00 00 	cmpl   $0x0,0x8
 2f0:	74 0d                	je     2ff <parse_args+0x1d1>
			{
				printf("No greedy mode specification for DEpacking!\n");
 2f2:	83 ec 0c             	sub    $0xc,%esp
 2f5:	68 d9 00 00 00       	push   $0xd9
 2fa:	e9 09 02 00 00       	jmp    508 <parse_args+0x3da>
				return ARG_PARSER_ERROR;
			}
			wrk.greedy = 1; // set greedy packing mode
 2ff:	c7 05 04 00 00 00 01 	movl   $0x1,0x4
 306:	00 00 00 
			break;
 309:	e9 09 02 00 00       	jmp    517 <parse_args+0x3e9>

		case ARG_PTYPE:
			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_MEGALZ ) )
 30e:	52                   	push   %edx
 30f:	52                   	push   %edx
 310:	68 05 01 00 00       	push   $0x105
 315:	ff 73 fc             	pushl  -0x4(%ebx)
 318:	e8 fc ff ff ff       	call   319 <parse_args+0x1eb>
 31d:	83 c4 10             	add    $0x10,%esp
 320:	85 c0                	test   %eax,%eax
 322:	75 41                	jne    365 <parse_args+0x237>
			{
				wrk.packtype = PK_MLZ;
 324:	c7 05 00 00 00 00 01 	movl   $0x1,0x0
 32b:	00 00 00 
				wrk.zxheader = 0;
 32e:	c7 05 0c 00 00 00 00 	movl   $0x0,0xc
 335:	00 00 00 
				wrk.wordbit  = 0;
 338:	c7 05 10 00 00 00 00 	movl   $0x0,0x10
 33f:	00 00 00 
				wrk.bigend   = 0;
 342:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
 349:	00 00 00 
				wrk.fullbits = 0;
 34c:	c7 05 18 00 00 00 00 	movl   $0x0,0x18
 353:	00 00 00 
				wrk.maxwin   = 4352;
 356:	c7 05 1c 00 00 00 00 	movl   $0x1100,0x1c
 35d:	11 00 00 
 360:	e9 b2 01 00 00       	jmp    517 <parse_args+0x3e9>
			}
			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUM ) )
 365:	50                   	push   %eax
 366:	50                   	push   %eax
 367:	68 09 01 00 00       	push   $0x109
 36c:	ff 73 fc             	pushl  -0x4(%ebx)
 36f:	e8 fc ff ff ff       	call   370 <parse_args+0x242>
 374:	83 c4 10             	add    $0x10,%esp
 377:	85 c0                	test   %eax,%eax
 379:	75 41                	jne    3bc <parse_args+0x28e>
			{
				wrk.packtype = PK_HRM;
 37b:	c7 05 00 00 00 00 02 	movl   $0x2,0x0
 382:	00 00 00 
				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified
 385:	c7 05 0c 00 00 00 00 	movl   $0x0,0xc
 38c:	00 00 00 
				wrk.wordbit  = 1;
 38f:	c7 05 10 00 00 00 01 	movl   $0x1,0x10
 396:	00 00 00 
				wrk.bigend   = 0;
 399:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
 3a0:	00 00 00 
				wrk.fullbits = 1;
 3a3:	c7 05 18 00 00 00 01 	movl   $0x1,0x18
 3aa:	00 00 00 
				wrk.maxwin   = 4096;
 3ad:	c7 05 1c 00 00 00 00 	movl   $0x1000,0x1c
 3b4:	10 00 00 
 3b7:	e9 5b 01 00 00       	jmp    517 <parse_args+0x3e9>
			}
			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUST ) )
 3bc:	57                   	push   %edi
 3bd:	57                   	push   %edi
 3be:	68 0d 01 00 00       	push   $0x10d
 3c3:	ff 73 fc             	pushl  -0x4(%ebx)
 3c6:	e8 fc ff ff ff       	call   3c7 <parse_args+0x299>
 3cb:	83 c4 10             	add    $0x10,%esp
 3ce:	85 c0                	test   %eax,%eax
 3d0:	75 41                	jne    413 <parse_args+0x2e5>
			{
				wrk.packtype = PK_HST;
 3d2:	c7 05 00 00 00 00 03 	movl   $0x3,0x0
 3d9:	00 00 00 
				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified
 3dc:	c7 05 0c 00 00 00 00 	movl   $0x0,0xc
 3e3:	00 00 00 
				wrk.wordbit  = 1;
 3e6:	c7 05 10 00 00 00 01 	movl   $0x1,0x10
 3ed:	00 00 00 
				wrk.bigend   = 0;
 3f0:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
 3f7:	00 00 00 
				wrk.fullbits = 1;
 3fa:	c7 05 18 00 00 00 01 	movl   $0x1,0x18
 401:	00 00 00 
				wrk.maxwin   = 65536;
 404:	c7 05 1c 00 00 00 00 	movl   $0x10000,0x1c
 40b:	00 01 00 
 40e:	e9 04 01 00 00       	jmp    517 <parse_args+0x3e9>
			}
			else // there shouldn't be this case, but nevertheless...
			{
				printf("Impossible error #1! Press any key to continue or \"SPACE\" to exit... :-)\n");
 413:	83 ec 0c             	sub    $0xc,%esp
 416:	68 11 01 00 00       	push   $0x111
 41b:	e9 e8 00 00 00       	jmp    508 <parse_args+0x3da>
			break;

		case ARG_ZXHEAD:
			// ZX-header is not applicable for PK_MLZ type...
			// also wrk.packtype has been already set before...
			if( PK_MLZ==wrk.packtype )
 420:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0
 427:	75 0d                	jne    436 <parse_args+0x308>
			{
				printf("There couldn't be zx-header in megalz mode!\n");
 429:	83 ec 0c             	sub    $0xc,%esp
 42c:	68 5a 01 00 00       	push   $0x15a
 431:	e9 d2 00 00 00       	jmp    508 <parse_args+0x3da>
				return ARG_PARSER_ERROR;
			}
			wrk.zxheader = 1;
 436:	c7 05 0c 00 00 00 01 	movl   $0x1,0xc
 43d:	00 00 00 
			break;
 440:	e9 d2 00 00 00       	jmp    517 <parse_args+0x3e9>

		case ARG_WORD:
			// whether bits must be grouped in words or in bytes
			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_8 ) )
 445:	56                   	push   %esi
 446:	56                   	push   %esi
 447:	68 86 01 00 00       	push   $0x186
 44c:	ff 73 fc             	pushl  -0x4(%ebx)
 44f:	e8 fc ff ff ff       	call   450 <parse_args+0x322>
 454:	83 c4 10             	add    $0x10,%esp
 457:	85 c0                	test   %eax,%eax
 459:	75 25                	jne    480 <parse_args+0x352>
			{
				if( wrk.zxheader ) // won't force byte-wise bits when there is a zx-header
 45b:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
 462:	74 0d                	je     471 <parse_args+0x343>
				{
					printf("There can be only 16bit grouping of bits when ZX-header is active!\n");
 464:	83 ec 0c             	sub    $0xc,%esp
 467:	68 88 01 00 00       	push   $0x188
 46c:	e9 97 00 00 00       	jmp    508 <parse_args+0x3da>
					return ARG_PARSER_ERROR;
				}
				wrk.wordbit = 0;
 471:	c7 05 10 00 00 00 00 	movl   $0x0,0x10
 478:	00 00 00 
 47b:	e9 97 00 00 00       	jmp    517 <parse_args+0x3e9>
			}
			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_16 ) )
 480:	51                   	push   %ecx
 481:	51                   	push   %ecx
 482:	68 cb 01 00 00       	push   $0x1cb
 487:	ff 73 fc             	pushl  -0x4(%ebx)
 48a:	e8 fc ff ff ff       	call   48b <parse_args+0x35d>
 48f:	83 c4 10             	add    $0x10,%esp
 492:	85 c0                	test   %eax,%eax
 494:	75 0c                	jne    4a2 <parse_args+0x374>
			{
				wrk.wordbit = 1;
 496:	c7 05 10 00 00 00 01 	movl   $0x1,0x10
 49d:	00 00 00 
 4a0:	eb 75                	jmp    517 <parse_args+0x3e9>
			}
			else // there shouldn't be this case, but nevertheless...
			{
				printf("Impossible error #2! Press any key to continue or \"SPACE\" to exit... :-)\n");
 4a2:	83 ec 0c             	sub    $0xc,%esp
 4a5:	68 ce 01 00 00       	push   $0x1ce
 4aa:	eb 5c                	jmp    508 <parse_args+0x3da>
			}
			break;

		case ARG_BIGEND:
			// whether word-grouped bits must be big- or little-endian arranged
			if( wrk.zxheader )
 4ac:	83 3d 0c 00 00 00 00 	cmpl   $0x0,0xc
 4b3:	74 0a                	je     4bf <parse_args+0x391>
			{
				printf("There can be only little-endian arrangement of bits when ZX-header is active!\n");
 4b5:	83 ec 0c             	sub    $0xc,%esp
 4b8:	68 17 02 00 00       	push   $0x217
 4bd:	eb 49                	jmp    508 <parse_args+0x3da>
				return ARG_PARSER_ERROR;
			}
			wrk.bigend = 1;
 4bf:	c7 05 14 00 00 00 01 	movl   $0x1,0x14
 4c6:	00 00 00 
			break;
 4c9:	eb 4c                	jmp    517 <parse_args+0x3e9>

		case ARG_MAXWIN:
			maxwin = get_maxwin( argstore[storearg_pos].name );
 4cb:	83 ec 0c             	sub    $0xc,%esp
 4ce:	ff 73 fc             	pushl  -0x4(%ebx)
 4d1:	e8 fc ff ff ff       	call   4d2 <parse_args+0x3a4>
			if( !maxwin ) // there shouldn't be this case, but nevertheless...
 4d6:	83 c4 10             	add    $0x10,%esp
 4d9:	85 c0                	test   %eax,%eax
 4db:	75 0a                	jne    4e7 <parse_args+0x3b9>
			{
				printf("Impossible error #3! Press any key to continue or \"SPACE\" to exit... :-)\n");
 4dd:	83 ec 0c             	sub    $0xc,%esp
 4e0:	68 65 02 00 00       	push   $0x265
 4e5:	eb 21                	jmp    508 <parse_args+0x3da>
				return ARG_PARSER_ERROR;
			}

                        // wrk.maxwin is already initialized to the maximum value suitable for given packing type, so check new setting
			if( maxwin > wrk.maxwin )
 4e7:	3b 05 1c 00 00 00    	cmp    0x1c,%eax
 4ed:	76 0a                	jbe    4f9 <parse_args+0x3cb>
			{
				printf("Maximum window specified is too big for given packing type!\n");
 4ef:	83 ec 0c             	sub    $0xc,%esp
 4f2:	68 ae 02 00 00       	push   $0x2ae
 4f7:	eb 0f                	jmp    508 <parse_args+0x3da>
				return ARG_PARSER_ERROR;
			}
			wrk.maxwin = maxwin;
 4f9:	a3 1c 00 00 00       	mov    %eax,0x1c
			break;
 4fe:	eb 17                	jmp    517 <parse_args+0x3e9>

		default:
			// once again impossible error: we shouldn't be here since "while" loop condition...
			printf("Impossible error #4! Press any key to continue or \"SPACE\" to exit... :-)\n");
 500:	83 ec 0c             	sub    $0xc,%esp
 503:	68 ea 02 00 00       	push   $0x2ea
 508:	e8 fc ff ff ff       	call   509 <parse_args+0x3db>
 50d:	b8 00 01 00 00       	mov    $0x100,%eax
			return ARG_PARSER_ERROR;
 512:	83 c4 10             	add    $0x10,%esp
 515:	eb 1b                	jmp    532 <parse_args+0x404>
			break;
		}


		last_arg_type = argstore[storearg_pos++].type;
 517:	8b 13                	mov    (%ebx),%edx
 519:	83 c3 08             	add    $0x8,%ebx
	// sort argument array (in increasing .type order) to ensure correct parsing
	sort_args( argstore, ARG_STORE_SIZE );

	storearg_pos = 0;
	last_arg_type = ARG_INIT; // there is no such value in argstore[].type
	while( argstore[storearg_pos].type != ARG_NOARG )
 51c:	8b 03                	mov    (%ebx),%eax
 51e:	3d ff 00 00 00       	cmp    $0xff,%eax
 523:	0f 85 8f fd ff ff    	jne    2b8 <parse_args+0x18a>
 529:	b0 02                	mov    $0x2,%al
 52b:	eb 05                	jmp    532 <parse_args+0x404>
 52d:	b8 01 00 00 00       	mov    $0x1,%eax
		last_arg_type = argstore[storearg_pos++].type;
	}


	return ARG_PARSER_GO;
}
 532:	8d 65 f4             	lea    -0xc(%ebp),%esp
 535:	5b                   	pop    %ebx
 536:	5e                   	pop    %esi
 537:	5f                   	pop    %edi
 538:	5d                   	pop    %ebp
 539:	c3                   	ret    

mhmt-tb.o:     file format elf32-i386


Disassembly of section .text:

00000000 <init_tb>:




void init_tb(void)
{
   0:	55                   	push   %ebp
	ULONG i;

	tb_free=NULL;    // init linked list of free tb_chain elements
	tb_bunches=NULL; // no bunches already allocated
   1:	31 c0                	xor    %eax,%eax




void init_tb(void)
{
   3:	89 e5                	mov    %esp,%ebp
	ULONG i;

	tb_free=NULL;    // init linked list of free tb_chain elements
   5:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
   c:	00 00 00 
	tb_bunches=NULL; // no bunches already allocated
   f:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
  16:	00 00 00 

	for(i=0;i<65536;i++) // init array of 2-byte match pointers
	{
		tb_entry[i]=NULL;
  19:	c7 04 85 00 00 00 00 	movl   $0x0,0x0(,%eax,4)
  20:	00 00 00 00 
	ULONG i;

	tb_free=NULL;    // init linked list of free tb_chain elements
	tb_bunches=NULL; // no bunches already allocated

	for(i=0;i<65536;i++) // init array of 2-byte match pointers
  24:	40                   	inc    %eax
  25:	3d 00 00 01 00       	cmp    $0x10000,%eax
  2a:	75 ed                	jne    19 <init_tb+0x19>
	{
		tb_entry[i]=NULL;
	}
}
  2c:	5d                   	pop    %ebp
  2d:	c3                   	ret    

0000002e <cutoff_tb_chain>:
}


// shorten given twobyter chain to have only actual (<wrk.maxwin old) elements, giving some free elements to reuse
void cutoff_tb_chain(UWORD index,ULONG position)
{
  2e:	55                   	push   %ebp
  2f:	89 e5                	mov    %esp,%ebp
  31:	57                   	push   %edi
  32:	56                   	push   %esi
  33:	53                   	push   %ebx
  34:	83 ec 04             	sub    $0x4,%esp
	struct tb_chain * curr, * prev;


	curr=tb_entry[index];
  37:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
}


// shorten given twobyter chain to have only actual (<wrk.maxwin old) elements, giving some free elements to reuse
void cutoff_tb_chain(UWORD index,ULONG position)
{
  3b:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct tb_chain * curr, * prev;


	curr=tb_entry[index];
  3e:	8b 14 9d 00 00 00 00 	mov    0x0(,%ebx,4),%edx
	if( !curr ) return; // if nothing to remove
  45:	85 d2                	test   %edx,%edx
  47:	74 64                	je     ad <cutoff_tb_chain+0x7f>
	prev=curr;
	curr=curr->next;

	while( curr )
	{
		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it
  49:	8b 0d 1c 00 00 00    	mov    0x1c,%ecx
	if( !curr ) return; // if nothing to remove


	// see if we should delete some elements after first element in the given chain
	prev=curr;
	curr=curr->next;
  4f:	8b 42 04             	mov    0x4(%edx),%eax

	while( curr )
	{
		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it
  52:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  55:	89 d1                	mov    %edx,%ecx

	// see if we should delete some elements after first element in the given chain
	prev=curr;
	curr=curr->next;

	while( curr )
  57:	eb 30                	jmp    89 <cutoff_tb_chain+0x5b>
	{
		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it
  59:	89 f7                	mov    %esi,%edi
  5b:	2b 38                	sub    (%eax),%edi
  5d:	3b 7d f0             	cmp    -0x10(%ebp),%edi
  60:	76 22                	jbe    84 <cutoff_tb_chain+0x56>
		{
			// find end of chain
			while( curr->next )
  62:	89 c7                	mov    %eax,%edi
  64:	8b 40 04             	mov    0x4(%eax),%eax
  67:	85 c0                	test   %eax,%eax
  69:	75 f7                	jne    62 <cutoff_tb_chain+0x34>
				curr = curr->next;
			}

			// now curr - last chain element, prev->next - beginning of orphaned chain
			// add orphaned chain to free list
			curr->next = tb_free;
  6b:	a1 00 00 00 00       	mov    0x0,%eax
  70:	89 47 04             	mov    %eax,0x4(%edi)
			tb_free = prev->next;
  73:	8b 41 04             	mov    0x4(%ecx),%eax
  76:	a3 00 00 00 00       	mov    %eax,0x0

			prev->next = NULL; // cut off chain
  7b:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)

			break;
  82:	eb 09                	jmp    8d <cutoff_tb_chain+0x5f>
		}
		else
		{
			prev=curr;
			curr=curr->next;
  84:	89 c1                	mov    %eax,%ecx
  86:	8b 40 04             	mov    0x4(%eax),%eax

	// see if we should delete some elements after first element in the given chain
	prev=curr;
	curr=curr->next;

	while( curr )
  89:	85 c0                	test   %eax,%eax
  8b:	75 cc                	jne    59 <cutoff_tb_chain+0x2b>
		}
	}

	// delete first (entry) element in chain if needed (in this case, all subsequent els are already deleted)
	curr=tb_entry[index];
	if( (position-(curr->pos)) > wrk.maxwin )
  8d:	2b 32                	sub    (%edx),%esi
  8f:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  92:	76 19                	jbe    ad <cutoff_tb_chain+0x7f>
	{
		tb_entry[index] = NULL;

		curr->next=tb_free; // element goes to free list
  94:	a1 00 00 00 00       	mov    0x0,%eax

	// delete first (entry) element in chain if needed (in this case, all subsequent els are already deleted)
	curr=tb_entry[index];
	if( (position-(curr->pos)) > wrk.maxwin )
	{
		tb_entry[index] = NULL;
  99:	c7 04 9d 00 00 00 00 	movl   $0x0,0x0(,%ebx,4)
  a0:	00 00 00 00 

		curr->next=tb_free; // element goes to free list
  a4:	89 42 04             	mov    %eax,0x4(%edx)
		tb_free=curr;
  a7:	89 15 00 00 00 00    	mov    %edx,0x0
	}
}
  ad:	58                   	pop    %eax
  ae:	5b                   	pop    %ebx
  af:	5e                   	pop    %esi
  b0:	5f                   	pop    %edi
  b1:	5d                   	pop    %ebp
  b2:	c3                   	ret    

000000b3 <get_free_tb>:
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
  b3:	a1 00 00 00 00       	mov    0x0,%eax
}


// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
  b8:	55                   	push   %ebp
  b9:	89 e5                	mov    %esp,%ebp
	struct tb_chain * newtb;

	if( tb_free )
  bb:	85 c0                	test   %eax,%eax
  bd:	74 09                	je     c8 <get_free_tb+0x15>
	{
		newtb=tb_free;
		tb_free=tb_free->next;
  bf:	8b 50 04             	mov    0x4(%eax),%edx
  c2:	89 15 00 00 00 00    	mov    %edx,0x0
	}
	else
	{
		return NULL;
	}
}
  c8:	5d                   	pop    %ebp
  c9:	c3                   	ret    

000000ca <add_bunch_of_tb>:


// adds new bunch of TBs when needed
// zero - error
ULONG add_bunch_of_tb(void)
{
  ca:	55                   	push   %ebp
  cb:	89 e5                	mov    %esp,%ebp
  cd:	83 ec 14             	sub    $0x14,%esp
	ULONG i;
	struct tb_bunch * newbunch;

	// alloc new bunch
	newbunch=(struct tb_bunch *)malloc( sizeof(struct tb_bunch) );
  d0:	68 04 80 00 00       	push   $0x8004
  d5:	e8 fc ff ff ff       	call   d6 <add_bunch_of_tb+0xc>
	if( !newbunch ) return 0;
  da:	83 c4 10             	add    $0x10,%esp
  dd:	31 d2                	xor    %edx,%edx
  df:	31 c9                	xor    %ecx,%ecx
  e1:	85 c0                	test   %eax,%eax
  e3:	74 37                	je     11c <add_bunch_of_tb+0x52>

	// link every twobyter into one list
	for(i=0;i<(BUNCHSIZE-1);i++)
	{
		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);
  e5:	42                   	inc    %edx
  e6:	8d 4c d0 04          	lea    0x4(%eax,%edx,8),%ecx
	// alloc new bunch
	newbunch=(struct tb_bunch *)malloc( sizeof(struct tb_bunch) );
	if( !newbunch ) return 0;

	// link every twobyter into one list
	for(i=0;i<(BUNCHSIZE-1);i++)
  ea:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
	{
		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);
  f0:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
	// alloc new bunch
	newbunch=(struct tb_bunch *)malloc( sizeof(struct tb_bunch) );
	if( !newbunch ) return 0;

	// link every twobyter into one list
	for(i=0;i<(BUNCHSIZE-1);i++)
  f3:	75 f0                	jne    e5 <add_bunch_of_tb+0x1b>
	{
		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);
	}

	// add this list to the free list
	newbunch->bunch[BUNCHSIZE-1].next=tb_free;
  f5:	8b 15 00 00 00 00    	mov    0x0,%edx
	tb_free=&(newbunch->bunch[0]);

	// add bunch to bunches list
	newbunch->next=tb_bunches;
	tb_bunches=newbunch;
  fb:	b9 01 00 00 00       	mov    $0x1,%ecx
	{
		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);
	}

	// add this list to the free list
	newbunch->bunch[BUNCHSIZE-1].next=tb_free;
 100:	89 90 00 80 00 00    	mov    %edx,0x8000(%eax)
	tb_free=&(newbunch->bunch[0]);
 106:	8d 50 04             	lea    0x4(%eax),%edx
 109:	89 15 00 00 00 00    	mov    %edx,0x0

	// add bunch to bunches list
	newbunch->next=tb_bunches;
 10f:	8b 15 00 00 00 00    	mov    0x0,%edx
 115:	89 10                	mov    %edx,(%eax)
	tb_bunches=newbunch;
 117:	a3 00 00 00 00       	mov    %eax,0x0

	return 1;
}
 11c:	89 c8                	mov    %ecx,%eax
 11e:	c9                   	leave  
 11f:	c3                   	ret    

00000120 <add_tb>:
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
 120:	a1 00 00 00 00       	mov    0x0,%eax
// addw new twobyter:
// index=(prev<<8)+curr - index into tb_entry,
// position - position in input file for 'curr' byte
// returns zero if any error (cant allocate mem), otherwise 1
ULONG add_tb(UWORD index, ULONG position)
{
 125:	55                   	push   %ebp
 126:	89 e5                	mov    %esp,%ebp
 128:	56                   	push   %esi
 129:	8b 75 08             	mov    0x8(%ebp),%esi
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
 12c:	85 c0                	test   %eax,%eax
// addw new twobyter:
// index=(prev<<8)+curr - index into tb_entry,
// position - position in input file for 'curr' byte
// returns zero if any error (cant allocate mem), otherwise 1
ULONG add_tb(UWORD index, ULONG position)
{
 12e:	53                   	push   %ebx
 12f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
 132:	75 33                	jne    167 <add_tb+0x47>

	newtb=get_free_tb();
	if( !newtb )
	{ // no free elements

		if( position > wrk.maxwin ) // if there could be enough tbs to try to flush
 134:	3b 1d 1c 00 00 00    	cmp    0x1c,%ebx
 13a:	76 0c                	jbe    148 <add_tb+0x28>
		{
			// try to flush current chain
			cutoff_tb_chain(index,position);
 13c:	53                   	push   %ebx
 13d:	0f b7 c6             	movzwl %si,%eax
 140:	50                   	push   %eax
 141:	e8 fc ff ff ff       	call   142 <add_tb+0x22>
 146:	5a                   	pop    %edx
 147:	59                   	pop    %ecx
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
 148:	a1 00 00 00 00       	mov    0x0,%eax
 14d:	85 c0                	test   %eax,%eax
 14f:	75 16                	jne    167 <add_tb+0x47>
		}

		newtb=get_free_tb();
		if( !newtb )
		{ // nothing free - allocate new bunch
			if( !add_bunch_of_tb() )
 151:	e8 fc ff ff ff       	call   152 <add_tb+0x32>
 156:	89 c2                	mov    %eax,%edx
 158:	31 c0                	xor    %eax,%eax
 15a:	85 d2                	test   %edx,%edx
 15c:	74 2e                	je     18c <add_tb+0x6c>
// find free tb, if any, otherwise NULL
struct tb_chain * get_free_tb(void)
{
	struct tb_chain * newtb;

	if( tb_free )
 15e:	a1 00 00 00 00       	mov    0x0,%eax
 163:	85 c0                	test   %eax,%eax
 165:	74 09                	je     170 <add_tb+0x50>
	{
		newtb=tb_free;
		tb_free=tb_free->next;
 167:	8b 50 04             	mov    0x4(%eax),%edx
 16a:	89 15 00 00 00 00    	mov    %edx,0x0
	}



	newtb->pos=position-1; // points to the first byte of given two bytes
	newtb->next=tb_entry[index];
 170:	0f b7 f6             	movzwl %si,%esi
		}
	}



	newtb->pos=position-1; // points to the first byte of given two bytes
 173:	4b                   	dec    %ebx
	newtb->next=tb_entry[index];
 174:	8b 14 b5 00 00 00 00 	mov    0x0(,%esi,4),%edx
		}
	}



	newtb->pos=position-1; // points to the first byte of given two bytes
 17b:	89 18                	mov    %ebx,(%eax)
	newtb->next=tb_entry[index];
 17d:	89 50 04             	mov    %edx,0x4(%eax)
	tb_entry[index]=newtb;
 180:	89 04 b5 00 00 00 00 	mov    %eax,0x0(,%esi,4)
 187:	b8 01 00 00 00       	mov    $0x1,%eax


	return 1;
}
 18c:	8d 65 f8             	lea    -0x8(%ebp),%esp
 18f:	5b                   	pop    %ebx
 190:	5e                   	pop    %esi
 191:	5d                   	pop    %ebp
 192:	c3                   	ret    

00000193 <free_tb>:
	}
}


void free_tb(void)
{
 193:	55                   	push   %ebp
 194:	89 e5                	mov    %esp,%ebp
 196:	83 ec 08             	sub    $0x8,%esp
	// free all allocated bunches

	struct tb_bunch * tbtmp;

	while( tb_bunches )
 199:	eb 14                	jmp    1af <free_tb+0x1c>
	{
		tbtmp=tb_bunches;
		tb_bunches=tb_bunches->next;
 19b:	8b 10                	mov    (%eax),%edx
		free( tbtmp );
 19d:	83 ec 0c             	sub    $0xc,%esp
 1a0:	50                   	push   %eax
	struct tb_bunch * tbtmp;

	while( tb_bunches )
	{
		tbtmp=tb_bunches;
		tb_bunches=tb_bunches->next;
 1a1:	89 15 00 00 00 00    	mov    %edx,0x0
		free( tbtmp );
 1a7:	e8 fc ff ff ff       	call   1a8 <free_tb+0x15>
 1ac:	83 c4 10             	add    $0x10,%esp
{
	// free all allocated bunches

	struct tb_bunch * tbtmp;

	while( tb_bunches )
 1af:	a1 00 00 00 00       	mov    0x0,%eax
 1b4:	85 c0                	test   %eax,%eax
 1b6:	75 e3                	jne    19b <free_tb+0x8>
	{
		tbtmp=tb_bunches;
		tb_bunches=tb_bunches->next;
		free( tbtmp );
	}
}
 1b8:	c9                   	leave  
 1b9:	c3                   	ret    
