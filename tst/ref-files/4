; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-depack.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_buf_size
PUBLIC	_buf_ptr
PUBLIC	_buffer
PUBLIC	??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@ ; `string'
PUBLIC	??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@ ; `string'
PUBLIC	??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ ; `string'
PUBLIC	??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ ; `string'
PUBLIC	??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@ ; `string'
PUBLIC	??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@ ; `string'
PUBLIC	??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ ; `string'
PUBLIC	??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ ; `string'
PUBLIC	??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@ ; `string'
PUBLIC	??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@ ; `string'
PUBLIC	??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@ ; `string'
PUBLIC	??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ ; `string'
PUBLIC	??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ ; `string'
PUBLIC	??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@ ; `string'
PUBLIC	??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@ ; `string'
PUBLIC	??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@ ; `string'
PUBLIC	??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@ ; `string'
PUBLIC	??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ ; `string'
PUBLIC	??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ ; `string'
PUBLIC	??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@ ; `string'
PUBLIC	??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
PUBLIC	??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
PUBLIC	??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ ; `string'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__printf:PROC
_buf_size DD	01H DUP (?)
_buf_ptr DD	01H DUP (?)
_buffer	DD	01H DUP (?)
;	COMDAT ??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - displacement greater than buffer '
	DB	'size!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - non-negative displacement!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
CONST	SEGMENT
??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@ DB 'mhmt'
	DB	'-depack.c:depack_repeat() - zero length!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_outbyte() - bad operation requested', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_getbits() - wrong operation code', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@ DB 'mhmt-'
	DB	'depack.c:depack_getbits() - too many (>31) or zero bits reque'
	DB	'sted', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@
CONST	SEGMENT
??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@ DB 'mhmt'
	DB	'-depack.c:depack_get() - wrong operation code', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@
CONST	SEGMENT
??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - Wrong lookback displacement of %d, gre'
	DB	'ater than maxwin', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@
CONST	SEGMENT
??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - Wrong displacement in disptype!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@
CONST	SEGMENT
??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@ DB 'mh'
	DB	'mt-depack-hrust.c:{} - bitlen of expandable displacement expa'
	DB	'nded more than 16 bits!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
CONST	SEGMENT
??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@
CONST	SEGMENT
??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@
CONST	SEGMENT
??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Bad zx-header!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@
CONST	SEGMENT
??_C@_0DF@PEAELEOK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5r@ DB 'm'
	DB	'hmt-depack-hrust.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@
CONST	SEGMENT
??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@ DB 'mh'
	DB	'mt-depack-hrum.c:{} - Wrong lookback displacement of %d, grea'
	DB	'ter than maxwin', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
CONST	SEGMENT
??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@
CONST	SEGMENT
??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@
CONST	SEGMENT
??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@ DB 'mh'
	DB	'mt-depack-hrum.c:{} - Wrong ZX-header!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@
CONST	SEGMENT
??_C@_0DE@JBIDLANM@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5re@ DB 'm'
	DB	'hmt-depack-hrum.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
CONST	SEGMENT
??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ DB 'mh'
	DB	'mt-depack-megalz.c:{} - Wrong LZ code', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
CONST	SEGMENT
??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@ DB 'mh'
	DB	'mt-depack-megalz.c:{} - Wrong lookback displacement of %d, gr'
	DB	'eater than maxwin', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t get bits from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t get byte from input stream!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0DG@PAJMLAFL@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@ DB 'm'
	DB	'hmt-depack-megalz.c:{} - Can''t rewind input stream!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@
CONST	SEGMENT
??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@ DB 'mhmt-'
	DB	'depack.c:depack() cannot allocate memory for depack buffer!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@
CONST	SEGMENT
??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@ DB 'mhm'
	DB	't-depack.c:depack() - format unsupported!', 0aH, 00H ; `string'
PUBLIC	_depack_outbyte
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack.c
;	COMDAT _depack_outbyte
_TEXT	SEGMENT
_operation$ = 8						; size = 4
_depack_outbyte PROC					; COMDAT
; _byte$ = eax

; 259  : 	if( operation==DEPACK_OUTBYTE_ADD )

  00000	83 7c 24 04 02	 cmp	 DWORD PTR _operation$[esp-4], 2
  00005	75 3e		 jne	 SHORT $LN7@depack_out

; 260  : 	{
; 261  : 		buffer[buf_ptr++] = byte;

  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buf_ptr
  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _buffer
  00013	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 262  : 
; 263  : 
; 264  : 		if( buf_ptr>0x51d )
; 265  : 		{
; 266  : //			printf("слом\n");
; 267  : 		}
; 268  : 
; 269  : 
; 270  : 		if( buf_ptr >= buf_size )

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_size
  0001b	41		 inc	 ecx
  0001c	89 0d 00 00 00
	00		 mov	 DWORD PTR _buf_ptr, ecx
  00022	3b c8		 cmp	 ecx, eax
  00024	72 13		 jb	 SHORT $LN5@depack_out

; 271  : 		{
; 272  : 			buf_ptr=0;

  00026	83 25 00 00 00
	00 00		 and	 DWORD PTR _buf_ptr, 0

; 273  : 			return emit_file( buffer, buf_size );

  0002d	83 f8 ff	 cmp	 eax, -1
  00030	75 0b		 jne	 SHORT $LN29@depack_out
$LN52@depack_out:
  00032	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??emit_file@@9@9, 0
$LN5@depack_out:

; 274  : 		}
; 275  : 
; 276  : 		return 1;

  00039	33 c0		 xor	 eax, eax
  0003b	40		 inc	 eax

; 287  : 	}
; 288  : }

  0003c	c3		 ret	 0

; 273  : 			return emit_file( buffer, buf_size );

$LN29@depack_out:
  0003d	52		 push	 edx
$LN51@depack_out:
  0003e	e8 00 00 00 00	 call	 _emit_file

; 281  : 		return 1;
; 282  : 	}
; 283  : 	else
; 284  : 	{
; 285  : 		printf("mhmt-depack.c:depack_outbyte() - bad operation requested\n");

  00043	59		 pop	 ecx

; 287  : 	}
; 288  : }

  00044	c3		 ret	 0
$LN7@depack_out:

; 277  : 	}
; 278  : 	else if( operation==DEPACK_OUTBYTE_FLUSH )

  00045	83 7c 24 04 01	 cmp	 DWORD PTR _operation$[esp-4], 1
  0004a	75 16		 jne	 SHORT $LN3@depack_out

; 279  : 	{
; 280  : 		if( buf_ptr ) return emit_file( buffer, buf_ptr );

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _buf_ptr
  00051	85 c0		 test	 eax, eax
  00053	74 e4		 je	 SHORT $LN5@depack_out
  00055	83 f8 ff	 cmp	 eax, -1
  00058	74 d8		 je	 SHORT $LN52@depack_out
  0005a	ff 35 00 00 00
	00		 push	 DWORD PTR _buffer
  00060	eb dc		 jmp	 SHORT $LN51@depack_out
$LN3@depack_out:

; 281  : 		return 1;
; 282  : 	}
; 283  : 	else
; 284  : 	{
; 285  : 		printf("mhmt-depack.c:depack_outbyte() - bad operation requested\n");

  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@BHKGCDOH@mhmt?9depack?4c?3depack_outbyte?$CI?$CJ?5?9@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 286  : 		return 0;

  0006d	33 c0		 xor	 eax, eax
  0006f	59		 pop	 ecx

; 287  : 	}
; 288  : }

  00070	c3		 ret	 0
_depack_outbyte ENDP
_TEXT	ENDS
PUBLIC	_depack_getbyte
?position@?1??depack_getbyte@@9@9 DD 01H DUP (?)	; `depack_getbyte'::`2'::position
; Function compile flags: /Ogspy
;	COMDAT _depack_getbyte
_TEXT	SEGMENT
_operation$ = 8						; size = 4
_depack_getbyte PROC					; COMDAT

; 125  : 	static ULONG position;
; 126  : 
; 127  : 	if( operation==DEPACK_GETBYTE_REWIND )
; 128  : 	{
; 129  : 		position=0;
; 130  : 		return 0;
; 131  : 	}
; 132  : 	else if( operation==DEPACK_GETBYTE_NEXT )

  00000	83 7c 24 04 01	 cmp	 DWORD PTR _operation$[esp-4], 1
  00005	75 1f		 jne	 SHORT $LN3@depack_get

; 133  : 	{
; 134  : 		if( position < wrk.inlen )

  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?position@?1??depack_getbyte@@9@9
  0000d	3b 0d 34 00 00
	00		 cmp	 ecx, DWORD PTR _wrk+52
  00013	73 1d		 jae	 SHORT $LN1@depack_get

; 135  : 		{
; 136  : //#ifdef DBG
; 137  : //			printf("<%02x>", wrk.indata[position]);
; 138  : //#endif
; 139  : 			return (ULONG)wrk.indata[position++];

  00015	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  0001a	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0001e	41		 inc	 ecx
  0001f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, ecx

; 146  : }

  00025	c3		 ret	 0
$LN3@depack_get:

; 140  : 		}
; 141  : 	}
; 142  : 	else // should never happen in a correct program
; 143  : 		printf("mhmt-depack.c:depack_get() - wrong operation code\n");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PBHPHMIG@mhmt?9depack?4c?3depack_get?$CI?$CJ?5?9?5wro@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00031	59		 pop	 ecx
$LN1@depack_get:

; 144  : 
; 145  : 	return 0xFFFFFFFF;

  00032	83 c8 ff	 or	 eax, -1

; 146  : }

  00035	c3		 ret	 0
_depack_getbyte ENDP
PUBLIC	_depack_repeat
; Function compile flags: /Ogspy
;	COMDAT _depack_repeat
_TEXT	SEGMENT
_length$ = 8						; size = 4
_depack_repeat PROC					; COMDAT
; _disp$ = ecx

; 296  : 	ULONG back_ptr;
; 297  : 	ULONG success=1;

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax

; 298  : 
; 299  : //#ifdef DBG
; 300  : //	printf("\n");
; 301  : //#endif
; 302  : 
; 303  : 
; 304  : 	// in a self-consistent system, these three errors should never appear, since there is input stream check before actual depacking
; 305  : 	if( !length )
; 306  : 	{
; 307  : 		printf("mhmt-depack.c:depack_repeat() - zero length!\n");
; 308  : 		return 0;
; 309  : 	}
; 310  : 	else if( disp>=0 )

  00003	85 c9		 test	 ecx, ecx
  00005	7c 0f		 jl	 SHORT $LN7@depack_rep

; 311  : 	{
; 312  : 		printf("mhmt-depack.c:depack_repeat() - non-negative displacement!\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ONMOONNM@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00012	59		 pop	 ecx

; 313  : 		return 0;

  00013	33 c0		 xor	 eax, eax

; 331  : 	}
; 332  : 
; 333  : 	return success;
; 334  : }

  00015	c3		 ret	 0
$LN7@depack_rep:

; 314  : 	}
; 315  : 	else if( (ULONG)(-disp)>buf_size )

  00016	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _buf_size
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx
  0001f	f7 de		 neg	 esi
  00021	3b f2		 cmp	 esi, edx
  00023	76 10		 jbe	 SHORT $LN5@depack_rep

; 316  : 	{
; 317  : 		printf("mhmt-depack.c:depack_repeat() - displacement greater than buffer size!\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@NMELNPMH@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00030	59		 pop	 ecx

; 318  : 		return 0;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 331  : 	}
; 332  : 
; 333  : 	return success;
; 334  : }

  00034	c3		 ret	 0
$LN5@depack_rep:

; 319  : 	}
; 320  : 	else
; 321  : 	{
; 322  : 		back_ptr = (disp+buf_ptr) & (buf_size-1); // buf_size MUST BE 2^N!

  00035	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _buf_ptr
  0003b	03 f1		 add	 esi, ecx
  0003d	4a		 dec	 edx
  0003e	23 f2		 and	 esi, edx
$LL3@depack_rep:

; 323  : 
; 324  : 		do
; 325  : 		{
; 326  : 			success = success && depack_outbyte( buffer[back_ptr], DEPACK_OUTBYTE_ADD ); // also increases buf_ptr

  00040	85 c0		 test	 eax, eax
  00042	74 19		 je	 SHORT $LN18@depack_rep
  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  00049	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  0004c	6a 02		 push	 2
  0004e	e8 00 00 00 00	 call	 _depack_outbyte
  00053	59		 pop	 ecx
  00054	85 c0		 test	 eax, eax
  00056	74 05		 je	 SHORT $LN18@depack_rep
  00058	33 c0		 xor	 eax, eax
  0005a	40		 inc	 eax
  0005b	eb 02		 jmp	 SHORT $LN13@depack_rep
$LN18@depack_rep:
  0005d	33 c0		 xor	 eax, eax
$LN13@depack_rep:

; 327  : 
; 328  : 			back_ptr = (back_ptr+1) & (buf_size-1); // buf_size MUST BE 2^N!

  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _buf_size
  00065	49		 dec	 ecx
  00066	46		 inc	 esi
  00067	23 f1		 and	 esi, ecx

; 329  : 
; 330  : 		} while( --length );

  00069	ff 4c 24 08	 dec	 DWORD PTR _length$[esp]
  0006d	75 d1		 jne	 SHORT $LL3@depack_rep
  0006f	5e		 pop	 esi

; 331  : 	}
; 332  : 
; 333  : 	return success;
; 334  : }

  00070	c3		 ret	 0
_depack_repeat ENDP
_TEXT	ENDS
PUBLIC	_depack_getbits_word
; Function compile flags: /Ogspy
;	COMDAT _depack_getbits_word
_TEXT	SEGMENT
_depack_getbits_word PROC				; COMDAT

; 221  : 	ULONG bits,bits2;
; 222  : 
; 223  : 	if( wrk.wordbit ) // 16bits

  00000	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 226  : 		{
; 227  : 			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00009	6a 01		 push	 1
  0000b	74 52		 je	 SHORT $LN9@depack_get@2

; 224  : 	{
; 225  : 		if( wrk.bigend )

  0000d	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _wrk+20, 0
  00014	74 2e		 je	 SHORT $LN8@depack_get@2

; 226  : 		{
; 227  : 			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00016	e8 00 00 00 00	 call	 _depack_getbyte
  0001b	8b f0		 mov	 esi, eax
  0001d	59		 pop	 ecx

; 228  : 			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;

  0001e	83 fe ff	 cmp	 esi, -1
  00021	75 05		 jne	 SHORT $LN7@depack_get@2
$LN62@depack_get@2:
  00023	83 c8 ff	 or	 eax, -1
  00026	eb 45		 jmp	 SHORT $LN10@depack_get@2
$LN7@depack_get@2:

; 229  : 			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00028	6a 01		 push	 1
  0002a	e8 00 00 00 00	 call	 _depack_getbyte
  0002f	8b d8		 mov	 ebx, eax

; 230  : 			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;

  00031	83 fb ff	 cmp	 ebx, -1
$LN64@depack_get@2:

; 229  : 			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00034	59		 pop	 ecx

; 230  : 			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;

  00035	74 ec		 je	 SHORT $LN62@depack_get@2

; 238  : 		}
; 239  : 
; 240  : 		bits = (bits<<24) | ( 0x00FF0000&(bits2<<16) );

  00037	0f b6 c3	 movzx	 eax, bl
  0003a	c1 e6 08	 shl	 esi, 8
  0003d	0b c6		 or	 eax, esi
  0003f	c1 e0 10	 shl	 eax, 16			; 00000010H

; 241  : 	}
; 242  : 	else // 8bits

  00042	eb 29		 jmp	 SHORT $LN10@depack_get@2
$LN8@depack_get@2:

; 231  : 		}
; 232  : 		else
; 233  : 		{
; 234  : 			bits2 = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00044	e8 00 00 00 00	 call	 _depack_getbyte
  00049	8b d8		 mov	 ebx, eax
  0004b	59		 pop	 ecx

; 235  : 			if( bits2 == 0xFFFFFFFF ) return 0xFFFFFFFF;

  0004c	83 fb ff	 cmp	 ebx, -1
  0004f	74 d2		 je	 SHORT $LN62@depack_get@2

; 236  : 			bits  = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00051	6a 01		 push	 1
  00053	e8 00 00 00 00	 call	 _depack_getbyte
  00058	8b f0		 mov	 esi, eax

; 237  : 			if( bits  == 0xFFFFFFFF ) return 0xFFFFFFFF;

  0005a	83 fe ff	 cmp	 esi, -1
  0005d	eb d5		 jmp	 SHORT $LN64@depack_get@2
$LN9@depack_get@2:

; 243  : 	{
; 244  : 		bits=depack_getbyte(DEPACK_GETBYTE_NEXT);

  0005f	e8 00 00 00 00	 call	 _depack_getbyte
  00064	59		 pop	 ecx

; 245  : 		if( bits!=0xFFFFFFFF)

  00065	83 f8 ff	 cmp	 eax, -1
  00068	74 03		 je	 SHORT $LN10@depack_get@2

; 246  : 			bits <<= 24;

  0006a	c1 e0 18	 shl	 eax, 24			; 00000018H
$LN10@depack_get@2:
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 247  : 	}
; 248  : 
; 249  : 	return bits;
; 250  : }

  0006f	c3		 ret	 0
_depack_getbits_word ENDP
_TEXT	ENDS
PUBLIC	_depack_getbits
?num_bits_left@?1??depack_getbits@@9@9 DD 01H DUP (?)	; `depack_getbits'::`2'::num_bits_left
?bits@?1??depack_getbits@@9@9 DD 01H DUP (?)		; `depack_getbits'::`2'::bits
; Function compile flags: /Ogspy
;	COMDAT _depack_getbits
_TEXT	SEGMENT
_operation$ = 8						; size = 4
_depack_getbits PROC					; COMDAT
; _numbits$ = eax

; 154  : 
; 155  : 	static ULONG num_bits_left;
; 156  : 
; 157  : 	ULONG fetched_bits;
; 158  : 
; 159  : 
; 160  : 	if( operation==DEPACK_GETBITS_FORCE ) // force word retrieval (for start of stream)

  00000	83 7c 24 04 01	 cmp	 DWORD PTR _operation$[esp-4], 1
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax
  00009	75 31		 jne	 SHORT $LN16@depack_get@3

; 161  : 	{
; 162  : 		bits = depack_getbits_word();

  0000b	e8 00 00 00 00	 call	 _depack_getbits_word
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 163  : 		if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  00015	83 f8 ff	 cmp	 eax, -1
  00018	0f 84 d8 00 00
	00		 je	 $LN24@depack_get@3

; 164  : 		num_bits_left = wrk.wordbit ? 16 : 8;

  0001e	33 c0		 xor	 eax, eax
  00020	39 05 10 00 00
	00		 cmp	 DWORD PTR _wrk+16, eax
  00026	0f 95 c0	 setne	 al
  00029	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax

; 165  : 		return 0;

  00035	33 c0		 xor	 eax, eax
  00037	e9 bd 00 00 00	 jmp	 $LN1@depack_get@3
$LN16@depack_get@3:

; 166  : 	}
; 167  : 	else if( operation==DEPACK_GETBITS_NEXT ) // return bits and fetch new as needed (wrk.fullbits accounted for)

  0003c	83 7c 24 0c 02	 cmp	 DWORD PTR _operation$[esp+4], 2
  00041	0f 85 a3 00 00
	00		 jne	 $LN13@depack_get@3

; 168  : 	{
; 169  : 		if( (numbits==0) || (numbits>31) )

  00047	85 ff		 test	 edi, edi
  00049	0f 84 94 00 00
	00		 je	 $LN11@depack_get@3
  0004f	83 ff 1f	 cmp	 edi, 31			; 0000001fH
  00052	0f 87 8b 00 00
	00		 ja	 $LN11@depack_get@3

; 173  : 		}
; 174  : 
; 175  : 		fetched_bits = 0;

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9
  0005d	33 f6		 xor	 esi, esi
$LL10@depack_get@3:

; 176  : 		do
; 177  : 		{
; 178  : 			if( !wrk.fullbits ) // empty bits

  0005f	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  00066	75 25		 jne	 SHORT $LN23@depack_get@3

; 179  : 			{
; 180  : 				if( !num_bits_left )

  00068	85 c0		 test	 eax, eax
  0006a	75 21		 jne	 SHORT $LN23@depack_get@3

; 181  : 				{
; 182  : 					bits = depack_getbits_word();

  0006c	e8 00 00 00 00	 call	 _depack_getbits_word
  00071	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 183  : 					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  00076	83 f8 ff	 cmp	 eax, -1
  00079	74 7b		 je	 SHORT $LN24@depack_get@3

; 184  : 					num_bits_left = wrk.wordbit ? 16 : 8;

  0007b	33 c0		 xor	 eax, eax
  0007d	39 05 10 00 00
	00		 cmp	 DWORD PTR _wrk+16, eax
  00083	0f 95 c0	 setne	 al
  00086	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
$LN23@depack_get@3:

; 185  : 				}
; 186  : 			}
; 187  : 
; 188  : //#ifdef DBG
; 189  : //			printf("%d",bits>>31);
; 190  : //#endif
; 191  : 			fetched_bits = ( fetched_bits<<1 ) | ( 1&(bits>>31) );

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bits@?1??depack_getbits@@9@9

; 192  : 			bits <<= 1;

  00093	d1 25 00 00 00
	00		 shl	 DWORD PTR ?bits@?1??depack_getbits@@9@9, 1
  00099	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009c	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0009f	0b ca		 or	 ecx, edx

; 193  : 			num_bits_left--;

  000a1	48		 dec	 eax

; 194  : 
; 195  : 			if( wrk.fullbits )

  000a2	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _wrk+24, 0
  000a9	8b f1		 mov	 esi, ecx
  000ab	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax
  000b0	74 2a		 je	 SHORT $LN9@depack_get@3

; 196  : 			{
; 197  : 				if( !num_bits_left )

  000b2	85 c0		 test	 eax, eax
  000b4	75 26		 jne	 SHORT $LN9@depack_get@3

; 198  : 				{
; 199  : 					bits = depack_getbits_word();

  000b6	e8 00 00 00 00	 call	 _depack_getbits_word
  000bb	a3 00 00 00 00	 mov	 DWORD PTR ?bits@?1??depack_getbits@@9@9, eax

; 200  : 					if( bits==0xFFFFFFFF) return 0xFFFFFFFF;

  000c0	83 f8 ff	 cmp	 eax, -1
  000c3	74 31		 je	 SHORT $LN24@depack_get@3

; 201  : 					num_bits_left = wrk.wordbit ? 16 : 8;

  000c5	33 c0		 xor	 eax, eax
  000c7	39 05 10 00 00
	00		 cmp	 DWORD PTR _wrk+16, eax
  000cd	0f 95 c0	 setne	 al
  000d0	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [eax*8+8]
  000d7	a3 00 00 00 00	 mov	 DWORD PTR ?num_bits_left@?1??depack_getbits@@9@9, eax
$LN9@depack_get@3:

; 202  : 				}
; 203  : 			}
; 204  : 
; 205  : 		} while( --numbits );

  000dc	4f		 dec	 edi
  000dd	75 80		 jne	 SHORT $LL10@depack_get@3

; 206  : 
; 207  : 		return fetched_bits;

  000df	8b c6		 mov	 eax, esi
  000e1	eb 16		 jmp	 SHORT $LN1@depack_get@3
$LN11@depack_get@3:

; 170  : 		{
; 171  : 			printf("mhmt-depack.c:depack_getbits() - too many (>31) or zero bits requested\n");

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@ODDGDKLE@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@

; 172  : 			return 0xFFFFFFFF;

  000e8	eb 05		 jmp	 SHORT $LN25@depack_get@3
$LN13@depack_get@3:

; 208  : 	}
; 209  : 	else
; 210  : 	{
; 211  : 		printf("mhmt-depack.c:depack_getbits() - wrong operation code\n");

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@HCOMJLBG@mhmt?9depack?4c?3depack_getbits?$CI?$CJ?5?9@
$LN25@depack_get@3:
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000f5	59		 pop	 ecx
$LN24@depack_get@3:

; 212  : 		return 0xFFFFFFFF;

  000f6	83 c8 ff	 or	 eax, -1
$LN1@depack_get@3:
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi

; 213  : 	}
; 214  : }

  000fb	c3		 ret	 0
_depack_getbits ENDP
_TEXT	ENDS
PUBLIC	_depacker_hrust
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack-hrust.c
;	COMDAT _depacker_hrust
_TEXT	SEGMENT
_success$ = -12						; size = 4
_expbitlen$ = -8					; size = 4
_disp$ = -4						; size = 4
_length$ = -4						; size = 4
_skipdisp$ = -4						; size = 4
_depacker_hrust PROC					; COMDAT

; 8    : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 
; 14   : 	LONG   disp;
; 15   : 	LONG length; // if -3 - insertion match, if 0 - nothing to do
; 16   : 
; 17   : 	ULONG skipdisp,skiplen;
; 18   : 
; 19   : 	ULONG disptype;
; 20   : // fetch byte and add to existing disp
; 21   : #define DISP_PLUSBYTE 0
; 22   : // fetch 5 bits to disp
; 23   : #define DISP_ABCDE    1
; 24   : // common disp for 3+ lengthes
; 25   : #define DISP_COMMON   2
; 26   : 
; 27   : 	ULONG docopy; // do copy from input instead of repeating
; 28   : 
; 29   : 	ULONG expbitlen = 2; // expandable displacement
; 30   : 
; 31   : 
; 32   : 	ULONG stop;
; 33   : 
; 34   : 
; 35   : 	ULONG success = 1;
; 36   : 
; 37   : 
; 38   : 
; 39   : 
; 40   : 
; 41   : 	// rewind input stream
; 42   : 	//
; 43   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
; 44   : #ifdef DPK_CHECK
; 45   : 	if( 0xFFFFFFFF == check )
; 46   : 	{
; 47   :  #ifdef DPK_REPERR
; 48   : 		printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");
; 49   :  #endif
; 50   : 		return 0;
; 51   : 	}
; 52   : #endif
; 53   : 
; 54   : 
; 55   : 	// manage zx header if needed
; 56   : 	if( wrk.zxheader )

  00007	33 db		 xor	 ebx, ebx
  00009	6a 02		 push	 2
  0000b	33 f6		 xor	 esi, esi
  0000d	5d		 pop	 ebp
  0000e	43		 inc	 ebx
  0000f	83 cf ff	 or	 edi, -1
  00012	89 6c 24 14	 mov	 DWORD PTR _expbitlen$[esp+28], ebp
  00016	89 35 00 00 00
	00		 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, esi
  0001c	39 35 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, esi
  00022	74 50		 je	 SHORT $LN101@depacker_h

; 57   : 	{
; 58   : 		// check for "HR" in beginning
; 59   : 		check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 _depack_getbyte
  0002a	59		 pop	 ecx

; 60   : #ifdef DPK_CHECK
; 61   : 		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  0002b	3b c7		 cmp	 eax, edi
  0002d	0f 84 05 05 00
	00		 je	 $NO_BYTE_HST$4203

; 62   : 		if( check != 'H' )

  00033	83 f8 48	 cmp	 eax, 72			; 00000048H
  00036	74 13		 je	 SHORT $LN106@depacker_h
$LN365@depacker_h:

; 63   : 		{
; 64   :  #ifdef DPK_REPERR
; 65   : 			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FMIJKBNK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Bad?5zx?9@
$LN366@depacker_h:
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
$LN367@depacker_h:
  00043	59		 pop	 ecx

; 66   :  #endif
; 67   : 			return 0;

  00044	33 c0		 xor	 eax, eax
  00046	e9 e5 04 00 00	 jmp	 $LN110@depacker_h
$LN106@depacker_h:

; 68   : 		}
; 69   : #endif
; 70   : 		check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0004b	53		 push	 ebx
  0004c	e8 00 00 00 00	 call	 _depack_getbyte
  00051	59		 pop	 ecx

; 71   : #ifdef DPK_CHECK
; 72   : 		if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00052	3b c7		 cmp	 eax, edi
  00054	0f 84 de 04 00
	00		 je	 $NO_BYTE_HST$4203

; 73   : 		if( check != 'R' )

  0005a	83 f8 52	 cmp	 eax, 82			; 00000052H

; 74   : 		{
; 75   :  #ifdef DPK_REPERR
; 76   : 			printf("mhmt-depack-hrust.c:{} - Bad zx-header!\n");
; 77   :  #endif
; 78   : 			return 0;

  0005d	75 d9		 jne	 SHORT $LN365@depacker_h
$LL104@depacker_h:

; 79   : 		}
; 80   : #endif
; 81   : 
; 82   : 		// skip 10 bytes
; 83   : 		for(i=0;i<10;i++)
; 84   : 		{
; 85   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0005f	53		 push	 ebx
  00060	e8 00 00 00 00	 call	 _depack_getbyte
  00065	59		 pop	 ecx

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;

  00066	3b c7		 cmp	 eax, edi
  00068	0f 84 ca 04 00
	00		 je	 $NO_BYTE_HST$4203
  0006e	46		 inc	 esi
  0006f	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00072	7c eb		 jl	 SHORT $LL104@depacker_h
$LN101@depacker_h:

; 88   : #endif
; 89   : 		}
; 90   : 	}
; 91   : 
; 92   : 
; 93   : 
; 94   : 	// initialize bitstream first
; 95   : 	//
; 96   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  00074	53		 push	 ebx
  00075	6a 10		 push	 16			; 00000010H
  00077	58		 pop	 eax
  00078	e8 00 00 00 00	 call	 _depack_getbits
  0007d	59		 pop	 ecx

; 97   : #ifdef DPK_CHECK
; 98   : 	if( 0xFFFFFFFF == check )

  0007e	3b c7		 cmp	 eax, edi
  00080	0f 84 41 04 00
	00		 je	 $NO_BITS_HST$4213

; 105  : 	}
; 106  : #endif
; 107  : 
; 108  : 
; 109  : 
; 110  : 	// then byte of input stream goes to the output unchanged
; 111  : 	//
; 112  : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00086	53		 push	 ebx
  00087	e8 00 00 00 00	 call	 _depack_getbyte
  0008c	59		 pop	 ecx

; 113  : #ifdef DPK_CHECK
; 114  : 	if( 0xFFFFFFFF == byte )

  0008d	3b c7		 cmp	 eax, edi
  0008f	0f 84 a3 04 00
	00		 je	 $NO_BYTE_HST$4203

; 121  : 	}
; 122  : #endif
; 123  : 
; 124  : #ifdef DPK_DEPACK
; 125  : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00095	55		 push	 ebp
  00096	e8 00 00 00 00	 call	 _depack_outbyte
  0009b	8b 7c 24 1c	 mov	 edi, DWORD PTR _length$[esp+32]
  0009f	8b 74 24 1c	 mov	 esi, DWORD PTR _disp$[esp+32]
  000a3	f7 d8		 neg	 eax
  000a5	1b c0		 sbb	 eax, eax
  000a7	f7 d8		 neg	 eax
  000a9	59		 pop	 ecx
  000aa	89 44 24 10	 mov	 DWORD PTR _success$[esp+28], eax
$LL97@depacker_h:

; 126  : #endif
; 127  : 
; 128  : 
; 129  : 
; 130  : 	// now normal depacking loop
; 131  : 	//
; 132  :   	stop = 0;
; 133  : 	while( (!stop) && success )

  000ae	83 7c 24 10 00	 cmp	 DWORD PTR _success$[esp+28], 0
  000b3	0f 84 2c 04 00
	00		 je	 $LN96@depacker_h

; 134  :  	{
; 135  : 		skiplen  = 0;
; 136  : 		skipdisp = 0;
; 137  : 		disptype = DISP_PLUSBYTE;
; 138  : 		docopy = 0;
; 139  : 
; 140  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  000b9	33 c0		 xor	 eax, eax
  000bb	33 db		 xor	 ebx, ebx
  000bd	6a 02		 push	 2
  000bf	40		 inc	 eax
  000c0	33 ed		 xor	 ebp, ebp
  000c2	89 5c 24 1c	 mov	 DWORD PTR _skipdisp$[esp+32], ebx
  000c6	e8 00 00 00 00	 call	 _depack_getbits
  000cb	59		 pop	 ecx

; 141  : #ifdef DPK_CHECK
; 142  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  000cc	83 f8 ff	 cmp	 eax, -1
  000cf	0f 84 f2 03 00
	00		 je	 $NO_BITS_HST$4213

; 143  : #endif
; 144  : 
; 145  : 		if( 1&bits ) // %1<byte>

  000d5	a8 01		 test	 al, 1
  000d7	74 40		 je	 SHORT $LN94@depacker_h

; 146  : 		{
; 147  : 			docopy = 1;
; 148  : 			length = 1;

  000d9	33 ff		 xor	 edi, edi
  000db	47		 inc	 edi
$LN344@depacker_h:

; 474  : 			}
; 475  : #endif
; 476  : 
; 477  : 
; 478  : 			if( docopy && (!stop) )
; 479  : 			{
; 480  : 				#ifdef DBG
; 481  : 					printf("copy.len=%d\n",length);
; 482  : 				#endif
; 483  : 				for(i=0;i<length;i++)

  000dc	33 ed		 xor	 ebp, ebp
  000de	85 ff		 test	 edi, edi
  000e0	7e cc		 jle	 SHORT $LL97@depacker_h
  000e2	33 db		 xor	 ebx, ebx
  000e4	43		 inc	 ebx
$LL20@depacker_h:

; 484  : 				{
; 485  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 _depack_getbyte
  000eb	59		 pop	 ecx

; 486  : #ifdef DPK_CHECK
; 487  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  000ec	83 f8 ff	 cmp	 eax, -1
  000ef	0f 84 43 04 00
	00		 je	 $NO_BYTE_HST$4203

; 488  : #endif
; 489  : 
; 490  : 
; 491  : #ifdef DPK_DEPACK
; 492  : 					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  000f5	83 7c 24 10 00	 cmp	 DWORD PTR _success$[esp+28], 0
  000fa	0f 84 5a 03 00
	00		 je	 $LN359@depacker_h
  00100	6a 02		 push	 2
  00102	e8 00 00 00 00	 call	 _depack_outbyte
  00107	59		 pop	 ecx
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 4a 03 00
	00		 je	 $LN359@depacker_h
  00110	89 5c 24 10	 mov	 DWORD PTR _success$[esp+28], ebx
  00114	e9 46 03 00 00	 jmp	 $LN115@depacker_h
$LN94@depacker_h:

; 149  : 		}
; 150  : 		else // %0xx
; 151  : 		{
; 152  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00119	6a 02		 push	 2
  0011b	58		 pop	 eax
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _depack_getbits
  00122	59		 pop	 ecx

; 153  : #ifdef DPK_CHECK
; 154  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00123	83 f8 ff	 cmp	 eax, -1
  00126	0f 84 9b 03 00
	00		 je	 $NO_BITS_HST$4213

; 155  : #endif
; 156  : 
; 157  : 			switch( bits&3 )

  0012c	83 e0 03	 and	 eax, 3
  0012f	83 e8 00	 sub	 eax, 0
  00132	0f 84 d3 00 00
	00		 je	 $LN89@depacker_h
  00138	48		 dec	 eax
  00139	74 1d		 je	 SHORT $LN87@depacker_h
  0013b	48		 dec	 eax
  0013c	74 0f		 je	 SHORT $LN73@depacker_h
  0013e	48		 dec	 eax
  0013f	0f 85 e8 00 00
	00		 jne	 $LN90@depacker_h

; 263  : 
; 264  : 
; 265  : 			case 3: // %011 - varlen
; 266  : 
; 267  : 				disptype = DISP_COMMON;

  00145	6a 02		 push	 2
  00147	5b		 pop	 ebx

; 268  : 
; 269  : 				break;

  00148	e9 e8 00 00 00	 jmp	 $LN345@depacker_h
$LN73@depacker_h:

; 253  : 
; 254  : 
; 255  : 
; 256  : 			case 2: // %010 - 3 bytes or something
; 257  : 
; 258  : 				length = 3;

  0014d	6a 03		 push	 3
  0014f	5f		 pop	 edi

; 259  : 				skiplen = 1;
; 260  : 				disptype = DISP_COMMON;

  00150	6a 02		 push	 2
  00152	5b		 pop	 ebx

; 261  : 
; 262  : 				break;

  00153	e9 f1 01 00 00	 jmp	 $LN346@depacker_h
$LN87@depacker_h:

; 171  : 
; 172  : 				break;
; 173  : 
; 174  : 
; 175  : 
; 176  : 
; 177  : 
; 178  : 
; 179  : 			case 1: // %001 - 2 bytes or insertion match part 1
; 180  : 
; 181  : 				length = 2;

  00158	6a 02		 push	 2
  0015a	58		 pop	 eax

; 182  : 				skiplen = 1;

  0015b	33 ed		 xor	 ebp, ebp

; 183  : 
; 184  : 				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0015d	50		 push	 eax
  0015e	8b f8		 mov	 edi, eax
  00160	45		 inc	 ebp
  00161	e8 00 00 00 00	 call	 _depack_getbits
  00166	59		 pop	 ecx

; 185  : #ifdef DPK_CHECK
; 186  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00167	83 f8 ff	 cmp	 eax, -1
  0016a	0f 84 57 03 00
	00		 je	 $NO_BITS_HST$4213

; 187  : #endif
; 188  : 
; 189  : 				switch( bits&3 )

  00170	83 e0 03	 and	 eax, 3
  00173	83 e8 00	 sub	 eax, 0
  00176	0f 84 85 00 00
	00		 je	 $LN83@depacker_h
  0017c	48		 dec	 eax
  0017d	74 78		 je	 SHORT $LN82@depacker_h
  0017f	48		 dec	 eax
  00180	74 0f		 je	 SHORT $LN81@depacker_h
  00182	48		 dec	 eax
  00183	0f 85 a4 00 00
	00		 jne	 $LN90@depacker_h

; 244  : 
; 245  : 				case 3: // %001 11 - disp FFE0+[abcde]
; 246  : 
; 247  : 					disptype = DISP_ABCDE;

  00189	33 db		 xor	 ebx, ebx
  0018b	43		 inc	 ebx

; 248  : 
; 249  : 					break;

  0018c	e9 b8 01 00 00	 jmp	 $LN346@depacker_h
$LN81@depacker_h:

; 202  : 
; 203  : 				case 2: // %001 10 - ff00..ffdf or insertion match
; 204  : 
; 205  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00191	6a 01		 push	 1
  00193	e8 00 00 00 00	 call	 _depack_getbyte
  00198	59		 pop	 ecx

; 206  : #ifdef DPK_CHECK
; 207  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00199	83 f8 ff	 cmp	 eax, -1
  0019c	0f 84 96 03 00
	00		 je	 $NO_BYTE_HST$4203

; 208  : #endif
; 209  : 					skipdisp = 1;
; 210  : 
; 211  : 					if( byte<0x00E0 ) // ff00..ffdf

  001a2	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  001a7	73 0c		 jae	 SHORT $LN79@depacker_h
$LN363@depacker_h:

; 212  : 					{
; 213  : 						disp = (-256) | (byte&0x00FF);

  001a9	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
$LN362@depacker_h:
  001ae	8b f0		 mov	 esi, eax
  001b0	e9 6f 02 00 00	 jmp	 $LN357@depacker_h
$LN79@depacker_h:

; 214  : 					}
; 215  : 					else if( byte==0x00FE ) // expand bitlen of expandable displacement

  001b5	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  001ba	75 1b		 jne	 SHORT $LN77@depacker_h

; 216  : 					{
; 217  : 						#ifdef DBG
; 218  : 							printf("expansion\n");
; 219  : 						#endif
; 220  : 
; 221  : 						length = 0; // nothing to do

  001bc	33 ff		 xor	 edi, edi

; 222  : 						expbitlen++;

  001be	ff 44 24 14	 inc	 DWORD PTR _expbitlen$[esp+28]

; 223  : #ifdef DPK_CHECK
; 224  : 						if( expbitlen>8 )

  001c2	83 7c 24 14 08	 cmp	 DWORD PTR _expbitlen$[esp+28], 8
  001c7	0f 86 57 02 00
	00		 jbe	 $LN357@depacker_h

; 225  : 						{
; 226  :  #ifdef DPK_REPERR
; 227  : 							printf("mhmt-depack-hrust.c:{} - bitlen of expandable displacement expanded more than 16 bits!\n");

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@MECGFIAE@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5bitlen?5@

; 228  :  #endif
; 229  : 							return 0;

  001d2	e9 66 fe ff ff	 jmp	 $LN366@depacker_h
$LN77@depacker_h:

; 230  : 						}
; 231  : #endif
; 232  : 					}
; 233  : 					else // insertion match - xor 2
; 234  : 					{
; 235  : 						length = (-3); // mark insertion match
; 236  : 
; 237  : 						byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
; 238  : 						byte ^= 0x02;
; 239  : 						byte -= 15;
; 240  : 
; 241  : 						disp = (-256) | (byte&0x00FF);

  001d7	8b f0		 mov	 esi, eax
  001d9	c1 ee 07	 shr	 esi, 7
  001dc	83 e6 01	 and	 esi, 1
  001df	03 c0		 add	 eax, eax
  001e1	0b f0		 or	 esi, eax
  001e3	83 f6 02	 xor	 esi, 2
$LN370@depacker_h:
  001e6	6a fd		 push	 -3			; fffffffdH
  001e8	83 ee 0f	 sub	 esi, 15			; 0000000fH
  001eb	5f		 pop	 edi
  001ec	81 ce 00 ff ff
	ff		 or	 esi, -256		; ffffff00H

; 242  : 					}
; 243  : 					break;

  001f2	e9 2d 02 00 00	 jmp	 $LN357@depacker_h
$LN82@depacker_h:

; 194  : 
; 195  : 					break;
; 196  : 
; 197  : 				case 1: // %001 01 - disp FExx
; 198  : 					//disptype = DISP_PLUSBYTE; // default value
; 199  : 					disp = (-512);

  001f7	be 00 fe ff ff	 mov	 esi, -512		; fffffe00H

; 200  : 
; 201  : 					break;

  001fc	e9 48 01 00 00	 jmp	 $LN346@depacker_h
$LN83@depacker_h:

; 190  : 				{
; 191  : 				case 0: // %001 00 - disp FDxx
; 192  : 					//disptype = DISP_PLUSBYTE; // default value
; 193  : 					disp = (-768);

  00201	be 00 fd ff ff	 mov	 esi, -768		; fffffd00H

; 250  : 				}
; 251  : 
; 252  : 				break;

  00206	e9 3e 01 00 00	 jmp	 $LN346@depacker_h
$LN89@depacker_h:

; 158  : 			{
; 159  : 			case 0: // %000xxx
; 160  : 
; 161  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  0020b	6a 02		 push	 2
  0020d	6a 03		 push	 3
  0020f	58		 pop	 eax
  00210	e8 00 00 00 00	 call	 _depack_getbits
  00215	59		 pop	 ecx

; 162  : #ifdef DPK_CHECK
; 163  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00216	83 f8 ff	 cmp	 eax, -1
  00219	0f 84 a8 02 00
	00		 je	 $NO_BITS_HST$4213

; 164  : #endif
; 165  : 
; 166  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0021f	83 c8 f8	 or	 eax, -8			; fffffff8H

; 167  : 				length = 1;

  00222	33 ff		 xor	 edi, edi
  00224	47		 inc	 edi
  00225	8b f0		 mov	 esi, eax

; 168  : 
; 169  : 				skiplen  = 1;

  00227	8b ef		 mov	 ebp, edi

; 170  : 				skipdisp = 1;

  00229	89 7c 24 18	 mov	 DWORD PTR _skipdisp$[esp+28], edi
$LN90@depacker_h:

; 270  : 			}
; 271  : 		}
; 272  : 
; 273  : 			if( (!stop) && (!skiplen) && (!docopy) )

  0022d	85 ed		 test	 ebp, ebp
  0022f	0f 85 09 01 00
	00		 jne	 $LN356@depacker_h
$LN345@depacker_h:

; 274  : 			{
; 275  : 				// read variable length
; 276  : 				bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00235	6a 02		 push	 2
  00237	5d		 pop	 ebp
  00238	55		 push	 ebp
  00239	8b c5		 mov	 eax, ebp
  0023b	e8 00 00 00 00	 call	 _depack_getbits
  00240	59		 pop	 ecx

; 277  : #ifdef DPK_CHECK
; 278  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00241	83 f8 ff	 cmp	 eax, -1
  00244	0f 84 7d 02 00
	00		 je	 $NO_BITS_HST$4213

; 279  : #endif                                                                                 
; 280  : 				switch( bits&3 )

  0024a	83 e0 03	 and	 eax, 3
  0024d	83 e8 00	 sub	 eax, 0
  00250	74 46		 je	 SHORT $LN67@depacker_h
  00252	48		 dec	 eax
  00253	74 3f		 je	 SHORT $LN52@depacker_h
  00255	48		 dec	 eax
  00256	74 34		 je	 SHORT $LN51@depacker_h
  00258	48		 dec	 eax
  00259	0f 85 df 00 00
	00		 jne	 $LN356@depacker_h

; 348  : 				case 3: // variable length (6-15), %01111...
; 349  : 
; 350  : 					length = 6;

  0025f	6a 06		 push	 6
  00261	5f		 pop	 edi
$LL49@depacker_h:

; 351  : 					do
; 352  : 					{
; 353  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00262	55		 push	 ebp
  00263	8b c5		 mov	 eax, ebp
  00265	e8 00 00 00 00	 call	 _depack_getbits
  0026a	59		 pop	 ecx

; 354  : #ifdef DPK_CHECK
; 355  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  0026b	83 f8 ff	 cmp	 eax, -1
  0026e	0f 84 53 02 00
	00		 je	 $NO_BITS_HST$4213

; 356  : #endif                                                                                  
; 357  : 						bits &= 3;

  00274	83 e0 03	 and	 eax, 3

; 358  : 						length += bits;

  00277	03 f8		 add	 edi, eax

; 359  : 
; 360  : 					} while( (bits==3) && (length<15) );

  00279	83 f8 03	 cmp	 eax, 3
  0027c	0f 85 bc 00 00
	00		 jne	 $LN356@depacker_h
  00282	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00285	7c db		 jl	 SHORT $LL49@depacker_h

; 361  : 					break;

  00287	e9 b2 00 00 00	 jmp	 $LN356@depacker_h
$LN51@depacker_h:

; 345  : 				case 2: // %01110
; 346  : 					length = 5;

  0028c	6a 05		 push	 5
$LN360@depacker_h:
  0028e	5f		 pop	 edi

; 347  : 					break;

  0028f	e9 aa 00 00 00	 jmp	 $LN356@depacker_h
$LN52@depacker_h:

; 338  : 							}
; 339  : 						}
; 340  : 					}
; 341  : 					break;
; 342  : 				case 1: // %01101
; 343  : 					length = 4;

  00294	6a 04		 push	 4

; 344  : 					break;

  00296	eb f6		 jmp	 SHORT $LN360@depacker_h
$LN67@depacker_h:

; 281  : 				{
; 282  : 				case 0: // special cases
; 283  : 
; 284  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00298	33 c0		 xor	 eax, eax
  0029a	55		 push	 ebp
  0029b	40		 inc	 eax
  0029c	e8 00 00 00 00	 call	 _depack_getbits

; 285  : #ifdef DPK_CHECK
; 286  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  002a1	83 cf ff	 or	 edi, -1
  002a4	59		 pop	 ecx
  002a5	3b c7		 cmp	 eax, edi
  002a7	0f 84 1a 02 00
	00		 je	 $NO_BITS_HST$4213

; 287  : #endif
; 288  : 					if( bits&1 ) // %011 001abcd<byte> - insertion match, displacements -1..-16
; 289  : 					{
; 290  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  002ad	55		 push	 ebp
  002ae	a8 01		 test	 al, 1
  002b0	74 1c		 je	 SHORT $LN65@depacker_h
  002b2	6a 04		 push	 4
  002b4	58		 pop	 eax
  002b5	e8 00 00 00 00	 call	 _depack_getbits
  002ba	59		 pop	 ecx

; 291  : #ifdef DPK_CHECK
; 292  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  002bb	3b c7		 cmp	 eax, edi
  002bd	0f 84 04 02 00
	00		 je	 $NO_BITS_HST$4213

; 293  : #endif
; 294  : 						length = (-3); // mark insertion match

  002c3	6a fd		 push	 -3			; fffffffdH
  002c5	5f		 pop	 edi

; 295  : 
; 296  : 						skipdisp = 1; // prepare displacement
; 297  : 						disp = (-16) | (bits&15);

  002c6	83 c8 f0	 or	 eax, -16		; fffffff0H

; 298  : 					}
; 299  : 					else

  002c9	e9 e0 fe ff ff	 jmp	 $LN362@depacker_h
$LN65@depacker_h:

; 300  : 					{
; 301  : 						bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  002ce	33 c0		 xor	 eax, eax
  002d0	40		 inc	 eax
  002d1	e8 00 00 00 00	 call	 _depack_getbits
  002d6	59		 pop	 ecx

; 302  : #ifdef DPK_CHECK
; 303  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  002d7	3b c7		 cmp	 eax, edi
  002d9	0f 84 e8 01 00
	00		 je	 $NO_BITS_HST$4213

; 304  : #endif
; 305  : 						if( bits&1 ) // %011 0001abcd - copy-many-bytes
; 306  : 						{
; 307  : 							bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  002df	55		 push	 ebp
  002e0	a8 01		 test	 al, 1
  002e2	74 1d		 je	 SHORT $LN61@depacker_h
  002e4	6a 04		 push	 4
  002e6	58		 pop	 eax
  002e7	e8 00 00 00 00	 call	 _depack_getbits
  002ec	59		 pop	 ecx

; 308  : #ifdef DPK_CHECK
; 309  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  002ed	3b c7		 cmp	 eax, edi
  002ef	0f 84 d2 01 00
	00		 je	 $NO_BITS_HST$4213

; 310  : #endif
; 311  : 							length = ((bits&15)+6)<<1;

  002f5	83 e0 0f	 and	 eax, 15			; 0000000fH
  002f8	8d 7c 00 0c	 lea	 edi, DWORD PTR [eax+eax+12]

; 312  : 							skipdisp = 1;
; 313  : 							docopy = 1;
; 314  : 						}
; 315  : 						else // %011 0000abcdefg[<byte>] - longer lengthes

  002fc	e9 db fd ff ff	 jmp	 $LN344@depacker_h
$LN61@depacker_h:

; 316  : 						{
; 317  : 							bits = depack_getbits(7,DEPACK_GETBITS_NEXT);

  00301	6a 07		 push	 7
  00303	58		 pop	 eax
  00304	e8 00 00 00 00	 call	 _depack_getbits
  00309	8b f8		 mov	 edi, eax
  0030b	59		 pop	 ecx

; 318  : #ifdef DPK_CHECK
; 319  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  0030c	83 ff ff	 cmp	 edi, -1
  0030f	0f 84 b2 01 00
	00		 je	 $NO_BITS_HST$4213

; 320  : #endif
; 321  : 							bits &= 127;

  00315	83 e7 7f	 and	 edi, 127		; 0000007fH

; 322  : 
; 323  : 							if( bits==15 ) // stop depack

  00318	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0031b	0f 84 c4 01 00
	00		 je	 $LN96@depacker_h

; 324  : 							{
; 325  : 								stop=1;
; 326  : 							}
; 327  : 							else if( bits>15 ) // 16..127
; 328  : 							{
; 329  : 								length = bits;
; 330  : 							}
; 331  : 							else // 0..14: longer lengthes

  00321	77 1b		 ja	 SHORT $LN356@depacker_h

; 332  : 							{
; 333  : 								byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00323	6a 01		 push	 1
  00325	e8 00 00 00 00	 call	 _depack_getbyte
  0032a	59		 pop	 ecx

; 334  : #ifdef DPK_CHECK
; 335  : 								if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  0032b	83 f8 ff	 cmp	 eax, -1
  0032e	0f 84 04 02 00
	00		 je	 $NO_BYTE_HST$4203

; 336  : #endif
; 337  : 								length = (bits<<8) + (byte&0x00FF);

  00334	c1 e7 08	 shl	 edi, 8
  00337	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0033c	03 f8		 add	 edi, eax
$LN356@depacker_h:

; 362  : 				}
; 363  : 			}
; 364  : 
; 365  : 			if( (!stop) && (!skipdisp) && (!docopy) )

  0033e	83 7c 24 18 00	 cmp	 DWORD PTR _skipdisp$[esp+28], 0
  00343	0f 85 db 00 00
	00		 jne	 $LN357@depacker_h
$LN346@depacker_h:

; 366  : 			{
; 367  : 				// extract displacement
; 368  : 
; 369  : 				switch( disptype )

  00349	8b c3		 mov	 eax, ebx
  0034b	83 e8 00	 sub	 eax, 0
  0034e	74 31		 je	 SHORT $LN33@depacker_h
  00350	48		 dec	 eax
  00351	0f 84 b7 00 00
	00		 je	 $LN25@depacker_h
  00357	48		 dec	 eax
  00358	0f 85 5f 01 00
	00		 jne	 $LN23@depacker_h

; 370  : 				{
; 371  : 				case DISP_COMMON:
; 372  : 
; 373  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0035e	6a 02		 push	 2
  00360	5e		 pop	 esi
  00361	56		 push	 esi
  00362	8b c6		 mov	 eax, esi
  00364	e8 00 00 00 00	 call	 _depack_getbits

; 374  : #ifdef DPK_CHECK
; 375  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00369	83 cd ff	 or	 ebp, -1
  0036c	59		 pop	 ecx
  0036d	3b c5		 cmp	 eax, ebp
  0036f	0f 84 52 01 00
	00		 je	 $NO_BITS_HST$4213

; 376  : #endif                                                                                  
; 377  : 					bits &= 3;

  00375	83 e0 03	 and	 eax, 3

; 378  : 					if( !bits ) // %00<byte> - fe00..feff

  00378	75 40		 jne	 SHORT $LN39@depacker_h

; 379  : 					{
; 380  : 						disp = (-512);

  0037a	be 00 fe ff ff	 mov	 esi, -512		; fffffe00H
$LN361@depacker_h:

; 381  : 						disptype=DISP_PLUSBYTE; // we fall in next section and there is check

  0037f	33 db		 xor	 ebx, ebx
$LN33@depacker_h:

; 412  : 						// NO break!
; 413  : 					}
; 414  : 
; 415  : 				case DISP_PLUSBYTE:
; 416  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00381	6a 01		 push	 1
  00383	e8 00 00 00 00	 call	 _depack_getbyte
  00388	59		 pop	 ecx

; 417  : #ifdef DPK_CHECK
; 418  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00389	83 f8 ff	 cmp	 eax, -1
  0038c	0f 84 a6 01 00
	00		 je	 $NO_BYTE_HST$4203

; 419  : #endif
; 420  : 					if( disptype==DISP_COMMON ) // if we here from previous section of switch()

  00392	83 fb 02	 cmp	 ebx, 2
  00395	0f 85 82 00 00
	00		 jne	 $LN29@depacker_h

; 421  : 					{                           // we must check for insertion match!
; 422  : 
; 423  : 						if( byte<0x00E0 ) // ff00..ffdf

  0039b	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H

; 424  : 						{
; 425  : 							disp = (-256) | (byte&0x00FF);
; 426  : 						}
; 427  : 						else // insertion match - xor 3

  003a0	0f 82 03 fe ff
	ff		 jb	 $LN363@depacker_h

; 428  : 						{
; 429  : 							length = (-3); // mark insertion match
; 430  : 
; 431  : 							byte = ((byte<<1)&0x00FE) | ((byte>>7)&0x01); // byte<<<1
; 432  : 							byte ^= 0x03;
; 433  : 							byte -= 15;
; 434  : 
; 435  : 							disp = (-256) | (byte&0x00FF);

  003a6	8b f0		 mov	 esi, eax
  003a8	c1 ee 07	 shr	 esi, 7
  003ab	83 e6 01	 and	 esi, 1
  003ae	03 c0		 add	 eax, eax
  003b0	0b f0		 or	 esi, eax
  003b2	83 f6 03	 xor	 esi, 3

; 436  : 						}
; 437  : 					}
; 438  : 					else

  003b5	e9 2c fe ff ff	 jmp	 $LN370@depacker_h
$LN39@depacker_h:

; 382  : 						// NO break!
; 383  : 					}
; 384  : 					else if( bits==1 ) // %01<byte> - ff00..ffdf

  003ba	83 f8 01	 cmp	 eax, 1
  003bd	75 07		 jne	 SHORT $LN37@depacker_h

; 385  : 					{
; 386  : 						disp = (-256);

  003bf	be 00 ff ff ff	 mov	 esi, -256		; ffffff00H
  003c4	eb bb		 jmp	 SHORT $LN33@depacker_h
$LN37@depacker_h:

; 387  : 						// NO break!
; 388  : 						// no check for byte in range e0..ff here - but in next switch section!
; 389  : 					}
; 390  : 					else if( bits==2 ) // %10abcde - ffe0..ffff
; 391  : 					{
; 392  : 						bits = depack_getbits(5,DEPACK_GETBITS_NEXT);

  003c6	56		 push	 esi
  003c7	3b c6		 cmp	 eax, esi
  003c9	75 19		 jne	 SHORT $LN35@depacker_h
  003cb	6a 05		 push	 5
  003cd	58		 pop	 eax
  003ce	e8 00 00 00 00	 call	 _depack_getbits

; 393  : #ifdef DPK_CHECK
; 394  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  003d3	3b c5		 cmp	 eax, ebp
$LN369@depacker_h:

; 387  : 						// NO break!
; 388  : 						// no check for byte in range e0..ff here - but in next switch section!
; 389  : 					}
; 390  : 					else if( bits==2 ) // %10abcde - ffe0..ffff
; 391  : 					{
; 392  : 						bits = depack_getbits(5,DEPACK_GETBITS_NEXT);

  003d5	59		 pop	 ecx

; 393  : #ifdef DPK_CHECK
; 394  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  003d6	0f 84 eb 00 00
	00		 je	 $NO_BITS_HST$4213

; 395  : #endif                                                                                  
; 396  : 						disp = (-32) | (bits&31);

  003dc	83 c8 e0	 or	 eax, -32		; ffffffe0H

; 397  : 
; 398  : 						break;

  003df	e9 ca fd ff ff	 jmp	 $LN362@depacker_h
$LN35@depacker_h:

; 399  : 					}
; 400  : 					else // %11... - expanding displacement
; 401  : 					{
; 402  : 						bits = depack_getbits(expbitlen,DEPACK_GETBITS_NEXT);

  003e4	8b 44 24 18	 mov	 eax, DWORD PTR _expbitlen$[esp+32]
  003e8	e8 00 00 00 00	 call	 _depack_getbits
  003ed	59		 pop	 ecx

; 403  : #ifdef DPK_CHECK
; 404  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  003ee	3b c5		 cmp	 eax, ebp
  003f0	0f 84 d1 00 00
	00		 je	 $NO_BITS_HST$4213

; 405  : #endif                                                                                  
; 406  : 						disp = (-1)<<expbitlen;

  003f6	8b 4c 24 14	 mov	 ecx, DWORD PTR _expbitlen$[esp+28]
  003fa	8b d5		 mov	 edx, ebp
  003fc	d3 e2		 shl	 edx, cl

; 407  : 						disp |= (bits&(~disp));

  003fe	8b f2		 mov	 esi, edx
  00400	f7 d6		 not	 esi

; 408  : 
; 409  : 						disp <<= 8;

  00402	23 f0		 and	 esi, eax
  00404	0b f2		 or	 esi, edx
  00406	c1 e6 08	 shl	 esi, 8

; 410  : 
; 411  : 						disptype = DISP_PLUSBYTE;

  00409	e9 71 ff ff ff	 jmp	 $LN361@depacker_h
$LN25@depacker_h:

; 441  : 					}
; 442  : 
; 443  : 					break;
; 444  : 
; 445  : 				case DISP_ABCDE:
; 446  : 					bits = depack_getbits(5,DEPACK_GETBITS_NEXT);

  0040e	6a 02		 push	 2
  00410	6a 05		 push	 5
  00412	58		 pop	 eax
  00413	e8 00 00 00 00	 call	 _depack_getbits

; 447  : #ifdef DPK_CHECK
; 448  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HST;

  00418	83 f8 ff	 cmp	 eax, -1

; 449  : #endif
; 450  : 					disp = (-32) | (bits&31);
; 451  : 
; 452  : 					break;

  0041b	eb b8		 jmp	 SHORT $LN369@depacker_h
$LN29@depacker_h:

; 439  : 					{
; 440  :  						disp = disp + (byte&0x00FF);

  0041d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00422	03 f0		 add	 esi, eax
$LN357@depacker_h:

; 460  : #endif
; 461  : 					break;
; 462  : 				}
; 463  : 			}
; 464  : 
; 465  : 
; 466  : #ifdef DPK_CHECK
; 467  : 			if( success && (!docopy) && (!stop) && ((ULONG)(-disp)>wrk.maxwin) )

  00424	8b c6		 mov	 eax, esi
  00426	f7 d8		 neg	 eax
  00428	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _wrk+28
  0042e	0f 87 9d 00 00
	00		 ja	 $LN325@depacker_h

; 497  : 			{
; 498  : 				if( length!=(-3) )

  00434	83 ff fd	 cmp	 edi, -3			; fffffffdH
  00437	74 34		 je	 SHORT $LN14@depacker_h

; 499  : 				{
; 500  : 					#ifdef DBG
; 501  : 						printf("match.len=%d,disp=%d\n",length,disp);
; 502  : 					#endif
; 503  : 
; 504  : #ifdef DPK_DEPACK
; 505  : 					if( length )

  00439	85 ff		 test	 edi, edi
  0043b	0f 84 6d fc ff
	ff		 je	 $LL97@depacker_h

; 506  : 						success = success && depack_repeat(disp,length);

  00441	57		 push	 edi
  00442	8b ce		 mov	 ecx, esi
  00444	e8 00 00 00 00	 call	 _depack_repeat
  00449	59		 pop	 ecx
  0044a	33 c9		 xor	 ecx, ecx
  0044c	85 c0		 test	 eax, eax
  0044e	0f 95 c1	 setne	 cl
  00451	89 4c 24 10	 mov	 DWORD PTR _success$[esp+28], ecx

; 507  : #endif
; 508  : 				}
; 509  : 				else // (-3)

  00455	e9 54 fc ff ff	 jmp	 $LL97@depacker_h
$LN359@depacker_h:

; 488  : #endif
; 489  : 
; 490  : 
; 491  : #ifdef DPK_DEPACK
; 492  : 					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0045a	83 64 24 10 00	 and	 DWORD PTR _success$[esp+28], 0
$LN115@depacker_h:

; 474  : 			}
; 475  : #endif
; 476  : 
; 477  : 
; 478  : 			if( docopy && (!stop) )
; 479  : 			{
; 480  : 				#ifdef DBG
; 481  : 					printf("copy.len=%d\n",length);
; 482  : 				#endif
; 483  : 				for(i=0;i<length;i++)

  0045f	45		 inc	 ebp
  00460	3b ef		 cmp	 ebp, edi
  00462	0f 8c 7d fc ff
	ff		 jl	 $LL20@depacker_h

; 493  : #endif
; 494  : 				}
; 495  : 			}
; 496  : 			else if( (!docopy) && (!stop) )// not do-copy

  00468	e9 41 fc ff ff	 jmp	 $LL97@depacker_h
$LN14@depacker_h:

; 510  : 				{
; 511  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0046d	33 ed		 xor	 ebp, ebp
  0046f	45		 inc	 ebp
  00470	55		 push	 ebp
  00471	e8 00 00 00 00	 call	 _depack_getbyte
  00476	8b d8		 mov	 ebx, eax
  00478	59		 pop	 ecx

; 512  : #ifdef DPK_CHECK
; 513  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE_HST;

  00479	83 fb ff	 cmp	 ebx, -1
  0047c	0f 84 b6 00 00
	00		 je	 $NO_BYTE_HST$4203

; 514  : #endif
; 515  : 					#ifdef DBG
; 516  : 						printf("insert-match.len=%d,disp=%d\n",(-length),disp);
; 517  : 					#endif
; 518  : 
; 519  : 
; 520  : #ifdef DPK_DEPACK
; 521  : 					success = success && depack_repeat(disp,1);

  00482	55		 push	 ebp
  00483	8b ce		 mov	 ecx, esi
  00485	e8 00 00 00 00	 call	 _depack_repeat
  0048a	59		 pop	 ecx
  0048b	85 c0		 test	 eax, eax
  0048d	74 24		 je	 SHORT $LN122@depacker_h

; 522  : 					success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0048f	6a 02		 push	 2
  00491	8a c3		 mov	 al, bl
  00493	e8 00 00 00 00	 call	 _depack_outbyte
  00498	59		 pop	 ecx
  00499	85 c0		 test	 eax, eax

; 523  : 					success = success && depack_repeat(disp,1);

  0049b	74 16		 je	 SHORT $LN122@depacker_h
  0049d	55		 push	 ebp
  0049e	8b ce		 mov	 ecx, esi
  004a0	e8 00 00 00 00	 call	 _depack_repeat
  004a5	59		 pop	 ecx
  004a6	85 c0		 test	 eax, eax
  004a8	74 09		 je	 SHORT $LN122@depacker_h
  004aa	89 6c 24 10	 mov	 DWORD PTR _success$[esp+28], ebp
  004ae	e9 fb fb ff ff	 jmp	 $LL97@depacker_h
$LN122@depacker_h:
  004b3	83 64 24 10 00	 and	 DWORD PTR _success$[esp+28], 0

; 126  : #endif
; 127  : 
; 128  : 
; 129  : 
; 130  : 	// now normal depacking loop
; 131  : 	//
; 132  :   	stop = 0;
; 133  : 	while( (!stop) && success )

  004b8	e9 f1 fb ff ff	 jmp	 $LL97@depacker_h
$LN23@depacker_h:

; 453  : 
; 454  : 				default:
; 455  : #ifdef DPK_CHECK
; 456  :  #ifdef DPK_REPERR
; 457  : 					printf("mhmt-depack-hrust.c:{} - Wrong displacement in disptype!\n");

  004bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HIAMKLID@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5d@

; 458  :  #endif
; 459  : 					return 0;

  004c2	e9 76 fb ff ff	 jmp	 $LN366@depacker_h
$NO_BITS_HST$4213:

; 99   : 	{
; 100  : NO_BITS_HST:
; 101  :  #ifdef DPK_REPERR
; 102  : 		printf("mhmt-depack-hrust.c:{} - Can't get bits from input stream!\n");

  004c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@JPGKIGCA@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@

; 103  :  #endif
; 104  : 		return 0;

  004cc	e9 6c fb ff ff	 jmp	 $LN366@depacker_h
$LN325@depacker_h:

; 468  : 			{
; 469  : WRONG_DISP_HST:
; 470  :  #ifdef DPK_REPERR
; 471  : 				printf("mhmt-depack-hrust.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );

  004d1	f7 de		 neg	 esi
  004d3	56		 push	 esi
  004d4	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@CEPOHOBK@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Wrong?5l@
$WRONG_DISP_HST$4306:
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004df	59		 pop	 ecx

; 472  :  #endif
; 473  : 				return 0;

  004e0	e9 5e fb ff ff	 jmp	 $LN367@depacker_h
$LN96@depacker_h:

; 524  : #endif
; 525  : 				}
; 526  : 
; 527  : 			}
; 528  : 	}
; 529  : 
; 530  : 	//manage zxheader again (copy to the end of output)
; 531  : #ifdef DPK_DEPACK
; 532  : 	if( wrk.zxheader )

  004e5	33 db		 xor	 ebx, ebx
  004e7	39 1d 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, ebx
  004ed	74 3d		 je	 SHORT $LN358@depacker_h

; 533  : 	{
; 534  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  004ef	6a 06		 push	 6
  004f1	33 ff		 xor	 edi, edi
  004f3	89 1d 00 00 00
	00		 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, ebx
  004f9	5e		 pop	 esi
  004fa	47		 inc	 edi
$LL8@depacker_h:

; 535  :  #ifdef DPK_CHECK
; 536  : 		if( 0xFFFFFFFF == check )
; 537  : 		{
; 538  :   #ifdef DPK_REPERR
; 539  : 			printf("mhmt-depack-hrust.c:{} - Can't rewind input stream!\n");
; 540  :   #endif
; 541  : 			return 0;
; 542  : 		}
; 543  :  #endif
; 544  : 
; 545  : 		for(i=0;i<6;i++) // skip bytes
; 546  : 		{
; 547  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  004fb	57		 push	 edi
  004fc	e8 00 00 00 00	 call	 _depack_getbyte
  00501	4e		 dec	 esi
  00502	59		 pop	 ecx
  00503	75 f6		 jne	 SHORT $LL8@depacker_h

; 548  :  #ifdef DPK_CHECK
; 549  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
; 550  :  #endif
; 551  : 		}
; 552  : 		// place 6 bytes of header to the end
; 553  : 		for(i=0;i<6;i++)

  00505	6a 06		 push	 6
  00507	5e		 pop	 esi
$LL4@depacker_h:

; 554  : 		{
; 555  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00508	57		 push	 edi
  00509	e8 00 00 00 00	 call	 _depack_getbyte
  0050e	59		 pop	 ecx

; 556  :  #ifdef DPK_CHECK
; 557  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
; 558  :  #endif
; 559  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0050f	39 5c 24 10	 cmp	 DWORD PTR _success$[esp+28], ebx
  00513	74 10		 je	 SHORT $LN124@depacker_h
  00515	6a 02		 push	 2
  00517	e8 00 00 00 00	 call	 _depack_outbyte
  0051c	59		 pop	 ecx
  0051d	89 7c 24 10	 mov	 DWORD PTR _success$[esp+28], edi
  00521	85 c0		 test	 eax, eax
  00523	75 04		 jne	 SHORT $LN125@depacker_h
$LN124@depacker_h:
  00525	89 5c 24 10	 mov	 DWORD PTR _success$[esp+28], ebx
$LN125@depacker_h:

; 548  :  #ifdef DPK_CHECK
; 549  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HST;
; 550  :  #endif
; 551  : 		}
; 552  : 		// place 6 bytes of header to the end
; 553  : 		for(i=0;i<6;i++)

  00529	4e		 dec	 esi
  0052a	75 dc		 jne	 SHORT $LL4@depacker_h
$LN358@depacker_h:

; 560  : 		}
; 561  : 	}
; 562  : #endif
; 563  : 
; 564  : 	return success;

  0052c	8b 44 24 10	 mov	 eax, DWORD PTR _success$[esp+28]
$LN110@depacker_h:
  00530	5f		 pop	 edi
  00531	5e		 pop	 esi
  00532	5d		 pop	 ebp
  00533	5b		 pop	 ebx

; 565  : }

  00534	83 c4 0c	 add	 esp, 12			; 0000000cH
  00537	c3		 ret	 0
$NO_BYTE_HST$4203:

; 115  : 	{
; 116  : NO_BYTE_HST:
; 117  :  #ifdef DPK_REPERR
; 118  : 		printf("mhmt-depack-hrust.c:{} - Can't get byte from input stream!\n");

  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DLAHOJNM@mhmt?9depack?9hrust?4c?3?$HL?$HN?5?9?5Can?8t?5g@

; 119  :  #endif
; 120  : 		return 0;

  0053d	e9 fb fa ff ff	 jmp	 $LN366@depacker_h
_depacker_hrust ENDP
_TEXT	ENDS
PUBLIC	_depacker_hrum
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack-hrum.c
;	COMDAT _depacker_hrum
_TEXT	SEGMENT
_depacker_hrum PROC					; COMDAT

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 	LONG  disp;
; 14   : 	ULONG length;
; 15   : 
; 16   : 	ULONG stop;
; 17   : 
; 18   : 
; 19   : 	ULONG success = 1;
; 20   : 
; 21   : 
; 22   : 	// rewind input stream
; 23   : 	//
; 24   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??depack_getbyte@@9@9, 0
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 25   : #ifdef DPK_CHECK
; 26   : 	if( 0xFFFFFFFF == check )
; 27   : 	{
; 28   :  #ifdef DPK_REPERR
; 29   : 		printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 30   :  #endif
; 31   : 		return 0;
; 32   : 	}
; 33   : #endif
; 34   : 
; 35   : 
; 36   : 	// manage zx header if needed
; 37   : 	if( wrk.zxheader )

  0000b	33 db		 xor	 ebx, ebx
  0000d	43		 inc	 ebx
  0000e	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  00015	6a 02		 push	 2
  00017	5d		 pop	 ebp
  00018	74 19		 je	 SHORT $LN246@depacker_h@2

; 38   : 	{
; 39   : 		// skip 5 bytes (they will go to the end of output file)
; 40   : 		for(i=0;i<5;i++)

  0001a	6a 05		 push	 5
  0001c	5e		 pop	 esi
$LL49@depacker_h@2:

; 41   : 		{
; 42   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 _depack_getbyte
  00023	4e		 dec	 esi
  00024	59		 pop	 ecx
  00025	75 f6		 jne	 SHORT $LL49@depacker_h@2

; 43   : #ifdef DPK_CHECK
; 44   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
; 45   : #endif
; 46   : 		}
; 47   : 
; 48   : 		// next 2 bytes must be 0x10
; 49   : 		for(i=0;i<2;i++)

  00027	8b f5		 mov	 esi, ebp
$LL46@depacker_h@2:

; 50   : 		{
; 51   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00029	53		 push	 ebx
  0002a	e8 00 00 00 00	 call	 _depack_getbyte
  0002f	4e		 dec	 esi
  00030	59		 pop	 ecx
  00031	75 f6		 jne	 SHORT $LL46@depacker_h@2
$LN246@depacker_h@2:

; 52   : #ifdef DPK_CHECK
; 53   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;
; 54   : 			if( check != 0x0010 )
; 55   : 			{
; 56   :  #ifdef DPK_REPERR
; 57   : 				printf("mhmt-depack-hrum.c:{} - Wrong ZX-header!\n");
; 58   :  #endif
; 59   : 				return 0;
; 60   : 			}
; 61   : #endif
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 
; 66   : 
; 67   : 	// initialize bitstream first
; 68   : 	//
; 69   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  00033	53		 push	 ebx
  00034	6a 10		 push	 16			; 00000010H
  00036	58		 pop	 eax
  00037	e8 00 00 00 00	 call	 _depack_getbits

; 70   : #ifdef DPK_CHECK
; 71   : 	if( 0xFFFFFFFF == check )
; 72   : 	{
; 73   : NO_BITS_HRM:
; 74   :  #ifdef DPK_REPERR
; 75   : 		printf("mhmt-depack-hrum.c:{} - Can't get bits from input stream!\n");
; 76   :  #endif
; 77   : 		return 0;
; 78   : 	}
; 79   : #endif
; 80   : 
; 81   : 
; 82   : 
; 83   : 	// then byte of input stream goes to the output unchanged
; 84   : 	//
; 85   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0003c	53		 push	 ebx
  0003d	e8 00 00 00 00	 call	 _depack_getbyte

; 86   : #ifdef DPK_CHECK
; 87   : 	if( 0xFFFFFFFF == byte )
; 88   : 	{
; 89   : NO_BYTE_HRM:
; 90   :  #ifdef DPK_REPERR
; 91   : 		printf("mhmt-depack-hrum.c:{} - Can't get byte from input stream!\n");
; 92   :  #endif
; 93   : 		return 0;
; 94   : 	}
; 95   : #endif
; 96   : 
; 97   : #ifdef DPK_DEPACK
; 98   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00042	55		 push	 ebp
  00043	e8 00 00 00 00	 call	 _depack_outbyte
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN254@depacker_h@2:
  0004b	8b f0		 mov	 esi, eax
  0004d	f7 de		 neg	 esi
  0004f	1b f6		 sbb	 esi, esi
  00051	f7 de		 neg	 esi
$LL43@depacker_h@2:

; 99   : #endif
; 100  : 
; 101  : 
; 102  : 
; 103  : 	// now normal depacking loop
; 104  : 	//
; 105  : 	stop = 0;
; 106  : 	while( (!stop) && success )

  00053	85 f6		 test	 esi, esi
  00055	74 64		 je	 SHORT $LN247@depacker_h@2

; 107  :  	{
; 108  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00057	55		 push	 ebp
  00058	8b c3		 mov	 eax, ebx
  0005a	e8 00 00 00 00	 call	 _depack_getbits
  0005f	59		 pop	 ecx

; 109  : #ifdef DPK_CHECK
; 110  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 111  : #endif
; 112  : 
; 113  : 		if( 1&bits ) // %1<byte>

  00060	84 c3		 test	 al, bl
  00062	74 11		 je	 SHORT $LN41@depacker_h@2

; 114  : 		{
; 115  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 _depack_getbyte

; 116  : #ifdef DPK_CHECK
; 117  : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 118  : #endif
; 119  : 
; 120  : #ifdef DPK_DEPACK
; 121  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0006a	55		 push	 ebp
  0006b	e8 00 00 00 00	 call	 _depack_outbyte

; 122  : #endif
; 123  : 		}
; 124  : 		else // %0xx

  00070	e9 82 01 00 00	 jmp	 $LN249@depacker_h@2
$LN41@depacker_h@2:

; 125  : 		{
; 126  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00075	55		 push	 ebp
  00076	8b c5		 mov	 eax, ebp
  00078	e8 00 00 00 00	 call	 _depack_getbits
  0007d	59		 pop	 ecx

; 127  : #ifdef DPK_CHECK
; 128  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 129  : #endif
; 130  : 
; 131  : 			switch( 0x03 & bits )

  0007e	6a 03		 push	 3
  00080	5f		 pop	 edi
  00081	23 c7		 and	 eax, edi
  00083	8b c8		 mov	 ecx, eax
  00085	83 e9 00	 sub	 ecx, 0
  00088	0f 84 56 01 00
	00		 je	 $LN37@depacker_h@2
  0008e	49		 dec	 ecx
  0008f	0f 84 41 01 00
	00		 je	 $LN36@depacker_h@2

; 174  : 
; 175  : 			default: // %010 or %011
; 176  : 
; 177  : 				if( (bits&3)==2 ) // %010 - 3 bytes

  00095	3b c5		 cmp	 eax, ebp

; 178  : 				{
; 179  : 					length = 3;
; 180  : 				}
; 181  : 				else // %011 - varlen

  00097	0f 84 d2 00 00
	00		 je	 $LN9@depacker_h@2

; 182  : 				{
; 183  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0009d	55		 push	 ebp
  0009e	8b c5		 mov	 eax, ebp
  000a0	e8 00 00 00 00	 call	 _depack_getbits
  000a5	59		 pop	 ecx

; 184  : #ifdef DPK_CHECK
; 185  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 186  : #endif
; 187  : 					//  fetch len
; 188  : 					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop

  000a6	85 c0		 test	 eax, eax
  000a8	75 4d		 jne	 SHORT $LN32@depacker_h@2

; 189  : 					{
; 190  : 						length = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000aa	53		 push	 ebx
  000ab	e8 00 00 00 00	 call	 _depack_getbyte
  000b0	8b f8		 mov	 edi, eax
  000b2	59		 pop	 ecx

; 191  : #ifdef DPK_CHECK
; 192  : 						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;
; 193  : #endif
; 194  : 						if( length == 0 )

  000b3	85 ff		 test	 edi, edi
  000b5	0f 85 b4 00 00
	00		 jne	 $LN9@depacker_h@2
$LN247@depacker_h@2:

; 306  : #endif
; 307  : 					}
; 308  : 				}
; 309  : 
; 310  : 				break;
; 311  : 			}
; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	//manage zxheader again (copy to the end of output)
; 316  : #ifdef DPK_DEPACK
; 317  : 	if( wrk.zxheader )

  000bb	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _wrk+12, 0
  000c2	0f 84 3f 01 00
	00		 je	 $LN1@depacker_h@2

; 318  : 	{
; 319  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  000c8	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??depack_getbyte@@9@9, 0
  000cf	6a 05		 push	 5
  000d1	5f		 pop	 edi
$LL3@depacker_h@2:

; 332  : 		{
; 333  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000d2	53		 push	 ebx
  000d3	e8 00 00 00 00	 call	 _depack_getbyte
  000d8	59		 pop	 ecx

; 334  :  #ifdef DPK_CHECK
; 335  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
; 336  :  #endif
; 337  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  000d9	85 f6		 test	 esi, esi
  000db	0f 84 1d 01 00
	00		 je	 $LN248@depacker_h@2
  000e1	55		 push	 ebp
  000e2	e8 00 00 00 00	 call	 _depack_outbyte
  000e7	59		 pop	 ecx
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 0e 01 00
	00		 je	 $LN248@depacker_h@2
  000f0	8b f3		 mov	 esi, ebx
  000f2	e9 09 01 00 00	 jmp	 $LN66@depacker_h@2
$LN32@depacker_h@2:

; 195  : 							stop = 1;
; 196  : 					}
; 197  : 					else if( bits == 0x01 ) // %01101 - len=4

  000f7	3b c3		 cmp	 eax, ebx
  000f9	75 05		 jne	 SHORT $LN29@depacker_h@2

; 198  : 					{
; 199  : 						length = 4;

  000fb	6a 04		 push	 4
$LN252@depacker_h@2:
  000fd	5f		 pop	 edi
  000fe	eb 6f		 jmp	 SHORT $LN9@depacker_h@2
$LN29@depacker_h@2:

; 200  : 					}
; 201  : 					else if( bits == 0x02 ) // %01110 - len=5

  00100	3b c5		 cmp	 eax, ebp
  00102	75 04		 jne	 SHORT $LN27@depacker_h@2

; 202  : 					{
; 203  : 						length = 5;

  00104	6a 05		 push	 5

; 204  : 					}
; 205  : 					else // %01111

  00106	eb f5		 jmp	 SHORT $LN252@depacker_h@2
$LN27@depacker_h@2:

; 206  : 					{
; 207  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00108	55		 push	 ebp
  00109	8b c5		 mov	 eax, ebp
  0010b	e8 00 00 00 00	 call	 _depack_getbits
  00110	59		 pop	 ecx

; 208  : #ifdef DPK_CHECK
; 209  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 210  : #endif
; 211  : 						if( bits == 0x00 ) // %0111100

  00111	85 c0		 test	 eax, eax
  00113	75 04		 jne	 SHORT $LN25@depacker_h@2

; 212  : 						{
; 213  : 							length = 6;

  00115	6a 06		 push	 6
  00117	eb e4		 jmp	 SHORT $LN252@depacker_h@2
$LN25@depacker_h@2:

; 214  : 						}
; 215  : 						else if( bits == 0x01 ) // %0111101

  00119	3b c3		 cmp	 eax, ebx
  0011b	75 04		 jne	 SHORT $LN23@depacker_h@2

; 216  : 						{
; 217  : 							length = 7;

  0011d	6a 07		 push	 7
  0011f	eb dc		 jmp	 SHORT $LN252@depacker_h@2
$LN23@depacker_h@2:

; 218  : 						}
; 219  : 						else if( bits == 0x02 ) // %0111110

  00121	3b c5		 cmp	 eax, ebp
  00123	75 04		 jne	 SHORT $LN21@depacker_h@2

; 220  : 						{
; 221  : 							length = 8;

  00125	6a 08		 push	 8

; 222  : 						}
; 223  : 						else // %0111111

  00127	eb d4		 jmp	 SHORT $LN252@depacker_h@2
$LN21@depacker_h@2:

; 224  : 						{
; 225  : 							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00129	55		 push	 ebp
  0012a	8b c5		 mov	 eax, ebp
  0012c	e8 00 00 00 00	 call	 _depack_getbits
  00131	59		 pop	 ecx

; 226  : #ifdef DPK_CHECK
; 227  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 228  : #endif
; 229  : 							if( bits == 0x00 ) // %011111100

  00132	85 c0		 test	 eax, eax
  00134	75 04		 jne	 SHORT $LN19@depacker_h@2

; 230  : 							{
; 231  : 								length = 9;

  00136	6a 09		 push	 9
  00138	eb c3		 jmp	 SHORT $LN252@depacker_h@2
$LN19@depacker_h@2:

; 232  : 							}
; 233  : 							else if( bits == 0x01 ) // %011111101

  0013a	3b c3		 cmp	 eax, ebx
  0013c	75 04		 jne	 SHORT $LN17@depacker_h@2

; 234  : 							{
; 235  : 								length = 10;

  0013e	6a 0a		 push	 10			; 0000000aH
  00140	eb bb		 jmp	 SHORT $LN252@depacker_h@2
$LN17@depacker_h@2:

; 236  : 							}
; 237  : 							else if( bits == 0x02 ) // %011111110

  00142	3b c5		 cmp	 eax, ebp
  00144	75 04		 jne	 SHORT $LN15@depacker_h@2

; 238  : 							{
; 239  : 								length = 11;

  00146	6a 0b		 push	 11			; 0000000bH

; 240  : 							}
; 241  : 							else // %011111111

  00148	eb b3		 jmp	 SHORT $LN252@depacker_h@2
$LN15@depacker_h@2:

; 242  : 							{
; 243  : 								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0014a	55		 push	 ebp
  0014b	8b c5		 mov	 eax, ebp
  0014d	e8 00 00 00 00	 call	 _depack_getbits
  00152	59		 pop	 ecx

; 244  : #ifdef DPK_CHECK
; 245  : 								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 246  : #endif
; 247  : 								if( bits == 0x00 ) // %01111111100

  00153	85 c0		 test	 eax, eax
  00155	75 04		 jne	 SHORT $LN13@depacker_h@2

; 248  : 								{
; 249  : 									length = 12;

  00157	6a 0c		 push	 12			; 0000000cH
  00159	eb a2		 jmp	 SHORT $LN252@depacker_h@2
$LN13@depacker_h@2:

; 250  : 								}
; 251  : 								else if( bits == 0x01 ) // %01111111101

  0015b	3b c3		 cmp	 eax, ebx
  0015d	75 04		 jne	 SHORT $LN11@depacker_h@2

; 252  : 								{
; 253  : 									length = 13;

  0015f	6a 0d		 push	 13			; 0000000dH
  00161	eb 9a		 jmp	 SHORT $LN252@depacker_h@2
$LN11@depacker_h@2:

; 254  : 								}
; 255  : 								else if( bits == 0x02 ) // %01111111110

  00163	33 c9		 xor	 ecx, ecx
  00165	3b c5		 cmp	 eax, ebp
  00167	0f 95 c1	 setne	 cl
  0016a	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0016d	8b f9		 mov	 edi, ecx
$LN9@depacker_h@2:

; 256  : 								{
; 257  : 									length = 14;
; 258  : 								}
; 259  : 								else // %01111111111
; 260  : 								{
; 261  : 									length = 15;
; 262  : 								}
; 263  : 							}
; 264  : 						}
; 265  : 					}
; 266  : 				}
; 267  : 
; 268  : 
; 269  : 				// fetch disp and depack
; 270  : 				if( !stop )
; 271  : 				{
; 272  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  0016f	55		 push	 ebp
  00170	8b c3		 mov	 eax, ebx
  00172	e8 00 00 00 00	 call	 _depack_getbits
  00177	59		 pop	 ecx

; 273  : #ifdef DPK_CHECK
; 274  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 275  : #endif
; 276  : 					if( bits == 0x00 ) // %0<disp>

  00178	85 c0		 test	 eax, eax
  0017a	75 34		 jne	 SHORT $LN6@depacker_h@2

; 277  : 					{
; 278  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0017c	53		 push	 ebx
  0017d	e8 00 00 00 00	 call	 _depack_getbyte

; 279  : #ifdef DPK_CHECK
; 280  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 281  : #endif
; 282  : 						disp = (-256) | (0x00FF&byte); // -1..-256

  00182	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00187	eb 46		 jmp	 SHORT $LN255@depacker_h@2
$LN253@depacker_h@2:

; 283  : #ifdef DPK_CHECK
; 284  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 285  : #endif
; 286  : #ifdef DPK_DEPACK
; 287  : 						success = success && depack_repeat(disp,length);

  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00194	59		 pop	 ecx
$LN61@depacker_h@2:
  00195	33 f6		 xor	 esi, esi

; 288  : #endif
; 289  : 					}
; 290  : 					else // %1abcd<disp>

  00197	e9 b7 fe ff ff	 jmp	 $LL43@depacker_h@2

; 283  : #ifdef DPK_CHECK
; 284  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 285  : #endif
; 286  : #ifdef DPK_DEPACK
; 287  : 						success = success && depack_repeat(disp,length);

$LN191@depacker_h@2:
  0019c	57		 push	 edi
  0019d	8b c8		 mov	 ecx, eax
  0019f	e8 00 00 00 00	 call	 _depack_repeat
  001a4	59		 pop	 ecx
  001a5	85 c0		 test	 eax, eax
  001a7	74 ec		 je	 SHORT $LN61@depacker_h@2
  001a9	8b f3		 mov	 esi, ebx
  001ab	e9 a3 fe ff ff	 jmp	 $LL43@depacker_h@2
$LN6@depacker_h@2:

; 291  : 					{
; 292  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  001b0	55		 push	 ebp
  001b1	6a 04		 push	 4
  001b3	58		 pop	 eax
  001b4	e8 00 00 00 00	 call	 _depack_getbits

; 293  : #ifdef DPK_CHECK
; 294  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 295  : #endif
; 296  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  001b9	53		 push	 ebx
  001ba	8b f0		 mov	 esi, eax
  001bc	e8 00 00 00 00	 call	 _depack_getbyte

; 297  : #ifdef DPK_CHECK
; 298  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 299  : #endif
; 300  : 						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096

  001c1	83 ce f0	 or	 esi, -16		; fffffff0H
  001c4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c9	c1 e6 08	 shl	 esi, 8
  001cc	59		 pop	 ecx
  001cd	0b c6		 or	 eax, esi
$LN255@depacker_h@2:
  001cf	59		 pop	 ecx

; 301  : #ifdef DPK_CHECK
; 302  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 303  : #endif
; 304  : #ifdef DPK_DEPACK
; 305  : 						success = success && depack_repeat(disp,length);

  001d0	85 ff		 test	 edi, edi
  001d2	74 b5		 je	 SHORT $LN253@depacker_h@2
  001d4	eb c6		 jmp	 SHORT $LN191@depacker_h@2
$LN36@depacker_h@2:

; 154  : #endif
; 155  : 				break;
; 156  : 
; 157  : 
; 158  : 			case 0x01: // %001
; 159  : 
; 160  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  001d6	53		 push	 ebx
  001d7	e8 00 00 00 00	 call	 _depack_getbyte

; 161  : #ifdef DPK_CHECK
; 162  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 163  : #endif
; 164  : 
; 165  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  001dc	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H

; 166  : #ifdef DPK_CHECK
; 167  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 168  : #endif
; 169  : 
; 170  : #ifdef DPK_DEPACK
; 171  : 				success = success && depack_repeat(disp,2);

  001e1	55		 push	 ebp

; 172  : #endif
; 173  : 				break;

  001e2	eb 0c		 jmp	 SHORT $LN250@depacker_h@2
$LN37@depacker_h@2:

; 132  : 			{
; 133  : 			case 0x00: // %000xxx
; 134  : 
; 135  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  001e4	55		 push	 ebp
  001e5	8b c7		 mov	 eax, edi
  001e7	e8 00 00 00 00	 call	 _depack_getbits

; 136  : #ifdef DPK_CHECK
; 137  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;
; 138  : #endif
; 139  : 
; 140  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  001ec	83 c8 f8	 or	 eax, -8			; fffffff8H

; 141  : #ifdef DPK_CHECK
; 142  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 143  : 				{
; 144  : WRONG_DISP_HRM:
; 145  :  #ifdef DPK_REPERR
; 146  : 					printf("mhmt-depack-hrum.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 147  :  #endif
; 148  : 					return 0;
; 149  : 				}
; 150  : #endif
; 151  : 
; 152  : #ifdef DPK_DEPACK
; 153  : 				success = success && depack_repeat(disp,1);

  001ef	53		 push	 ebx
$LN250@depacker_h@2:
  001f0	8b c8		 mov	 ecx, eax
  001f2	e8 00 00 00 00	 call	 _depack_repeat
$LN249@depacker_h@2:
  001f7	59		 pop	 ecx
  001f8	59		 pop	 ecx
  001f9	e9 4d fe ff ff	 jmp	 $LN254@depacker_h@2
$LN248@depacker_h@2:

; 334  :  #ifdef DPK_CHECK
; 335  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
; 336  :  #endif
; 337  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  001fe	33 f6		 xor	 esi, esi
$LN66@depacker_h@2:

; 320  :  #ifdef DPK_CHECK
; 321  : 		if( 0xFFFFFFFF == check )
; 322  : 		{
; 323  :   #ifdef DPK_REPERR
; 324  : 			printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 325  :   #endif
; 326  : 			return 0;
; 327  : 		}
; 328  :  #endif
; 329  : 
; 330  : 		// place 5 bytes of header to the end
; 331  : 		for(i=0;i<5;i++)

  00200	4f		 dec	 edi
  00201	0f 85 cb fe ff
	ff		 jne	 $LL3@depacker_h@2
$LN1@depacker_h@2:
  00207	5f		 pop	 edi

; 338  : 		}
; 339  : 	}
; 340  : #endif
; 341  : 
; 342  : 	return success;

  00208	8b c6		 mov	 eax, esi
  0020a	5e		 pop	 esi
  0020b	5d		 pop	 ebp
  0020c	5b		 pop	 ebx

; 343  : }

  0020d	c3		 ret	 0
_depacker_hrum ENDP
_TEXT	ENDS
PUBLIC	_depacker_megalz
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack-megalz.c
;	COMDAT _depacker_megalz
_TEXT	SEGMENT
_depacker_megalz PROC					; COMDAT

; 9    : 	ULONG check;
; 10   : 	ULONG byte,bits,bitlen;
; 11   : 	LONG disp;
; 12   : 	ULONG length;
; 13   : 
; 14   : 	ULONG stop;
; 15   : 
; 16   : 
; 17   : 	ULONG success = 1;
; 18   : 
; 19   : 
; 20   : 	// rewind input stream
; 21   : 	//
; 22   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??depack_getbyte@@9@9, 0
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi

; 23   : #ifdef DPK_CHECK
; 24   : 	if( 0xFFFFFFFF == check )
; 25   : 	{
; 26   :  #ifdef DPK_REPERR
; 27   : 		printf("mhmt-depack-megalz.c:{} - Can't rewind input stream!\n");
; 28   :  #endif
; 29   : 		return 0;
; 30   : 	}
; 31   : #endif
; 32   : 
; 33   : 
; 34   : 	// first byte of input stream goes to the output unchanged
; 35   : 	//
; 36   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0000a	33 db		 xor	 ebx, ebx
  0000c	57		 push	 edi
  0000d	43		 inc	 ebx
  0000e	53		 push	 ebx
  0000f	e8 00 00 00 00	 call	 _depack_getbyte

; 37   : #ifdef DPK_CHECK
; 38   : 	if( 0xFFFFFFFF == byte )
; 39   : 	{
; 40   : NO_BYTE:
; 41   :  #ifdef DPK_REPERR
; 42   : 		printf("mhmt-depack-megalz.c:{} - Can't get byte from input stream!\n");
; 43   :  #endif
; 44   : 		return 0;
; 45   : 	}
; 46   : #endif
; 47   : 
; 48   : #ifdef DPK_DEPACK
; 49   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  00014	6a 02		 push	 2
  00016	5d		 pop	 ebp
  00017	55		 push	 ebp
  00018	e8 00 00 00 00	 call	 _depack_outbyte
  0001d	8b f0		 mov	 esi, eax

; 50   : #endif
; 51   : 
; 52   : 
; 53   : #ifdef DPK_CHECK
; 54   :  #ifdef DPK_REPERR
; 55   :  #endif
; 56   : #endif
; 57   : 	// next is byte to the bitstream
; 58   : 	//
; 59   : 	check = depack_getbits(8,DEPACK_GETBITS_FORCE);

  0001f	53		 push	 ebx
  00020	f7 de		 neg	 esi
  00022	1b f6		 sbb	 esi, esi
  00024	6a 08		 push	 8
  00026	58		 pop	 eax
  00027	f7 de		 neg	 esi
  00029	e8 00 00 00 00	 call	 _depack_getbits
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LL16@depacker_m:

; 60   : #ifdef DPK_CHECK
; 61   : 	if( 0xFFFFFFFF == check )
; 62   : 	{
; 63   : NO_BITS:
; 64   :  #ifdef DPK_REPERR
; 65   : 		printf("mhmt-depack-megalz.c:{} - Can't get bits from input stream!\n");
; 66   :  #endif
; 67   : 		return 0;
; 68   : 	}
; 69   : #endif
; 70   : 
; 71   : 
; 72   : 
; 73   : 	// now normal depacking loop
; 74   : 	//
; 75   : 	stop = 0;
; 76   : 	while( (!stop) && success )

  00031	85 f6		 test	 esi, esi
  00033	0f 84 0d 01 00
	00		 je	 $LN154@depacker_m

; 77   :  	{
; 78   : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00039	55		 push	 ebp
  0003a	8b c3		 mov	 eax, ebx
  0003c	e8 00 00 00 00	 call	 _depack_getbits
  00041	59		 pop	 ecx

; 79   : #ifdef DPK_CHECK
; 80   : 		if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 81   : #endif
; 82   : 
; 83   : 		if( 1&bits ) // %1<byte>

  00042	84 c3		 test	 al, bl
  00044	74 11		 je	 SHORT $LN14@depacker_m

; 84   : 		{
; 85   : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 _depack_getbyte

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 88   : #endif
; 89   : 
; 90   : #ifdef DPK_DEPACK
; 91   : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );

  0004c	55		 push	 ebp
  0004d	e8 00 00 00 00	 call	 _depack_outbyte

; 92   : #endif
; 93   : 		}
; 94   : 		else // %0xx

  00052	e9 e0 00 00 00	 jmp	 $LN157@depacker_m
$LN14@depacker_m:

; 95   : 		{
; 96   : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00057	55		 push	 ebp
  00058	8b c5		 mov	 eax, ebp
  0005a	e8 00 00 00 00	 call	 _depack_getbits
  0005f	59		 pop	 ecx

; 97   : #ifdef DPK_CHECK
; 98   : 			if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 99   : #endif
; 100  : 
; 101  : 			switch( 0x03 & bits )

  00060	6a 03		 push	 3
  00062	5f		 pop	 edi
  00063	23 c7		 and	 eax, edi
  00065	83 e8 00	 sub	 eax, 0
  00068	0f 84 b6 00 00
	00		 je	 $LN10@depacker_m
  0006e	48		 dec	 eax
  0006f	0f 84 a1 00 00
	00		 je	 $LN9@depacker_m
  00075	48		 dec	 eax
  00076	74 34		 je	 SHORT $FAR_DISP$4109
  00078	48		 dec	 eax
  00079	75 b6		 jne	 SHORT $LL16@depacker_m

; 186  : #endif
; 187  : 				}
; 188  : 
; 189  : 				break;
; 190  : 
; 191  : 
; 192  : 			case 0x03: // %011 - variable length
; 193  : 
; 194  : 				bitlen = 0;

  0007b	33 ff		 xor	 edi, edi
$LL4@depacker_m:

; 195  : 				do
; 196  : 				{
; 197  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  0007d	55		 push	 ebp
  0007e	8b c3		 mov	 eax, ebx

; 198  : #ifdef DPK_CHECK
; 199  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 200  : #endif
; 201  : 					bitlen++;

  00080	47		 inc	 edi
  00081	e8 00 00 00 00	 call	 _depack_getbits
  00086	59		 pop	 ecx

; 202  : 
; 203  : 				} while ( !(1&bits) );

  00087	84 c3		 test	 al, bl
  00089	74 f2		 je	 SHORT $LL4@depacker_m

; 204  : 
; 205  : 				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!

  0008b	83 ff 09	 cmp	 edi, 9
  0008e	0f 84 b2 00 00
	00		 je	 $LN154@depacker_m

; 206  : 				{
; 207  : 					stop = 1;
; 208  : 					break; // exit switch(){}
; 209  : 				}
; 210  : #ifdef DPK_CHECK
; 211  : 				if( bitlen>7 )
; 212  : 				{
; 213  :  #ifdef DPK_REPERR
; 214  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
; 215  :  #endif
; 216  : 					return 0;
; 217  : 				}
; 218  : #endif
; 219  : 				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);
; 220  : #ifdef DPK_CHECK
; 221  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 222  : #endif
; 223  : 				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );

  00094	8b cf		 mov	 ecx, edi
  00096	8b f3		 mov	 esi, ebx
  00098	55		 push	 ebp
  00099	8b c7		 mov	 eax, edi
  0009b	d3 e6		 shl	 esi, cl
  0009d	e8 00 00 00 00	 call	 _depack_getbits
  000a2	59		 pop	 ecx
  000a3	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  000a6	23 c1		 and	 eax, ecx
  000a8	8d 7c 30 02	 lea	 edi, DWORD PTR [eax+esi+2]
$FAR_DISP$4109:
  000ac	55		 push	 ebp
  000ad	8b c3		 mov	 eax, ebx
  000af	e8 00 00 00 00	 call	 _depack_getbits
  000b4	59		 pop	 ecx
  000b5	84 c3		 test	 al, bl
  000b7	75 37		 jne	 SHORT $LN7@depacker_m
  000b9	53		 push	 ebx
  000ba	e8 00 00 00 00	 call	 _depack_getbyte
  000bf	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  000c4	59		 pop	 ecx
  000c5	85 ff		 test	 edi, edi
  000c7	75 13		 jne	 SHORT $LN125@depacker_m
$LN160@depacker_m:

; 144  : 
; 145  : 
; 146  : 			case 0x02: // %010
; 147  : 
; 148  : 				length = 3;
; 149  : FAR_DISP:
; 150  : 				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
; 151  : #ifdef DPK_CHECK
; 152  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 153  : #endif
; 154  : 				if( !(1&bits) ) // -1..-256
; 155  : 				{
; 156  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 157  : #ifdef DPK_CHECK
; 158  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 159  : #endif
; 160  : 					disp = (-256) | (0x00FF&byte); // -1..-256
; 161  : #ifdef DPK_CHECK
; 162  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 163  : #endif
; 164  : 
; 165  : #ifdef DPK_DEPACK
; 166  : 					success = success && depack_repeat(disp,length);

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OBOPLPCL@mhmt?9depack?4c?3depack_repeat?$CI?$CJ?5?9?5@
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000d4	59		 pop	 ecx
$LN27@depacker_m:
  000d5	33 f6		 xor	 esi, esi

; 167  : #endif
; 168  : 				}
; 169  : 				else // -257..-4352

  000d7	e9 55 ff ff ff	 jmp	 $LL16@depacker_m

; 144  : 
; 145  : 
; 146  : 			case 0x02: // %010
; 147  : 
; 148  : 				length = 3;
; 149  : FAR_DISP:
; 150  : 				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);
; 151  : #ifdef DPK_CHECK
; 152  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 153  : #endif
; 154  : 				if( !(1&bits) ) // -1..-256
; 155  : 				{
; 156  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 157  : #ifdef DPK_CHECK
; 158  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 159  : #endif
; 160  : 					disp = (-256) | (0x00FF&byte); // -1..-256
; 161  : #ifdef DPK_CHECK
; 162  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 163  : #endif
; 164  : 
; 165  : #ifdef DPK_DEPACK
; 166  : 					success = success && depack_repeat(disp,length);

$LN125@depacker_m:
  000dc	8b c8		 mov	 ecx, eax
$LN161@depacker_m:
  000de	57		 push	 edi
  000df	e8 00 00 00 00	 call	 _depack_repeat
  000e4	59		 pop	 ecx
  000e5	85 c0		 test	 eax, eax
  000e7	74 ec		 je	 SHORT $LN27@depacker_m
  000e9	8b f3		 mov	 esi, ebx
  000eb	e9 41 ff ff ff	 jmp	 $LL16@depacker_m
$LN7@depacker_m:

; 170  : 				{
; 171  : 					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  000f0	55		 push	 ebp
  000f1	6a 04		 push	 4
  000f3	58		 pop	 eax
  000f4	e8 00 00 00 00	 call	 _depack_getbits

; 172  : #ifdef DPK_CHECK
; 173  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 174  : #endif
; 175  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000f9	53		 push	 ebx
  000fa	8b f0		 mov	 esi, eax
  000fc	e8 00 00 00 00	 call	 _depack_getbyte

; 176  : #ifdef DPK_CHECK
; 177  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 178  : #endif
; 179  : 					disp = ( ((-16)|(15&bits)) - 1 )*0x100 + byte;

  00101	83 ce f0	 or	 esi, -16		; fffffff0H
  00104	59		 pop	 ecx
  00105	c1 e6 08	 shl	 esi, 8
  00108	59		 pop	 ecx
  00109	8d 8c 30 00 ff
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-256]

; 180  : #ifdef DPK_CHECK
; 181  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 182  : #endif
; 183  : 
; 184  : #ifdef DPK_DEPACK
; 185  : 					success = success && depack_repeat(disp,length);

  00110	85 ff		 test	 edi, edi
  00112	74 b5		 je	 SHORT $LN160@depacker_m
  00114	eb c8		 jmp	 SHORT $LN161@depacker_m
$LN9@depacker_m:

; 124  : #endif
; 125  : 				break;
; 126  : 
; 127  : 
; 128  : 			case 0x01: // %001
; 129  : 
; 130  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00116	53		 push	 ebx
  00117	e8 00 00 00 00	 call	 _depack_getbyte

; 131  : #ifdef DPK_CHECK
; 132  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 133  : #endif
; 134  : 
; 135  : 				disp = (-256) | (0x00FF&byte); // -1..-256

  0011c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H

; 136  : #ifdef DPK_CHECK
; 137  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 138  : #endif
; 139  : 
; 140  : #ifdef DPK_DEPACK
; 141  : 				success = success && depack_repeat(disp,2);

  00121	55		 push	 ebp

; 142  : #endif
; 143  : 				break;

  00122	eb 0c		 jmp	 SHORT $LN158@depacker_m
$LN10@depacker_m:

; 102  : 			{
; 103  : 			case 0x00: // %000xxx
; 104  : 
; 105  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  00124	55		 push	 ebp
  00125	8b c7		 mov	 eax, edi
  00127	e8 00 00 00 00	 call	 _depack_getbits

; 106  : #ifdef DPK_CHECK
; 107  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;
; 108  : #endif
; 109  : 
; 110  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  0012c	83 c8 f8	 or	 eax, -8			; fffffff8H

; 111  : #ifdef DPK_CHECK
; 112  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 113  : 				{
; 114  : WRONG_DISP:
; 115  :  #ifdef DPK_REPERR
; 116  : 					printf("mhmt-depack-megalz.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 117  :  #endif
; 118  : 					return 0;
; 119  : 				}
; 120  : #endif
; 121  : 
; 122  : #ifdef DPK_DEPACK
; 123  : 				success = success && depack_repeat(disp,1);

  0012f	53		 push	 ebx
$LN158@depacker_m:
  00130	8b c8		 mov	 ecx, eax
  00132	e8 00 00 00 00	 call	 _depack_repeat
$LN157@depacker_m:
  00137	8b f0		 mov	 esi, eax
  00139	f7 de		 neg	 esi
  0013b	59		 pop	 ecx
  0013c	1b f6		 sbb	 esi, esi
  0013e	59		 pop	 ecx
  0013f	f7 de		 neg	 esi
  00141	e9 eb fe ff ff	 jmp	 $LL16@depacker_m
$LN154@depacker_m:
  00146	5f		 pop	 edi

; 224  : #ifdef DPK_CHECK
; 225  : 				if( length>255 )
; 226  : 				{
; 227  :  #ifdef DPK_REPERR
; 228  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
; 229  :  #endif
; 230  : 					return 0;
; 231  : 				}
; 232  : #endif
; 233  : 				goto FAR_DISP;
; 234  : 
; 235  : 				break;
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	}
; 240  : 
; 241  : 	return success;

  00147	8b c6		 mov	 eax, esi
  00149	5e		 pop	 esi
  0014a	5d		 pop	 ebp
  0014b	5b		 pop	 ebx

; 242  : }

  0014c	c3		 ret	 0
_depacker_megalz ENDP
_TEXT	ENDS
PUBLIC	_checker_hrum
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack-hrum.c
;	COMDAT _checker_hrum
_TEXT	SEGMENT
_checker_hrum PROC					; COMDAT

; 8    : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 9    : 	LONG i;
; 10   : 
; 11   : 	ULONG check;
; 12   : 	ULONG byte,bits;//,bitlen;
; 13   : 	LONG  disp;
; 14   : 	ULONG length;
; 15   : 
; 16   : 	ULONG stop;
; 17   : 
; 18   : 
; 19   : 	ULONG success = 1;
; 20   : 
; 21   : 
; 22   : 	// rewind input stream
; 23   : 	//
; 24   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);
; 25   : #ifdef DPK_CHECK
; 26   : 	if( 0xFFFFFFFF == check )
; 27   : 	{
; 28   :  #ifdef DPK_REPERR
; 29   : 		printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 30   :  #endif
; 31   : 		return 0;
; 32   : 	}
; 33   : #endif
; 34   : 
; 35   : 
; 36   : 	// manage zx header if needed
; 37   : 	if( wrk.zxheader )

  00004	33 db		 xor	 ebx, ebx
  00006	33 f6		 xor	 esi, esi
  00008	43		 inc	 ebx
  00009	83 cf ff	 or	 edi, -1
  0000c	6a 02		 push	 2
  0000e	89 35 00 00 00
	00		 mov	 DWORD PTR ?position@?1??depack_getbyte@@9@9, esi
  00014	5d		 pop	 ebp
  00015	39 35 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, esi
  0001b	74 28		 je	 SHORT $LN62@checker_hr
$LL68@checker_hr:

; 38   : 	{
; 39   : 		// skip 5 bytes (they will go to the end of output file)
; 40   : 		for(i=0;i<5;i++)
; 41   : 		{
; 42   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 _depack_getbyte
  00023	59		 pop	 ecx

; 43   : #ifdef DPK_CHECK
; 44   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;

  00024	3b c7		 cmp	 eax, edi
  00026	74 5e		 je	 SHORT $NO_BYTE_HRM$4007
  00028	46		 inc	 esi
  00029	83 fe 05	 cmp	 esi, 5
  0002c	7c ef		 jl	 SHORT $LL68@checker_hr

; 45   : #endif
; 46   : 		}
; 47   : 
; 48   : 		// next 2 bytes must be 0x10
; 49   : 		for(i=0;i<2;i++)

  0002e	33 f6		 xor	 esi, esi
$LL64@checker_hr:

; 50   : 		{
; 51   : 			check = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00030	53		 push	 ebx
  00031	e8 00 00 00 00	 call	 _depack_getbyte
  00036	59		 pop	 ecx

; 52   : #ifdef DPK_CHECK
; 53   : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM;

  00037	3b c7		 cmp	 eax, edi
  00039	74 4b		 je	 SHORT $NO_BYTE_HRM$4007

; 54   : 			if( check != 0x0010 )

  0003b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003e	75 1a		 jne	 SHORT $LN165@checker_hr
  00040	46		 inc	 esi
  00041	3b f5		 cmp	 esi, ebp
  00043	7c eb		 jl	 SHORT $LL64@checker_hr
$LN62@checker_hr:

; 60   : 			}
; 61   : #endif
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 
; 66   : 
; 67   : 	// initialize bitstream first
; 68   : 	//
; 69   : 	check = depack_getbits(16,DEPACK_GETBITS_FORCE); // number 16 is ignored! - just for convenience here...

  00045	53		 push	 ebx
  00046	6a 10		 push	 16			; 00000010H
  00048	58		 pop	 eax
  00049	e8 00 00 00 00	 call	 _depack_getbits
  0004e	59		 pop	 ecx

; 70   : #ifdef DPK_CHECK
; 71   : 	if( 0xFFFFFFFF == check )

  0004f	3b c7		 cmp	 eax, edi
  00051	75 28		 jne	 SHORT $LN189@checker_hr
$NO_BITS_HRM$4015:

; 72   : 	{
; 73   : NO_BITS_HRM:
; 74   :  #ifdef DPK_REPERR
; 75   : 		printf("mhmt-depack-hrum.c:{} - Can't get bits from input stream!\n");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MAHGDPON@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@

; 76   :  #endif
; 77   : 		return 0;

  00058	eb 05		 jmp	 SHORT $LN191@checker_hr
$LN165@checker_hr:

; 55   : 			{
; 56   :  #ifdef DPK_REPERR
; 57   : 				printf("mhmt-depack-hrum.c:{} - Wrong ZX-header!\n");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LKONFCFB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5ZX@
$LN191@checker_hr:
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
$LN192@checker_hr:
  00065	59		 pop	 ecx

; 58   :  #endif
; 59   : 				return 0;

  00066	33 c0		 xor	 eax, eax
  00068	eb 6b		 jmp	 SHORT $LN71@checker_hr
$LL57@checker_hr:

; 107  :  	{
; 108  : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  0006a	55		 push	 ebp
  0006b	8b c3		 mov	 eax, ebx
  0006d	e8 00 00 00 00	 call	 _depack_getbits
  00072	59		 pop	 ecx

; 109  : #ifdef DPK_CHECK
; 110  : 		if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00073	3b c7		 cmp	 eax, edi
  00075	74 dc		 je	 SHORT $NO_BITS_HRM$4015

; 111  : #endif
; 112  : 
; 113  : 		if( 1&bits ) // %1<byte>

  00077	84 c3		 test	 al, bl
  00079	74 12		 je	 SHORT $LN54@checker_hr
$LN189@checker_hr:

; 114  : 		{
; 115  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 _depack_getbyte
  00081	59		 pop	 ecx

; 116  : #ifdef DPK_CHECK
; 117  : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00082	3b c7		 cmp	 eax, edi
  00084	75 e4		 jne	 SHORT $LL57@checker_hr
$NO_BYTE_HRM$4007:

; 78   : 	}
; 79   : #endif
; 80   : 
; 81   : 
; 82   : 
; 83   : 	// then byte of input stream goes to the output unchanged
; 84   : 	//
; 85   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 86   : #ifdef DPK_CHECK
; 87   : 	if( 0xFFFFFFFF == byte )
; 88   : 	{
; 89   : NO_BYTE_HRM:
; 90   :  #ifdef DPK_REPERR
; 91   : 		printf("mhmt-depack-hrum.c:{} - Can't get byte from input stream!\n");

  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GEBLFABB@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Can?8t?5ge@

; 92   :  #endif
; 93   : 		return 0;

  0008b	eb d2		 jmp	 SHORT $LN191@checker_hr
$LN54@checker_hr:

; 118  : #endif
; 119  : 
; 120  : #ifdef DPK_DEPACK
; 121  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 122  : #endif
; 123  : 		}
; 124  : 		else // %0xx
; 125  : 		{
; 126  : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0008d	55		 push	 ebp
  0008e	8b c5		 mov	 eax, ebp
  00090	e8 00 00 00 00	 call	 _depack_getbits
  00095	59		 pop	 ecx

; 127  : #ifdef DPK_CHECK
; 128  : 			if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00096	3b c7		 cmp	 eax, edi
  00098	74 b9		 je	 SHORT $NO_BITS_HRM$4015

; 129  : #endif
; 130  : 
; 131  : 			switch( 0x03 & bits )

  0009a	83 e0 03	 and	 eax, 3
  0009d	8b c8		 mov	 ecx, eax
  0009f	83 e9 00	 sub	 ecx, 0
  000a2	0f 84 06 01 00
	00		 je	 $LN48@checker_hr
  000a8	49		 dec	 ecx
  000a9	0f 84 93 00 00
	00		 je	 $LN45@checker_hr

; 141  : #ifdef DPK_CHECK
; 142  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 143  : 				{
; 144  : WRONG_DISP_HRM:
; 145  :  #ifdef DPK_REPERR
; 146  : 					printf("mhmt-depack-hrum.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 147  :  #endif
; 148  : 					return 0;
; 149  : 				}
; 150  : #endif
; 151  : 
; 152  : #ifdef DPK_DEPACK
; 153  : 				success = success && depack_repeat(disp,1);
; 154  : #endif
; 155  : 				break;
; 156  : 
; 157  : 
; 158  : 			case 0x01: // %001
; 159  : 
; 160  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 161  : #ifdef DPK_CHECK
; 162  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;
; 163  : #endif
; 164  : 
; 165  : 				disp = (-256) | (0x00FF&byte); // -1..-256
; 166  : #ifdef DPK_CHECK
; 167  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 168  : #endif
; 169  : 
; 170  : #ifdef DPK_DEPACK
; 171  : 				success = success && depack_repeat(disp,2);
; 172  : #endif
; 173  : 				break;
; 174  : 
; 175  : 			default: // %010 or %011
; 176  : 
; 177  : 				if( (bits&3)==2 ) // %010 - 3 bytes

  000af	3b c5		 cmp	 eax, ebp
  000b1	74 7a		 je	 SHORT $LN11@checker_hr

; 178  : 				{
; 179  : 					length = 3;
; 180  : 				}
; 181  : 				else // %011 - varlen
; 182  : 				{
; 183  : 					bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  000b3	55		 push	 ebp
  000b4	8b c5		 mov	 eax, ebp
  000b6	e8 00 00 00 00	 call	 _depack_getbits
  000bb	59		 pop	 ecx

; 184  : #ifdef DPK_CHECK
; 185  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  000bc	3b c7		 cmp	 eax, edi
  000be	74 93		 je	 SHORT $NO_BITS_HRM$4015

; 186  : #endif
; 187  : 					//  fetch len
; 188  : 					if( bits == 0x00 ) // %01100<len>, if <len>==0 - stop

  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN38@checker_hr

; 189  : 					{
; 190  : 						length = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000c4	53		 push	 ebx
  000c5	e8 00 00 00 00	 call	 _depack_getbyte
  000ca	59		 pop	 ecx

; 191  : #ifdef DPK_CHECK
; 192  : 						if( 0xFFFFFFFF == length ) goto NO_BYTE_HRM;

  000cb	3b c7		 cmp	 eax, edi
  000cd	74 b7		 je	 SHORT $NO_BYTE_HRM$4007

; 193  : #endif
; 194  : 						if( length == 0 )

  000cf	85 c0		 test	 eax, eax
  000d1	75 5a		 jne	 SHORT $LN11@checker_hr

; 311  : 			}
; 312  : 		}
; 313  : 	}
; 314  : 
; 315  : 	//manage zxheader again (copy to the end of output)
; 316  : #ifdef DPK_DEPACK
; 317  : 	if( wrk.zxheader )
; 318  : 	{
; 319  : 		check = depack_getbyte(DEPACK_GETBYTE_REWIND);
; 320  :  #ifdef DPK_CHECK
; 321  : 		if( 0xFFFFFFFF == check )
; 322  : 		{
; 323  :   #ifdef DPK_REPERR
; 324  : 			printf("mhmt-depack-hrum.c:{} - Can't rewind input stream!\n");
; 325  :   #endif
; 326  : 			return 0;
; 327  : 		}
; 328  :  #endif
; 329  : 
; 330  : 		// place 5 bytes of header to the end
; 331  : 		for(i=0;i<5;i++)
; 332  : 		{
; 333  : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 334  :  #ifdef DPK_CHECK
; 335  : 			if( 0xFFFFFFFF == check ) goto NO_BYTE_HRM:
; 336  :  #endif
; 337  : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 338  : 		}
; 339  : 	}
; 340  : #endif
; 341  : 
; 342  : 	return success;

  000d3	8b c3		 mov	 eax, ebx
$LN71@checker_hr:
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5d		 pop	 ebp
  000d8	5b		 pop	 ebx

; 343  : }

  000d9	c3		 ret	 0
$LN38@checker_hr:

; 195  : 							stop = 1;
; 196  : 					}
; 197  : 					else if( bits == 0x01 ) // %01101 - len=4

  000da	3b c3		 cmp	 eax, ebx
  000dc	74 4f		 je	 SHORT $LN11@checker_hr

; 198  : 					{
; 199  : 						length = 4;
; 200  : 					}
; 201  : 					else if( bits == 0x02 ) // %01110 - len=5

  000de	3b c5		 cmp	 eax, ebp
  000e0	74 4b		 je	 SHORT $LN11@checker_hr

; 202  : 					{
; 203  : 						length = 5;
; 204  : 					}
; 205  : 					else // %01111
; 206  : 					{
; 207  : 						bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  000e2	55		 push	 ebp
  000e3	8b c5		 mov	 eax, ebp
  000e5	e8 00 00 00 00	 call	 _depack_getbits
  000ea	59		 pop	 ecx

; 208  : #ifdef DPK_CHECK
; 209  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  000eb	3b c7		 cmp	 eax, edi
  000ed	0f 84 60 ff ff
	ff		 je	 $NO_BITS_HRM$4015

; 210  : #endif
; 211  : 						if( bits == 0x00 ) // %0111100

  000f3	85 c0		 test	 eax, eax
  000f5	74 36		 je	 SHORT $LN11@checker_hr

; 212  : 						{
; 213  : 							length = 6;
; 214  : 						}
; 215  : 						else if( bits == 0x01 ) // %0111101

  000f7	3b c3		 cmp	 eax, ebx
  000f9	74 32		 je	 SHORT $LN11@checker_hr

; 216  : 						{
; 217  : 							length = 7;
; 218  : 						}
; 219  : 						else if( bits == 0x02 ) // %0111110

  000fb	3b c5		 cmp	 eax, ebp
  000fd	74 2e		 je	 SHORT $LN11@checker_hr

; 220  : 						{
; 221  : 							length = 8;
; 222  : 						}
; 223  : 						else // %0111111
; 224  : 						{
; 225  : 							bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  000ff	55		 push	 ebp
  00100	8b c5		 mov	 eax, ebp
  00102	e8 00 00 00 00	 call	 _depack_getbits
  00107	59		 pop	 ecx

; 226  : #ifdef DPK_CHECK
; 227  : 							if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00108	3b c7		 cmp	 eax, edi
  0010a	0f 84 43 ff ff
	ff		 je	 $NO_BITS_HRM$4015

; 228  : #endif
; 229  : 							if( bits == 0x00 ) // %011111100

  00110	85 c0		 test	 eax, eax
  00112	74 19		 je	 SHORT $LN11@checker_hr

; 230  : 							{
; 231  : 								length = 9;
; 232  : 							}
; 233  : 							else if( bits == 0x01 ) // %011111101

  00114	3b c3		 cmp	 eax, ebx
  00116	74 15		 je	 SHORT $LN11@checker_hr

; 234  : 							{
; 235  : 								length = 10;
; 236  : 							}
; 237  : 							else if( bits == 0x02 ) // %011111110

  00118	3b c5		 cmp	 eax, ebp
  0011a	74 11		 je	 SHORT $LN11@checker_hr

; 238  : 							{
; 239  : 								length = 11;
; 240  : 							}
; 241  : 							else // %011111111
; 242  : 							{
; 243  : 								bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  0011c	55		 push	 ebp
  0011d	8b c5		 mov	 eax, ebp
  0011f	e8 00 00 00 00	 call	 _depack_getbits
  00124	59		 pop	 ecx

; 244  : #ifdef DPK_CHECK
; 245  : 								if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00125	3b c7		 cmp	 eax, edi
  00127	0f 84 26 ff ff
	ff		 je	 $NO_BITS_HRM$4015
$LN11@checker_hr:

; 246  : #endif
; 247  : 								if( bits == 0x00 ) // %01111111100
; 248  : 								{
; 249  : 									length = 12;
; 250  : 								}
; 251  : 								else if( bits == 0x01 ) // %01111111101
; 252  : 								{
; 253  : 									length = 13;
; 254  : 								}
; 255  : 								else if( bits == 0x02 ) // %01111111110
; 256  : 								{
; 257  : 									length = 14;
; 258  : 								}
; 259  : 								else // %01111111111
; 260  : 								{
; 261  : 									length = 15;
; 262  : 								}
; 263  : 							}
; 264  : 						}
; 265  : 					}
; 266  : 				}
; 267  : 
; 268  : 
; 269  : 				// fetch disp and depack
; 270  : 				if( !stop )
; 271  : 				{
; 272  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  0012d	55		 push	 ebp
  0012e	8b c3		 mov	 eax, ebx
  00130	e8 00 00 00 00	 call	 _depack_getbits
  00135	59		 pop	 ecx

; 273  : #ifdef DPK_CHECK
; 274  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00136	3b c7		 cmp	 eax, edi
  00138	0f 84 15 ff ff
	ff		 je	 $NO_BITS_HRM$4015

; 275  : #endif
; 276  : 					if( bits == 0x00 ) // %0<disp>

  0013e	85 c0		 test	 eax, eax
  00140	75 38		 jne	 SHORT $LN7@checker_hr
$LN45@checker_hr:

; 277  : 					{
; 278  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00142	53		 push	 ebx
  00143	e8 00 00 00 00	 call	 _depack_getbyte
  00148	59		 pop	 ecx

; 279  : #ifdef DPK_CHECK
; 280  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00149	3b c7		 cmp	 eax, edi
  0014b	0f 84 35 ff ff
	ff		 je	 $NO_BYTE_HRM$4007

; 281  : #endif
; 282  : 						disp = (-256) | (0x00FF&byte); // -1..-256

  00151	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
$LN190@checker_hr:

; 283  : #ifdef DPK_CHECK
; 284  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;

  00156	8b c8		 mov	 ecx, eax
  00158	f7 d9		 neg	 ecx
  0015a	3b 0d 1c 00 00
	00		 cmp	 ecx, DWORD PTR _wrk+28
  00160	0f 86 04 ff ff
	ff		 jbe	 $LL57@checker_hr
  00166	f7 d8		 neg	 eax
  00168	50		 push	 eax
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LCNANFJA@mhmt?9depack?9hrum?4c?3?$HL?$HN?5?9?5Wrong?5lo@
$WRONG_DISP_HRM$4035:
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00174	59		 pop	 ecx
  00175	e9 eb fe ff ff	 jmp	 $LN192@checker_hr
$LN7@checker_hr:

; 285  : #endif
; 286  : #ifdef DPK_DEPACK
; 287  : 						success = success && depack_repeat(disp,length);
; 288  : #endif
; 289  : 					}
; 290  : 					else // %1abcd<disp>
; 291  : 					{
; 292  : 						bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  0017a	55		 push	 ebp
  0017b	6a 04		 push	 4
  0017d	58		 pop	 eax
  0017e	e8 00 00 00 00	 call	 _depack_getbits
  00183	8b f0		 mov	 esi, eax
  00185	59		 pop	 ecx

; 293  : #ifdef DPK_CHECK
; 294  : 						if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  00186	3b f7		 cmp	 esi, edi
  00188	0f 84 c5 fe ff
	ff		 je	 $NO_BITS_HRM$4015

; 295  : #endif
; 296  : 						byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0018e	53		 push	 ebx
  0018f	e8 00 00 00 00	 call	 _depack_getbyte
  00194	59		 pop	 ecx

; 297  : #ifdef DPK_CHECK
; 298  : 						if( 0xFFFFFFFF == byte ) goto NO_BYTE_HRM;

  00195	3b c7		 cmp	 eax, edi
  00197	0f 84 e9 fe ff
	ff		 je	 $NO_BYTE_HRM$4007

; 299  : #endif
; 300  : 						disp = (-4096) | (0x0F00&(bits<<8)) | (0x00FF&byte); // -1..-4096

  0019d	83 ce f0	 or	 esi, -16		; fffffff0H
  001a0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001a5	c1 e6 08	 shl	 esi, 8
  001a8	0b f0		 or	 esi, eax
  001aa	8b c6		 mov	 eax, esi

; 301  : #ifdef DPK_CHECK
; 302  : 						if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP_HRM;
; 303  : #endif
; 304  : #ifdef DPK_DEPACK
; 305  : 						success = success && depack_repeat(disp,length);
; 306  : #endif
; 307  : 					}
; 308  : 				}
; 309  : 
; 310  : 				break;

  001ac	eb a8		 jmp	 SHORT $LN190@checker_hr
$LN48@checker_hr:

; 132  : 			{
; 133  : 			case 0x00: // %000xxx
; 134  : 
; 135  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  001ae	55		 push	 ebp
  001af	6a 03		 push	 3
  001b1	58		 pop	 eax
  001b2	e8 00 00 00 00	 call	 _depack_getbits
  001b7	59		 pop	 ecx

; 136  : #ifdef DPK_CHECK
; 137  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS_HRM;

  001b8	3b c7		 cmp	 eax, edi
  001ba	0f 84 93 fe ff
	ff		 je	 $NO_BITS_HRM$4015

; 138  : #endif
; 139  : 
; 140  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  001c0	83 c8 f8	 or	 eax, -8			; fffffff8H

; 94   : 	}
; 95   : #endif
; 96   : 
; 97   : #ifdef DPK_DEPACK
; 98   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 99   : #endif
; 100  : 
; 101  : 
; 102  : 
; 103  : 	// now normal depacking loop
; 104  : 	//
; 105  : 	stop = 0;
; 106  : 	while( (!stop) && success )

  001c3	eb 91		 jmp	 SHORT $LN190@checker_hr
_checker_hrum ENDP
_TEXT	ENDS
PUBLIC	_checker_megalz
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack-megalz.c
;	COMDAT _checker_megalz
_TEXT	SEGMENT
_checker_megalz PROC					; COMDAT

; 9    : 	ULONG check;
; 10   : 	ULONG byte,bits,bitlen;
; 11   : 	LONG disp;
; 12   : 	ULONG length;
; 13   : 
; 14   : 	ULONG stop;
; 15   : 
; 16   : 
; 17   : 	ULONG success = 1;
; 18   : 
; 19   : 
; 20   : 	// rewind input stream
; 21   : 	//
; 22   : 	check = depack_getbyte(DEPACK_GETBYTE_REWIND);

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??depack_getbyte@@9@9, 0
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi

; 23   : #ifdef DPK_CHECK
; 24   : 	if( 0xFFFFFFFF == check )
; 25   : 	{
; 26   :  #ifdef DPK_REPERR
; 27   : 		printf("mhmt-depack-megalz.c:{} - Can't rewind input stream!\n");
; 28   :  #endif
; 29   : 		return 0;
; 30   : 	}
; 31   : #endif
; 32   : 
; 33   : 
; 34   : 	// first byte of input stream goes to the output unchanged
; 35   : 	//
; 36   : 	byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0000a	33 db		 xor	 ebx, ebx
  0000c	57		 push	 edi
  0000d	43		 inc	 ebx
  0000e	53		 push	 ebx
  0000f	e8 00 00 00 00	 call	 _depack_getbyte

; 37   : #ifdef DPK_CHECK
; 38   : 	if( 0xFFFFFFFF == byte )

  00014	83 cf ff	 or	 edi, -1
  00017	59		 pop	 ecx
  00018	3b c7		 cmp	 eax, edi
  0001a	74 35		 je	 SHORT $NO_BYTE$3940

; 45   : 	}
; 46   : #endif
; 47   : 
; 48   : #ifdef DPK_DEPACK
; 49   : 	success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 50   : #endif
; 51   : 
; 52   : 
; 53   : #ifdef DPK_CHECK
; 54   :  #ifdef DPK_REPERR
; 55   :  #endif
; 56   : #endif
; 57   : 	// next is byte to the bitstream
; 58   : 	//
; 59   : 	check = depack_getbits(8,DEPACK_GETBITS_FORCE);

  0001c	53		 push	 ebx
  0001d	6a 08		 push	 8
  0001f	58		 pop	 eax
  00020	e8 00 00 00 00	 call	 _depack_getbits
  00025	59		 pop	 ecx

; 60   : #ifdef DPK_CHECK
; 61   : 	if( 0xFFFFFFFF == check )

  00026	3b c7		 cmp	 eax, edi
  00028	0f 84 48 01 00
	00		 je	 $NO_BITS$3943
  0002e	6a 02		 push	 2
  00030	5d		 pop	 ebp
$LL33@checker_me:

; 77   :  	{
; 78   : 		bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  00031	55		 push	 ebp
  00032	8b c3		 mov	 eax, ebx
  00034	e8 00 00 00 00	 call	 _depack_getbits
  00039	59		 pop	 ecx

; 79   : #ifdef DPK_CHECK
; 80   : 		if( 0xFFFFFFFF == bits ) goto NO_BITS;

  0003a	3b c7		 cmp	 eax, edi
  0003c	0f 84 34 01 00
	00		 je	 $NO_BITS$3943

; 81   : #endif
; 82   : 
; 83   : 		if( 1&bits ) // %1<byte>

  00042	84 c3		 test	 al, bl
  00044	74 1e		 je	 SHORT $LN30@checker_me

; 84   : 		{
; 85   : 			byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 _depack_getbyte
  0004c	59		 pop	 ecx

; 86   : #ifdef DPK_CHECK
; 87   : 			if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  0004d	3b c7		 cmp	 eax, edi
  0004f	75 e0		 jne	 SHORT $LL33@checker_me
$NO_BYTE$3940:

; 39   : 	{
; 40   : NO_BYTE:
; 41   :  #ifdef DPK_REPERR
; 42   : 		printf("mhmt-depack-megalz.c:{} - Can't get byte from input stream!\n");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EIIABEFI@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@
$LN119@checker_me:
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
$LN120@checker_me:
  0005c	59		 pop	 ecx

; 43   :  #endif
; 44   : 		return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 1e 01 00 00	 jmp	 $LN37@checker_me
$LN30@checker_me:

; 88   : #endif
; 89   : 
; 90   : #ifdef DPK_DEPACK
; 91   : 			success = success && depack_outbyte( (UBYTE)(0x00FF&byte), DEPACK_OUTBYTE_ADD );
; 92   : #endif
; 93   : 		}
; 94   : 		else // %0xx
; 95   : 		{
; 96   : 			bits = depack_getbits(2,DEPACK_GETBITS_NEXT);

  00064	55		 push	 ebp
  00065	8b c5		 mov	 eax, ebp
  00067	e8 00 00 00 00	 call	 _depack_getbits
  0006c	59		 pop	 ecx

; 97   : #ifdef DPK_CHECK
; 98   : 			if( 0xFFFFFFFF == bits ) goto NO_BITS;

  0006d	3b c7		 cmp	 eax, edi
  0006f	0f 84 01 01 00
	00		 je	 $NO_BITS$3943

; 99   : #endif
; 100  : 
; 101  : 			switch( 0x03 & bits )

  00075	83 e0 03	 and	 eax, 3
  00078	33 f6		 xor	 esi, esi
  0007a	2b c6		 sub	 eax, esi
  0007c	0f 84 d7 00 00
	00		 je	 $LN24@checker_me
  00082	48		 dec	 eax
  00083	74 6e		 je	 SHORT $LN21@checker_me
  00085	48		 dec	 eax
  00086	74 56		 je	 SHORT $FAR_DISP$3968
  00088	48		 dec	 eax
  00089	75 a6		 jne	 SHORT $LL33@checker_me
$LL8@checker_me:

; 190  : 
; 191  : 
; 192  : 			case 0x03: // %011 - variable length
; 193  : 
; 194  : 				bitlen = 0;
; 195  : 				do
; 196  : 				{
; 197  : 					bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  0008b	55		 push	 ebp
  0008c	8b c3		 mov	 eax, ebx
  0008e	e8 00 00 00 00	 call	 _depack_getbits
  00093	59		 pop	 ecx

; 198  : #ifdef DPK_CHECK
; 199  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00094	3b c7		 cmp	 eax, edi
  00096	0f 84 da 00 00
	00		 je	 $NO_BITS$3943

; 200  : #endif
; 201  : 					bitlen++;

  0009c	46		 inc	 esi

; 202  : 
; 203  : 				} while ( !(1&bits) );

  0009d	84 c3		 test	 al, bl
  0009f	74 ea		 je	 SHORT $LL8@checker_me

; 204  : 
; 205  : 				if( bitlen==9 ) // happy final! WARNING: does not check whether there is remaining of input stream left unused!

  000a1	83 fe 09	 cmp	 esi, 9
  000a4	0f 84 d6 00 00
	00		 je	 $LN32@checker_me

; 206  : 				{
; 207  : 					stop = 1;
; 208  : 					break; // exit switch(){}
; 209  : 				}
; 210  : #ifdef DPK_CHECK
; 211  : 				if( bitlen>7 )

  000aa	83 fe 07	 cmp	 esi, 7
  000ad	0f 87 b9 00 00
	00		 ja	 $LN103@checker_me

; 217  : 				}
; 218  : #endif
; 219  : 				bits = depack_getbits(bitlen,DEPACK_GETBITS_NEXT);

  000b3	55		 push	 ebp
  000b4	8b c6		 mov	 eax, esi
  000b6	e8 00 00 00 00	 call	 _depack_getbits
  000bb	59		 pop	 ecx

; 220  : #ifdef DPK_CHECK
; 221  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  000bc	3b c7		 cmp	 eax, edi
  000be	0f 84 b2 00 00
	00		 je	 $NO_BITS$3943

; 222  : #endif
; 223  : 				length = 2 + (1<<bitlen) + ( bits & ((1<<bitlen)-1) );

  000c4	8b ce		 mov	 ecx, esi
  000c6	8b d3		 mov	 edx, ebx
  000c8	d3 e2		 shl	 edx, cl
  000ca	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  000cd	23 c8		 and	 ecx, eax

; 224  : #ifdef DPK_CHECK
; 225  : 				if( length>255 )

  000cf	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  000d3	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000d8	0f 87 8e 00 00
	00		 ja	 $LN103@checker_me
$FAR_DISP$3968:

; 111  : #ifdef DPK_CHECK
; 112  : 				if( (ULONG)(-disp) > wrk.maxwin )
; 113  : 				{
; 114  : WRONG_DISP:
; 115  :  #ifdef DPK_REPERR
; 116  : 					printf("mhmt-depack-megalz.c:{} - Wrong lookback displacement of %d, greater than maxwin\n",(-disp) );
; 117  :  #endif
; 118  : 					return 0;
; 119  : 				}
; 120  : #endif
; 121  : 
; 122  : #ifdef DPK_DEPACK
; 123  : 				success = success && depack_repeat(disp,1);
; 124  : #endif
; 125  : 				break;
; 126  : 
; 127  : 
; 128  : 			case 0x01: // %001
; 129  : 
; 130  : 				byte = depack_getbyte(DEPACK_GETBYTE_NEXT);
; 131  : #ifdef DPK_CHECK
; 132  : 				if( 0xFFFFFFFF == byte ) goto NO_BYTE;
; 133  : #endif
; 134  : 
; 135  : 				disp = (-256) | (0x00FF&byte); // -1..-256
; 136  : #ifdef DPK_CHECK
; 137  : 				if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 138  : #endif
; 139  : 
; 140  : #ifdef DPK_DEPACK
; 141  : 				success = success && depack_repeat(disp,2);
; 142  : #endif
; 143  : 				break;
; 144  : 
; 145  : 
; 146  : 			case 0x02: // %010
; 147  : 
; 148  : 				length = 3;
; 149  : FAR_DISP:
; 150  : 				bits = depack_getbits(1,DEPACK_GETBITS_NEXT);

  000de	55		 push	 ebp
  000df	8b c3		 mov	 eax, ebx
  000e1	e8 00 00 00 00	 call	 _depack_getbits
  000e6	59		 pop	 ecx

; 151  : #ifdef DPK_CHECK
; 152  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  000e7	3b c7		 cmp	 eax, edi
  000e9	0f 84 87 00 00
	00		 je	 $NO_BITS$3943

; 153  : #endif
; 154  : 				if( !(1&bits) ) // -1..-256

  000ef	84 c3		 test	 al, bl
  000f1	75 38		 jne	 SHORT $LN16@checker_me
$LN21@checker_me:

; 155  : 				{
; 156  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  000f3	53		 push	 ebx
  000f4	e8 00 00 00 00	 call	 _depack_getbyte
  000f9	59		 pop	 ecx

; 157  : #ifdef DPK_CHECK
; 158  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  000fa	3b c7		 cmp	 eax, edi
  000fc	0f 84 4f ff ff
	ff		 je	 $NO_BYTE$3940

; 159  : #endif
; 160  : 					disp = (-256) | (0x00FF&byte); // -1..-256

  00102	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
$LN118@checker_me:

; 161  : #ifdef DPK_CHECK
; 162  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;

  00107	8b c8		 mov	 ecx, eax
  00109	f7 d9		 neg	 ecx
  0010b	3b 0d 1c 00 00
	00		 cmp	 ecx, DWORD PTR _wrk+28
  00111	0f 86 1a ff ff
	ff		 jbe	 $LL33@checker_me
  00117	f7 d8		 neg	 eax
  00119	50		 push	 eax
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@OFBHOAIK@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@
$WRONG_DISP$3961:
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00125	59		 pop	 ecx
  00126	e9 31 ff ff ff	 jmp	 $LN120@checker_me
$LN16@checker_me:

; 163  : #endif
; 164  : 
; 165  : #ifdef DPK_DEPACK
; 166  : 					success = success && depack_repeat(disp,length);
; 167  : #endif
; 168  : 				}
; 169  : 				else // -257..-4352
; 170  : 				{
; 171  : 					bits = depack_getbits(4,DEPACK_GETBITS_NEXT);

  0012b	55		 push	 ebp
  0012c	6a 04		 push	 4
  0012e	58		 pop	 eax
  0012f	e8 00 00 00 00	 call	 _depack_getbits
  00134	8b f0		 mov	 esi, eax
  00136	59		 pop	 ecx

; 172  : #ifdef DPK_CHECK
; 173  : 					if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00137	3b f7		 cmp	 esi, edi
  00139	74 3b		 je	 SHORT $NO_BITS$3943

; 174  : #endif
; 175  : 					byte = depack_getbyte(DEPACK_GETBYTE_NEXT);

  0013b	53		 push	 ebx
  0013c	e8 00 00 00 00	 call	 _depack_getbyte
  00141	59		 pop	 ecx

; 176  : #ifdef DPK_CHECK
; 177  : 					if( 0xFFFFFFFF == byte ) goto NO_BYTE;

  00142	3b c7		 cmp	 eax, edi
  00144	0f 84 07 ff ff
	ff		 je	 $NO_BYTE$3940

; 178  : #endif
; 179  : 					disp = ( ((-16)|(15&bits)) - 1 )*0x100 + byte;

  0014a	83 ce f0	 or	 esi, -16		; fffffff0H
  0014d	c1 e6 08	 shl	 esi, 8
  00150	8d 84 06 00 ff
	ff ff		 lea	 eax, DWORD PTR [esi+eax-256]

; 180  : #ifdef DPK_CHECK
; 181  : 					if( (ULONG)(-disp) > wrk.maxwin ) goto WRONG_DISP;
; 182  : #endif
; 183  : 
; 184  : #ifdef DPK_DEPACK
; 185  : 					success = success && depack_repeat(disp,length);
; 186  : #endif
; 187  : 				}
; 188  : 
; 189  : 				break;

  00157	eb ae		 jmp	 SHORT $LN118@checker_me
$LN24@checker_me:

; 102  : 			{
; 103  : 			case 0x00: // %000xxx
; 104  : 
; 105  : 				bits = depack_getbits(3,DEPACK_GETBITS_NEXT);

  00159	55		 push	 ebp
  0015a	6a 03		 push	 3
  0015c	58		 pop	 eax
  0015d	e8 00 00 00 00	 call	 _depack_getbits
  00162	59		 pop	 ecx

; 106  : #ifdef DPK_CHECK
; 107  : 				if( 0xFFFFFFFF == bits ) goto NO_BITS;

  00163	3b c7		 cmp	 eax, edi
  00165	74 0f		 je	 SHORT $NO_BITS$3943

; 108  : #endif
; 109  : 
; 110  : 				disp = (-8) | (bits&0x07); // FFFFFFF8..FFFFFFFF (-8..-1)

  00167	83 c8 f8	 or	 eax, -8			; fffffff8H

; 68   : 	}
; 69   : #endif
; 70   : 
; 71   : 
; 72   : 
; 73   : 	// now normal depacking loop
; 74   : 	//
; 75   : 	stop = 0;
; 76   : 	while( (!stop) && success )

  0016a	eb 9b		 jmp	 SHORT $LN118@checker_me
$LN103@checker_me:

; 212  : 				{
; 213  :  #ifdef DPK_REPERR
; 214  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");

  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JMIKDCGD@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Wrong?5@

; 215  :  #endif
; 216  : 					return 0;

  00171	e9 e0 fe ff ff	 jmp	 $LN119@checker_me
$NO_BITS$3943:

; 62   : 	{
; 63   : NO_BITS:
; 64   :  #ifdef DPK_REPERR
; 65   : 		printf("mhmt-depack-megalz.c:{} - Can't get bits from input stream!\n");

  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@OMONHLKE@mhmt?9depack?9megalz?4c?3?$HL?$HN?5?9?5Can?8t?5@

; 66   :  #endif
; 67   : 		return 0;

  0017b	e9 d6 fe ff ff	 jmp	 $LN119@checker_me
$LN32@checker_me:

; 226  : 				{
; 227  :  #ifdef DPK_REPERR
; 228  : 					printf("mhmt-depack-megalz.c:{} - Wrong LZ code\n");
; 229  :  #endif
; 230  : 					return 0;
; 231  : 				}
; 232  : #endif
; 233  : 				goto FAR_DISP;
; 234  : 
; 235  : 				break;
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	}
; 240  : 
; 241  : 	return success;

  00180	8b c3		 mov	 eax, ebx
$LN37@checker_me:
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5d		 pop	 ebp
  00185	5b		 pop	 ebx

; 242  : }

  00186	c3		 ret	 0
_checker_megalz ENDP
_TEXT	ENDS
PUBLIC	_depack
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-depack.c
;	COMDAT _depack
_TEXT	SEGMENT
_depack	PROC						; COMDAT

; 18   : 	ULONG (*checker) (void) = NULL;
; 19   : 	ULONG (*depacker)(void) = NULL;
; 20   : 
; 21   : 
; 22   : 	ULONG success=1;
; 23   : 
; 24   : 
; 25   : 	// some preparations
; 26   : 	//
; 27   : 	if( wrk.packtype==PK_MLZ )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  00005	56		 push	 esi
  00006	83 f8 01	 cmp	 eax, 1
  00009	75 07		 jne	 SHORT $LN8@depack

; 28   : 	{
; 29   : 		checker  = &checker_megalz;
; 30   : 		depacker = &depacker_megalz;

  0000b	be 00 00 00 00	 mov	 esi, OFFSET _depacker_megalz
  00010	eb 16		 jmp	 SHORT $LN3@depack
$LN8@depack:

; 31   : 	}
; 32   : 	else if( wrk.packtype==PK_HRM )

  00012	83 f8 02	 cmp	 eax, 2
  00015	75 07		 jne	 SHORT $LN6@depack

; 33   : 	{
; 34   : 		checker  = &checker_hrum;
; 35   : 		depacker = &depacker_hrum;

  00017	be 00 00 00 00	 mov	 esi, OFFSET _depacker_hrum
  0001c	eb 0a		 jmp	 SHORT $LN3@depack
$LN6@depack:

; 36   : 	}
; 37   : 	else if( wrk.packtype==PK_HST )

  0001e	83 f8 03	 cmp	 eax, 3
  00021	75 74		 jne	 SHORT $LN4@depack

; 38   : 	{
; 39   : //		checker  = &checker_hrust;
; 40   : 		depacker = &depacker_hrust;

  00023	be 00 00 00 00	 mov	 esi, OFFSET _depacker_hrust
$LN3@depack:

; 46   : 	}
; 47   : 
; 48   : 
; 49   : 
; 50   : 	// allocate buffer used for depacking
; 51   : 	//
; 52   : 	buf_size = ( wrk.maxwin==4352 ) ? 8192 : wrk.maxwin; // provided there are no other non-2^n sizes

  00028	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  0002d	3d 00 11 00 00	 cmp	 eax, 4352		; 00001100H
  00032	75 05		 jne	 SHORT $LN11@depack
  00034	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
$LN11@depack:

; 53   : 
; 54   : 	buffer=(UBYTE*)malloc(buf_size);

  00039	50		 push	 eax
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _buf_size, eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00045	59		 pop	 ecx
  00046	a3 00 00 00 00	 mov	 DWORD PTR _buffer, eax

; 55   : 	if( !buffer )

  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN2@depack

; 56   : 	{
; 57   : 		printf("mhmt-depack.c:depack() cannot allocate memory for depack buffer!\n");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@GKFPOBPM@mhmt?9depack?4c?3depack?$CI?$CJ?5cannot?5al@

; 58   : 		return 0;

  00054	eb 46		 jmp	 SHORT $LN64@depack
$LN2@depack:

; 59   : 	}
; 60   : 
; 61   : 	buf_ptr=0;

  00056	83 25 00 00 00
	00 00		 and	 DWORD PTR _buf_ptr, 0

; 62   : 
; 63   : 
; 64   : 	success = success && emit_file(NULL,EMIT_FILE_INIT);

  0005d	83 25 00 00 00
	00 00		 and	 DWORD PTR ?position@?1??emit_file@@9@9, 0

; 65   : 
; 66   : //	success = success && (*checker) ();
; 67   : 
; 68   : //#ifdef DBG
; 69   : //	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
; 70   : //#endif
; 71   : 
; 72   : 
; 73   : 
; 74   : 	success = success && (*depacker)();

  00064	ff d6		 call	 esi
  00066	8b f0		 mov	 esi, eax
  00068	f7 de		 neg	 esi
  0006a	1b f6		 sbb	 esi, esi

; 75   : 
; 76   : 	/*success = success && */depack_outbyte( 0, DEPACK_OUTBYTE_FLUSH );

  0006c	6a 01		 push	 1
  0006e	32 c0		 xor	 al, al
  00070	f7 de		 neg	 esi
  00072	e8 00 00 00 00	 call	 _depack_outbyte

; 77   : 
; 78   : 	/*success = success && */emit_file(NULL,EMIT_FILE_FINISH);

  00077	6a 00		 push	 0
  00079	33 c0		 xor	 eax, eax
  0007b	e8 00 00 00 00	 call	 _emit_file

; 79   : 
; 80   : 
; 81   : 
; 82   : 
; 83   : 	if( buffer )

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  00085	59		 pop	 ecx
  00086	59		 pop	 ecx
  00087	85 c0		 test	 eax, eax
  00089	74 08		 je	 SHORT $LN1@depack

; 84   : 		free(buffer);

  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00092	59		 pop	 ecx
$LN1@depack:

; 85   : 
; 86   : 	return success;

  00093	8b c6		 mov	 eax, esi
  00095	5e		 pop	 esi

; 87   : }

  00096	c3		 ret	 0
$LN4@depack:

; 41   : 	}
; 42   : 	else
; 43   : 	{
; 44   : 		printf("mhmt-depack.c:depack() - format unsupported!\n");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CCLLFBOO@mhmt?9depack?4c?3depack?$CI?$CJ?5?9?5format?5@
$LN64@depack:
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000a2	59		 pop	 ecx

; 45   : 		return 0;

  000a3	33 c0		 xor	 eax, eax
  000a5	5e		 pop	 esi

; 87   : }

  000a6	c3		 ret	 0
_depack	ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-emit.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@ ; `string'
PUBLIC	??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@ ; `string'
PUBLIC	??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@ ; `string'
PUBLIC	??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@ ; `string'
PUBLIC	??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@ ; `string'
PUBLIC	??_C@_02FGFKJHMM@?$BA?$BA?$AA@			; `string'
PUBLIC	??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@ ; `string'
PUBLIC	??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@ ; `string'
PUBLIC	??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@ ; `string'
PUBLIC	??_C@_02PGLKMFED@HR?$AA@			; `string'
PUBLIC	??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@ ; `string'
PUBLIC	??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@ ; `string'
PUBLIC	??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@ ; `string'
PUBLIC	??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@ ; `string'
PUBLIC	??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@ ; `string'
PUBLIC	??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@ ; `string'
PUBLIC	??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@ ; `string'
EXTRN	__imp__fwrite:PROC
;	COMDAT ??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_bits() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_byte() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@
CONST	SEGMENT
??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@ DB 'mhmt-'
	DB	'emit.c:emit_byte() buffer overflow!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@
CONST	SEGMENT
??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@ DB 'mhmt-e'
	DB	'mit.c:emit_file() encountered invalid arguments!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@
CONST	SEGMENT
??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@ DB 'mhmt'
	DB	'-emit.c:emit_file() can''t write to file!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@
CONST	SEGMENT
??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@ DB 'mhmt'
	DB	'-emit.c:emit_hrust() - invalid code: length=%d, displacement='
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@
CONST	SEGMENT
??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@ DB 'mhmt'
	DB	'-emit.c:emit_hrust() - encountered stop-code in optimal chain'
	DB	' before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PGLKMFED@HR?$AA@
CONST	SEGMENT
??_C@_02PGLKMFED@HR?$AA@ DB 'HR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@
CONST	SEGMENT
??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@ DB 'mhm'
	DB	't-emit.c:emit_hrust() - NULL passed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@
CONST	SEGMENT
??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@ DB 'mhmt'
	DB	'-emit.c:emit_hrum() - invalid code: length=%d, displacement=%'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@
CONST	SEGMENT
??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@ DB 'mhmt'
	DB	'-emit.c:emit_hrum() - encountered stop-code in optimal chain '
	DB	'before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGFKJHMM@?$BA?$BA?$AA@
CONST	SEGMENT
??_C@_02FGFKJHMM@?$BA?$BA?$AA@ DB 010H, 010H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@
CONST	SEGMENT
??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@ DB 'mhm'
	DB	't-emit.c:emit_hrum() - NULL passed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
CONST	SEGMENT
??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@ DB 'Maximum displ'
	DB	'acement actually used is %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@
CONST	SEGMENT
??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - invalid code: length=%d, displacement'
	DB	'=%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@
CONST	SEGMENT
??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - encountered stop-code in optimal chai'
	DB	'n before emitting all data!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@
CONST	SEGMENT
??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@ DB 'mhmt'
	DB	'-emit.c:emit_megalz() - NULL passed!', 0aH, 00H ; `string'
PUBLIC	_emit_file
?buffer@?1??emit_file@@9@9 DB 01000H DUP (?)		; `emit_file'::`2'::buffer
?position@?1??emit_file@@9@9 DD 01H DUP (?)		; `emit_file'::`2'::position
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-emit.c
;	COMDAT _emit_file
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
_emit_file PROC						; COMDAT
; _length$ = eax

; 683  : {

  00000	53		 push	 ebx
  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _bytes$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 684  : 	static UBYTE buffer[EMIT_FILEBUF_SIZE];
; 685  : 
; 686  : 	static ULONG position;
; 687  : 
; 688  : 
; 689  : 	if( length==EMIT_FILE_INIT )
; 690  : 	{
; 691  : 		position = 0;
; 692  : 
; 693  : 		return 1;
; 694  : 	}
; 695  : 	else if( length>0 )

  00009	85 ff		 test	 edi, edi
  0000b	7e 72		 jle	 SHORT $LN29@emit_file

; 696  : 	{
; 697  : 		while( (position+length) >= EMIT_FILEBUF_SIZE ) // if we have to flush buffer

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  00012	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00015	be 00 10 00 00	 mov	 esi, 4096		; 00001000H
  0001a	3b ce		 cmp	 ecx, esi
  0001c	72 44		 jb	 SHORT $LN23@emit_file
$LL12@emit_file:

; 698  : 		{
; 699  : 			length -= (EMIT_FILEBUF_SIZE-position);

  0001e	8d bc 07 00 f0
	ff ff		 lea	 edi, DWORD PTR [edi+eax-4096]

; 700  : 
; 701  : 			while( position < EMIT_FILEBUF_SIZE ) // fill buffer to the end, if possible

  00025	3b c6		 cmp	 eax, esi
  00027	73 13		 jae	 SHORT $LN9@emit_file
$LL10@emit_file:

; 702  : 			{
; 703  :                                 buffer[position++] = *(bytes++);

  00029	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0002b	88 88 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_file@@9@9[eax], cl
  00031	40		 inc	 eax
  00032	43		 inc	 ebx
  00033	3b c6		 cmp	 eax, esi
  00035	72 f2		 jb	 SHORT $LL10@emit_file
  00037	a3 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, eax
$LN9@emit_file:

; 704  : 			}
; 705  : 
; 706  : 			if( EMIT_FILEBUF_SIZE!=fwrite(buffer, 1, EMIT_FILEBUF_SIZE, wrk.file_out) )

  0003c	ff 35 2c 00 00
	00		 push	 DWORD PTR _wrk+44
  00042	56		 push	 esi
  00043	6a 01		 push	 1
  00045	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_file@@9@9
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	3b c6		 cmp	 eax, esi
  00055	75 52		 jne	 SHORT $LN24@emit_file

; 710  : 			}
; 711  : 
; 712  : 			position=0;

  00057	33 c0		 xor	 eax, eax
  00059	a3 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, eax
  0005e	3b fe		 cmp	 edi, esi
  00060	73 bc		 jae	 SHORT $LL12@emit_file
$LN23@emit_file:

; 713  : 		}
; 714  : 
; 715  : 		while( length-- ) // if something left that does not need flushing

  00062	85 ff		 test	 edi, edi
  00064	74 14		 je	 SHORT $LN27@emit_file
$LL7@emit_file:

; 716  : 		{
; 717  : 			buffer[position++] = *(bytes++);

  00066	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00068	4f		 dec	 edi
  00069	88 88 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_file@@9@9[eax], cl
  0006f	40		 inc	 eax
  00070	43		 inc	 ebx
  00071	85 ff		 test	 edi, edi
  00073	75 f1		 jne	 SHORT $LL7@emit_file
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?position@?1??emit_file@@9@9, eax
$LN27@emit_file:

; 718  : 		}
; 719  : 
; 720  : 		return 1;

  0007a	33 c0		 xor	 eax, eax
  0007c	40		 inc	 eax
  0007d	eb 3f		 jmp	 SHORT $LN19@emit_file
$LN29@emit_file:

; 721  : 	}
; 722  : 	else if( length==EMIT_FILE_FINISH )

  0007f	75 2f		 jne	 SHORT $LN4@emit_file

; 723  : 	{
; 724  : 		if( position>0 ) // do we have anything to flush?

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?position@?1??emit_file@@9@9
  00086	85 c0		 test	 eax, eax
  00088	76 f0		 jbe	 SHORT $LN27@emit_file

; 725  : 		{
; 726  : 			if( position!=fwrite(buffer, 1, position, wrk.file_out) )

  0008a	ff 35 2c 00 00
	00		 push	 DWORD PTR _wrk+44
  00090	50		 push	 eax
  00091	6a 01		 push	 1
  00093	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_file@@9@9
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
  000a1	39 05 00 00 00
	00		 cmp	 DWORD PTR ?position@?1??emit_file@@9@9, eax
  000a7	74 d1		 je	 SHORT $LN27@emit_file
$LN24@emit_file:

; 707  : 			{
; 708  : 				printf("mhmt-emit.c:emit_file() can't write to file!\n");

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GFCAGLFK@mhmt?9emit?4c?3emit_file?$CI?$CJ?5can?8t?5wr@

; 709  : 				return 0;

  000ae	eb 05		 jmp	 SHORT $LN30@emit_file
$LN4@emit_file:

; 727  : 			{
; 728  : 				printf("mhmt-emit.c:emit_file() can't write to file!\n");
; 729  : 				return 0;
; 730  : 			}
; 731  : 		}
; 732  : 
; 733  : 		return 1;
; 734  : 	}
; 735  : 	else
; 736  : 	{
; 737  : 		printf("mhmt-emit.c:emit_file() encountered invalid arguments!\n");

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PIBOFFDF@mhmt?9emit?4c?3emit_file?$CI?$CJ?5encounte@
$LN30@emit_file:
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000bb	59		 pop	 ecx

; 738  : 		return 0;

  000bc	33 c0		 xor	 eax, eax
$LN19@emit_file:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 739  : 	}
; 740  : }

  000c1	c3		 ret	 0
_emit_file ENDP
PUBLIC	_emit_bits_flush
?bit_store@?1??emit_bits@@9@9 DD 01H DUP (?)		; `emit_bits'::`2'::bit_store
; Function compile flags: /Ogspy
;	COMDAT _emit_bits_flush
_TEXT	SEGMENT
_store_byte$ = -1					; size = 1
_emit_bits_flush PROC					; COMDAT

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 895  : 	UBYTE store_byte;
; 896  : 
; 897  : 	ULONG success = 1;
; 898  : 
; 899  : 	if( wrk.wordbit ) // 16bits

  00004	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _wrk+16, 0
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  00010	53		 push	 ebx
  00011	8b d8		 mov	 ebx, eax
  00013	74 5d		 je	 SHORT $LN4@emit_bits_

; 900  : 	{
; 901  : 		if( wrk.bigend ) // big endian

  00015	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _wrk+20, 0
  0001c	74 1a		 je	 SHORT $LN3@emit_bits_

; 902  : 		{
; 903  : 			store_byte = 0x00FF & (bits >> 8);

  0001e	c1 e8 08	 shr	 eax, 8
  00021	88 45 ff	 mov	 BYTE PTR _store_byte$[ebp], al

; 904  : 			success = success && emit_file( &store_byte, 1);

  00024	8d 45 ff	 lea	 eax, DWORD PTR _store_byte$[ebp]
  00027	50		 push	 eax
  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	e8 00 00 00 00	 call	 _emit_file
  00030	f7 d8		 neg	 eax
  00032	1b c0		 sbb	 eax, eax
  00034	f7 d8		 neg	 eax

; 905  : 
; 906  : 			store_byte = 0x00FF & bits;
; 907  : 			success = success && emit_file( &store_byte, 1);

  00036	eb 1a		 jmp	 SHORT $LN118@emit_bits_
$LN3@emit_bits_:

; 908  : 		}
; 909  : 		else // little endian
; 910  : 		{
; 911  : 			store_byte = 0x00FF & bits;

  00038	88 45 ff	 mov	 BYTE PTR _store_byte$[ebp], al

; 912  : 			success = success && emit_file( &store_byte, 1);

  0003b	8d 45 ff	 lea	 eax, DWORD PTR _store_byte$[ebp]
  0003e	50		 push	 eax
  0003f	33 c0		 xor	 eax, eax
  00041	40		 inc	 eax
  00042	e8 00 00 00 00	 call	 _emit_file
  00047	f7 d8		 neg	 eax
  00049	1b c0		 sbb	 eax, eax
  0004b	f7 d8		 neg	 eax

; 913  : 
; 914  : 			store_byte = 0x00FF & (bits >> 8);

  0004d	c1 eb 08	 shr	 ebx, 8

; 915  : 			success = success && emit_file( &store_byte, 1);

  00050	85 c0		 test	 eax, eax
$LN118@emit_bits_:
  00052	88 5d ff	 mov	 BYTE PTR _store_byte$[ebp], bl
  00055	59		 pop	 ecx
  00056	74 16		 je	 SHORT $LN13@emit_bits_
  00058	8d 45 ff	 lea	 eax, DWORD PTR _store_byte$[ebp]
  0005b	50		 push	 eax
  0005c	33 c0		 xor	 eax, eax
  0005e	40		 inc	 eax
  0005f	e8 00 00 00 00	 call	 _emit_file
  00064	59		 pop	 ecx
  00065	85 c0		 test	 eax, eax
  00067	74 05		 je	 SHORT $LN13@emit_bits_
  00069	33 c0		 xor	 eax, eax
  0006b	40		 inc	 eax
  0006c	eb 1a		 jmp	 SHORT $LN15@emit_bits_
$LN13@emit_bits_:
  0006e	33 c0		 xor	 eax, eax

; 916  : 		}
; 917  : 	}
; 918  : 	else // 8bits

  00070	eb 16		 jmp	 SHORT $LN15@emit_bits_
$LN4@emit_bits_:

; 919  : 	{
; 920  : 		store_byte = 0x00FF & bits;

  00072	88 45 ff	 mov	 BYTE PTR _store_byte$[ebp], al

; 921  : 		success = success && emit_file( &store_byte, 1);

  00075	8d 45 ff	 lea	 eax, DWORD PTR _store_byte$[ebp]
  00078	50		 push	 eax
  00079	33 c0		 xor	 eax, eax
  0007b	40		 inc	 eax
  0007c	e8 00 00 00 00	 call	 _emit_file
  00081	f7 d8		 neg	 eax
  00083	1b c0		 sbb	 eax, eax
  00085	59		 pop	 ecx
  00086	f7 d8		 neg	 eax
$LN15@emit_bits_:
  00088	5b		 pop	 ebx

; 922  : 	}
; 923  : 
; 924  : 	return success;
; 925  : }

  00089	c9		 leave
  0008a	c3		 ret	 0
_emit_bits_flush ENDP
_TEXT	ENDS
PUBLIC	_emit_byte
?out_pos@?1??emit_byte@@9@9 DD 01H DUP (?)		; `emit_byte'::`2'::out_pos
?buffer@?1??emit_byte@@9@9 DB 0100H DUP (?)		; `emit_byte'::`2'::buffer
?in_pos@?1??emit_byte@@9@9 DD 01H DUP (?)		; `emit_byte'::`2'::in_pos
; Function compile flags: /Ogspy
;	COMDAT _emit_byte
_TEXT	SEGMENT
_byte$ = 8						; size = 1
_emit_byte PROC						; COMDAT
; _operation$ = eax

; 748  : {

  00000	56		 push	 esi

; 749  : 	static UBYTE buffer[EMIT_BYTEBUF_SIZE];
; 750  : 
; 751  : 	static ULONG in_pos, out_pos;
; 752  : 
; 753  : 	ULONG success;
; 754  : 
; 755  : 
; 756  : 	switch( operation )

  00001	33 f6		 xor	 esi, esi
  00003	2b c6		 sub	 eax, esi
  00005	0f 84 d3 00 00
	00		 je	 $LN10@emit_byte
  0000b	48		 dec	 eax
  0000c	74 40		 je	 SHORT $LN7@emit_byte
  0000e	48		 dec	 eax
  0000f	74 07		 je	 SHORT $LN9@emit_byte

; 803  : 		return success;
; 804  : 
; 805  : 	default:
; 806  : 		printf("mhmt-emit.c:emit_byte() encountered invalid arguments!\n");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@BCGDHPHO@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5encounte@

; 807  : 		return 0;

  00016	eb 2b		 jmp	 SHORT $LN80@emit_byte
$LN9@emit_byte:

; 764  : 
; 765  : 
; 766  : 	case EMIT_BYTE_ADD:
; 767  : 
; 768  : 		#ifdef DBG
; 769  : 			printf("<%02x>",byte&0x00FF);
; 770  : 		#endif
; 771  : 
; 772  : 		buffer[in_pos] = byte;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  0001d	8a 4c 24 08	 mov	 cl, BYTE PTR _byte$[esp]
  00021	88 88 00 00 00
	00		 mov	 BYTE PTR ?buffer@?1??emit_byte@@9@9[eax], cl

; 773  : 
; 774  : 		in_pos = (in_pos+1) & (EMIT_BYTEBUF_SIZE-1);

  00027	40		 inc	 eax
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, eax

; 775  : 
; 776  : 
; 777  : 		if( in_pos==out_pos ) // overflow!

  00032	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00038	0f 85 ac 00 00
	00		 jne	 $LN8@emit_byte

; 778  : 		{
; 779  : 			printf("mhmt-emit.c:emit_byte() buffer overflow!\n");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@ILMDOCHH@mhmt?9emit?4c?3emit_byte?$CI?$CJ?5buffer?5o@
$LN80@emit_byte:
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00049	59		 pop	 ecx

; 780  : 			return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	5e		 pop	 esi

; 808  : 	}
; 809  : }

  0004d	c3		 ret	 0
$LN7@emit_byte:

; 781  : 		}
; 782  : 
; 783  : 		return 1;
; 784  : 
; 785  : 
; 786  : 	case EMIT_BYTE_FLUSH:
; 787  : 
; 788  : 		if( in_pos==out_pos ) // nothing to do?

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?out_pos@?1??emit_byte@@9@9
  00059	3b c1		 cmp	 eax, ecx

; 789  : 			return 1;

  0005b	0f 84 89 00 00
	00		 je	 $LN8@emit_byte

; 790  : 		else if( in_pos>out_pos ) // no index wraparound

  00061	76 16		 jbe	 SHORT $LN4@emit_byte

; 791  : 		{
; 792  : 			success = emit_file( &buffer[out_pos], in_pos-out_pos );

  00063	2b c1		 sub	 eax, ecx
  00065	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?buffer@?1??emit_byte@@9@9[ecx]
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	74 40		 je	 SHORT $LN81@emit_byte
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _emit_file
  00076	59		 pop	 ecx

; 793  : 		}
; 794  : 		else // in_pos<out_pos - wraparound

  00077	eb 57		 jmp	 SHORT $LN16@emit_byte
$LN4@emit_byte:

; 795  : 		{
; 796  : 			success = emit_file( &buffer[out_pos], EMIT_BYTEBUF_SIZE-out_pos );

  00079	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0007e	2b c1		 sub	 eax, ecx
  00080	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?buffer@?1??emit_byte@@9@9[ecx]
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 0b		 jne	 SHORT $LN56@emit_byte
  0008b	33 c0		 xor	 eax, eax
  0008d	89 35 00 00 00
	00		 mov	 DWORD PTR ?position@?1??emit_file@@9@9, esi
  00093	40		 inc	 eax
  00094	eb 07		 jmp	 SHORT $LN52@emit_byte
$LN56@emit_byte:
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _emit_file
  0009c	59		 pop	 ecx
$LN52@emit_byte:

; 797  : 
; 798  : 			if( in_pos )

  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  000a3	3b ce		 cmp	 ecx, esi
  000a5	74 29		 je	 SHORT $LN16@emit_byte

; 799  : 				success = success && emit_file( &buffer[0], in_pos );

  000a7	3b c6		 cmp	 eax, esi
  000a9	74 23		 je	 SHORT $LN78@emit_byte
  000ab	83 f9 ff	 cmp	 ecx, -1
  000ae	75 08		 jne	 SHORT $LN76@emit_byte
$LN81@emit_byte:
  000b0	89 35 00 00 00
	00		 mov	 DWORD PTR ?position@?1??emit_file@@9@9, esi
  000b6	eb 11		 jmp	 SHORT $LN77@emit_byte
$LN76@emit_byte:
  000b8	68 00 00 00 00	 push	 OFFSET ?buffer@?1??emit_byte@@9@9
  000bd	8b c1		 mov	 eax, ecx
  000bf	e8 00 00 00 00	 call	 _emit_file
  000c4	59		 pop	 ecx
  000c5	3b c6		 cmp	 eax, esi
  000c7	74 05		 je	 SHORT $LN78@emit_byte
$LN77@emit_byte:
  000c9	33 c0		 xor	 eax, eax
  000cb	40		 inc	 eax
  000cc	eb 02		 jmp	 SHORT $LN16@emit_byte
$LN78@emit_byte:
  000ce	33 c0		 xor	 eax, eax
$LN16@emit_byte:

; 800  : 		}
; 801  : 
; 802  : 		out_pos=in_pos;

  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?in_pos@?1??emit_byte@@9@9
  000d6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, ecx
  000dc	5e		 pop	 esi

; 808  : 	}
; 809  : }

  000dd	c3		 ret	 0
$LN10@emit_byte:

; 757  : 	{
; 758  : 	case EMIT_BYTE_INIT:
; 759  : 
; 760  : 		in_pos  = 0;

  000de	89 35 00 00 00
	00		 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, esi

; 761  : 		out_pos = 0;

  000e4	89 35 00 00 00
	00		 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, esi
$LN8@emit_byte:

; 762  : 
; 763  : 		return 1;

  000ea	33 c0		 xor	 eax, eax
  000ec	40		 inc	 eax
  000ed	5e		 pop	 esi

; 808  : 	}
; 809  : }

  000ee	c3		 ret	 0
_emit_byte ENDP
PUBLIC	_emit_bits
?bit_count@?1??emit_bits@@9@9 DD 01H DUP (?)		; `emit_bits'::`2'::bit_count
; Function compile flags: /Ogspy
;	COMDAT _emit_bits
_TEXT	SEGMENT
_msb_aligned_bits$ = 8					; size = 4
_length$ = 12						; size = 4
_emit_bits PROC						; COMDAT

; 816  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 817  : 	static ULONG bit_store;
; 818  : 	static ULONG bit_count;
; 819  : 
; 820  : 	ULONG max_bits;
; 821  : 
; 822  : 	ULONG success = 1;

  00004	33 c0		 xor	 eax, eax

; 823  : 
; 824  : 
; 825  : 	max_bits = wrk.wordbit ? 16 : 8;

  00006	33 c9		 xor	 ecx, ecx
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	40		 inc	 eax
  0000c	39 3d 10 00 00
	00		 cmp	 DWORD PTR _wrk+16, edi
  00012	0f 95 c1	 setne	 cl
  00015	8d 0c cd 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*8+8]
  0001c	8b f1		 mov	 esi, ecx

; 826  : 
; 827  : 	if( length==EMIT_BITS_INIT )
; 828  : 	{
; 829  : 		bit_store = 0;
; 830  : 		bit_count = 0;
; 831  : 		return 1;
; 832  : 	}
; 833  : 	else if( length==EMIT_BITS_FINISH )

  0001e	39 7d 0c	 cmp	 DWORD PTR _length$[ebp], edi
  00021	75 49		 jne	 SHORT $LN47@emit_bits

; 834  : 	{
; 835  : 		if( bit_count ) // some bits to flush

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  00028	3b c7		 cmp	 eax, edi
  0002a	74 26		 je	 SHORT $LN38@emit_bits

; 836  : 		{
; 837  : 			while( (bit_count++)<max_bits )

  0002c	3b c6		 cmp	 eax, esi
  0002e	73 0f		 jae	 SHORT $LN36@emit_bits
  00030	2b f0		 sub	 esi, eax
  00032	8b ce		 mov	 ecx, esi
  00034	03 c1		 add	 eax, ecx
$LL12@emit_bits:

; 838  : 				bit_store <<= 1;

  00036	d1 25 00 00 00
	00		 shl	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, 1
  0003c	49		 dec	 ecx
  0003d	75 f7		 jne	 SHORT $LL12@emit_bits
$LN36@emit_bits:

; 836  : 		{
; 837  : 			while( (bit_count++)<max_bits )

  0003f	40		 inc	 eax
  00040	a3 00 00 00 00	 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, eax

; 839  : 
; 840  : 			success = success && emit_bits_flush(bit_store);

  00045	e8 00 00 00 00	 call	 _emit_bits_flush
  0004a	85 c0		 test	 eax, eax

; 841  : 		}
; 842  : 
; 843  : 		success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  0004c	0f 84 c5 00 00
	00		 je	 $LN21@emit_bits
$LN38@emit_bits:
  00052	33 c0		 xor	 eax, eax
  00054	57		 push	 edi
  00055	40		 inc	 eax
  00056	e8 00 00 00 00	 call	 _emit_byte
  0005b	59		 pop	 ecx
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 b3 00 00
	00		 je	 $LN21@emit_bits
  00064	33 c0		 xor	 eax, eax
  00066	40		 inc	 eax
  00067	e9 ad 00 00 00	 jmp	 $LN32@emit_bits
$LN47@emit_bits:

; 844  : 
; 845  : 		return success;
; 846  : 	}
; 847  : 	else if( length>0 ) // add bits

  0006c	0f 8e 99 00 00
	00		 jle	 $LN9@emit_bits
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?bit_count@?1??emit_bits@@9@9
  00078	53		 push	 ebx
$LL8@emit_bits:

; 848  : 	{
; 849  : 		do
; 850  : 		{
; 851  : 			if( !wrk.fullbits ) // empty bits - check for flushing before shiftin

  00079	39 3d 18 00 00
	00		 cmp	 DWORD PTR _wrk+24, edi
  0007f	75 28		 jne	 SHORT $LN4@emit_bits

; 852  : 			{
; 853  : 				if( bit_count==max_bits )

  00081	3b ce		 cmp	 ecx, esi
  00083	75 24		 jne	 SHORT $LN4@emit_bits

; 854  : 				{
; 855  : 					success = success && emit_bits_flush(bit_store);

  00085	3b c7		 cmp	 eax, edi
  00087	74 1c		 je	 SHORT $LN41@emit_bits
  00089	e8 00 00 00 00	 call	 _emit_bits_flush
  0008e	85 c0		 test	 eax, eax

; 856  : 					success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  00090	74 13		 je	 SHORT $LN41@emit_bits
  00092	33 c0		 xor	 eax, eax
  00094	57		 push	 edi
  00095	40		 inc	 eax
  00096	e8 00 00 00 00	 call	 _emit_byte
  0009b	59		 pop	 ecx
  0009c	85 c0		 test	 eax, eax
  0009e	74 05		 je	 SHORT $LN41@emit_bits
  000a0	33 c0		 xor	 eax, eax
  000a2	40		 inc	 eax
  000a3	eb 02		 jmp	 SHORT $LN26@emit_bits
$LN41@emit_bits:
  000a5	33 c0		 xor	 eax, eax
$LN26@emit_bits:

; 857  : 
; 858  : 					bit_count = 0;

  000a7	33 c9		 xor	 ecx, ecx
$LN4@emit_bits:

; 859  : 				}
; 860  : 			}
; 861  : 
; 862  : 			#ifdef DBG
; 863  : 				printf("%d",1&(msb_aligned_bits>>31));
; 864  : 			#endif
; 865  : 			bit_store = (bit_store<<1) | ( 1 & (msb_aligned_bits>>31) );

  000a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?bit_store@?1??emit_bits@@9@9
  000af	8b 5d 08	 mov	 ebx, DWORD PTR _msb_aligned_bits$[ebp]

; 866  : 			msb_aligned_bits <<= 1;

  000b2	d1 65 08	 shl	 DWORD PTR _msb_aligned_bits$[ebp], 1
  000b5	03 d2		 add	 edx, edx
  000b7	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000ba	0b d3		 or	 edx, ebx

; 867  : 			bit_count++;

  000bc	41		 inc	 ecx
  000bd	89 15 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, edx
  000c3	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, ecx

; 868  : 
; 869  : 			if( wrk.fullbits ) // full bits - check for flushing after bit shiftin

  000c9	39 3d 18 00 00
	00		 cmp	 DWORD PTR _wrk+24, edi
  000cf	74 2e		 je	 SHORT $LN7@emit_bits

; 870  : 			{
; 871  : 				if( bit_count==max_bits )

  000d1	3b ce		 cmp	 ecx, esi
  000d3	75 2a		 jne	 SHORT $LN7@emit_bits

; 872  : 				{
; 873  : 					success = success && emit_bits_flush(bit_store);

  000d5	3b c7		 cmp	 eax, edi
  000d7	74 1c		 je	 SHORT $LN43@emit_bits
  000d9	e8 00 00 00 00	 call	 _emit_bits_flush
  000de	85 c0		 test	 eax, eax

; 874  : 					success = success && emit_byte(0, EMIT_BYTE_FLUSH);

  000e0	74 13		 je	 SHORT $LN43@emit_bits
  000e2	33 c0		 xor	 eax, eax
  000e4	57		 push	 edi
  000e5	40		 inc	 eax
  000e6	e8 00 00 00 00	 call	 _emit_byte
  000eb	59		 pop	 ecx
  000ec	85 c0		 test	 eax, eax
  000ee	74 05		 je	 SHORT $LN43@emit_bits
  000f0	33 c0		 xor	 eax, eax
  000f2	40		 inc	 eax
  000f3	eb 02		 jmp	 SHORT $LN30@emit_bits
$LN43@emit_bits:
  000f5	33 c0		 xor	 eax, eax
$LN30@emit_bits:

; 875  : 
; 876  : 					bit_count = 0;

  000f7	33 c9		 xor	 ecx, ecx
  000f9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, ecx
$LN7@emit_bits:

; 877  : 				}
; 878  : 			}
; 879  : 
; 880  : 		} while( --length );

  000ff	ff 4d 0c	 dec	 DWORD PTR _length$[ebp]
  00102	0f 85 71 ff ff
	ff		 jne	 $LL8@emit_bits
  00108	5b		 pop	 ebx

; 881  : 
; 882  : 		return success;

  00109	eb 0e		 jmp	 SHORT $LN32@emit_bits
$LN9@emit_bits:

; 883  : 	}
; 884  : 	else
; 885  : 	{
; 886  : 		printf("mhmt-emit.c:emit_bits() encountered invalid arguments!\n");

  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IPFABJLD@mhmt?9emit?4c?3emit_bits?$CI?$CJ?5encounte@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00116	59		 pop	 ecx
$LN21@emit_bits:

; 887  : 		return 0;

  00117	33 c0		 xor	 eax, eax
$LN32@emit_bits:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi

; 888  : 	}
; 889  : }

  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
_emit_bits ENDP
_TEXT	ENDS
PUBLIC	_emit_hrust
; Function compile flags: /Ogspy
;	COMDAT _emit_hrust
_TEXT	SEGMENT
_length$ = -16						; size = 4
_wrlen$ = -16						; size = 2
_position$ = -12					; size = 4
_expbitlen$ = -8					; size = 4
_max_disp$ = -4						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_hrust PROC					; COMDAT

; 341  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	56		 push	 esi
  00004	57		 push	 edi

; 342  : 	ULONG position;
; 343  : 	LONG length;
; 344  : 	LONG disp;
; 345  : 
; 346  : 	LONG max_disp; // maximum encountered displacement
; 347  : 
; 348  : 	ULONG varbits,varlen;
; 349  : 	ULONG success = 1;
; 350  : 
; 351  : 	UBYTE wrlen[2];
; 352  : 
; 353  : 	ULONG expbitlen = 2; // expandable match: bitlength of displacement

  00005	6a 02		 push	 2

; 354  : 
; 355  : 
; 356  : 	max_disp = 0;

  00007	33 ff		 xor	 edi, edi
  00009	5e		 pop	 esi
  0000a	89 74 24 10	 mov	 DWORD PTR _expbitlen$[esp+24], esi
  0000e	89 7c 24 14	 mov	 DWORD PTR _max_disp$[esp+24], edi

; 357  : 
; 358  : 
; 359  : 	// some checks
; 360  : 	if( !optch )

  00012	39 7c 24 1c	 cmp	 DWORD PTR _optch$[esp+20], edi
  00016	75 13		 jne	 SHORT $LN60@emit_hrust

; 361  : 	{
; 362  : 		printf("mhmt-emit.c:emit_hrust() - NULL passed!\n");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EOIDLNAA@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5NULL?5@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00023	59		 pop	 ecx

; 363  : 		return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 ab 05 00 00	 jmp	 $LN61@emit_hrust
$LN60@emit_hrust:
  0002b	55		 push	 ebp

; 364  : 	}
; 365  : 
; 366  : 	// initialize
; 367  : 	success = success && emit_file(NULL, EMIT_FILE_INIT);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?position@?1??emit_file@@9@9, edi

; 368  : 
; 369  : 	success = success && emit_byte(0, EMIT_BYTE_INIT);

  00032	89 3d 00 00 00
	00		 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, edi
  00038	89 3d 00 00 00
	00		 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, edi

; 370  : 
; 371  : 	success = success && emit_bits(0, EMIT_BITS_INIT);

  0003e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, edi
  00044	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, edi

; 372  : 
; 373  : 
; 374  : 	// manage zx header info
; 375  : 	if( wrk.zxheader )

  0004a	39 3d 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, edi
  00050	74 64		 je	 SHORT $LN1437@emit_hrust

; 376  : 	{
; 377  : 		success = success && emit_file( (UBYTE*)"HR", 2);

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_02PGLKMFED@HR?$AA@
  00057	8b c6		 mov	 eax, esi
  00059	e8 00 00 00 00	 call	 _emit_file
  0005e	f7 d8		 neg	 eax
  00060	1b c0		 sbb	 eax, eax
  00062	59		 pop	 ecx

; 378  : 
; 379  : 		wrlen[0] = wrk.inlen&0x00FF;

  00063	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR _wrk+52
  00069	f7 d8		 neg	 eax
  0006b	88 4c 24 0c	 mov	 BYTE PTR _wrlen$[esp+28], cl

; 380  : 		wrlen[1] = (wrk.inlen>>8)&0x00FF;

  0006f	88 6c 24 0d	 mov	 BYTE PTR _wrlen$[esp+29], ch

; 381  : 		success = success && emit_file( wrlen, 2); // unpacked length mod 65536

  00073	3b c7		 cmp	 eax, edi
  00075	74 5b		 je	 SHORT $LN77@emit_hrust
  00077	8d 44 24 0c	 lea	 eax, DWORD PTR _wrlen$[esp+28]
  0007b	50		 push	 eax
  0007c	8b c6		 mov	 eax, esi
  0007e	e8 00 00 00 00	 call	 _emit_file
  00083	59		 pop	 ecx
  00084	85 c0		 test	 eax, eax

; 382  : 
; 383  : 		success = success && emit_file( wrlen, 2); // packed length - !to be filled later!

  00086	74 4a		 je	 SHORT $LN77@emit_hrust
  00088	8d 44 24 0c	 lea	 eax, DWORD PTR _wrlen$[esp+28]
  0008c	50		 push	 eax
  0008d	8b c6		 mov	 eax, esi
  0008f	e8 00 00 00 00	 call	 _emit_file
  00094	59		 pop	 ecx
  00095	85 c0		 test	 eax, eax

; 384  : 
; 385  :         success = success && emit_file( &wrk.indata[wrk.inlen-6], 6); // last bytes

  00097	74 39		 je	 SHORT $LN77@emit_hrust
  00099	a1 34 00 00 00	 mov	 eax, DWORD PTR _wrk+52
  0009e	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  000a4	8d 44 01 fa	 lea	 eax, DWORD PTR [ecx+eax-6]
  000a8	50		 push	 eax
  000a9	6a 06		 push	 6
  000ab	58		 pop	 eax
  000ac	e8 00 00 00 00	 call	 _emit_file
  000b1	59		 pop	 ecx
  000b2	85 c0		 test	 eax, eax

; 386  : 	}
; 387  : 
; 388  : 	// schedule first byte to be placed just after first bitstream word
; 389  : 	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

  000b4	74 1c		 je	 SHORT $LN77@emit_hrust
$LN1437@emit_hrust:
  000b6	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000bb	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000be	50		 push	 eax
  000bf	8b c6		 mov	 eax, esi
  000c1	e8 00 00 00 00	 call	 _emit_byte
  000c6	59		 pop	 ecx
  000c7	85 c0		 test	 eax, eax
  000c9	74 07		 je	 SHORT $LN77@emit_hrust
  000cb	33 ed		 xor	 ebp, ebp
  000cd	45		 inc	 ebp
  000ce	8b c5		 mov	 eax, ebp
  000d0	eb 05		 jmp	 SHORT $LN78@emit_hrust
$LN77@emit_hrust:
  000d2	33 ed		 xor	 ebp, ebp
  000d4	33 c0		 xor	 eax, eax
  000d6	45		 inc	 ebp
$LN78@emit_hrust:
  000d7	53		 push	 ebx

; 390  : 
; 391  : 	// go emitting codes
; 392  : 	position = 1;

  000d8	89 6c 24 14	 mov	 DWORD PTR _position$[esp+32], ebp

; 393  : 
; 394  : 	while( (position<actual_len) && success )

  000dc	39 6c 24 28	 cmp	 DWORD PTR _actual_len$[esp+28], ebp
  000e0	0f 86 a6 04 00
	00		 jbe	 $LN57@emit_hrust
$LL58@emit_hrust:
  000e6	3b c7		 cmp	 eax, edi
  000e8	0f 84 10 05 00
	00		 je	 $LN167@emit_hrust

; 395  : 	{
; 396  : 		#ifdef DBG
; 397  : 			printf("%04x:",position);
; 398  : 		#endif
; 399  : 
; 400  : 		length = optch[position].code.length;

  000ee	8b 74 24 14	 mov	 esi, DWORD PTR _position$[esp+32]
  000f2	8b 54 24 24	 mov	 edx, DWORD PTR _optch$[esp+28]
  000f6	8b ce		 mov	 ecx, esi
  000f8	c1 e1 04	 shl	 ecx, 4
  000fb	03 ca		 add	 ecx, edx
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]

; 401  : 		disp   = optch[position].code.disp;

  000ff	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  00102	89 54 24 10	 mov	 DWORD PTR _length$[esp+32], edx

; 402  : 
; 403  : 		if( length==0 )

  00106	3b d7		 cmp	 edx, edi
  00108	0f 84 ce 04 00
	00		 je	 $LN1426@emit_hrust

; 407  : 		}
; 408  : 		else if( disp==0 ) // copy-bytes

  0010e	3b df		 cmp	 ebx, edi
  00110	0f 85 a1 00 00
	00		 jne	 $LN54@emit_hrust

; 409  : 		{
; 410  : 			if( length==1 ) // 1 byte: %1<byte>

  00116	3b d5		 cmp	 edx, ebp
  00118	75 24		 jne	 SHORT $LN53@emit_hrust

; 411  : 			{
; 412  : 				success = success && emit_bits( 0x80000000, 1 );

  0011a	55		 push	 ebp
  0011b	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00120	e8 00 00 00 00	 call	 _emit_bits
  00125	59		 pop	 ecx
  00126	59		 pop	 ecx
  00127	85 c0		 test	 eax, eax

; 413  : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  00129	0f 84 c2 00 00
	00		 je	 $LN1472@emit_hrust
  0012f	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00134	0f b6 04 30	 movzx	 eax, BYTE PTR [eax+esi]
$LN1490@emit_hrust:
  00138	50		 push	 eax
  00139	e9 24 04 00 00	 jmp	 $LN1478@emit_hrust
$LN53@emit_hrust:

; 414  : 			}
; 415  : 			else if( (12<=length) && (length<=42) && ( !(length&1) ) ) // %0110001abcd<byte,byte,...>

  0013e	8d 42 f4	 lea	 eax, DWORD PTR [edx-12]
  00141	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00144	0f 87 a0 04 00
	00		 ja	 $INVALID_CODE_HRUST$2781
  0014a	f6 c2 01	 test	 dl, 1
  0014d	0f 85 97 04 00
	00		 jne	 $INVALID_CODE_HRUST$2781

; 416  : 			{
; 417  : 				varbits = (length-12)<<27;

  00153	8d 72 f4	 lea	 esi, DWORD PTR [edx-12]

; 418  : 				success = success && emit_bits( 0x62000000, 7 );

  00156	6a 07		 push	 7
  00158	68 00 00 00 62	 push	 1644167168		; 62000000H
  0015d	c1 e6 1b	 shl	 esi, 27			; 0000001bH
  00160	e8 00 00 00 00	 call	 _emit_bits
  00165	59		 pop	 ecx
  00166	59		 pop	 ecx
  00167	85 c0		 test	 eax, eax

; 419  : 
; 420  : 				success = success && emit_bits( varbits, 4 );

  00169	74 12		 je	 SHORT $LN85@emit_hrust
  0016b	6a 04		 push	 4
  0016d	56		 push	 esi
  0016e	e8 00 00 00 00	 call	 _emit_bits
  00173	59		 pop	 ecx
  00174	59		 pop	 ecx
  00175	85 c0		 test	 eax, eax
  00177	74 04		 je	 SHORT $LN85@emit_hrust
  00179	8b c5		 mov	 eax, ebp
  0017b	eb 02		 jmp	 SHORT $LN86@emit_hrust
$LN85@emit_hrust:
  0017d	33 c0		 xor	 eax, eax
$LN86@emit_hrust:

; 421  : 
; 422  : 				varlen = 0;

  0017f	33 f6		 xor	 esi, esi
  00181	eb 2e		 jmp	 SHORT $LN1479@emit_hrust
$LL50@emit_hrust:

; 423  : 				while( success && (varlen<(ULONG)length) )

  00183	3b 74 24 10	 cmp	 esi, DWORD PTR _length$[esp+32]
  00187	73 6a		 jae	 SHORT $LN1473@emit_hrust

; 424  : 				{
; 425  : 					success = success && emit_byte( wrk.indata[position+varlen], EMIT_BYTE_ADD );

  00189	3b c7		 cmp	 eax, edi
  0018b	74 21		 je	 SHORT $LN87@emit_hrust
  0018d	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00192	8b 4c 24 14	 mov	 ecx, DWORD PTR _position$[esp+32]
  00196	03 c6		 add	 eax, esi
  00198	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0019c	50		 push	 eax
  0019d	6a 02		 push	 2
  0019f	58		 pop	 eax
  001a0	e8 00 00 00 00	 call	 _emit_byte
  001a5	59		 pop	 ecx
  001a6	85 c0		 test	 eax, eax
  001a8	74 04		 je	 SHORT $LN87@emit_hrust
  001aa	8b c5		 mov	 eax, ebp
  001ac	eb 02		 jmp	 SHORT $LN88@emit_hrust
$LN87@emit_hrust:
  001ae	33 c0		 xor	 eax, eax
$LN88@emit_hrust:

; 426  : 					varlen++;

  001b0	46		 inc	 esi
$LN1479@emit_hrust:

; 423  : 				while( success && (varlen<(ULONG)length) )

  001b1	3b c7		 cmp	 eax, edi
  001b3	75 ce		 jne	 SHORT $LL50@emit_hrust

; 427  : 				}
; 428  : 			}
; 429  : 			else
; 430  : 				goto INVALID_CODE_HRUST;
; 431  : 		}
; 432  : 		else if( length==(-3) ) // insertion code

  001b5	eb 3c		 jmp	 SHORT $LN1473@emit_hrust
$LN54@emit_hrust:
  001b7	83 fa fd	 cmp	 edx, -3			; fffffffdH
  001ba	0f 85 cc 00 00
	00		 jne	 $LN46@emit_hrust

; 433  : 		{
; 434  : 			if( (-16)<=disp && disp<=(-1) ) // %011001abcd<byte>

  001c0	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  001c3	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001c6	77 4a		 ja	 SHORT $LN45@emit_hrust

; 435  : 			{
; 436  : 				success = success && emit_bits( 0x64000000, 6 );

  001c8	6a 06		 push	 6
  001ca	68 00 00 00 64	 push	 1677721600		; 64000000H
  001cf	e8 00 00 00 00	 call	 _emit_bits
  001d4	59		 pop	 ecx
  001d5	59		 pop	 ecx
  001d6	85 c0		 test	 eax, eax

; 437  : 				success = success && emit_bits( disp<<(32-4), 4 );

  001d8	74 17		 je	 SHORT $LN1472@emit_hrust
  001da	8b c3		 mov	 eax, ebx
  001dc	c1 e0 1c	 shl	 eax, 28			; 0000001cH
  001df	6a 04		 push	 4
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _emit_bits
  001e7	59		 pop	 ecx
$LN1480@emit_hrust:
  001e8	59		 pop	 ecx
  001e9	85 c0		 test	 eax, eax
  001eb	0f 85 8c 00 00
	00		 jne	 $LN1474@emit_hrust
$LN1472@emit_hrust:

; 598  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  001f1	33 c0		 xor	 eax, eax
$LN1473@emit_hrust:

; 606  : 		}
; 607  : 
; 608  : 		#ifdef DBG
; 609  : 			if( length==(-3) )
; 610  : 			{
; 611  : 				printf("insert-match.len=%d,disp=%d\n",(-length),disp);
; 612  : 			}
; 613  : 			else if( disp==0 )
; 614  : 			{
; 615  : 				printf("copy.len=%d\n",length);
; 616  : 			}
; 617  : 			else
; 618  : 			{
; 619  : 				printf("match.len=%d,disp=%d\n",length,disp);
; 620  : 			}
; 621  : 		#endif
; 622  : 
; 623  : 
; 624  : 		if( max_disp > disp ) max_disp = disp;

  001f3	39 5c 24 1c	 cmp	 DWORD PTR _max_disp$[esp+32], ebx
  001f7	7e 04		 jle	 SHORT $LN4@emit_hrust
  001f9	89 5c 24 1c	 mov	 DWORD PTR _max_disp$[esp+32], ebx
$LN4@emit_hrust:

; 625  : 
; 626  : 		if( length>0 ) // account for negative length

  001fd	8b 4c 24 10	 mov	 ecx, DWORD PTR _length$[esp+32]
  00201	3b cf		 cmp	 ecx, edi
  00203	0f 8e 71 03 00
	00		 jle	 $LN3@emit_hrust

; 627  : 			position += length;

  00209	01 4c 24 14	 add	 DWORD PTR _position$[esp+32], ecx

; 628  : 		else

  0020d	e9 6c 03 00 00	 jmp	 $LN2@emit_hrust
$LN45@emit_hrust:

; 438  : 			}
; 439  : 			else if( (-79)<=disp && disp<(-16) )

  00212	8d 43 4f	 lea	 eax, DWORD PTR [ebx+79]
  00215	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  00218	0f 87 cc 03 00
	00		 ja	 $INVALID_CODE_HRUST$2781

; 440  : 			{
; 441  : 				if( disp&1 ) // ffb1..ffef: %01001<byte><byte>
; 442  : 				{
; 443  : 					success = success && emit_bits( 0x48000000, 5 );

  0021e	6a 05		 push	 5
  00220	f6 c3 01	 test	 bl, 1
  00223	74 1d		 je	 SHORT $LN42@emit_hrust
  00225	68 00 00 00 48	 push	 1207959552		; 48000000H
  0022a	e8 00 00 00 00	 call	 _emit_bits
  0022f	59		 pop	 ecx
  00230	59		 pop	 ecx
  00231	f7 d8		 neg	 eax

; 444  : 
; 445  : 					varbits = disp&0x00FF;

  00233	0f b6 cb	 movzx	 ecx, bl
  00236	1b c0		 sbb	 eax, eax

; 446  : 					varbits += 15;

  00238	83 c1 0f	 add	 ecx, 15			; 0000000fH
  0023b	f7 d8		 neg	 eax

; 447  : 					varbits ^= 3;

  0023d	83 f1 03	 xor	 ecx, 3

; 448  : 					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );
; 449  : 
; 450  : 					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );
; 451  : 				}
; 452  : 				else // ffb2..ffee: %00110<byte><byte>

  00240	eb 1b		 jmp	 SHORT $LN1495@emit_hrust
$LN42@emit_hrust:

; 453  : 				{
; 454  : 					success = success && emit_bits( 0x30000000, 5 );

  00242	68 00 00 00 30	 push	 805306368		; 30000000H
  00247	e8 00 00 00 00	 call	 _emit_bits
  0024c	59		 pop	 ecx
  0024d	59		 pop	 ecx
  0024e	f7 d8		 neg	 eax

; 455  : 
; 456  : 					varbits = disp&0x00FF;

  00250	0f b6 cb	 movzx	 ecx, bl
  00253	1b c0		 sbb	 eax, eax

; 457  : 					varbits += 15;

  00255	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00258	f7 d8		 neg	 eax

; 458  : 					varbits ^= 2;

  0025a	83 f1 02	 xor	 ecx, 2
$LN1495@emit_hrust:

; 459  : 					varbits = ( (varbits>>1)&0x007F ) | ( (varbits<<7)&0x0080 );
; 460  : 
; 461  : 					success = success && emit_byte( (UBYTE)(varbits&0x00FF), EMIT_BYTE_ADD );

  0025d	3b c7		 cmp	 eax, edi
  0025f	74 90		 je	 SHORT $LN1472@emit_hrust
  00261	8b c1		 mov	 eax, ecx
  00263	d1 e8		 shr	 eax, 1
  00265	24 7f		 and	 al, 127			; 0000007fH
  00267	c0 e1 07	 shl	 cl, 7
  0026a	0a c1		 or	 al, cl
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	50		 push	 eax
  00270	6a 02		 push	 2
  00272	58		 pop	 eax
  00273	e8 00 00 00 00	 call	 _emit_byte
  00278	e9 6b ff ff ff	 jmp	 $LN1480@emit_hrust
$LN1474@emit_hrust:

; 462  : 				}
; 463  : 			}
; 464  : 			else
; 465  : 				goto INVALID_CODE_HRUST;
; 466  : 
; 467  : 			success = success && emit_byte( wrk.indata[position+1], EMIT_BYTE_ADD );

  0027d	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00282	0f b6 44 30 01	 movzx	 eax, BYTE PTR [eax+esi+1]
  00287	e9 ac fe ff ff	 jmp	 $LN1490@emit_hrust
$LN46@emit_hrust:

; 468  : 		}
; 469  : 		else if( length==1 ) // %000abc

  0028c	3b d5		 cmp	 edx, ebp
  0028e	75 31		 jne	 SHORT $LN38@emit_hrust

; 470  : 		{
; 471  : 			if( (-8)<=disp && disp<=(-1) )

  00290	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00293	83 f8 07	 cmp	 eax, 7
  00296	0f 87 4e 03 00
	00		 ja	 $INVALID_CODE_HRUST$2781

; 472  : 			{
; 473  : 				success = success && emit_bits( 0x00000000, 3 );

  0029c	6a 03		 push	 3
  0029e	57		 push	 edi
  0029f	e8 00 00 00 00	 call	 _emit_bits
  002a4	59		 pop	 ecx
  002a5	59		 pop	 ecx
  002a6	85 c0		 test	 eax, eax

; 474  : 				success = success && emit_bits( disp<<(32-3), 3 );

  002a8	0f 84 43 ff ff
	ff		 je	 $LN1472@emit_hrust
  002ae	8b c3		 mov	 eax, ebx
  002b0	6a 03		 push	 3
  002b2	c1 e0 1d	 shl	 eax, 29			; 0000001dH
$LN1492@emit_hrust:
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 _emit_bits
  002bb	59		 pop	 ecx

; 475  : 			}
; 476  : 			else
; 477  : 				goto INVALID_CODE_HRUST;
; 478  : 		}
; 479  : 		else if( length==2 )

  002bc	e9 a9 02 00 00	 jmp	 $LN1482@emit_hrust
$LN38@emit_hrust:
  002c1	6a 02		 push	 2
  002c3	5e		 pop	 esi
  002c4	3b d6		 cmp	 edx, esi
  002c6	0f 85 81 00 00
	00		 jne	 $LN34@emit_hrust

; 480  : 		{
; 481  : 			if( (-32)<=disp && disp<=(-1) ) // %00111abcde

  002cc	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]
  002cf	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002d2	77 1f		 ja	 SHORT $LN33@emit_hrust

; 482  : 			{
; 483  : 				success = success && emit_bits( 0x38000000, 5 );

  002d4	6a 05		 push	 5
  002d6	68 00 00 00 38	 push	 939524096		; 38000000H
$LN1494@emit_hrust:
  002db	e8 00 00 00 00	 call	 _emit_bits
  002e0	59		 pop	 ecx
  002e1	59		 pop	 ecx
  002e2	85 c0		 test	 eax, eax

; 484  : 				success = success && emit_bits( disp<<(32-5), 5 );

  002e4	0f 84 07 ff ff
	ff		 je	 $LN1472@emit_hrust
  002ea	8b c3		 mov	 eax, ebx
  002ec	6a 05		 push	 5
  002ee	c1 e0 1b	 shl	 eax, 27			; 0000001bH
  002f1	eb c2		 jmp	 SHORT $LN1492@emit_hrust
$LN33@emit_hrust:

; 485  : 			}
; 486  : 			else if( (-256)<=disp && disp<(-32) ) // %00110<byte>

  002f3	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  002f9	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  002fe	77 1e		 ja	 SHORT $LN31@emit_hrust

; 487  : 			{
; 488  : 				success = success && emit_bits( 0x30000000, 5 );

  00300	6a 05		 push	 5
  00302	68 00 00 00 30	 push	 805306368		; 30000000H
$LN1491@emit_hrust:
  00307	e8 00 00 00 00	 call	 _emit_bits
  0030c	59		 pop	 ecx
  0030d	59		 pop	 ecx
  0030e	85 c0		 test	 eax, eax

; 489  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00310	0f 84 db fe ff
	ff		 je	 $LN1472@emit_hrust
  00316	53		 push	 ebx
  00317	8b c6		 mov	 eax, esi
  00319	e9 47 02 00 00	 jmp	 $LN1483@emit_hrust
$LN31@emit_hrust:

; 490  : 			}
; 491  : 			else if( (-512)<=disp && disp<(-256) ) // %00101<byte>

  0031e	8d 8b 00 02 00
	00		 lea	 ecx, DWORD PTR [ebx+512]
  00324	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00329	3b c8		 cmp	 ecx, eax
  0032b	77 09		 ja	 SHORT $LN29@emit_hrust

; 492  : 			{
; 493  : 				success = success && emit_bits( 0x28000000, 5 );

  0032d	6a 05		 push	 5
  0032f	68 00 00 00 28	 push	 671088640		; 28000000H

; 494  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00334	eb d1		 jmp	 SHORT $LN1491@emit_hrust
$LN29@emit_hrust:

; 495  : 			}
; 496  : 			else if( (-768)<=disp && disp<(-512) ) // %00100<byte>

  00336	8d 8b 00 03 00
	00		 lea	 ecx, DWORD PTR [ebx+768]
  0033c	3b c8		 cmp	 ecx, eax
  0033e	0f 87 a6 02 00
	00		 ja	 $INVALID_CODE_HRUST$2781

; 497  : 			{
; 498  : 				success = success && emit_bits( 0x20000000, 5 );

  00344	6a 05		 push	 5
  00346	68 00 00 00 20	 push	 536870912		; 20000000H

; 499  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );
; 500  : 			}
; 501  : 			else
; 502  : 				goto INVALID_CODE_HRUST;
; 503  : 		}
; 504  : 		else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )

  0034b	eb ba		 jmp	 SHORT $LN1491@emit_hrust
$LN34@emit_hrust:
  0034d	8d 4a fd	 lea	 ecx, DWORD PTR [edx-3]
  00350	81 f9 fc 0e 00
	00		 cmp	 ecx, 3836		; 00000efcH
  00356	0f 87 8e 02 00
	00		 ja	 $INVALID_CODE_HRUST$2781
  0035c	8d 8b 00 00 01
	00		 lea	 ecx, DWORD PTR [ebx+65536]
  00362	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00368	0f 87 7c 02 00
	00		 ja	 $INVALID_CODE_HRUST$2781

; 505  : 		{
; 506  : 			// first see if we need emitting expansion codes
; 507  : 
; 508  : 				//  -513.. -1024  (FDFF..FC00) - 2 bits
; 509  : 				//  -1025..-2048  (FBFF..F800) - 3
; 510  : 				//  -2049..-4096  (F7FF..F000) - 4
; 511  : 				//  -4097..-8192  (EFFF..E000) - 5
; 512  : 				//  -8193..-16384 (DFFF..C000) - 6
; 513  : 				// -16385..-32768 (BFFF..8000) - 7
; 514  : 				// -32769..-65536 (7FFF..0000) - 8
; 515  : 			if( disp<(-512) )

  0036e	81 fb 00 fe ff
	ff		 cmp	 ebx, -512		; fffffe00H
  00374	7d 56		 jge	 SHORT $LN1463@emit_hrust

; 516  : 			{
; 517  : 				varbits = 1024;
; 518  : 				varlen  = 2;

  00376	6a 02		 push	 2

; 519  : 				while( (ULONG)(-disp) > varbits )

  00378	8b d3		 mov	 edx, ebx
  0037a	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  0037f	59		 pop	 ecx
  00380	f7 da		 neg	 edx
  00382	eb 03		 jmp	 SHORT $LN1484@emit_hrust
$LL22@emit_hrust:

; 520  : 				{
; 521  : 					varbits <<= 1;

  00384	03 f6		 add	 esi, esi

; 522  : 					varlen++;

  00386	41		 inc	 ecx
$LN1484@emit_hrust:

; 519  : 				while( (ULONG)(-disp) > varbits )

  00387	3b d6		 cmp	 edx, esi
  00389	77 f9		 ja	 SHORT $LL22@emit_hrust

; 523  : 				}
; 524  : 
; 525  : 				// emit expansion codes, if necessary: %00110<FE>
; 526  : 				while( varlen>expbitlen )

  0038b	3b 4c 24 18	 cmp	 ecx, DWORD PTR _expbitlen$[esp+32]
  0038f	76 3b		 jbe	 SHORT $LN1463@emit_hrust
  00391	2b 4c 24 18	 sub	 ecx, DWORD PTR _expbitlen$[esp+32]
  00395	8b f1		 mov	 esi, ecx
  00397	01 74 24 18	 add	 DWORD PTR _expbitlen$[esp+32], esi
$LL20@emit_hrust:

; 527  : 				{
; 528  : 					success = success && emit_bits( 0x30000000, 5 );

  0039b	3b c7		 cmp	 eax, edi
  0039d	74 28		 je	 SHORT $LN125@emit_hrust
  0039f	6a 05		 push	 5
  003a1	68 00 00 00 30	 push	 805306368		; 30000000H
  003a6	e8 00 00 00 00	 call	 _emit_bits
  003ab	59		 pop	 ecx
  003ac	59		 pop	 ecx
  003ad	85 c0		 test	 eax, eax

; 529  : 					success = success && emit_byte( 0x00FE, EMIT_BYTE_ADD );

  003af	74 16		 je	 SHORT $LN125@emit_hrust
  003b1	68 fe 00 00 00	 push	 254			; 000000feH
  003b6	6a 02		 push	 2
  003b8	58		 pop	 eax
  003b9	e8 00 00 00 00	 call	 _emit_byte
  003be	59		 pop	 ecx
  003bf	85 c0		 test	 eax, eax
  003c1	74 04		 je	 SHORT $LN125@emit_hrust
  003c3	8b c5		 mov	 eax, ebp
  003c5	eb 02		 jmp	 SHORT $LN126@emit_hrust
$LN125@emit_hrust:
  003c7	33 c0		 xor	 eax, eax
$LN126@emit_hrust:

; 523  : 				}
; 524  : 
; 525  : 				// emit expansion codes, if necessary: %00110<FE>
; 526  : 				while( varlen>expbitlen )

  003c9	4e		 dec	 esi
  003ca	75 cf		 jne	 SHORT $LL20@emit_hrust
$LN1463@emit_hrust:

; 530  : 					#ifdef DBG
; 531  : 						printf("expansion\n");
; 532  : 					#endif
; 533  : 
; 534  : 					expbitlen++;
; 535  : 				}
; 536  : 			}
; 537  : 
; 538  : 
; 539  : 
; 540  : 
; 541  : 
; 542  : 			// emit length
; 543  : 
; 544  : 			if( length<=15 ) // 3..15

  003cc	83 7c 24 10 0f	 cmp	 DWORD PTR _length$[esp+32], 15 ; 0000000fH
  003d1	0f 8f 82 00 00
	00		 jg	 $LN18@emit_hrust

; 545  : 			{
; 546  : 				success = success && emit_bits( 0, 1 );

  003d7	3b c7		 cmp	 eax, edi
  003d9	74 11		 je	 SHORT $LN1464@emit_hrust
  003db	55		 push	 ebp
  003dc	57		 push	 edi
  003dd	e8 00 00 00 00	 call	 _emit_bits
  003e2	59		 pop	 ecx
  003e3	59		 pop	 ecx
  003e4	85 c0		 test	 eax, eax
  003e6	74 04		 je	 SHORT $LN1464@emit_hrust
  003e8	8b cd		 mov	 ecx, ebp
  003ea	eb 02		 jmp	 SHORT $LN128@emit_hrust
$LN1464@emit_hrust:
  003ec	33 c9		 xor	 ecx, ecx
$LN128@emit_hrust:

; 547  : 
; 548  : 				if( length==3 )

  003ee	8b 44 24 10	 mov	 eax, DWORD PTR _length$[esp+32]
  003f2	83 f8 03	 cmp	 eax, 3
  003f5	75 1a		 jne	 SHORT $LN17@emit_hrust

; 549  : 				{
; 550  : 					success = success && emit_bits( 0x80000000, 2 ); // %010

  003f7	3b cf		 cmp	 ecx, edi
  003f9	0f 84 c3 00 00
	00		 je	 $LN1467@emit_hrust
  003ff	6a 02		 push	 2
  00401	68 00 00 00 80	 push	 -2147483648		; 80000000H
$LN1487@emit_hrust:
  00406	e8 00 00 00 00	 call	 _emit_bits
  0040b	59		 pop	 ecx

; 551  : 				}
; 552  : 				else

  0040c	e9 a8 00 00 00	 jmp	 $LN1486@emit_hrust
$LN17@emit_hrust:

; 553  : 				{
; 554  : 					varlen  = length/3;
; 555  : 					varbits = length%3;

  00411	6a 03		 push	 3
  00413	99		 cdq
  00414	5e		 pop	 esi
  00415	f7 fe		 idiv	 esi
  00417	8b f2		 mov	 esi, edx

; 556  : 
; 557  : 					success = success && emit_bits( 0xFFFFFFFF, varlen<<1 );

  00419	3b cf		 cmp	 ecx, edi
  0041b	74 27		 je	 SHORT $LN131@emit_hrust
  0041d	03 c0		 add	 eax, eax
  0041f	83 f8 ff	 cmp	 eax, -1
  00422	75 0e		 jne	 SHORT $LN968@emit_hrust
  00424	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, edi
  0042a	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, edi
  00430	eb 0e		 jmp	 SHORT $LN1450@emit_hrust
$LN968@emit_hrust:
  00432	50		 push	 eax
  00433	6a ff		 push	 -1
  00435	e8 00 00 00 00	 call	 _emit_bits
  0043a	59		 pop	 ecx
  0043b	59		 pop	 ecx
  0043c	3b c7		 cmp	 eax, edi
  0043e	74 04		 je	 SHORT $LN131@emit_hrust
$LN1450@emit_hrust:
  00440	8b c5		 mov	 eax, ebp
  00442	eb 02		 jmp	 SHORT $LN132@emit_hrust
$LN131@emit_hrust:
  00444	33 c0		 xor	 eax, eax
$LN132@emit_hrust:

; 558  : 
; 559  : 					if( length!=15 )

  00446	83 7c 24 10 0f	 cmp	 DWORD PTR _length$[esp+32], 15 ; 0000000fH
  0044b	74 77		 je	 SHORT $LN1468@emit_hrust

; 560  : 						success = success && emit_bits( varbits<<(32-2), 2 );

  0044d	3b c7		 cmp	 eax, edi
  0044f	74 71		 je	 SHORT $LN1467@emit_hrust
  00451	6a 02		 push	 2
  00453	c1 e6 1e	 shl	 esi, 30			; 0000001eH
  00456	56		 push	 esi

; 561  : 				}

  00457	eb ad		 jmp	 SHORT $LN1487@emit_hrust
$LN18@emit_hrust:

; 562  : 			}
; 563  : 			else if( length<=127 ) // 16..127: %0110000abcdefg

  00459	83 7c 24 10 7f	 cmp	 DWORD PTR _length$[esp+32], 127 ; 0000007fH
  0045e	7f 22		 jg	 SHORT $LN13@emit_hrust

; 564  : 			{
; 565  : 				success = success && emit_bits( 0x60000000, 7 );

  00460	3b c7		 cmp	 eax, edi
  00462	74 5e		 je	 SHORT $LN1467@emit_hrust
  00464	6a 07		 push	 7
  00466	68 00 00 00 60	 push	 1610612736		; 60000000H
  0046b	e8 00 00 00 00	 call	 _emit_bits
  00470	59		 pop	 ecx
  00471	59		 pop	 ecx
  00472	85 c0		 test	 eax, eax

; 566  : 				success = success && emit_bits( length<<(32-7), 7 );

  00474	74 4c		 je	 SHORT $LN1467@emit_hrust
  00476	8b 44 24 10	 mov	 eax, DWORD PTR _length$[esp+32]
  0047a	6a 07		 push	 7
  0047c	c1 e0 19	 shl	 eax, 25			; 00000019H
  0047f	50		 push	 eax

; 567  : 			}
; 568  : 			else // 128..3839

  00480	eb 84		 jmp	 SHORT $LN1487@emit_hrust
$LN13@emit_hrust:

; 569  : 			{
; 570  : 				success = success && emit_bits( 0x60000000, 7 );

  00482	3b c7		 cmp	 eax, edi
  00484	74 3c		 je	 SHORT $LN1467@emit_hrust
  00486	6a 07		 push	 7
  00488	68 00 00 00 60	 push	 1610612736		; 60000000H
  0048d	e8 00 00 00 00	 call	 _emit_bits
  00492	59		 pop	 ecx
  00493	59		 pop	 ecx
  00494	85 c0		 test	 eax, eax

; 571  : 				success = success && emit_bits( length<<(32-15), 7 );

  00496	74 2a		 je	 SHORT $LN1467@emit_hrust
  00498	8b 44 24 10	 mov	 eax, DWORD PTR _length$[esp+32]
  0049c	c1 e0 11	 shl	 eax, 17			; 00000011H
  0049f	6a 07		 push	 7
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 _emit_bits
  004a7	59		 pop	 ecx
  004a8	59		 pop	 ecx
  004a9	85 c0		 test	 eax, eax

; 572  : 				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );

  004ab	74 15		 je	 SHORT $LN1467@emit_hrust
  004ad	ff 74 24 10	 push	 DWORD PTR _length$[esp+32]
  004b1	6a 02		 push	 2
  004b3	58		 pop	 eax
  004b4	e8 00 00 00 00	 call	 _emit_byte
$LN1486@emit_hrust:
  004b9	59		 pop	 ecx
  004ba	85 c0		 test	 eax, eax
  004bc	74 04		 je	 SHORT $LN1467@emit_hrust
  004be	8b c5		 mov	 eax, ebp
  004c0	eb 02		 jmp	 SHORT $LN1468@emit_hrust
$LN1467@emit_hrust:
  004c2	33 c0		 xor	 eax, eax
$LN1468@emit_hrust:

; 573  : 			}
; 574  : 
; 575  : 
; 576  : 			// emit displacement
; 577  : 			if( (-32)<=disp ) // ffe0..ffff: %10abcde

  004c4	83 fb e0	 cmp	 ebx, -32		; ffffffe0H
  004c7	7c 14		 jl	 SHORT $LN11@emit_hrust

; 578  : 			{
; 579  : 				success = success && emit_bits( 0x80000000, 2 );

  004c9	3b c7		 cmp	 eax, edi
  004cb	0f 84 20 fd ff
	ff		 je	 $LN1472@emit_hrust
  004d1	6a 02		 push	 2
  004d3	68 00 00 00 80	 push	 -2147483648		; 80000000H

; 580  : 				success = success && emit_bits( disp<<(32-5), 5 );

  004d8	e9 fe fd ff ff	 jmp	 $LN1494@emit_hrust
$LN11@emit_hrust:

; 581  : 			}
; 582  : 			else if( (-256)<=disp ) // ff00..ffdf: %01<byte>

  004dd	81 fb 00 ff ff
	ff		 cmp	 ebx, -256		; ffffff00H
  004e3	7c 18		 jl	 SHORT $LN9@emit_hrust

; 583  : 			{
; 584  : 				success = success && emit_bits( 0x40000000, 2 );

  004e5	3b c7		 cmp	 eax, edi
  004e7	0f 84 04 fd ff
	ff		 je	 $LN1472@emit_hrust
  004ed	6a 02		 push	 2
  004ef	68 00 00 00 40	 push	 1073741824		; 40000000H
$LN1489@emit_hrust:
  004f4	e8 00 00 00 00	 call	 _emit_bits
  004f9	85 c0		 test	 eax, eax

; 585  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  004fb	eb 5c		 jmp	 SHORT $LN1488@emit_hrust
$LN9@emit_hrust:

; 586  : 			}
; 587  : 			else if( (-512)<=disp ) // fe00..feff: %00<byte>

  004fd	81 fb 00 fe ff
	ff		 cmp	 ebx, -512		; fffffe00H
  00503	7c 0d		 jl	 SHORT $LN7@emit_hrust

; 588  : 			{
; 589  : 				success = success && emit_bits( 0x00000000, 2 );

  00505	3b c7		 cmp	 eax, edi
  00507	0f 84 e4 fc ff
	ff		 je	 $LN1472@emit_hrust
  0050d	6a 02		 push	 2
  0050f	57		 push	 edi

; 590  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );
; 591  : 			}
; 592  : 			else // variable code length: [-65536..-512)

  00510	eb e2		 jmp	 SHORT $LN1489@emit_hrust
$LN7@emit_hrust:

; 593  : 			{
; 594  : 
; 595  : 				// displacement itself: %11ab[cdefgh]<byte>
; 596  : 				success = success && emit_bits( 0xC0000000, 2 );

  00512	3b c7		 cmp	 eax, edi
  00514	0f 84 d7 fc ff
	ff		 je	 $LN1472@emit_hrust
  0051a	6a 02		 push	 2
  0051c	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00521	e8 00 00 00 00	 call	 _emit_bits
  00526	59		 pop	 ecx
  00527	59		 pop	 ecx
  00528	85 c0		 test	 eax, eax

; 597  : 				success = success && emit_bits( disp<<(24-expbitlen), expbitlen );

  0052a	0f 84 c1 fc ff
	ff		 je	 $LN1472@emit_hrust
  00530	8b 44 24 18	 mov	 eax, DWORD PTR _expbitlen$[esp+32]
  00534	83 f8 ff	 cmp	 eax, -1
  00537	75 0e		 jne	 SHORT $LN1331@emit_hrust
  00539	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, edi
  0053f	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, edi
  00545	eb 1a		 jmp	 SHORT $LN1459@emit_hrust
$LN1331@emit_hrust:
  00547	50		 push	 eax
  00548	6a 18		 push	 24			; 00000018H
  0054a	59		 pop	 ecx
  0054b	2b c8		 sub	 ecx, eax
  0054d	8b c3		 mov	 eax, ebx
  0054f	d3 e0		 shl	 eax, cl
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 _emit_bits
  00557	3b c7		 cmp	 eax, edi
$LN1488@emit_hrust:
  00559	59		 pop	 ecx
  0055a	59		 pop	 ecx
  0055b	0f 84 90 fc ff
	ff		 je	 $LN1472@emit_hrust
$LN1459@emit_hrust:

; 598  : 				success = success && emit_byte( (UBYTE)(disp&0x00FF), EMIT_BYTE_ADD );

  00561	53		 push	 ebx
$LN1478@emit_hrust:
  00562	6a 02		 push	 2
  00564	58		 pop	 eax
$LN1483@emit_hrust:
  00565	e8 00 00 00 00	 call	 _emit_byte
$LN1482@emit_hrust:
  0056a	59		 pop	 ecx
  0056b	85 c0		 test	 eax, eax
  0056d	0f 84 7e fc ff
	ff		 je	 $LN1472@emit_hrust
  00573	8b c5		 mov	 eax, ebp
  00575	e9 79 fc ff ff	 jmp	 $LN1473@emit_hrust
$LN3@emit_hrust:

; 629  : 			position -= length;

  0057a	29 4c 24 14	 sub	 DWORD PTR _position$[esp+32], ecx
$LN2@emit_hrust:

; 393  : 
; 394  : 	while( (position<actual_len) && success )

  0057e	8b 4c 24 14	 mov	 ecx, DWORD PTR _position$[esp+32]
  00582	3b 4c 24 28	 cmp	 ecx, DWORD PTR _actual_len$[esp+28]
  00586	0f 82 5a fb ff
	ff		 jb	 $LL58@emit_hrust
$LN57@emit_hrust:

; 630  : 	}
; 631  : 
; 632  : 	// stop-code: %0110_0000_0011_11
; 633  : 	success = success && emit_bits( 0x603C0000, 14 );

  0058c	3b c7		 cmp	 eax, edi
  0058e	74 6e		 je	 SHORT $LN167@emit_hrust
  00590	6a 0e		 push	 14			; 0000000eH
  00592	68 00 00 3c 60	 push	 1614544896		; 603c0000H
  00597	e8 00 00 00 00	 call	 _emit_bits
  0059c	59		 pop	 ecx
  0059d	59		 pop	 ecx
  0059e	85 c0		 test	 eax, eax

; 634  : 
; 635  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  005a0	74 5c		 je	 SHORT $LN167@emit_hrust
  005a2	57		 push	 edi
  005a3	57		 push	 edi
  005a4	e8 00 00 00 00	 call	 _emit_bits
  005a9	59		 pop	 ecx
  005aa	59		 pop	 ecx
  005ab	85 c0		 test	 eax, eax

; 636  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  005ad	74 4f		 je	 SHORT $LN167@emit_hrust
  005af	57		 push	 edi
  005b0	33 c0		 xor	 eax, eax
  005b2	e8 00 00 00 00	 call	 _emit_file
  005b7	59		 pop	 ecx
  005b8	85 c0		 test	 eax, eax
  005ba	74 42		 je	 SHORT $LN167@emit_hrust

; 639  : 	{
; 640  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  005bc	8b 44 24 1c	 mov	 eax, DWORD PTR _max_disp$[esp+32]
  005c0	f7 d8		 neg	 eax
  005c2	50		 push	 eax
  005c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  005c8	8b f5		 mov	 esi, ebp
  005ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005d0	59		 pop	 ecx
  005d1	59		 pop	 ecx
$LN1@emit_hrust:

; 641  : 
; 642  : 		// TODO: patch packed length in file, if zx header
; 643  : 	}
; 644  : 
; 645  : 
; 646  : 	return success;

  005d2	8b c6		 mov	 eax, esi
$LN1476@emit_hrust:
  005d4	5b		 pop	 ebx
  005d5	5d		 pop	 ebp
$LN61@emit_hrust:
  005d6	5f		 pop	 edi
  005d7	5e		 pop	 esi

; 647  : }

  005d8	83 c4 10	 add	 esp, 16			; 00000010H
  005db	c3		 ret	 0
$LN1426@emit_hrust:

; 404  : 		{
; 405  : 			printf("mhmt-emit.c:emit_hrust() - encountered stop-code in optimal chain before emitting all data!\n");

  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@ENDDEHIC@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5encou@
  005e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005e7	59		 pop	 ecx

; 406  : 			return 0;

  005e8	eb 10		 jmp	 SHORT $LN1493@emit_hrust
$INVALID_CODE_HRUST$2781:

; 599  : 			}
; 600  : 		}
; 601  : 		else
; 602  : 		{
; 603  : INVALID_CODE_HRUST:
; 604  : 			printf("mhmt-emit.c:emit_hrust() - invalid code: length=%d, displacement=%d\n",length,disp);

  005ea	53		 push	 ebx
  005eb	52		 push	 edx
  005ec	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@PKMFGNFM@mhmt?9emit?4c?3emit_hrust?$CI?$CJ?5?9?5inval@
  005f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1493@emit_hrust:

; 605  : 			return 0;

  005fa	33 c0		 xor	 eax, eax
  005fc	eb d6		 jmp	 SHORT $LN1476@emit_hrust
$LN167@emit_hrust:

; 636  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  005fe	33 f6		 xor	 esi, esi

; 637  : 
; 638  : 	if( success )

  00600	eb d0		 jmp	 SHORT $LN1@emit_hrust
_emit_hrust ENDP
_TEXT	ENDS
PUBLIC	_emit_hrum
; Function compile flags: /Ogspy
;	COMDAT _emit_hrum
_TEXT	SEGMENT
_max_disp$ = -8						; size = 4
_position$ = -4						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_hrum PROC						; COMDAT

; 174  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx
  00003	57		 push	 edi

; 175  : 	ULONG position;
; 176  : 	LONG length;
; 177  : 	LONG disp;
; 178  : 
; 179  : 	LONG max_disp; // maximum encountered displacement
; 180  : 
; 181  : 
; 182  : 	ULONG varbits,varlen;
; 183  : 
; 184  : 	ULONG success = 1;
; 185  : 
; 186  : 	max_disp = 0;

  00004	33 ff		 xor	 edi, edi
  00006	33 db		 xor	 ebx, ebx
  00008	89 5c 24 08	 mov	 DWORD PTR _max_disp$[esp+16], ebx

; 187  : 
; 188  : 
; 189  : 	// some checks
; 190  : 	if( !optch )

  0000c	39 7c 24 14	 cmp	 DWORD PTR _optch$[esp+12], edi
  00010	75 13		 jne	 SHORT $LN35@emit_hrum

; 191  : 	{
; 192  : 		printf("mhmt-emit.c:emit_hrum() - NULL passed!\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HACLCCPA@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5NULL?5p@
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0001d	59		 pop	 ecx

; 193  : 		return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	e9 1c 03 00 00	 jmp	 $LN36@emit_hrum
$LN35@emit_hrum:
  00025	56		 push	 esi

; 194  : 	}
; 195  : 
; 196  : 	// initialize
; 197  : 	success = success && emit_file(NULL, EMIT_FILE_INIT);

  00026	89 3d 00 00 00
	00		 mov	 DWORD PTR ?position@?1??emit_file@@9@9, edi

; 198  : 
; 199  : 	success = success && emit_byte(0, EMIT_BYTE_INIT);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, edi
  00032	89 3d 00 00 00
	00		 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, edi

; 200  : 
; 201  : 	success = success && emit_bits(0, EMIT_BITS_INIT);

  00038	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, edi
  0003e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, edi

; 202  : 
; 203  : 
; 204  : 	// manage zx header info
; 205  : 	if( wrk.zxheader )

  00044	39 3d 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, edi
  0004a	74 2f		 je	 SHORT $LN734@emit_hrum

; 206  : 	{
; 207  :         success = success && emit_file( &wrk.indata[wrk.inlen-5], 5);

  0004c	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00051	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR _wrk+52
  00057	8d 44 01 fb	 lea	 eax, DWORD PTR [ecx+eax-5]
  0005b	50		 push	 eax
  0005c	6a 05		 push	 5
  0005e	58		 pop	 eax
  0005f	e8 00 00 00 00	 call	 _emit_file
  00064	59		 pop	 ecx
  00065	85 c0		 test	 eax, eax

; 208  : 		success = success && emit_file( (UBYTE*)"\020\020", 2); // 0x10, 0x10

  00067	74 2f		 je	 SHORT $LN735@emit_hrum
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_02FGFKJHMM@?$BA?$BA?$AA@
  0006e	6a 02		 push	 2
  00070	58		 pop	 eax
  00071	e8 00 00 00 00	 call	 _emit_file
  00076	59		 pop	 ecx
  00077	85 c0		 test	 eax, eax

; 209  : 	}
; 210  : 
; 211  : 	// schedule first byte to be placed just after first bitstream word
; 212  : 	success = success && emit_byte( wrk.indata[0], EMIT_BYTE_ADD);

  00079	74 1d		 je	 SHORT $LN735@emit_hrum
$LN734@emit_hrum:
  0007b	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00080	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00083	50		 push	 eax
  00084	6a 02		 push	 2
  00086	58		 pop	 eax
  00087	e8 00 00 00 00	 call	 _emit_byte
  0008c	59		 pop	 ecx
  0008d	85 c0		 test	 eax, eax
  0008f	74 07		 je	 SHORT $LN735@emit_hrum
  00091	33 f6		 xor	 esi, esi
  00093	46		 inc	 esi
  00094	8b c6		 mov	 eax, esi
  00096	eb 05		 jmp	 SHORT $LN49@emit_hrum
$LN735@emit_hrum:
  00098	33 f6		 xor	 esi, esi
  0009a	33 c0		 xor	 eax, eax
  0009c	46		 inc	 esi
$LN49@emit_hrum:
  0009d	55		 push	 ebp

; 213  : 
; 214  : 	// go emitting codes
; 215  : 	position = 1;

  0009e	89 74 24 14	 mov	 DWORD PTR _position$[esp+24], esi

; 216  : 
; 217  : 	while( (position<actual_len) && success )

  000a2	39 74 24 20	 cmp	 DWORD PTR _actual_len$[esp+20], esi
  000a6	0f 86 1d 02 00
	00		 jbe	 $LN32@emit_hrum
$LL33@emit_hrum:
  000ac	3b c7		 cmp	 eax, edi
  000ae	0f 84 53 02 00
	00		 je	 $LN88@emit_hrum

; 218  : 	{
; 219  : 		length = optch[position].code.length;

  000b4	8b 44 24 14	 mov	 eax, DWORD PTR _position$[esp+24]
  000b8	8b 4c 24 1c	 mov	 ecx, DWORD PTR _optch$[esp+20]
  000bc	c1 e0 04	 shl	 eax, 4
  000bf	03 c1		 add	 eax, ecx
  000c1	8b 28		 mov	 ebp, DWORD PTR [eax]

; 220  : 		disp   = optch[position].code.disp;

  000c3	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 221  : 
; 222  : 		if( length==0 )

  000c6	3b ef		 cmp	 ebp, edi
  000c8	0f 84 3d 02 00
	00		 je	 $LN710@emit_hrum

; 226  : 		}
; 227  : 		else if( length==1 ) // either copy-byte or len=1 code

  000ce	3b ee		 cmp	 ebp, esi
  000d0	75 6f		 jne	 SHORT $LN29@emit_hrum

; 228  : 		{
; 229  : 			if( disp==0 ) // copy-byte (%1<byte>)

  000d2	3b df		 cmp	 ebx, edi
  000d4	75 3a		 jne	 SHORT $LN28@emit_hrum

; 230  : 			{
; 231  : 				success = success && emit_bits( 0x80000000, 1 );

  000d6	56		 push	 esi
  000d7	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000dc	e8 00 00 00 00	 call	 _emit_bits
  000e1	59		 pop	 ecx
  000e2	59		 pop	 ecx
  000e3	85 c0		 test	 eax, eax

; 232  : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  000e5	74 22		 je	 SHORT $LN739@emit_hrum
  000e7	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000ec	8b 4c 24 14	 mov	 ecx, DWORD PTR _position$[esp+24]
  000f0	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  000f4	50		 push	 eax
  000f5	6a 02		 push	 2
  000f7	58		 pop	 eax
  000f8	e8 00 00 00 00	 call	 _emit_byte
  000fd	59		 pop	 ecx
  000fe	85 c0		 test	 eax, eax
  00100	74 07		 je	 SHORT $LN739@emit_hrum
  00102	8b c6		 mov	 eax, esi
  00104	e9 aa 01 00 00	 jmp	 $LN740@emit_hrum
$LN739@emit_hrum:
  00109	33 c0		 xor	 eax, eax
  0010b	e9 a3 01 00 00	 jmp	 $LN740@emit_hrum
$LN28@emit_hrum:

; 233  : 			}
; 234  : 			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)

  00110	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00113	83 f8 07	 cmp	 eax, 7
  00116	0f 87 fd 01 00
	00		 ja	 $INVALID_CODE_HRUM$2716

; 235  : 			{
; 236  : 				success = success && emit_bits( 0x00000000,   3 );

  0011c	6a 03		 push	 3
  0011e	57		 push	 edi
  0011f	e8 00 00 00 00	 call	 _emit_bits
  00124	59		 pop	 ecx
  00125	59		 pop	 ecx
  00126	85 c0		 test	 eax, eax

; 237  : 				success = success && emit_bits( disp<<(32-3), 3 );

  00128	0f 84 79 01 00
	00		 je	 $LN80@emit_hrum
  0012e	8b c3		 mov	 eax, ebx
  00130	c1 e0 1d	 shl	 eax, 29			; 0000001dH
  00133	6a 03		 push	 3
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _emit_bits
  0013b	59		 pop	 ecx
  0013c	e9 5d 01 00 00	 jmp	 $LN744@emit_hrum
$LN29@emit_hrum:

; 238  : 
; 239  : 				if( max_disp > disp ) max_disp = disp;
; 240  : 			}
; 241  : 			else
; 242  : 				goto INVALID_CODE_HRUM;
; 243  : 		}
; 244  : 		else if( length==2 )

  00141	83 fd 02	 cmp	 ebp, 2
  00144	75 1d		 jne	 SHORT $LN22@emit_hrum

; 245  : 		{
; 246  : 			if( (-256)<=disp && disp<=(-1) ) // %001<byte>

  00146	8d 83 00 01 00
	00		 lea	 eax, DWORD PTR [ebx+256]
  0014c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00151	0f 87 c2 01 00
	00		 ja	 $INVALID_CODE_HRUM$2716

; 247  : 			{
; 248  : 				success = success && emit_bits( 0x20000000, 3 );

  00157	6a 03		 push	 3
  00159	68 00 00 00 20	 push	 536870912		; 20000000H

; 249  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  0015e	e9 27 01 00 00	 jmp	 $LN745@emit_hrum
$LN22@emit_hrum:

; 250  : 
; 251  : 				if( max_disp > disp ) max_disp = disp;
; 252  : 			}
; 253  : 			else
; 254  : 				goto INVALID_CODE_HRUM;
; 255  : 		}
; 256  : 		else if( 3<=length && length<=255 )

  00163	8d 45 fd	 lea	 eax, DWORD PTR [ebp-3]
  00166	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  0016b	0f 87 a8 01 00
	00		 ja	 $INVALID_CODE_HRUM$2716

; 257  : 		{
; 258  : 			// length coding
; 259  : 			if( length==3 )

  00171	83 fd 03	 cmp	 ebp, 3
  00174	75 18		 jne	 SHORT $LN16@emit_hrum

; 260  : 			{
; 261  : 				success = success && emit_bits( 0x40000000, 3 );

  00176	55		 push	 ebp
  00177	68 00 00 00 40	 push	 1073741824		; 40000000H
  0017c	e8 00 00 00 00	 call	 _emit_bits
  00181	f7 d8		 neg	 eax
  00183	59		 pop	 ecx
  00184	1b c0		 sbb	 eax, eax
  00186	59		 pop	 ecx
  00187	f7 d8		 neg	 eax
  00189	e9 b2 00 00 00	 jmp	 $LN71@emit_hrum
$LN16@emit_hrum:

; 262  : 			}
; 263  : 			else if( length<=15 )

  0018e	83 fd 0f	 cmp	 ebp, 15			; 0000000fH
  00191	0f 8f 83 00 00
	00		 jg	 $LN14@emit_hrum

; 264  : 			{
; 265  : 				varlen=2;

  00197	6a 02		 push	 2
  00199	5f		 pop	 edi

; 266  : 
; 267  : 				varbits = (length % 3)<<30; // low 2 bits (except for length==15)

  0019a	8b c5		 mov	 eax, ebp
  0019c	99		 cdq
  0019d	6a 03		 push	 3
  0019f	59		 pop	 ecx
  001a0	f7 f9		 idiv	 ecx

; 268  : 				if( length==15 ) varbits = 0xC0000000;

  001a2	b8 00 00 00 c0	 mov	 eax, -1073741824	; c0000000H
  001a7	8b f2		 mov	 esi, edx
  001a9	c1 e6 1e	 shl	 esi, 30			; 0000001eH
  001ac	83 fd 0f	 cmp	 ebp, 15			; 0000000fH
  001af	75 02		 jne	 SHORT $LN13@emit_hrum
  001b1	8b f0		 mov	 esi, eax
$LN13@emit_hrum:

; 269  : 
; 270  : 				if( length>=6 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  001b3	83 fd 06	 cmp	 ebp, 6
  001b6	7c 08		 jl	 SHORT $LN12@emit_hrum
  001b8	c1 ee 02	 shr	 esi, 2
  001bb	6a 04		 push	 4
  001bd	0b f0		 or	 esi, eax
  001bf	5f		 pop	 edi
$LN12@emit_hrum:

; 271  : 				if( length>=9 ) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  001c0	83 fd 09	 cmp	 ebp, 9
  001c3	7c 07		 jl	 SHORT $LN737@emit_hrum
  001c5	c1 ee 02	 shr	 esi, 2
  001c8	0b f0		 or	 esi, eax
  001ca	47		 inc	 edi
  001cb	47		 inc	 edi
$LN737@emit_hrum:

; 272  : 				if( length>=12) { varbits = 0xC0000000 | (varbits>>2); varlen += 2; }

  001cc	83 fd 0c	 cmp	 ebp, 12			; 0000000cH
  001cf	7c 07		 jl	 SHORT $LN10@emit_hrum
  001d1	c1 ee 02	 shr	 esi, 2
  001d4	0b f0		 or	 esi, eax
  001d6	47		 inc	 edi
  001d7	47		 inc	 edi
$LN10@emit_hrum:

; 273  : 
; 274  : 				success = success && emit_bits( 0x60000000, 3 );

  001d8	6a 03		 push	 3
  001da	68 00 00 00 60	 push	 1610612736		; 60000000H
  001df	e8 00 00 00 00	 call	 _emit_bits
  001e4	59		 pop	 ecx
  001e5	59		 pop	 ecx
  001e6	85 c0		 test	 eax, eax

; 275  : 				success = success && emit_bits( varbits, varlen );

  001e8	74 27		 je	 SHORT $LN66@emit_hrum
  001ea	83 ff ff	 cmp	 edi, -1
  001ed	75 10		 jne	 SHORT $LN486@emit_hrum
  001ef	83 25 00 00 00
	00 00		 and	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, 0
  001f6	83 25 00 00 00
	00 00		 and	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0
  001fd	eb 0d		 jmp	 SHORT $LN725@emit_hrum
$LN486@emit_hrum:
  001ff	57		 push	 edi
  00200	56		 push	 esi
  00201	e8 00 00 00 00	 call	 _emit_bits
  00206	59		 pop	 ecx
  00207	59		 pop	 ecx
  00208	85 c0		 test	 eax, eax
  0020a	74 05		 je	 SHORT $LN66@emit_hrum
$LN725@emit_hrum:
  0020c	33 c0		 xor	 eax, eax
  0020e	40		 inc	 eax
  0020f	eb 02		 jmp	 SHORT $LN743@emit_hrum
$LN66@emit_hrum:
  00211	33 c0		 xor	 eax, eax
$LN743@emit_hrum:

; 276  : 			}
; 277  : 			else // 15<length<=255: %01100<len>

  00213	33 f6		 xor	 esi, esi
  00215	33 ff		 xor	 edi, edi
  00217	46		 inc	 esi
  00218	eb 26		 jmp	 SHORT $LN71@emit_hrum
$LN14@emit_hrum:

; 278  : 			{
; 279  : 				success = success && emit_bits( 0x60000000, 5 );

  0021a	6a 05		 push	 5
  0021c	68 00 00 00 60	 push	 1610612736		; 60000000H
  00221	e8 00 00 00 00	 call	 _emit_bits
  00226	59		 pop	 ecx
  00227	59		 pop	 ecx
  00228	85 c0		 test	 eax, eax

; 280  : 				success = success && emit_byte( (UBYTE)(length&0x00FF), EMIT_BYTE_ADD );

  0022a	74 12		 je	 SHORT $LN70@emit_hrum
  0022c	55		 push	 ebp
  0022d	6a 02		 push	 2
  0022f	58		 pop	 eax
  00230	e8 00 00 00 00	 call	 _emit_byte
  00235	59		 pop	 ecx
  00236	85 c0		 test	 eax, eax
  00238	74 04		 je	 SHORT $LN70@emit_hrum
  0023a	8b c6		 mov	 eax, esi
  0023c	eb 02		 jmp	 SHORT $LN71@emit_hrum
$LN70@emit_hrum:
  0023e	33 c0		 xor	 eax, eax
$LN71@emit_hrum:

; 281  : 			}
; 282  : 
; 283  : 			// displacement coding
; 284  : 			if( (-256)<=disp && disp<=(-1) ) // %0<disp>

  00240	8d 8b 00 01 00
	00		 lea	 ecx, DWORD PTR [ebx+256]
  00246	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0024c	77 08		 ja	 SHORT $LN8@emit_hrum

; 285  : 			{
; 286  : 				success = success && emit_bits( 0x00000000, 1 );

  0024e	3b c7		 cmp	 eax, edi
  00250	74 55		 je	 SHORT $LN80@emit_hrum
  00252	56		 push	 esi
  00253	57		 push	 edi

; 287  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00254	eb 34		 jmp	 SHORT $LN745@emit_hrum
$LN8@emit_hrum:

; 288  : 
; 289  : 				if( max_disp > disp ) max_disp = disp;
; 290  : 			}
; 291  : 			else if( (-4096)<=disp && disp<(-256) ) //%1abcd<disp>

  00256	8d 8b 00 10 00
	00		 lea	 ecx, DWORD PTR [ebx+4096]
  0025c	81 f9 ff 0e 00
	00		 cmp	 ecx, 3839		; 00000effH
  00262	0f 87 b1 00 00
	00		 ja	 $INVALID_CODE_HRUM$2716

; 292  : 			{
; 293  : 				success = success && emit_bits( 0x80000000, 1 );

  00268	3b c7		 cmp	 eax, edi
  0026a	74 3b		 je	 SHORT $LN80@emit_hrum
  0026c	56		 push	 esi
  0026d	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00272	e8 00 00 00 00	 call	 _emit_bits
  00277	59		 pop	 ecx
  00278	59		 pop	 ecx
  00279	85 c0		 test	 eax, eax

; 294  : 				success = success && emit_bits( (0x0F00&disp)<<20, 4 );

  0027b	74 2a		 je	 SHORT $LN80@emit_hrum
  0027d	8b c3		 mov	 eax, ebx
  0027f	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  00284	6a 04		 push	 4
  00286	c1 e0 14	 shl	 eax, 20			; 00000014H
  00289	50		 push	 eax
$LN745@emit_hrum:
  0028a	e8 00 00 00 00	 call	 _emit_bits
  0028f	59		 pop	 ecx
  00290	59		 pop	 ecx
  00291	85 c0		 test	 eax, eax

; 295  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00293	74 12		 je	 SHORT $LN80@emit_hrum
  00295	53		 push	 ebx
  00296	6a 02		 push	 2
  00298	58		 pop	 eax
  00299	e8 00 00 00 00	 call	 _emit_byte
$LN744@emit_hrum:
  0029e	59		 pop	 ecx
  0029f	85 c0		 test	 eax, eax
  002a1	74 04		 je	 SHORT $LN80@emit_hrum
  002a3	8b c6		 mov	 eax, esi
  002a5	eb 02		 jmp	 SHORT $LN81@emit_hrum
$LN80@emit_hrum:
  002a7	33 c0		 xor	 eax, eax
$LN81@emit_hrum:

; 296  : 
; 297  : 				if( max_disp > disp ) max_disp = disp;

  002a9	39 5c 24 10	 cmp	 DWORD PTR _max_disp$[esp+24], ebx
  002ad	7e 04		 jle	 SHORT $LN740@emit_hrum
  002af	89 5c 24 10	 mov	 DWORD PTR _max_disp$[esp+24], ebx
$LN740@emit_hrum:

; 307  : 		}
; 308  : 
; 309  : 		position += length;

  002b3	01 6c 24 14	 add	 DWORD PTR _position$[esp+24], ebp
  002b7	8b 4c 24 14	 mov	 ecx, DWORD PTR _position$[esp+24]
  002bb	3b 4c 24 20	 cmp	 ecx, DWORD PTR _actual_len$[esp+20]
  002bf	0f 82 e7 fd ff
	ff		 jb	 $LL33@emit_hrum

; 221  : 
; 222  : 		if( length==0 )

  002c5	8b 5c 24 10	 mov	 ebx, DWORD PTR _max_disp$[esp+24]
$LN32@emit_hrum:

; 310  : 	}
; 311  : 
; 312  : 	// stop-code: %01100<0>
; 313  : 	success = success && emit_bits( 0x60000000, 5 );

  002c9	3b c7		 cmp	 eax, edi
  002cb	74 3a		 je	 SHORT $LN88@emit_hrum
  002cd	6a 05		 push	 5
  002cf	68 00 00 00 60	 push	 1610612736		; 60000000H
  002d4	e8 00 00 00 00	 call	 _emit_bits
  002d9	59		 pop	 ecx
  002da	59		 pop	 ecx
  002db	85 c0		 test	 eax, eax

; 314  : 	success = success && emit_byte( 0x00, EMIT_BYTE_ADD );

  002dd	74 28		 je	 SHORT $LN88@emit_hrum
  002df	57		 push	 edi
  002e0	6a 02		 push	 2
  002e2	58		 pop	 eax
  002e3	e8 00 00 00 00	 call	 _emit_byte
  002e8	59		 pop	 ecx
  002e9	85 c0		 test	 eax, eax

; 315  : 
; 316  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  002eb	74 1a		 je	 SHORT $LN88@emit_hrum
  002ed	57		 push	 edi
  002ee	57		 push	 edi
  002ef	e8 00 00 00 00	 call	 _emit_bits
  002f4	59		 pop	 ecx
  002f5	59		 pop	 ecx
  002f6	85 c0		 test	 eax, eax

; 317  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  002f8	74 0d		 je	 SHORT $LN88@emit_hrum
  002fa	57		 push	 edi
  002fb	33 c0		 xor	 eax, eax
  002fd	e8 00 00 00 00	 call	 _emit_file
  00302	59		 pop	 ecx
  00303	85 c0		 test	 eax, eax
  00305	75 26		 jne	 SHORT $LN733@emit_hrum
$LN88@emit_hrum:
  00307	33 f6		 xor	 esi, esi

; 318  : 
; 319  : 	if( success )

  00309	eb 32		 jmp	 SHORT $LN1@emit_hrum
$LN710@emit_hrum:

; 223  : 		{
; 224  : 			printf("mhmt-emit.c:emit_hrum() - encountered stop-code in optimal chain before emitting all data!\n");

  0030b	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@BOEKDFGJ@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5encoun@
  00310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00316	59		 pop	 ecx

; 225  : 			return 0;

  00317	eb 10		 jmp	 SHORT $LN746@emit_hrum
$INVALID_CODE_HRUM$2716:

; 298  : 			}
; 299  : 			else
; 300  : 				goto INVALID_CODE_HRUM;
; 301  : 		}
; 302  : 		else
; 303  : 		{
; 304  : INVALID_CODE_HRUM:
; 305  : 			printf("mhmt-emit.c:emit_hrum() - invalid code: length=%d, displacement=%d\n",length,disp);

  00319	53		 push	 ebx
  0031a	55		 push	 ebp
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JHGBHOHH@mhmt?9emit?4c?3emit_hrum?$CI?$CJ?5?9?5invali@
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN746@emit_hrum:

; 306  : 			return 0;

  00329	33 c0		 xor	 eax, eax
  0032b	eb 12		 jmp	 SHORT $LN742@emit_hrum
$LN733@emit_hrum:

; 320  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  0032d	f7 db		 neg	 ebx
  0032f	53		 push	 ebx
  00330	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0033b	59		 pop	 ecx
  0033c	59		 pop	 ecx
$LN1@emit_hrum:

; 321  : 
; 322  : 	return success;

  0033d	8b c6		 mov	 eax, esi
$LN742@emit_hrum:
  0033f	5d		 pop	 ebp
  00340	5e		 pop	 esi
$LN36@emit_hrum:
  00341	5f		 pop	 edi
  00342	5b		 pop	 ebx

; 323  : }

  00343	59		 pop	 ecx
  00344	59		 pop	 ecx
  00345	c3		 ret	 0
_emit_hrum ENDP
_TEXT	ENDS
PUBLIC	_emit_megalz
; Function compile flags: /Ogspy
;	COMDAT _emit_megalz
_TEXT	SEGMENT
_max_disp$ = -12					; size = 4
_length$ = -8						; size = 4
_position$ = -4						; size = 4
_optch$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_emit_megalz PROC					; COMDAT

; 13   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 14   : 	ULONG position;
; 15   : 	LONG length;
; 16   : 	LONG disp;
; 17   : 
; 18   : 	LONG max_disp; // maximum encountered displacement
; 19   : 
; 20   : 
; 21   : 	ULONG varbits,varlen;
; 22   : 
; 23   : 	ULONG success = 1;
; 24   : 
; 25   : 	max_disp = 0;

  00005	33 f6		 xor	 esi, esi
  00007	33 db		 xor	 ebx, ebx
  00009	89 5c 24 08	 mov	 DWORD PTR _max_disp$[esp+20], ebx

; 26   : 
; 27   : 
; 28   : 	// some checks
; 29   : 	if( !optch )

  0000d	39 74 24 18	 cmp	 DWORD PTR _optch$[esp+16], esi
  00011	75 13		 jne	 SHORT $LN30@emit_megal

; 30   : 	{
; 31   : 		printf("mhmt-emit.c:emit_megalz() - NULL passed!\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GHMDONPJ@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5NULL@
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0001e	59		 pop	 ecx

; 32   : 		return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 80 02 00 00	 jmp	 $LN31@emit_megal
$LN30@emit_megal:
  00026	55		 push	 ebp
  00027	57		 push	 edi

; 33   : 	}
; 34   : 
; 35   : 	// initialize
; 36   : 	success = success && emit_file(NULL, EMIT_FILE_INIT);
; 37   : 
; 38   : 	success = success && emit_byte(0, EMIT_BYTE_INIT);
; 39   : 
; 40   : 	success = success && emit_bits(0, EMIT_BITS_INIT);
; 41   : 
; 42   : 
; 43   : 	// copy first byte as-is
; 44   : 	success = success && emit_file( wrk.indata, 1);

  00028	ff 35 30 00 00
	00		 push	 DWORD PTR _wrk+48
  0002e	33 ff		 xor	 edi, edi
  00030	47		 inc	 edi
  00031	8b c7		 mov	 eax, edi
  00033	89 35 00 00 00
	00		 mov	 DWORD PTR ?position@?1??emit_file@@9@9, esi
  00039	89 35 00 00 00
	00		 mov	 DWORD PTR ?in_pos@?1??emit_byte@@9@9, esi
  0003f	89 35 00 00 00
	00		 mov	 DWORD PTR ?out_pos@?1??emit_byte@@9@9, esi
  00045	89 35 00 00 00
	00		 mov	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, esi
  0004b	89 35 00 00 00
	00		 mov	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, esi
  00051	e8 00 00 00 00	 call	 _emit_file
  00056	f7 d8		 neg	 eax
  00058	1b c0		 sbb	 eax, eax
  0005a	f7 d8		 neg	 eax
  0005c	59		 pop	 ecx

; 45   : 
; 46   : 	// go emitting codes
; 47   : 	position = 1;

  0005d	89 7c 24 18	 mov	 DWORD PTR _position$[esp+28], edi

; 48   : 
; 49   : 	while( (position<actual_len) && success )

  00061	39 7c 24 24	 cmp	 DWORD PTR _actual_len$[esp+24], edi
  00065	0f 86 f4 01 00
	00		 jbe	 $LN28@emit_megal
$LL29@emit_megal:
  0006b	3b c6		 cmp	 eax, esi
  0006d	0f 84 2f 02 00
	00		 je	 $LN1@emit_megal

; 50   : 	{
; 51   : 		length = optch[position].code.length;

  00073	8b 4c 24 20	 mov	 ecx, DWORD PTR _optch$[esp+24]
  00077	8b c7		 mov	 eax, edi
  00079	c1 e0 04	 shl	 eax, 4
  0007c	03 c1		 add	 eax, ecx
  0007e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 52   : 		disp   = optch[position].code.disp;

  00080	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]
  00083	89 5c 24 14	 mov	 DWORD PTR _length$[esp+28], ebx

; 53   : 
; 54   : 		if( length==0 )

  00087	3b de		 cmp	 ebx, esi
  00089	0f 84 1d 02 00
	00		 je	 $LN678@emit_megal

; 58   : 		}
; 59   : 		else if( length==1 ) // either copy-byte or len=1 code

  0008f	83 fb 01	 cmp	 ebx, 1
  00092	75 6c		 jne	 SHORT $LN25@emit_megal

; 60   : 		{
; 61   : 			if( disp==0 ) // copy-byte (%1<byte>)

  00094	3b ee		 cmp	 ebp, esi
  00096	75 37		 jne	 SHORT $LN24@emit_megal

; 62   : 			{
; 63   : 				success = success && emit_bits( 0x80000000, 1 );

  00098	53		 push	 ebx
  00099	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0009e	e8 00 00 00 00	 call	 _emit_bits
  000a3	59		 pop	 ecx
  000a4	59		 pop	 ecx
  000a5	85 c0		 test	 eax, eax
  000a7	74 1f		 je	 SHORT $LN43@emit_megal

; 64   : 				success = success && emit_byte( wrk.indata[position], EMIT_BYTE_ADD );

  000a9	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000ae	0f b6 04 38	 movzx	 eax, BYTE PTR [eax+edi]
  000b2	50		 push	 eax
  000b3	6a 02		 push	 2
  000b5	58		 pop	 eax
  000b6	e8 00 00 00 00	 call	 _emit_byte
  000bb	59		 pop	 ecx
  000bc	85 c0		 test	 eax, eax
  000be	74 08		 je	 SHORT $LN43@emit_megal
  000c0	33 c0		 xor	 eax, eax
  000c2	40		 inc	 eax
  000c3	e9 7f 01 00 00	 jmp	 $LN703@emit_megal
$LN43@emit_megal:
  000c8	33 c0		 xor	 eax, eax
  000ca	e9 78 01 00 00	 jmp	 $LN703@emit_megal
$LN24@emit_megal:

; 65   : 			}
; 66   : 			else if( (-8)<=disp && disp<=(-1) ) // len=1, disp=-1..-8 (%000abc)

  000cf	8d 45 08	 lea	 eax, DWORD PTR [ebp+8]
  000d2	83 f8 07	 cmp	 eax, 7
  000d5	0f 87 df 01 00
	00		 ja	 $INVALID_CODE_MEGALZ$2659

; 67   : 			{
; 68   : 				success = success && emit_bits( 0x00000000,   3 );

  000db	6a 03		 push	 3
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 _emit_bits
  000e3	59		 pop	 ecx
  000e4	59		 pop	 ecx
  000e5	85 c0		 test	 eax, eax
  000e7	0f 84 4e 01 00
	00		 je	 $LN69@emit_megal

; 69   : 				success = success && emit_bits( disp<<(32-3), 3 );

  000ed	8b c5		 mov	 eax, ebp
  000ef	c1 e0 1d	 shl	 eax, 29			; 0000001dH
  000f2	6a 03		 push	 3
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _emit_bits
  000fa	59		 pop	 ecx
  000fb	e9 31 01 00 00	 jmp	 $LN708@emit_megal
$LN25@emit_megal:

; 70   : 
; 71   : 				if( max_disp > disp ) max_disp = disp;
; 72   : 			}
; 73   : 			else
; 74   : 				goto INVALID_CODE_MEGALZ;
; 75   : 		}
; 76   : 		else if( length==2 )

  00100	83 fb 02	 cmp	 ebx, 2
  00103	75 1d		 jne	 SHORT $LN18@emit_megal

; 77   : 		{
; 78   : 			if( (-256)<=disp && disp<=(-1) ) // %001<byte>

  00105	8d 85 00 01 00
	00		 lea	 eax, DWORD PTR [ebp+256]
  0010b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00110	0f 87 a4 01 00
	00		 ja	 $INVALID_CODE_MEGALZ$2659

; 79   : 			{
; 80   : 				success = success && emit_bits( 0x20000000, 3 );

  00116	6a 03		 push	 3
  00118	68 00 00 00 20	 push	 536870912		; 20000000H

; 81   : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  0011d	e9 fb 00 00 00	 jmp	 $LN709@emit_megal
$LN18@emit_megal:

; 82   : 
; 83   : 				if( max_disp > disp ) max_disp = disp;
; 84   : 			}
; 85   : 			else
; 86   : 				goto INVALID_CODE_MEGALZ;
; 87   : 		}
; 88   : 		else if( 3<=length && length<=255 )

  00122	8d 43 fd	 lea	 eax, DWORD PTR [ebx-3]
  00125	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  0012a	0f 87 8a 01 00
	00		 ja	 $INVALID_CODE_MEGALZ$2659

; 89   : 		{
; 90   : 			// length coding
; 91   : 			if( length==3 ) // %010
; 92   : 			{
; 93   : 				success = success && emit_bits( 0x40000000, 3 );

  00130	6a 03		 push	 3
  00132	83 fb 03	 cmp	 ebx, 3
  00135	75 14		 jne	 SHORT $LN12@emit_megal
  00137	68 00 00 00 40	 push	 1073741824		; 40000000H
  0013c	e8 00 00 00 00	 call	 _emit_bits
  00141	f7 d8		 neg	 eax
  00143	59		 pop	 ecx
  00144	1b c0		 sbb	 eax, eax
  00146	59		 pop	 ecx
  00147	f7 d8		 neg	 eax

; 94   : 			}
; 95   : 			else // length==4..255, %011

  00149	eb 59		 jmp	 SHORT $LN60@emit_megal
$LN12@emit_megal:

; 96   : 			{
; 97   : 				success = success && emit_bits( 0x60000000, 3 );

  0014b	68 00 00 00 60	 push	 1610612736		; 60000000H
  00150	e8 00 00 00 00	 call	 _emit_bits
  00155	f7 d8		 neg	 eax
  00157	59		 pop	 ecx
  00158	1b c0		 sbb	 eax, eax
  0015a	59		 pop	 ecx

; 98   : 
; 99   : 				// calculate size of variable bits
; 100  : 				varlen = 0;
; 101  : 				varbits = (length-2)>>1;

  0015b	8d 4b fe	 lea	 ecx, DWORD PTR [ebx-2]
  0015e	f7 d8		 neg	 eax
  00160	33 ff		 xor	 edi, edi
  00162	d1 f9		 sar	 ecx, 1

; 102  : 				while( varbits )

  00164	74 07		 je	 SHORT $LN9@emit_megal
$LL10@emit_megal:

; 103  : 				{
; 104  : 					varbits >>= 1;

  00166	d1 e9		 shr	 ecx, 1

; 105  : 					varlen++;

  00168	47		 inc	 edi
  00169	3b ce		 cmp	 ecx, esi
  0016b	75 f9		 jne	 SHORT $LL10@emit_megal
$LN9@emit_megal:

; 106  : 				}
; 107  : 
; 108  : 				varbits = length-2-(1<<varlen); // prepare length coding

  0016d	33 d2		 xor	 edx, edx
  0016f	42		 inc	 edx
  00170	8b cf		 mov	 ecx, edi
  00172	d3 e2		 shl	 edx, cl
  00174	8b f3		 mov	 esi, ebx
  00176	2b f2		 sub	 esi, edx
  00178	4e		 dec	 esi
  00179	4e		 dec	 esi

; 109  : 
; 110  : 				success = success && emit_bits(       1<<(32-varlen), varlen );

  0017a	85 c0		 test	 eax, eax
  0017c	74 22		 je	 SHORT $LN59@emit_megal
  0017e	83 ff ff	 cmp	 edi, -1
  00181	74 3c		 je	 SHORT $LN701@emit_megal
  00183	6a 20		 push	 32			; 00000020H
  00185	5b		 pop	 ebx
  00186	33 c0		 xor	 eax, eax
  00188	2b df		 sub	 ebx, edi
  0018a	40		 inc	 eax
  0018b	8b cb		 mov	 ecx, ebx
  0018d	d3 e0		 shl	 eax, cl
  0018f	57		 push	 edi
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _emit_bits
  00196	59		 pop	 ecx
  00197	59		 pop	 ecx
  00198	85 c0		 test	 eax, eax
  0019a	75 33		 jne	 SHORT $LN486@emit_megal
$LN702@emit_megal:

; 111  : 				success = success && emit_bits( varbits<<(32-varlen), varlen );

  0019c	8b 5c 24 14	 mov	 ebx, DWORD PTR _length$[esp+28]
$LN59@emit_megal:
  001a0	33 c0		 xor	 eax, eax
$LN707@emit_megal:
  001a2	33 f6		 xor	 esi, esi
$LN60@emit_megal:

; 112  : 			}
; 113  : 
; 114  : 			// displacement coding
; 115  : 			if( (-256)<=disp && disp<=(-1) )

  001a4	8d bd 00 01 00
	00		 lea	 edi, DWORD PTR [ebp+256]
  001aa	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  001b0	77 37		 ja	 SHORT $LN8@emit_megal

; 116  : 			{
; 117  : 				success = success && emit_bits( 0, 1 );

  001b2	3b c6		 cmp	 eax, esi
  001b4	0f 84 81 00 00
	00		 je	 $LN69@emit_megal
  001ba	6a 01		 push	 1
  001bc	56		 push	 esi

; 118  : 				success = success && emit_byte( (UBYTE)(0x00ff & disp), EMIT_BYTE_ADD );

  001bd	eb 5e		 jmp	 SHORT $LN709@emit_megal
$LN701@emit_megal:

; 111  : 				success = success && emit_bits( varbits<<(32-varlen), varlen );

  001bf	83 25 00 00 00
	00 00		 and	 DWORD PTR ?bit_store@?1??emit_bits@@9@9, 0
  001c6	83 25 00 00 00
	00 00		 and	 DWORD PTR ?bit_count@?1??emit_bits@@9@9, 0
  001cd	eb 15		 jmp	 SHORT $LN694@emit_megal
$LN486@emit_megal:
  001cf	8b cb		 mov	 ecx, ebx
  001d1	d3 e6		 shl	 esi, cl
  001d3	57		 push	 edi
  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 _emit_bits
  001da	59		 pop	 ecx
  001db	59		 pop	 ecx
  001dc	85 c0		 test	 eax, eax
  001de	74 bc		 je	 SHORT $LN702@emit_megal
  001e0	8b 5c 24 14	 mov	 ebx, DWORD PTR _length$[esp+28]
$LN694@emit_megal:
  001e4	33 c0		 xor	 eax, eax
  001e6	40		 inc	 eax
  001e7	eb b9		 jmp	 SHORT $LN707@emit_megal
$LN8@emit_megal:

; 119  : 
; 120  : 				if( max_disp > disp ) max_disp = disp;
; 121  : 			}
; 122  : 			else if( (-4352)<=disp && disp<(-256) )

  001e9	8d 8d 00 11 00
	00		 lea	 ecx, DWORD PTR [ebp+4352]
  001ef	81 f9 ff 0f 00
	00		 cmp	 ecx, 4095		; 00000fffH
  001f5	0f 87 bf 00 00
	00		 ja	 $INVALID_CODE_MEGALZ$2659

; 123  : 			{
; 124  : 				success = success && emit_bits( 0x80000000, 1 );

  001fb	3b c6		 cmp	 eax, esi
  001fd	74 3c		 je	 SHORT $LN69@emit_megal
  001ff	6a 01		 push	 1
  00201	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00206	e8 00 00 00 00	 call	 _emit_bits
  0020b	59		 pop	 ecx
  0020c	59		 pop	 ecx
  0020d	85 c0		 test	 eax, eax

; 125  : 
; 126  : 				success = success && emit_bits( (0x0F00&(disp+0x0100))<<20, 4 );

  0020f	74 2a		 je	 SHORT $LN69@emit_megal
  00211	c1 e7 14	 shl	 edi, 20			; 00000014H
  00214	6a 04		 push	 4
  00216	81 e7 00 00 00
	f0		 and	 edi, -268435456		; f0000000H
  0021c	57		 push	 edi
$LN709@emit_megal:
  0021d	e8 00 00 00 00	 call	 _emit_bits
  00222	59		 pop	 ecx
  00223	59		 pop	 ecx
  00224	85 c0		 test	 eax, eax

; 127  : 
; 128  : 				success = success && emit_byte( (UBYTE)(0x00FF & disp), EMIT_BYTE_ADD );

  00226	74 13		 je	 SHORT $LN69@emit_megal
  00228	55		 push	 ebp
  00229	6a 02		 push	 2
  0022b	58		 pop	 eax
  0022c	e8 00 00 00 00	 call	 _emit_byte
$LN708@emit_megal:
  00231	59		 pop	 ecx
  00232	85 c0		 test	 eax, eax
  00234	74 05		 je	 SHORT $LN69@emit_megal
  00236	33 c0		 xor	 eax, eax
  00238	40		 inc	 eax
  00239	eb 02		 jmp	 SHORT $LN70@emit_megal
$LN69@emit_megal:
  0023b	33 c0		 xor	 eax, eax
$LN70@emit_megal:

; 129  : 
; 130  : 				if( max_disp > disp ) max_disp = disp;

  0023d	39 6c 24 10	 cmp	 DWORD PTR _max_disp$[esp+28], ebp
  00241	7e 04		 jle	 SHORT $LN703@emit_megal
  00243	89 6c 24 10	 mov	 DWORD PTR _max_disp$[esp+28], ebp
$LN703@emit_megal:

; 140  : 		}
; 141  : 
; 142  : 		position += length;

  00247	8b 7c 24 18	 mov	 edi, DWORD PTR _position$[esp+28]
  0024b	03 fb		 add	 edi, ebx
  0024d	89 7c 24 18	 mov	 DWORD PTR _position$[esp+28], edi
  00251	3b 7c 24 24	 cmp	 edi, DWORD PTR _actual_len$[esp+24]
  00255	0f 82 10 fe ff
	ff		 jb	 $LL29@emit_megal

; 53   : 
; 54   : 		if( length==0 )

  0025b	8b 5c 24 10	 mov	 ebx, DWORD PTR _max_disp$[esp+28]
$LN28@emit_megal:

; 143  : 	}
; 144  : 
; 145  : 	// stop-code
; 146  : 	success = success && emit_bits( 0x60100000, 12 );

  0025f	3b c6		 cmp	 eax, esi
  00261	74 3f		 je	 SHORT $LN1@emit_megal
  00263	6a 0c		 push	 12			; 0000000cH
  00265	68 00 00 10 60	 push	 1611661312		; 60100000H
  0026a	e8 00 00 00 00	 call	 _emit_bits
  0026f	59		 pop	 ecx
  00270	59		 pop	 ecx
  00271	85 c0		 test	 eax, eax

; 147  : 	success = success && emit_bits( 0, EMIT_BITS_FINISH ); // this also flushes emit_byte()

  00273	74 2d		 je	 SHORT $LN1@emit_megal
  00275	56		 push	 esi
  00276	56		 push	 esi
  00277	e8 00 00 00 00	 call	 _emit_bits
  0027c	59		 pop	 ecx
  0027d	59		 pop	 ecx
  0027e	85 c0		 test	 eax, eax

; 148  : 
; 149  : 	success = success && emit_file( NULL, EMIT_FILE_FINISH );

  00280	74 20		 je	 SHORT $LN1@emit_megal
  00282	56		 push	 esi
  00283	33 c0		 xor	 eax, eax
  00285	e8 00 00 00 00	 call	 _emit_file
  0028a	59		 pop	 ecx
  0028b	85 c0		 test	 eax, eax
  0028d	74 13		 je	 SHORT $LN1@emit_megal

; 150  : 
; 151  : 	if( success )
; 152  : 		printf("Maximum displacement actually used is %d.\n",-max_disp);

  0028f	f7 db		 neg	 ebx
  00291	33 f6		 xor	 esi, esi
  00293	53		 push	 ebx
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NOIJGGOJ@Maximum?5displacement?5actually?5us@
  00299	46		 inc	 esi
  0029a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002a0	59		 pop	 ecx
  002a1	59		 pop	 ecx
$LN1@emit_megal:

; 153  : 
; 154  : 	return success;

  002a2	8b c6		 mov	 eax, esi
$LN705@emit_megal:
  002a4	5f		 pop	 edi
  002a5	5d		 pop	 ebp
$LN31@emit_megal:
  002a6	5e		 pop	 esi
  002a7	5b		 pop	 ebx

; 155  : }

  002a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ab	c3		 ret	 0
$LN678@emit_megal:

; 55   : 		{
; 56   : 			printf("mhmt-emit.c:emit_megalz() - encountered stop-code in optimal chain before emitting all data!\n");

  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@LNJOIALC@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5enco@
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002b7	59		 pop	 ecx

; 57   : 			return 0;

  002b8	eb 10		 jmp	 SHORT $LN710@emit_megal
$INVALID_CODE_MEGALZ$2659:

; 131  : 			}
; 132  : 			else
; 133  : 				goto INVALID_CODE_MEGALZ;
; 134  : 		}
; 135  : 		else
; 136  : 		{
; 137  : INVALID_CODE_MEGALZ:
; 138  : 			printf("mhmt-emit.c:emit_megalz() - invalid code: length=%d, displacement=%d\n",length,disp);

  002ba	55		 push	 ebp
  002bb	53		 push	 ebx
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@GNBNOJBP@mhmt?9emit?4c?3emit_megalz?$CI?$CJ?5?9?5inva@
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN710@emit_megal:

; 139  : 			return 0;

  002ca	33 c0		 xor	 eax, eax
  002cc	eb d6		 jmp	 SHORT $LN705@emit_megal
_emit_megalz ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-globals.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__fclose:PROC
COMM	_wrk:BYTE:038H
PUBLIC	_free_globals
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-globals.c
;	COMDAT _free_globals
_TEXT	SEGMENT
_free_globals PROC					; COMDAT

; 35   : 	if( wrk.indata ) free( wrk.indata );

  00000	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  00005	57		 push	 edi
  00006	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  0000c	85 c0		 test	 eax, eax
  0000e	74 04		 je	 SHORT $LN5@free_globa
  00010	50		 push	 eax
  00011	ff d7		 call	 edi
  00013	59		 pop	 ecx
$LN5@free_globa:

; 36   : 
; 37   : 	if( wrk.file_out ) fclose( wrk.file_out );

  00014	a1 2c 00 00 00	 mov	 eax, DWORD PTR _wrk+44
  00019	56		 push	 esi
  0001a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fclose
  00020	85 c0		 test	 eax, eax
  00022	74 04		 je	 SHORT $LN4@free_globa
  00024	50		 push	 eax
  00025	ff d6		 call	 esi
  00027	59		 pop	 ecx
$LN4@free_globa:

; 38   : 	if( wrk.file_in )  fclose( wrk.file_in );

  00028	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  0002d	85 c0		 test	 eax, eax
  0002f	74 04		 je	 SHORT $LN3@free_globa
  00031	50		 push	 eax
  00032	ff d6		 call	 esi
  00034	59		 pop	 ecx
$LN3@free_globa:

; 39   : 
; 40   : 	if( wrk.fname_out ) free( wrk.fname_out );

  00035	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  0003a	5e		 pop	 esi
  0003b	85 c0		 test	 eax, eax
  0003d	74 04		 je	 SHORT $LN2@free_globa
  0003f	50		 push	 eax
  00040	ff d7		 call	 edi
  00042	59		 pop	 ecx
$LN2@free_globa:

; 41   : 	if( wrk.fname_in )  free( wrk.fname_in );

  00043	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  00048	85 c0		 test	 eax, eax
  0004a	74 04		 je	 SHORT $LN1@free_globa
  0004c	50		 push	 eax
  0004d	ff d7		 call	 edi
  0004f	59		 pop	 ecx
$LN1@free_globa:
  00050	5f		 pop	 edi

; 42   : }

  00051	c3		 ret	 0
_free_globals ENDP
_TEXT	ENDS
PUBLIC	_init_globals
; Function compile flags: /Ogspy
;	COMDAT _init_globals
_TEXT	SEGMENT
_init_globals PROC					; COMDAT

; 11   : 	wrk.packtype = PK_MLZ;
; 12   : 	wrk.greedy   = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk, 1
  0000c	a3 04 00 00 00	 mov	 DWORD PTR _wrk+4, eax

; 13   : 	wrk.mode     = 0;

  00011	a3 08 00 00 00	 mov	 DWORD PTR _wrk+8, eax

; 14   : 	wrk.zxheader = 0;

  00016	a3 0c 00 00 00	 mov	 DWORD PTR _wrk+12, eax

; 15   : 	wrk.wordbit  = 0;

  0001b	a3 10 00 00 00	 mov	 DWORD PTR _wrk+16, eax

; 16   : 	wrk.bigend   = 0;

  00020	a3 14 00 00 00	 mov	 DWORD PTR _wrk+20, eax

; 17   : 	wrk.fullbits = 0;

  00025	a3 18 00 00 00	 mov	 DWORD PTR _wrk+24, eax

; 18   : 	wrk.maxwin   = 4352;

  0002a	c7 05 1c 00 00
	00 00 11 00 00	 mov	 DWORD PTR _wrk+28, 4352	; 00001100H

; 19   : 
; 20   : 	wrk.fname_in  = NULL;

  00034	a3 20 00 00 00	 mov	 DWORD PTR _wrk+32, eax

; 21   : 	wrk.fname_out = NULL;

  00039	a3 24 00 00 00	 mov	 DWORD PTR _wrk+36, eax

; 22   : 
; 23   : 	wrk.file_in  = NULL;

  0003e	a3 28 00 00 00	 mov	 DWORD PTR _wrk+40, eax

; 24   : 	wrk.file_out = NULL;

  00043	a3 2c 00 00 00	 mov	 DWORD PTR _wrk+44, eax

; 25   : 
; 26   : 	wrk.indata = NULL;

  00048	a3 30 00 00 00	 mov	 DWORD PTR _wrk+48, eax

; 27   : 	wrk.inlen = 0;

  0004d	a3 34 00 00 00	 mov	 DWORD PTR _wrk+52, eax

; 28   : }

  00052	c3		 ret	 0
_init_globals ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_destroy_hash
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-hash.c
;	COMDAT _destroy_hash
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_destroy_hash PROC					; COMDAT

; 49   : 	if( hash ) free(hash);

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _hash$[esp-4], 0
  00005	74 06		 je	 SHORT $LN1@destroy_ha
  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__free
$LN1@destroy_ha:

; 50   : }

  0000d	c3		 ret	 0
_destroy_hash ENDP
_TEXT	ENDS
PUBLIC	_build_hash
; Function compile flags: /Ogspy
;	COMDAT _build_hash
_TEXT	SEGMENT
_hash$ = -4						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_build_hash PROC					; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 11   : 	UBYTE * hash;
; 12   : 
; 13   : 	ULONG i; UBYTE *src,*dst;
; 14   : 	UBYTE curr,prev,prev2;
; 15   : 
; 16   : 	if( !length )

  00005	33 db		 xor	 ebx, ebx
  00007	39 5d 0c	 cmp	 DWORD PTR _length$[ebp], ebx
  0000a	75 04		 jne	 SHORT $LN5@build_hash

; 17   : 		return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 3b		 jmp	 SHORT $LN6@build_hash
$LN5@build_hash:
  00010	57		 push	 edi

; 18   : 
; 19   : 	hash=(UBYTE *)malloc( length );

  00011	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0001a	8b f8		 mov	 edi, eax
  0001c	59		 pop	 ecx
  0001d	89 7d fc	 mov	 DWORD PTR _hash$[ebp], edi

; 20   :         if( !hash )

  00020	3b fb		 cmp	 edi, ebx
  00022	75 04		 jne	 SHORT $LN4@build_hash

; 21   :         	return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	eb 22		 jmp	 SHORT $LN9@build_hash
$LN4@build_hash:

; 22   : 
; 23   : 
; 24   : 	prev=curr=0;
; 25   : 	i=length;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0002b	56		 push	 esi

; 26   : 	src = data;

  0002c	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0002f	32 d2		 xor	 dl, dl
$LL3@build_hash:

; 27   : 	dst = hash;
; 28   : 
; 29   : 	do
; 30   : 	{
; 31   : 		prev2 = (UBYTE)( (prev>>1) | (prev<<7) );

  00031	8a cb		 mov	 cl, bl
  00033	d0 c9		 ror	 cl, 1

; 32   : 		prev  = (UBYTE)( (curr>>1) | (curr<<7) );

  00035	d0 ca		 ror	 dl, 1
  00037	8a da		 mov	 bl, dl

; 33   : 		curr  = *(src++);

  00039	8a 16		 mov	 dl, BYTE PTR [esi]

; 34   : 
; 35   : 		*(dst++) = curr^prev^prev2;

  0003b	32 ca		 xor	 cl, dl
  0003d	32 cb		 xor	 cl, bl
  0003f	46		 inc	 esi
  00040	88 0f		 mov	 BYTE PTR [edi], cl
  00042	47		 inc	 edi

; 36   : 
; 37   : 	} while( --i );

  00043	48		 dec	 eax
  00044	75 eb		 jne	 SHORT $LL3@build_hash

; 38   : 
; 39   : 
; 40   : 
; 41   : 	return hash;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _hash$[ebp]
  00049	5e		 pop	 esi
$LN9@build_hash:
  0004a	5f		 pop	 edi
$LN6@build_hash:
  0004b	5b		 pop	 ebx

; 42   : }

  0004c	c9		 leave
  0004d	c3		 ret	 0
_build_hash ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-lz.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DA@NLLGIJDF@mhmt?9lz?4c?3make_lz_codes?$CI?$CJ?5?9?5wron@ ; `string'
PUBLIC	??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@ ; `string'
PUBLIC	??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@ ; `string'
PUBLIC	??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@ ; `string'
EXTRN	__imp__exit:PROC
;	COMDAT ??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@
CONST	SEGMENT
??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@ DB 'mhmt-'
	DB	'lz.c:get_lz_price_hrust(): Found invalid code length=%d, disp'
	DB	'lacement=%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@
CONST	SEGMENT
??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@ DB 'mhmt-'
	DB	'lz.c:get_lz_price_hrum(): Found invalid code length=%d, displ'
	DB	'acement=%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@
CONST	SEGMENT
??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@ DB 'mhmt-l'
	DB	'z.c:get_lz_price_megalz(): Found invalid code length=%d, disp'
	DB	'lacement=%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@ DB 'mhmt-l'
	DB	'z.c:make_lz_codes_hrust() encountered too many entries in cod'
	DB	'es[] table. Fatal error.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NLLGIJDF@mhmt?9lz?4c?3make_lz_codes?$CI?$CJ?5?9?5wron@
CONST	SEGMENT
??_C@_0DA@NLLGIJDF@mhmt?9lz?4c?3make_lz_codes?$CI?$CJ?5?9?5wron@ DB 'mhmt'
	DB	'-lz.c:make_lz_codes() - wrong packer type!', 0aH, 00H ; `string'
PUBLIC	_get_lz_price_hrust
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-lz.c
;	COMDAT _get_lz_price_hrust
_TEXT	SEGMENT
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_hrust PROC				; COMDAT

; 352  : 	ULONG varbits,varlen;
; 353  : 	LONG length,disp,tmp;
; 354  : 
; 355  : 	length = lzcode->length;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _lzcode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	56		 push	 esi

; 356  : 	disp   = lzcode->disp;

  00007	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 357  : 
; 358  : 
; 359  : 	if( disp==0 )

  0000a	85 f6		 test	 esi, esi
  0000c	75 28		 jne	 SHORT $LN38@get_lz_pri

; 360  : 	{
; 361  : 		if( length==1 )

  0000e	83 f9 01	 cmp	 ecx, 1
  00011	75 05		 jne	 SHORT $LN37@get_lz_pri

; 362  : 		{
; 363  : 			return 9; // copy-1-byte

  00013	6a 09		 push	 9
$LN44@get_lz_pri:
  00015	58		 pop	 eax
  00016	5e		 pop	 esi

; 464  : 	}
; 465  : }

  00017	c3		 ret	 0
$LN37@get_lz_pri:

; 364  : 		}
; 365  : 		else if( (12<=length) && (length<=42) && ( !(length&1) ) )

  00018	8d 41 f4	 lea	 eax, DWORD PTR [ecx-12]
  0001b	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0001e	0f 87 f3 00 00
	00		 ja	 $INVALID_CODE_HRUST$4785
  00024	f6 c1 01	 test	 cl, 1
  00027	0f 85 ea 00 00
	00		 jne	 $INVALID_CODE_HRUST$4785

; 366  : 		{
; 367  : 			return 11 + 8*length;

  0002d	8d 04 cd 0b 00
	00 00		 lea	 eax, DWORD PTR [ecx*8+11]
  00034	5e		 pop	 esi

; 464  : 	}
; 465  : }

  00035	c3		 ret	 0
$LN38@get_lz_pri:

; 368  : 		}
; 369  : 		else
; 370  : 			goto INVALID_CODE_HRUST;
; 371  : 	}
; 372  : 	else if( length==(-3) ) // insertion match!

  00036	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  00039	75 1c		 jne	 SHORT $LN32@get_lz_pri

; 373  : 	{
; 374  : 		if( (-16)<=disp && disp<=(-1) )

  0003b	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0003e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00041	77 04		 ja	 SHORT $LN31@get_lz_pri

; 375  : 		{
; 376  : 			return 10+8;

  00043	6a 12		 push	 18			; 00000012H
  00045	eb ce		 jmp	 SHORT $LN44@get_lz_pri
$LN31@get_lz_pri:

; 377  : 		}
; 378  : 		else if( (-79)<=disp && disp<(-16) )

  00047	8d 46 4f	 lea	 eax, DWORD PTR [esi+79]
  0004a	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0004d	0f 87 c4 00 00
	00		 ja	 $INVALID_CODE_HRUST$4785

; 379  : 		{
; 380  : 			return 5+8+8;

  00053	6a 15		 push	 21			; 00000015H
  00055	eb be		 jmp	 SHORT $LN44@get_lz_pri
$LN32@get_lz_pri:

; 381  : 		}
; 382  : 		else
; 383  : 			goto INVALID_CODE_HRUST;
; 384  : 	}
; 385  : 	else if( length==1 )

  00057	83 f9 01	 cmp	 ecx, 1
  0005a	75 10		 jne	 SHORT $LN26@get_lz_pri

; 386  : 	{
; 387  : 		if( (-8)<=disp && disp<=(-1) )

  0005c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0005f	83 f8 07	 cmp	 eax, 7
  00062	0f 87 af 00 00
	00		 ja	 $INVALID_CODE_HRUST$4785

; 388  : 			return 6;

  00068	6a 06		 push	 6
  0006a	eb a9		 jmp	 SHORT $LN44@get_lz_pri
$LN26@get_lz_pri:

; 389  : 		else
; 390  : 			goto INVALID_CODE_HRUST;
; 391  : 	}
; 392  : 	else if( length==2 )

  0006c	83 f9 02	 cmp	 ecx, 2
  0006f	75 21		 jne	 SHORT $LN22@get_lz_pri

; 393  : 	{
; 394  : 		if( (-32)<=disp && disp<=(-1) )

  00071	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00074	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00077	77 04		 ja	 SHORT $LN21@get_lz_pri

; 395  : 		{
; 396  : 			return 10;

  00079	6a 0a		 push	 10			; 0000000aH
  0007b	eb 98		 jmp	 SHORT $LN44@get_lz_pri
$LN21@get_lz_pri:

; 397  : 		}
; 398  : 		else if( (-768)<=disp && disp<(-32) )

  0007d	8d 86 00 03 00
	00		 lea	 eax, DWORD PTR [esi+768]
  00083	3d df 02 00 00	 cmp	 eax, 735		; 000002dfH
  00088	0f 87 89 00 00
	00		 ja	 $INVALID_CODE_HRUST$4785

; 399  : 		{
; 400  : 			return 13;

  0008e	6a 0d		 push	 13			; 0000000dH
  00090	eb 83		 jmp	 SHORT $LN44@get_lz_pri
$LN22@get_lz_pri:

; 401  : 		}
; 402  : 		else
; 403  : 			goto INVALID_CODE_HRUST;
; 404  : 	}
; 405  : 	else if (3<=length && length<=3839 && (-65536)<=disp && disp<=(-1) )

  00092	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]
  00095	3d fc 0e 00 00	 cmp	 eax, 3836		; 00000efcH
  0009a	77 7b		 ja	 SHORT $INVALID_CODE_HRUST$4785
  0009c	8d 86 00 00 01
	00		 lea	 eax, DWORD PTR [esi+65536]
  000a2	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000a7	77 6e		 ja	 SHORT $INVALID_CODE_HRUST$4785

; 406  : 	{
; 407  : 		// first, calc influence of length
; 408  : 		if( length<=15 ) // 3..15

  000a9	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000ac	7f 1f		 jg	 SHORT $LN15@get_lz_pri
  000ae	57		 push	 edi

; 409  : 		{
; 410  : 			varlen = 3 + ( (length/3)<<1 );

  000af	8b c1		 mov	 eax, ecx
  000b1	6a 03		 push	 3
  000b3	99		 cdq
  000b4	5f		 pop	 edi
  000b5	f7 ff		 idiv	 edi
  000b7	5f		 pop	 edi
  000b8	8d 44 00 03	 lea	 eax, DWORD PTR [eax+eax+3]

; 411  : 
; 412  : 			if( length==3 )  varlen = 3;

  000bc	83 f9 03	 cmp	 ecx, 3
  000bf	75 02		 jne	 SHORT $LN14@get_lz_pri
  000c1	51		 push	 ecx
  000c2	58		 pop	 eax
$LN14@get_lz_pri:

; 413  : 
; 414  : 			if( length==15 ) varlen = 11;

  000c3	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000c6	75 14		 jne	 SHORT $LN11@get_lz_pri
  000c8	6a 0b		 push	 11			; 0000000bH
  000ca	58		 pop	 eax

; 415  : 		}
; 416  : 		else if( length<=127 ) // 16..127

  000cb	eb 0f		 jmp	 SHORT $LN11@get_lz_pri
$LN15@get_lz_pri:
  000cd	33 c0		 xor	 eax, eax
  000cf	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  000d2	0f 9f c0	 setg	 al
  000d5	8d 04 c5 0e 00
	00 00		 lea	 eax, DWORD PTR [eax*8+14]
$LN11@get_lz_pri:

; 417  : 		{
; 418  : 			varlen = 14;
; 419  : 		}
; 420  : 		else // 128..3839
; 421  : 		{
; 422  : 			varlen = 14+8;
; 423  : 		}
; 424  : 
; 425  : 
; 426  : 		// add displacement length
; 427  : 		if( (-32)<=disp ) // ffe0..ffff

  000dc	83 fe e0	 cmp	 esi, -32		; ffffffe0H
  000df	7c 05		 jl	 SHORT $LN9@get_lz_pri

; 428  : 		{
; 429  : 			varlen += 7;

  000e1	83 c0 07	 add	 eax, 7
  000e4	5e		 pop	 esi

; 464  : 	}
; 465  : }

  000e5	c3		 ret	 0
$LN9@get_lz_pri:

; 430  : 		}
; 431  : 		else if( (-512)<=disp ) // fe00..ffdf

  000e6	81 fe 00 fe ff
	ff		 cmp	 esi, -512		; fffffe00H
  000ec	7c 05		 jl	 SHORT $LN7@get_lz_pri

; 432  : 		{
; 433  : 			varlen += 10;

  000ee	83 c0 0a	 add	 eax, 10			; 0000000aH
  000f1	5e		 pop	 esi

; 464  : 	}
; 465  : }

  000f2	c3		 ret	 0
$LN7@get_lz_pri:

; 434  : 		}
; 435  : 		else // 0000(-65536)..fdff: -513:-1024, -1025:-2048, -2049:-4096, ... ,-32769:-65536
; 436  : 		{    // bits:                   12           13           14               18
; 437  : 
; 438  : 			varlen += 12;

  000f3	83 c0 0c	 add	 eax, 12			; 0000000cH

; 439  : 
; 440  : 			if( position>32768 )

  000f6	81 7c 24 08 00
	80 00 00	 cmp	 DWORD PTR _position$[esp], 32768 ; 00008000H
  000fe	76 05		 jbe	 SHORT $LN5@get_lz_pri

; 441  : 			{
; 442  : 				varlen += 6; // 8bits

  00100	83 c0 06	 add	 eax, 6
  00103	5e		 pop	 esi

; 464  : 	}
; 465  : }

  00104	c3		 ret	 0
$LN5@get_lz_pri:

; 443  : 			}
; 444  : 			else
; 445  : 			{
; 446  : 				tmp = 1024;

  00105	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0010a	eb 03		 jmp	 SHORT $LN43@get_lz_pri
$LL3@get_lz_pri:

; 449  : 				{
; 450  : 					varlen++;

  0010c	40		 inc	 eax

; 451  : 
; 452  : 					tmp <<= 1;

  0010d	03 c9		 add	 ecx, ecx
$LN43@get_lz_pri:

; 447  : 
; 448  : 				while( position>(ULONG)tmp )

  0010f	39 4c 24 08	 cmp	 DWORD PTR _position$[esp], ecx
  00113	77 f7		 ja	 SHORT $LL3@get_lz_pri
  00115	5e		 pop	 esi

; 464  : 	}
; 465  : }

  00116	c3		 ret	 0
$INVALID_CODE_HRUST$4785:

; 453  : 				}
; 454  : 			}
; 455  : 		}
; 456  : 
; 457  : 		return varlen;
; 458  : 	}
; 459  : 	else
; 460  : 	{
; 461  : INVALID_CODE_HRUST:
; 462  : 		printf("mhmt-lz.c:get_lz_price_hrust(): Found invalid code length=%d, displacement=%d\n",length, disp);

  00117	56		 push	 esi
  00118	51		 push	 ecx
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@EGPLHNMD@mhmt?9lz?4c?3get_lz_price_hrust?$CI?$CJ?3?5@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 		return 0;

  00127	33 c0		 xor	 eax, eax
  00129	5e		 pop	 esi

; 464  : 	}
; 465  : }

  0012a	c3		 ret	 0
_get_lz_price_hrust ENDP
_TEXT	ENDS
PUBLIC	_get_lz_price_hrum
; Function compile flags: /Ogspy
;	COMDAT _get_lz_price_hrum
_TEXT	SEGMENT
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_hrum PROC					; COMDAT

; 285  : 	ULONG varlen;
; 286  : 	LONG length,disp;
; 287  : 
; 288  : 	length = lzcode->length;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _lzcode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]

; 289  : 	disp   = lzcode->disp;

  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi

; 290  : 
; 291  : 	if( length==1 )

  0000a	83 f9 01	 cmp	 ecx, 1
  0000d	75 15		 jne	 SHORT $LN22@get_lz_pri@2

; 292  : 	{
; 293  : 		if( disp==0 )

  0000f	85 d2		 test	 edx, edx
  00011	75 05		 jne	 SHORT $LN21@get_lz_pri@2

; 294  : 			return 9;

  00013	6a 09		 push	 9
$LN26@get_lz_pri@2:
  00015	58		 pop	 eax
  00016	5e		 pop	 esi

; 337  : 	}
; 338  : }

  00017	c3		 ret	 0
$LN21@get_lz_pri@2:

; 295  : 		else if( (-8)<=disp && disp<=(-1) )

  00018	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  0001b	83 f8 07	 cmp	 eax, 7
  0001e	77 7a		 ja	 SHORT $INVALID_CODE_HRUM$4751

; 296  : 			return 6;

  00020	6a 06		 push	 6
  00022	eb f1		 jmp	 SHORT $LN26@get_lz_pri@2
$LN22@get_lz_pri@2:

; 297  : 		else
; 298  : 			goto INVALID_CODE_HRUM;
; 299  : 	}
; 300  : 	else if( length==2 )

  00024	83 f9 02	 cmp	 ecx, 2
  00027	75 11		 jne	 SHORT $LN16@get_lz_pri@2

; 301  : 	{
; 302  : 		if( (-256)<=disp && disp<=(-1) )

  00029	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  0002f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00034	77 64		 ja	 SHORT $INVALID_CODE_HRUM$4751

; 303  : 			return 11;

  00036	6a 0b		 push	 11			; 0000000bH
  00038	eb db		 jmp	 SHORT $LN26@get_lz_pri@2
$LN16@get_lz_pri@2:

; 304  : 		else
; 305  : 			goto INVALID_CODE_HRUM;
; 306  : 	}
; 307  : 	else if (3<=length && length<=255)

  0003a	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]
  0003d	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  00042	77 56		 ja	 SHORT $INVALID_CODE_HRUM$4751

; 308  : 	{
; 309  : 		varlen = 3;
; 310  : 
; 311  : 		if( 4<=length && length<=15 )

  00044	83 f9 04	 cmp	 ecx, 4
  00047	6a 03		 push	 3
  00049	58		 pop	 eax
  0004a	7c 20		 jl	 SHORT $LN11@get_lz_pri@2
  0004c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0004f	7f 20		 jg	 SHORT $LN25@get_lz_pri@2

; 312  : 		{
; 313  : 			varlen = 5;
; 314  : 			if( length>=6 ) varlen += 2;

  00051	83 f9 06	 cmp	 ecx, 6
  00054	6a 05		 push	 5
  00056	58		 pop	 eax
  00057	7c 03		 jl	 SHORT $LN10@get_lz_pri@2
  00059	6a 07		 push	 7
  0005b	58		 pop	 eax
$LN10@get_lz_pri@2:

; 315  : 			if( length>=9 ) varlen += 2;

  0005c	83 f9 09	 cmp	 ecx, 9
  0005f	7c 02		 jl	 SHORT $LN9@get_lz_pri@2
  00061	40		 inc	 eax
  00062	40		 inc	 eax
$LN9@get_lz_pri@2:

; 316  : 			if( length>=12) varlen += 2;

  00063	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00066	7c 0c		 jl	 SHORT $LN6@get_lz_pri@2
  00068	40		 inc	 eax
  00069	40		 inc	 eax

; 317  : 		}
; 318  : 		else if( 15<length && length<=255 )

  0006a	eb 08		 jmp	 SHORT $LN6@get_lz_pri@2
$LN11@get_lz_pri@2:
  0006c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0006f	7e 03		 jle	 SHORT $LN6@get_lz_pri@2
$LN25@get_lz_pri@2:

; 319  : 		{
; 320  : 			varlen = 13;

  00071	6a 0d		 push	 13			; 0000000dH
  00073	58		 pop	 eax
$LN6@get_lz_pri@2:

; 321  : 		}
; 322  : 
; 323  : 		if( (-256)<=disp && disp<=(-1) )

  00074	8d b2 00 01 00
	00		 lea	 esi, DWORD PTR [edx+256]
  0007a	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00080	77 05		 ja	 SHORT $LN5@get_lz_pri@2

; 324  : 			varlen += 9;

  00082	83 c0 09	 add	 eax, 9
  00085	5e		 pop	 esi

; 337  : 	}
; 338  : }

  00086	c3		 ret	 0
$LN5@get_lz_pri@2:

; 325  : 		else if( (-4096)<=disp && disp<(-256) )

  00087	8d b2 00 10 00
	00		 lea	 esi, DWORD PTR [edx+4096]
  0008d	81 fe ff 0e 00
	00		 cmp	 esi, 3839		; 00000effH
  00093	77 05		 ja	 SHORT $INVALID_CODE_HRUM$4751

; 326  : 			varlen += 13;

  00095	83 c0 0d	 add	 eax, 13			; 0000000dH
  00098	5e		 pop	 esi

; 337  : 	}
; 338  : }

  00099	c3		 ret	 0
$INVALID_CODE_HRUM$4751:

; 327  : 		else
; 328  : 			goto INVALID_CODE_HRUM;
; 329  : 
; 330  : 		return varlen;
; 331  : 	}
; 332  : 	else
; 333  : 	{
; 334  : INVALID_CODE_HRUM:
; 335  : 		printf("mhmt-lz.c:get_lz_price_hrum(): Found invalid code length=%d, displacement=%d\n",length, disp);

  0009a	52		 push	 edx
  0009b	51		 push	 ecx
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@JLDCOJGF@mhmt?9lz?4c?3get_lz_price_hrum?$CI?$CJ?3?5F@
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 		return 0;

  000aa	33 c0		 xor	 eax, eax
  000ac	5e		 pop	 esi

; 337  : 	}
; 338  : }

  000ad	c3		 ret	 0
_get_lz_price_hrum ENDP
_TEXT	ENDS
PUBLIC	_get_lz_price_megalz
; Function compile flags: /Ogspy
;	COMDAT _get_lz_price_megalz
_TEXT	SEGMENT
_position$ = 8						; size = 4
_lzcode$ = 12						; size = 4
_get_lz_price_megalz PROC				; COMDAT

; 224  : 	ULONG varbits,varlen;
; 225  : 	LONG length,disp;
; 226  : 
; 227  : 	length = lzcode->length;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _lzcode$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]

; 228  : 	disp   = lzcode->disp;

  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi

; 229  : 
; 230  : 	if( length==1 )

  0000a	83 f9 01	 cmp	 ecx, 1
  0000d	75 19		 jne	 SHORT $LN24@get_lz_pri@3

; 231  : 	{
; 232  : 		if( disp==0 )

  0000f	85 d2		 test	 edx, edx
  00011	75 05		 jne	 SHORT $LN23@get_lz_pri@3

; 233  : 			return 9;

  00013	6a 09		 push	 9
$LN29@get_lz_pri@3:
  00015	58		 pop	 eax
  00016	5e		 pop	 esi

; 279  : 	}
; 280  : }

  00017	c3		 ret	 0
$LN23@get_lz_pri@3:

; 234  : 		else if( (-8)<=disp && disp<=(-1) )

  00018	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  0001b	83 f8 07	 cmp	 eax, 7
  0001e	0f 87 83 00 00
	00		 ja	 $INVALID_CODE_MEGALZ$4716

; 235  : 			return 6;

  00024	6a 06		 push	 6
  00026	eb ed		 jmp	 SHORT $LN29@get_lz_pri@3
$LN24@get_lz_pri@3:

; 236  : 		else
; 237  : 			goto INVALID_CODE_MEGALZ;
; 238  : 	}
; 239  : 	else if( length==2 )

  00028	83 f9 02	 cmp	 ecx, 2
  0002b	75 11		 jne	 SHORT $LN18@get_lz_pri@3

; 240  : 	{
; 241  : 		if( (-256)<=disp && disp<=(-1) )

  0002d	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  00033	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00038	77 6d		 ja	 SHORT $INVALID_CODE_MEGALZ$4716

; 242  : 			return 11;

  0003a	6a 0b		 push	 11			; 0000000bH
  0003c	eb d7		 jmp	 SHORT $LN29@get_lz_pri@3
$LN18@get_lz_pri@3:

; 243  : 		else
; 244  : 			goto INVALID_CODE_MEGALZ;
; 245  : 	}
; 246  : 	else if( length==3 )

  0003e	83 f9 03	 cmp	 ecx, 3
  00041	75 22		 jne	 SHORT $LN14@get_lz_pri@3

; 247  : 	{
; 248  : 		if( (-256)<=disp && disp<=(-1) )

  00043	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  00049	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0004e	77 04		 ja	 SHORT $LN13@get_lz_pri@3

; 249  : 			return 12;

  00050	6a 0c		 push	 12			; 0000000cH
  00052	eb c1		 jmp	 SHORT $LN29@get_lz_pri@3
$LN13@get_lz_pri@3:

; 250  : 		else if( (-4352)<=disp && disp<(-256) )

  00054	8d 82 00 11 00
	00		 lea	 eax, DWORD PTR [edx+4352]
  0005a	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  0005f	77 46		 ja	 SHORT $INVALID_CODE_MEGALZ$4716

; 251  : 			return 16;

  00061	6a 10		 push	 16			; 00000010H
  00063	eb b0		 jmp	 SHORT $LN29@get_lz_pri@3
$LN14@get_lz_pri@3:

; 252  : 		else
; 253  : 			goto INVALID_CODE_MEGALZ;
; 254  : 	}
; 255  : 	else if( 4<=length && length<=255 )

  00065	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00068	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  0006d	77 38		 ja	 SHORT $INVALID_CODE_MEGALZ$4716

; 256  : 	{
; 257  : 		varlen = 0;
; 258  : 		varbits = (length-2)>>1;

  0006f	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  00072	33 f6		 xor	 esi, esi
  00074	d1 f8		 sar	 eax, 1

; 259  : 		while( varbits )

  00076	74 08		 je	 SHORT $LN6@get_lz_pri@3
$LL7@get_lz_pri@3:

; 260  : 		{
; 261  : 			varbits >>= 1;

  00078	d1 e8		 shr	 eax, 1

; 262  : 			varlen+=2;

  0007a	46		 inc	 esi
  0007b	46		 inc	 esi
  0007c	85 c0		 test	 eax, eax
  0007e	75 f8		 jne	 SHORT $LL7@get_lz_pri@3
$LN6@get_lz_pri@3:

; 263  : 		}
; 264  : 
; 265  : 		if( (-256)<=disp && disp<=(-1) )

  00080	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  00086	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0008b	77 05		 ja	 SHORT $LN5@get_lz_pri@3

; 266  : 			varlen += 9;

  0008d	83 c6 09	 add	 esi, 9
  00090	eb 10		 jmp	 SHORT $LN2@get_lz_pri@3
$LN5@get_lz_pri@3:

; 267  : 		else if( (-4352)<=disp && disp<(-256) )

  00092	8d 82 00 11 00
	00		 lea	 eax, DWORD PTR [edx+4352]
  00098	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  0009d	77 08		 ja	 SHORT $INVALID_CODE_MEGALZ$4716

; 268  : 			varlen += 13;

  0009f	83 c6 0d	 add	 esi, 13			; 0000000dH
$LN2@get_lz_pri@3:

; 269  : 		else
; 270  : 			goto INVALID_CODE_MEGALZ;
; 271  : 
; 272  : 		return varlen+3;

  000a2	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  000a5	5e		 pop	 esi

; 279  : 	}
; 280  : }

  000a6	c3		 ret	 0
$INVALID_CODE_MEGALZ$4716:

; 273  : 	}
; 274  : 	else
; 275  : 	{
; 276  : INVALID_CODE_MEGALZ:
; 277  : 		printf("mhmt-lz.c:get_lz_price_megalz(): Found invalid code length=%d, displacement=%d\n",length, disp);

  000a7	52		 push	 edx
  000a8	51		 push	 ecx
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@MLBLLJMH@mhmt?9lz?4c?3get_lz_price_megalz?$CI?$CJ?3@
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 278  : 		return 0;

  000b7	33 c0		 xor	 eax, eax
  000b9	5e		 pop	 esi

; 279  : 	}
; 280  : }

  000ba	c3		 ret	 0
_get_lz_price_megalz ENDP
_TEXT	ENDS
PUBLIC	_make_lz_codes
; Function compile flags: /Ogspy
;	COMDAT _make_lz_codes
_TEXT	SEGMENT
_was_match$ = -24					; size = 4
_max_length$ = -20					; size = 4
tv431 = -16						; size = 4
_max_lookback$ = -12					; size = 4
_codepos$ = -8						; size = 4
_curr_byte$ = -1					; size = 1
_position$ = 8						; size = 4
_actual_len$ = 12					; size = 4
_hash$ = 16						; size = 4
_make_lz_codes PROC					; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 17   : 	ULONG codepos;
; 18   : 	ULONG codelen,i;
; 19   : 	ULONG was_match;
; 20   : 	UBYTE curr_byte,next_byte;
; 21   : 	struct tb_chain * curr_tb;
; 22   : 	UWORD index;
; 23   : 	ULONG max_lookback,max_length,max_tbdisp;
; 24   : 
; 25   : 	// copy-byte code is always present
; 26   : 	codes[0].length = 1;
; 27   : 	codes[0].disp   = 0;

  00006	83 25 04 00 00
	00 00		 and	 DWORD PTR ?codes@?1??pack@@9@9+4, 0
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _position$[ebp]
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	47		 inc	 edi

; 28   : 
; 29   : 	// start more filling of codes[] from that position
; 30   : 	codepos = 1;
; 31   : 
; 32   : 
; 33   : 	
; 34   : 	if( wrk.packtype==PK_HST ) // for hrust only,

  00016	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  0001d	89 3d 00 00 00
	00		 mov	 DWORD PTR ?codes@?1??pack@@9@9, edi
  00023	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi
  00026	75 26		 jne	 SHORT $LN34@make_lz_co

; 35   : 	{                          // add 12,14,16,...,40,42 bytes copies, if possible
; 36   : 		for(codelen=12;codelen<=42;codelen+=2)

  00028	6a 0c		 push	 12			; 0000000cH
  0002a	58		 pop	 eax
$LL37@make_lz_co:

; 37   : 		{
; 38   : 			if( position <= (actual_len-codelen) )

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _actual_len$[ebp]
  0002e	2b c8		 sub	 ecx, eax
  00030	3b f1		 cmp	 esi, ecx
  00032	77 1a		 ja	 SHORT $LN34@make_lz_co

; 39   : 			{
; 40   : 				codes[codepos].length = codelen;
; 41   : 				codes[codepos].disp   = 0;

  00034	83 24 fd 04 00
	00 00 00	 and	 DWORD PTR ?codes@?1??pack@@9@9[edi*8+4], 0
  0003c	89 04 fd 00 00
	00 00		 mov	 DWORD PTR ?codes@?1??pack@@9@9[edi*8], eax

; 42   : 				codepos++;

  00043	47		 inc	 edi
  00044	40		 inc	 eax
  00045	40		 inc	 eax
  00046	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi
  00049	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0004c	76 dd		 jbe	 SHORT $LL37@make_lz_co
$LN34@make_lz_co:

; 43   : 			}
; 44   : 			else
; 45   : 				break;
; 46   : 		}
; 47   : 	}
; 48   : 
; 49   : 
; 50   : 
; 51   : 
; 52   : 
; 53   : 	// check for one-byter (-1..-8)
; 54   : 	//
; 55   : 	curr_byte=wrk.indata[position];

  0004e	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR _wrk+48
  00054	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00057	8a 18		 mov	 bl, BYTE PTR [eax]
  00059	89 45 f0	 mov	 DWORD PTR tv431[ebp], eax

; 56   : 	//
; 57   : 	i = (position>8) ? position-8 : 0;

  0005c	6a 08		 push	 8
  0005e	58		 pop	 eax
  0005f	3b c6		 cmp	 eax, esi
  00061	8d 4e f8	 lea	 ecx, DWORD PTR [esi-8]
  00064	1b c0		 sbb	 eax, eax
  00066	88 5d ff	 mov	 BYTE PTR _curr_byte$[ebp], bl
  00069	23 c1		 and	 eax, ecx
$LL32@make_lz_co:

; 58   : 	do
; 59   : 	{
; 60   : 		if( wrk.indata[i] == curr_byte )

  0006b	38 1c 02	 cmp	 BYTE PTR [edx+eax], bl
  0006e	74 07		 je	 SHORT $LN51@make_lz_co

; 65   : 			break;
; 66   : 		}
; 67   : 	} while( (++i)<position );

  00070	40		 inc	 eax
  00071	3b c6		 cmp	 eax, esi
  00073	72 f6		 jb	 SHORT $LL32@make_lz_co
  00075	eb 16		 jmp	 SHORT $LN30@make_lz_co
$LN51@make_lz_co:

; 61   : 		{
; 62   : 			codes[codepos].length = 1;

  00077	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?codes@?1??pack@@9@9[edi*8]

; 63   : 			codes[codepos].disp   = -(LONG)(position-i);

  0007e	2b c6		 sub	 eax, esi

; 64   : 			codepos++;

  00080	47		 inc	 edi
  00081	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
  00087	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0008a	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi
$LN30@make_lz_co:

; 68   : 
; 69   : 
; 70   : 
; 71   : 
; 72   : 
; 73   : 
; 74   : 	// for hrust, check 3-byte insertion code (-1..-79)
; 75   : 	if( (wrk.packtype==PK_HST) && (position < (actual_len-2)) )

  0008d	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  00094	75 47		 jne	 SHORT $LN25@make_lz_co
  00096	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  00099	83 c0 fe	 add	 eax, -2			; fffffffeH
  0009c	3b f0		 cmp	 esi, eax
  0009e	73 3d		 jae	 SHORT $LN25@make_lz_co

; 76   : 	{
; 77   : 		i = (position>79) ? position-79 : 0;

  000a0	6a 4f		 push	 79			; 0000004fH
  000a2	58		 pop	 eax
  000a3	3b c6		 cmp	 eax, esi
  000a5	8d 4e b1	 lea	 ecx, DWORD PTR [esi-79]
  000a8	1b c0		 sbb	 eax, eax
  000aa	23 c1		 and	 eax, ecx
$LL27@make_lz_co:

; 78   : 		do
; 79   : 		{
; 80   : 			if( (wrk.indata[i]==curr_byte) && (wrk.indata[i+2]==wrk.indata[position+2]) )

  000ac	38 1c 02	 cmp	 BYTE PTR [edx+eax], bl
  000af	75 0f		 jne	 SHORT $LN26@make_lz_co
  000b1	8b 5d f0	 mov	 ebx, DWORD PTR tv431[ebp]
  000b4	8a 4c 02 02	 mov	 cl, BYTE PTR [edx+eax+2]
  000b8	3a 4b 02	 cmp	 cl, BYTE PTR [ebx+2]
  000bb	8a 5d ff	 mov	 bl, BYTE PTR _curr_byte$[ebp]
  000be	74 07		 je	 SHORT $LN52@make_lz_co
$LN26@make_lz_co:

; 85   : 				break;
; 86   : 			}
; 87   : 		} while( (++i)<position );

  000c0	40		 inc	 eax
  000c1	3b c6		 cmp	 eax, esi
  000c3	72 e7		 jb	 SHORT $LL27@make_lz_co
  000c5	eb 16		 jmp	 SHORT $LN25@make_lz_co
$LN52@make_lz_co:

; 81   : 			{
; 82   : 				codes[codepos].length = (-3);

  000c7	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?codes@?1??pack@@9@9[edi*8]

; 83   : 				codes[codepos].disp   = -(LONG)(position-i);

  000ce	2b c6		 sub	 eax, esi

; 84   : 				codepos++;

  000d0	47		 inc	 edi
  000d1	c7 01 fd ff ff
	ff		 mov	 DWORD PTR [ecx], -3	; fffffffdH
  000d7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000da	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi
$LN25@make_lz_co:

; 88   : 	}
; 89   : 
; 90   : 
; 91   : 
; 92   : 	
; 93   : 	switch( wrk.packtype ) // set maximum lookback and length

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  000e2	48		 dec	 eax
  000e3	74 43		 je	 SHORT $LN21@make_lz_co
  000e5	48		 dec	 eax
  000e6	74 39		 je	 SHORT $LN20@make_lz_co
  000e8	48		 dec	 eax
  000e9	74 14		 je	 SHORT $LN19@make_lz_co

; 110  : 	default:
; 111  : 		printf("mhmt-lz.c:make_lz_codes() - wrong packer type!\n");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NLLGIJDF@mhmt?9lz?4c?3make_lz_codes?$CI?$CJ?5?9?5wron@
$LN73@make_lz_co:
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000f6	59		 pop	 ecx

; 112  : 		exit(1);

  000f7	6a 01		 push	 1
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN19@make_lz_co:

; 105  : 	case PK_HST:
; 106  : 		max_lookback = (wrk.maxwin<65536) ? wrk.maxwin : 65536;

  000ff	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  00104	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00109	89 45 f4	 mov	 DWORD PTR _max_lookback$[ebp], eax
  0010c	3b c1		 cmp	 eax, ecx
  0010e	72 03		 jb	 SHORT $LN46@make_lz_co
  00110	89 4d f4	 mov	 DWORD PTR _max_lookback$[ebp], ecx
$LN46@make_lz_co:

; 107  : 		max_length = 3839;

  00113	c7 45 ec ff 0e
	00 00		 mov	 DWORD PTR _max_length$[ebp], 3839 ; 00000effH

; 108  : 		max_tbdisp = 768;

  0011a	ba 00 03 00 00	 mov	 edx, 768		; 00000300H

; 109  : 		break;

  0011f	eb 27		 jmp	 SHORT $LN22@make_lz_co
$LN20@make_lz_co:

; 99   : 		break;
; 100  : 	case PK_HRM:
; 101  : 		max_lookback = (wrk.maxwin<4096) ? wrk.maxwin : 4096;

  00121	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H

; 102  : 		max_length = 255;
; 103  : 		max_tbdisp = 256;
; 104  : 		break;

  00126	eb 05		 jmp	 SHORT $LN74@make_lz_co
$LN21@make_lz_co:

; 94   : 	{
; 95   : 	case PK_MLZ:
; 96   : 		max_lookback = (wrk.maxwin<4352) ? wrk.maxwin : 4352;

  00128	b9 00 11 00 00	 mov	 ecx, 4352		; 00001100H
$LN74@make_lz_co:
  0012d	a1 1c 00 00 00	 mov	 eax, DWORD PTR _wrk+28
  00132	89 45 f4	 mov	 DWORD PTR _max_lookback$[ebp], eax
  00135	3b c1		 cmp	 eax, ecx
  00137	72 03		 jb	 SHORT $LN42@make_lz_co
  00139	89 4d f4	 mov	 DWORD PTR _max_lookback$[ebp], ecx
$LN42@make_lz_co:

; 97   : 		max_length = 255;
; 98   : 		max_tbdisp = 256;

  0013c	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00141	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR _max_length$[ebp], 255 ; 000000ffH
$LN22@make_lz_co:

; 113  : 	}
; 114  : 
; 115  : 
; 116  : 
; 117  : 	// check for two-byter (-1..-max_tbdisp)
; 118  : 	//
; 119  : 	curr_tb = NULL;
; 120  : 	//
; 121  : 	if( position<(actual_len-1) ) // don't try two-byter if we are at the byte before last one

  00148	8b 45 0c	 mov	 eax, DWORD PTR _actual_len$[ebp]
  0014b	48		 dec	 eax
  0014c	3b f0		 cmp	 esi, eax
  0014e	0f 83 15 01 00
	00		 jae	 $LN60@make_lz_co

; 122  : 	{
; 123  : 		next_byte = wrk.indata[position+1];
; 124  : 		index=(curr_byte<<8) + next_byte;
; 125  : 		curr_tb = tb_entry[index];

  00154	8b 45 f0	 mov	 eax, DWORD PTR tv431[ebp]
  00157	66 0f b6 40 01	 movzx	 ax, BYTE PTR [eax+1]
  0015c	66 0f b6 cb	 movzx	 cx, bl
  00160	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  00165	66 0f af cb	 imul	 cx, bx
  00169	66 03 c1	 add	 ax, cx
  0016c	0f b7 c0	 movzx	 eax, ax
  0016f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _tb_entry[eax*4]

; 126  : 
; 127  : 		// there are two-byters!
; 128  : 		if( curr_tb )

  00176	85 c0		 test	 eax, eax
  00178	0f 84 eb 00 00
	00		 je	 $LN60@make_lz_co

; 129  : 		{
; 130  : 			if( ((position-curr_tb->pos)<=max_tbdisp) && ((position-curr_tb->pos)<=max_lookback) )

  0017e	8b ce		 mov	 ecx, esi
  00180	2b 08		 sub	 ecx, DWORD PTR [eax]
  00182	3b ca		 cmp	 ecx, edx
  00184	77 1d		 ja	 SHORT $LN61@make_lz_co
  00186	3b 4d f4	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  00189	77 18		 ja	 SHORT $LN61@make_lz_co

; 131  : 			{
; 132  : 				codes[codepos].length = 2;

  0018b	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?codes@?1??pack@@9@9[edi*8]
  00192	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 133  : 				codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00198	8b 10		 mov	 edx, DWORD PTR [eax]
  0019a	2b d6		 sub	 edx, esi

; 134  : 				codepos++;

  0019c	47		 inc	 edi
  0019d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001a0	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi
$LN61@make_lz_co:

; 135  : 			}
; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 
; 140  : 	// at last, check for lengths=3..max_length up to max_lookback 
; 141  : 	if(  curr_tb  &&  ( (position-curr_tb->pos)<=max_lookback )  &&  ( position<(actual_len-2) )  ) // if we can proceed at all

  001a3	8b ce		 mov	 ecx, esi
  001a5	2b 08		 sub	 ecx, DWORD PTR [eax]
  001a7	3b 4d f4	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  001aa	0f 87 b9 00 00
	00		 ja	 $LN60@make_lz_co
  001b0	8b 4d 0c	 mov	 ecx, DWORD PTR _actual_len$[ebp]
  001b3	83 c1 fe	 add	 ecx, -2			; fffffffeH
  001b6	3b f1		 cmp	 esi, ecx
  001b8	0f 83 ab 00 00
	00		 jae	 $LN60@make_lz_co

; 142  : 	{
; 143  : 		was_match = 1; // there was match at codelen-1
; 144  : 
; 145  : 		for( codelen=3; ( codelen<=max_length )&&( position<(actual_len-codelen+1) ); /*nothing*/ )

  001be	6a 03		 push	 3
  001c0	5a		 pop	 edx
  001c1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1
  001c8	39 55 ec	 cmp	 DWORD PTR _max_length$[ebp], edx
  001cb	0f 82 98 00 00
	00		 jb	 $LN60@make_lz_co
$LL13@make_lz_co:
  001d1	8b 4d 0c	 mov	 ecx, DWORD PTR _actual_len$[ebp]
  001d4	2b ca		 sub	 ecx, edx
  001d6	41		 inc	 ecx
  001d7	3b f1		 cmp	 esi, ecx
  001d9	0f 83 8a 00 00
	00		 jae	 $LN60@make_lz_co

; 146  : 		{
; 147  : 			if( was_match ) // for codelen-1

  001df	83 7d e8 00	 cmp	 DWORD PTR _was_match$[ebp], 0

; 148  : 			{
; 149  : 				// codelen-1 bytes are matched, compare one more byte
; 150  : 				if( wrk.indata[position+codelen-1] == wrk.indata[curr_tb->pos+codelen-1] )

  001e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e5	74 2c		 je	 SHORT $LN11@make_lz_co
  001e7	8b 5d f0	 mov	 ebx, DWORD PTR tv431[ebp]
  001ea	03 0d 30 00 00
	00		 add	 ecx, DWORD PTR _wrk+48
  001f0	8a 5c 13 ff	 mov	 bl, BYTE PTR [ebx+edx-1]
  001f4	3a 5c 11 ff	 cmp	 bl, BYTE PTR [ecx+edx-1]
  001f8	75 52		 jne	 SHORT $MATCH_FAIL$4691
$LN72@make_lz_co:

; 151  : 				{
; 152  : 					// add code to the table
; 153  : 					codes[codepos].length = codelen;

  001fa	89 14 fd 00 00
	00 00		 mov	 DWORD PTR ?codes@?1??pack@@9@9[edi*8], edx

; 154  : 					codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  00201	8b 08		 mov	 ecx, DWORD PTR [eax]
  00203	2b ce		 sub	 ecx, esi
  00205	89 0c fd 04 00
	00 00		 mov	 DWORD PTR ?codes@?1??pack@@9@9[edi*8+4], ecx

; 155  : 					codepos++;

  0020c	47		 inc	 edi
  0020d	89 7d f8	 mov	 DWORD PTR _codepos$[ebp], edi

; 156  : 
; 157  : 					codelen++; // next time do comparision of greater size

  00210	42		 inc	 edx

; 158  : 				}
; 159  : 				else // last bytes do not match

  00211	eb 4d		 jmp	 SHORT $LN9@make_lz_co
$LN11@make_lz_co:

; 173  : 				}
; 174  : 			}
; 175  : 			else // there were no matches for previous codelen
; 176  : 			{
; 177  : 				// next twobyter is already taken, but no comparision is done for codelen bytes
; 178  : 				// first we check if we need to do such comparision at all by seeing to the hashes of the ends of strings
; 179  : 				if( hash[position+codelen-1] == hash[curr_tb->pos+codelen-1] )

  00213	8d 1c 32	 lea	 ebx, DWORD PTR [edx+esi]
  00216	8b 75 10	 mov	 esi, DWORD PTR _hash$[ebp]
  00219	8a 5c 33 ff	 mov	 bl, BYTE PTR [ebx+esi-1]
  0021d	03 ca		 add	 ecx, edx
  0021f	3a 5c 31 ff	 cmp	 bl, BYTE PTR [ecx+esi-1]
  00223	75 24		 jne	 SHORT $LN58@make_lz_co

; 180  : 				{	// hashes match, so try matching complete string
; 181  : 					if( !memcmp( &wrk.indata[position], &wrk.indata[curr_tb->pos], codelen ) )

  00225	8b 30		 mov	 esi, DWORD PTR [eax]
  00227	8b 3d 30 00 00
	00		 mov	 edi, DWORD PTR _wrk+48
  0022d	03 fe		 add	 edi, esi
  0022f	8b 75 f0	 mov	 esi, DWORD PTR tv431[ebp]
  00232	8b ca		 mov	 ecx, edx
  00234	33 db		 xor	 ebx, ebx
  00236	f3 a6		 repe cmpsb
  00238	8b 7d f8	 mov	 edi, DWORD PTR _codepos$[ebp]

; 184  : 						codes[codepos].length = codelen;
; 185  : 						codes[codepos].disp   = -(LONG)(position - curr_tb->pos);

  0023b	8b 75 08	 mov	 esi, DWORD PTR _position$[ebp]
  0023e	75 0c		 jne	 SHORT $MATCH_FAIL$4691

; 182  : 					{
; 183  : 						was_match = 1;

  00240	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _was_match$[ebp], 1

; 186  : 						codepos++;
; 187  : 
; 188  : 						codelen++;
; 189  : 					}
; 190  : 					else
; 191  : 						// no match of whole string
; 192  : 						goto MATCH_FAIL;
; 193  : 				}
; 194  : 				else

  00247	eb b1		 jmp	 SHORT $LN72@make_lz_co
$LN58@make_lz_co:
  00249	8b 75 08	 mov	 esi, DWORD PTR _position$[ebp]
$MATCH_FAIL$4691:

; 160  : 				{
; 161  : 
; 162  : MATCH_FAIL: // entrance for failed matches here: used 3-fold so we set "goto" here
; 163  : 
; 164  : 					// go for older twobyter
; 165  : 					curr_tb = curr_tb->next;

  0024c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 166  : 
; 167  : 					// no more twobyters or they are too far - stop search at all
; 168  : 					if( !curr_tb ) break;

  0024f	85 c0		 test	 eax, eax
  00251	74 16		 je	 SHORT $LN60@make_lz_co

; 169  : 					if( (position - curr_tb->pos)>max_lookback ) break;

  00253	8b ce		 mov	 ecx, esi
  00255	2b 08		 sub	 ecx, DWORD PTR [eax]
  00257	3b 4d f4	 cmp	 ecx, DWORD PTR _max_lookback$[ebp]
  0025a	77 0d		 ja	 SHORT $LN60@make_lz_co

; 170  : 
; 171  : 					// mark there was no matches
; 172  : 					was_match = 0;

  0025c	83 65 e8 00	 and	 DWORD PTR _was_match$[ebp], 0
$LN9@make_lz_co:

; 142  : 	{
; 143  : 		was_match = 1; // there was match at codelen-1
; 144  : 
; 145  : 		for( codelen=3; ( codelen<=max_length )&&( position<(actual_len-codelen+1) ); /*nothing*/ )

  00260	3b 55 ec	 cmp	 edx, DWORD PTR _max_length$[ebp]
  00263	0f 86 68 ff ff
	ff		 jbe	 $LL13@make_lz_co
$LN60@make_lz_co:

; 195  : 					// no match of hashes
; 196  : 					goto MATCH_FAIL;
; 197  : 			}
; 198  : 		}
; 199  : 	}
; 200  : 
; 201  : 	// here we assume to have found all possible matches. check for codes[] table overflow:
; 202  : 	// there could be matches for length 1..3839, and there is copy-1-byte, 16 copymanybyters, 1 insertion match, total 3857 entries for hrust, 256 for megalz & hrum
; 203  : 	if(   codepos > ( (wrk.packtype==PK_HST) ? 3857 : 256 )   ) // this should not happen!

  00269	33 c0		 xor	 eax, eax
  0026b	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _wrk, 3
  00272	0f 95 c0	 setne	 al
  00275	48		 dec	 eax
  00276	25 11 0e 00 00	 and	 eax, 3601		; 00000e11H
  0027b	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00280	3b f8		 cmp	 edi, eax
  00282	76 0a		 jbe	 SHORT $LN1@make_lz_co

; 204  : 	{
; 205  : 		printf("mhmt-lz.c:make_lz_codes_hrust() encountered too many entries in codes[] table. Fatal error.\n");

  00284	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@GNIHAIOG@mhmt?9lz?4c?3make_lz_codes_hrust?$CI?$CJ?5@

; 206  : 		exit(1);

  00289	e9 62 fe ff ff	 jmp	 $LN73@make_lz_co
$LN1@make_lz_co:

; 207  : 	}
; 208  : 
; 209  : 	// mark end-of-records in codes[]
; 210  : 	codes[codepos].length = 0;

  0028e	8d 3c fd 00 00
	00 00		 lea	 edi, DWORD PTR ?codes@?1??pack@@9@9[edi*8]
  00295	83 27 00	 and	 DWORD PTR [edi], 0

; 211  : 	codes[codepos].disp   = 0;

  00298	83 67 04 00	 and	 DWORD PTR [edi+4], 0
  0029c	5f		 pop	 edi
  0029d	5e		 pop	 esi
  0029e	5b		 pop	 ebx

; 212  : }

  0029f	c9		 leave
  002a0	c3		 ret	 0
$LN71@make_lz_co:
_make_lz_codes ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@ ; `string'
PUBLIC	??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ ; `string'
PUBLIC	??_C@_0N@DNFBPHAO@parameters?3?6?$AA@		; `string'
PUBLIC	??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@ ; `string'
PUBLIC	??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@ ; `string'
PUBLIC	??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@ ; `string'
PUBLIC	??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@ ; `string'
PUBLIC	??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@ ; `string'
PUBLIC	??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@ ; `string'
PUBLIC	??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@ ; `string'
PUBLIC	??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@ ; `string'
PUBLIC	??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@ ; `string'
PUBLIC	??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@ ; `string'
PUBLIC	??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@ ; `string'
PUBLIC	??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@ ; `string'
PUBLIC	??_C@_07JELMINIL@usage?3?6?$AA@			; `string'
PUBLIC	??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@ ; `string'
PUBLIC	??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@ ; `string'
PUBLIC	??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@ ; `string'
PUBLIC	??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@ ; `string'
PUBLIC	??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@		; `string'
PUBLIC	??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@		; `string'
PUBLIC	??_C@_08OGNAOKAB@Hrum3?45?6?$AA@		; `string'
PUBLIC	??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@		; `string'
PUBLIC	??_C@_09GPCJIKDG@unknown?4?6?$AA@		; `string'
PUBLIC	??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_0M@IDENCAMB@depacking?4?6?$AA@		; `string'
PUBLIC	??_C@_09BBMFODNF@packing?4?6?$AA@		; `string'
PUBLIC	??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@		; `string'
PUBLIC	??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@ ; `string'
PUBLIC	??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@	; `string'
PUBLIC	??_C@_08LEKKEIK@hrum3?45?5?$AA@			; `string'
PUBLIC	??_C@_09LKFJHGLK@hrust1?4x?5?$AA@		; `string'
PUBLIC	??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@	; `string'
PUBLIC	??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@ ; `string'
PUBLIC	??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@ ; `string'
PUBLIC	??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@ ; `string'
PUBLIC	??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@ ; `string'
PUBLIC	??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@ ; `string'
PUBLIC	??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@ ; `string'
PUBLIC	??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@ ; `string'
PUBLIC	??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@ ; `string'
PUBLIC	??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@ ; `string'
PUBLIC	??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@ ; `string'
PUBLIC	??_C@_04CBJACDOP@?4dpk?$AA@			; `string'
PUBLIC	??_C@_04BKHNBFGB@?4mlz?$AA@			; `string'
PUBLIC	??_C@_04DOJIOPLP@?4hrm?$AA@			; `string'
PUBLIC	??_C@_04KEFKCMJA@?4hst?$AA@			; `string'
PUBLIC	??_C@_04ODAPCKGA@?4pak?$AA@			; `string'
PUBLIC	??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@ ; `string'
PUBLIC	??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@ ; `string'
PUBLIC	??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@ ; `string'
PUBLIC	??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@ ; `string'
PUBLIC	??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@ ; `string'
PUBLIC	??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@ ; `string'
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
;	COMDAT ??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@
CONST	SEGMENT
??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@ DB 'Cannot succe'
	DB	'ssfully load input file "%s" in memory!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@
CONST	SEGMENT
??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@ DB 'Cannot a'
	DB	'llocate %d bytes of memory for loading input file "%s"!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@
CONST	SEGMENT
??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@ DB 'I'
	DB	'nput file "%s" is smaller than 16 bytes - I won''t process it'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@
CONST	SEGMENT
??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@ DB 'Canno'
	DB	't ftell() length of input file "%s"!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@
CONST	SEGMENT
??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@ DB 'C'
	DB	'annot fseek() input file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@
CONST	SEGMENT
??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@ DB 'C'
	DB	'annot create output file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@ DB 'C'
	DB	'annot open input file "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@
CONST	SEGMENT
??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@ DB 'Can''t allo'
	DB	'cate memory for output filename!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODAPCKGA@?4pak?$AA@
CONST	SEGMENT
??_C@_04ODAPCKGA@?4pak?$AA@ DB '.pak', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEFKCMJA@?4hst?$AA@
CONST	SEGMENT
??_C@_04KEFKCMJA@?4hst?$AA@ DB '.hst', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOJIOPLP@?4hrm?$AA@
CONST	SEGMENT
??_C@_04DOJIOPLP@?4hrm?$AA@ DB '.hrm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKHNBFGB@?4mlz?$AA@
CONST	SEGMENT
??_C@_04BKHNBFGB@?4mlz?$AA@ DB '.mlz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CBJACDOP@?4dpk?$AA@
CONST	SEGMENT
??_C@_04CBJACDOP@?4dpk?$AA@ DB '.dpk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@ DB 'Outp'
	DB	'ut file "%s" created.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@
CONST	SEGMENT
??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@ DB 'I'
	DB	'nput file "%s" (%d bytes) successfully loaded.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@
CONST	SEGMENT
??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@ DB 'Maximum loo'
	DB	'kback window size is %d bytes.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@
CONST	SEGMENT
??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@ DB ' INCOMPATIBL'
	DB	'E with old ZX depackers!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@
CONST	SEGMENT
??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@ DB ' compatible'
	DB	' with old ZX depackers.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@
CONST	SEGMENT
??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@ DB 'Bitstream'
	DB	' is grouped in bytes -', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@
CONST	SEGMENT
??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@ DB 'compatible w'
	DB	'ith old ZX depackers.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@
CONST	SEGMENT
??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@ DB ' words are l'
	DB	'ittle-endian, ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@ DB ' words are'
	DB	' big-endian, %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
CONST	SEGMENT
??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@ DB 'INCOMPATIBLE w'
	DB	'ith old ZX depackers!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@
CONST	SEGMENT
??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@ DB 'Bitstream'
	DB	' is grouped in words -', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@ DB 'depackers is on.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKFJHGLK@hrust1?4x?5?$AA@
CONST	SEGMENT
??_C@_09LKFJHGLK@hrust1?4x?5?$AA@ DB 'hrust1.x ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEKKEIK@hrum3?45?5?$AA@
CONST	SEGMENT
??_C@_08LEKKEIK@hrum3?45?5?$AA@ DB 'hrum3.5 ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@
CONST	SEGMENT
??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@ DB 'Header for old ZX ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@ DB 'optimal (slower).'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@
CONST	SEGMENT
??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@ DB 'greed'
	DB	'y (sub-optimal but faster).', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@
CONST	SEGMENT
??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@ DB 'Pack coding: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBMFODNF@packing?4?6?$AA@
CONST	SEGMENT
??_C@_09BBMFODNF@packing?4?6?$AA@ DB 'packing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDENCAMB@depacking?4?6?$AA@
CONST	SEGMENT
??_C@_0M@IDENCAMB@depacking?4?6?$AA@ DB 'depacking.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@ DB 'Mode:        ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPCJIKDG@unknown?4?6?$AA@
CONST	SEGMENT
??_C@_09GPCJIKDG@unknown?4?6?$AA@ DB 'unknown.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@
CONST	SEGMENT
??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@ DB 'Hrust1.x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGNAOKAB@Hrum3?45?6?$AA@
CONST	SEGMENT
??_C@_08OGNAOKAB@Hrum3?45?6?$AA@ DB 'Hrum3.5', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@
CONST	SEGMENT
??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@ DB 'MegaLZ.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@
CONST	SEGMENT
??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@ DB 'Pack format: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@
CONST	SEGMENT
??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@ DB 'Configuration review'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ DB '='
	DB	'===== mhmt help end ======', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@
CONST	SEGMENT
??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@ DB 'in accordanc'
	DB	'e with format chosen; for depacking ".dpk" is appended', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@
CONST	SEGMENT
??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@ DB 'if no outpu'
	DB	't filename given, filename is appended with ".mlz", ".hrm" or'
	DB	' ".hst"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@
CONST	SEGMENT
??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@ DB 'mhm'
	DB	't [parameter list] <input filename> [<output filename>]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07JELMINIL@usage?3?6?$AA@
CONST	SEGMENT
??_C@_07JELMINIL@usage?3?6?$AA@ DB 'usage:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@
CONST	SEGMENT
??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@ DB ' '
	DB	'          For given format, window can''t be greater than def'
	DB	'ault value', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@
CONST	SEGMENT
??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@ DB '  '
	DB	'         maximum window: MegaLZ is 4352, hrum is 4096, hrust '
	DB	'is 65536.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@
CONST	SEGMENT
??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@ DB ' '
	DB	'          256,512,1024,2048,4096,8192,16384,32768. Default is'
	DB	' format-specific', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@
CONST	SEGMENT
??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@ DB '-maxwinN -'
	DB	' maximum lookback window. N is decimal number, which can only'
	DB	' be', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@
CONST	SEGMENT
??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@ DB '-bend '
	DB	'- if -16 specified, this makes words big-endian. Default is l'
	DB	'ittle-endian.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@
CONST	SEGMENT
??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@ DB '  '
	DB	'        Default for MegaLZ is -8, for hrum and hrust is -16.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@
CONST	SEGMENT
??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@ DB '-8, -'
	DB	'16 - bitstream is in bytes or words in packed file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@ DB '     '
	DB	'  NO -mlz is forced.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@
CONST	SEGMENT
??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@ DB '      '
	DB	' Not applicable for MegaLZ. If -zxh is specified, -16, NO -be'
	DB	'nd and', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@
CONST	SEGMENT
??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@ DB '-zxh - u'
	DB	'se zx-specific header for hrum or hrust. DEFAULT is NO HEADER'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@
CONST	SEGMENT
??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@ DB '-d - depa'
	DB	'cking instead of packing (default is packing)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@
CONST	SEGMENT
??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@ DB '-g - '
	DB	'greedy coding (default is optimal coding)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@
CONST	SEGMENT
??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@ DB '-ml'
	DB	'z, -hrm, -hst - use MegaLZ, hrum3.5 or hrust1.x format (defau'
	DB	'lt is MegaLZ)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNFBPHAO@parameters?3?6?$AA@
CONST	SEGMENT
??_C@_0N@DNFBPHAO@parameters?3?6?$AA@ DB 'parameters:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@ DB '='
	DB	'======= mhmt help ========', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@
CONST	SEGMENT
??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@ DB 'There were'
	DB	' errors in arguments.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@
CONST	SEGMENT
??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@ DB 'mhmt - '
	DB	'MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc', 0aH, 0aH
	DB	00H						; `string'
PUBLIC	_do_files
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-main.c
;	COMDAT _do_files
_TEXT	SEGMENT
_do_files PROC						; COMDAT

; 181  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 182  : 	char * pack_ext;
; 183  : 	char * depk_ext;
; 184  : 	LONG ext_pos;
; 185  : 
; 186  : 
; 187  : 	// if there is no output filename, create it
; 188  : 	if( !wrk.fname_out )

  00002	8b 2d 20 00 00
	00		 mov	 ebp, DWORD PTR _wrk+32
  00008	33 db		 xor	 ebx, ebx
  0000a	56		 push	 esi
  0000b	39 1d 24 00 00
	00		 cmp	 DWORD PTR _wrk+36, ebx
  00011	0f 85 0b 01 00
	00		 jne	 $LN10@do_files

; 189  : 	{
; 190  : 		depk_ext = ".dpk";
; 191  : 
; 192  : 		if( wrk.packtype==PK_MLZ )

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	75 07		 jne	 SHORT $LN20@do_files

; 193  : 			pack_ext = ".mlz";

  00021	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04BKHNBFGB@?4mlz?$AA@
  00026	eb 1b		 jmp	 SHORT $LN15@do_files
$LN20@do_files:

; 194  : 		else if( wrk.packtype==PK_HRM )

  00028	83 f8 02	 cmp	 eax, 2
  0002b	75 07		 jne	 SHORT $LN18@do_files

; 195  : 			pack_ext = ".hrm";

  0002d	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04DOJIOPLP@?4hrm?$AA@
  00032	eb 0f		 jmp	 SHORT $LN15@do_files
$LN18@do_files:

; 196  : 		else if( wrk.packtype==PK_HST )
; 197  : 			pack_ext = ".hst";

  00034	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04KEFKCMJA@?4hst?$AA@
  00039	83 f8 03	 cmp	 eax, 3
  0003c	74 05		 je	 SHORT $LN15@do_files

; 198  : 		else
; 199  : 			pack_ext = ".pak"; // all have the same size, as well as depk_ext - 4 bytes!

  0003e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04ODAPCKGA@?4pak?$AA@
$LN15@do_files:

; 200  : 
; 201  : 
; 202  : 		wrk.fname_out = (char *)malloc( 5 + strlen(wrk.fname_in) );

  00043	8b c5		 mov	 eax, ebp
  00045	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL28@do_files:
  00048	8a 10		 mov	 dl, BYTE PTR [eax]
  0004a	40		 inc	 eax
  0004b	3a d3		 cmp	 dl, bl
  0004d	75 f9		 jne	 SHORT $LL28@do_files
  0004f	2b c1		 sub	 eax, ecx
  00051	83 c0 05	 add	 eax, 5
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0005b	59		 pop	 ecx
  0005c	a3 24 00 00 00	 mov	 DWORD PTR _wrk+36, eax

; 203  : 		if( !wrk.fname_out )

  00061	3b c3		 cmp	 eax, ebx
  00063	75 13		 jne	 SHORT $LN14@do_files

; 204  : 		{
; 205  : 			printf("Can't allocate memory for output filename!\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IKJIGAGC@Can?8t?5allocate?5memory?5for?5output@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
$LN38@do_files:
  00070	59		 pop	 ecx
$LN39@do_files:

; 206  : 			return 0;

  00071	33 c0		 xor	 eax, eax
  00073	e9 dd 01 00 00	 jmp	 $LN22@do_files
$LN14@do_files:
  00078	57		 push	 edi

; 207  : 		}
; 208  : 
; 209  : 		strcpy(wrk.fname_out, wrk.fname_in);

  00079	8b f8		 mov	 edi, eax
  0007b	8b cd		 mov	 ecx, ebp
  0007d	2b fd		 sub	 edi, ebp
$LL24@do_files:
  0007f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00081	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00084	41		 inc	 ecx
  00085	3a d3		 cmp	 dl, bl
  00087	75 f6		 jne	 SHORT $LL24@do_files

; 210  : 
; 211  : 		if( !wrk.mode ) // packing

  00089	39 1d 08 00 00
	00		 cmp	 DWORD PTR _wrk+8, ebx
  0008f	75 28		 jne	 SHORT $LN13@do_files

; 212  : 		{
; 213  : 			strcat(wrk.fname_out, pack_ext);

  00091	8b ce		 mov	 ecx, esi
$LL29@do_files:
  00093	8a 11		 mov	 dl, BYTE PTR [ecx]
  00095	41		 inc	 ecx
  00096	3a d3		 cmp	 dl, bl
  00098	75 f9		 jne	 SHORT $LL29@do_files
  0009a	2b ce		 sub	 ecx, esi
  0009c	8b d1		 mov	 edx, ecx
  0009e	48		 dec	 eax
$LL30@do_files:
  0009f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000a2	40		 inc	 eax
  000a3	3a cb		 cmp	 cl, bl
  000a5	75 f8		 jne	 SHORT $LL30@do_files
  000a7	8b ca		 mov	 ecx, edx
  000a9	c1 e9 02	 shr	 ecx, 2
  000ac	8b f8		 mov	 edi, eax
  000ae	f3 a5		 rep movsd
  000b0	8b ca		 mov	 ecx, edx
  000b2	83 e1 03	 and	 ecx, 3
  000b5	f3 a4		 rep movsb

; 214  : 		}
; 215  : 		else // depacking

  000b7	eb 68		 jmp	 SHORT $LN37@do_files
$LN13@do_files:

; 216  : 		{
; 217  : 			ext_pos = strlen( wrk.fname_out ) - 4;

  000b9	8b c8		 mov	 ecx, eax
  000bb	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL31@do_files:
  000be	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c0	41		 inc	 ecx
  000c1	3a d3		 cmp	 dl, bl
  000c3	75 f9		 jne	 SHORT $LL31@do_files
  000c5	2b cf		 sub	 ecx, edi
  000c7	83 c1 fc	 add	 ecx, -4			; fffffffcH

; 218  : 
; 219  : 			if( (ext_pos>=0) && (!strcmp(&wrk.fname_out[ext_pos], pack_ext)) )

  000ca	3b cb		 cmp	 ecx, ebx
  000cc	7c 41		 jl	 SHORT $LN11@do_files
  000ce	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  000d1	8b cf		 mov	 ecx, edi
$LL32@do_files:
  000d3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000d5	3a 16		 cmp	 dl, BYTE PTR [esi]
  000d7	75 18		 jne	 SHORT $LN33@do_files
  000d9	3a d3		 cmp	 dl, bl
  000db	74 10		 je	 SHORT $LN34@do_files
  000dd	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000e0	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  000e3	75 0c		 jne	 SHORT $LN33@do_files
  000e5	41		 inc	 ecx
  000e6	41		 inc	 ecx
  000e7	46		 inc	 esi
  000e8	46		 inc	 esi
  000e9	3a d3		 cmp	 dl, bl
  000eb	75 e6		 jne	 SHORT $LL32@do_files
$LN34@do_files:
  000ed	33 c9		 xor	 ecx, ecx
  000ef	eb 05		 jmp	 SHORT $LN35@do_files
$LN33@do_files:
  000f1	1b c9		 sbb	 ecx, ecx
  000f3	83 d9 ff	 sbb	 ecx, -1
$LN35@do_files:
  000f6	3b cb		 cmp	 ecx, ebx
  000f8	75 15		 jne	 SHORT $LN11@do_files

; 220  : 				strcpy( &wrk.fname_out[ext_pos], depk_ext );

  000fa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04CBJACDOP@?4dpk?$AA@
  000ff	8b d7		 mov	 edx, edi
  00101	2b d0		 sub	 edx, eax
$LL25@do_files:
  00103	8a 08		 mov	 cl, BYTE PTR [eax]
  00105	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00108	40		 inc	 eax
  00109	3a cb		 cmp	 cl, bl
  0010b	75 f6		 jne	 SHORT $LL25@do_files

; 221  : 			else

  0010d	eb 12		 jmp	 SHORT $LN37@do_files
$LN11@do_files:

; 222  : 				strcat( wrk.fname_out, depk_ext );

  0010f	48		 dec	 eax
$LL36@do_files:
  00110	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00113	40		 inc	 eax
  00114	3a cb		 cmp	 cl, bl
  00116	75 f8		 jne	 SHORT $LL36@do_files
  00118	8b f8		 mov	 edi, eax
  0011a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04CBJACDOP@?4dpk?$AA@
  0011f	a5		 movsd
  00120	a4		 movsb
$LN37@do_files:
  00121	5f		 pop	 edi
$LN10@do_files:

; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 
; 227  : 	//open files
; 228  : 	wrk.file_in=fopen(wrk.fname_in,"rb");

  00122	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fopen
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0012d	55		 push	 ebp
  0012e	ff d6		 call	 esi
  00130	59		 pop	 ecx
  00131	59		 pop	 ecx
  00132	a3 28 00 00 00	 mov	 DWORD PTR _wrk+40, eax

; 229  : 
; 230  : 	if(!wrk.file_in)

  00137	3b c3		 cmp	 eax, ebx
  00139	75 17		 jne	 SHORT $LN9@do_files

; 231  : 	{
; 232  : 		printf("Cannot open input file \"%s\"!\n",wrk.fname_in);

  0013b	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JAKCDELD@Cannot?5open?5input?5file?5?$CC?$CFs?$CC?$CB?6?$AA@
$LN40@do_files:
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0014c	59		 pop	 ecx

; 233  : 		return 0;

  0014d	e9 1e ff ff ff	 jmp	 $LN38@do_files
$LN9@do_files:

; 234  : 	}
; 235  : 
; 236  : 	wrk.file_out=fopen(wrk.fname_out,"wb");

  00152	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  00157	ff 35 24 00 00
	00		 push	 DWORD PTR _wrk+36
  0015d	ff d6		 call	 esi
  0015f	59		 pop	 ecx
  00160	59		 pop	 ecx
  00161	a3 2c 00 00 00	 mov	 DWORD PTR _wrk+44, eax

; 237  : 	if(!wrk.file_out)

  00166	3b c3		 cmp	 eax, ebx
  00168	75 0d		 jne	 SHORT $LN8@do_files

; 238  : 	{
; 239  : 		printf("Cannot create output file \"%s\"!\n",wrk.fname_out);

  0016a	ff 35 24 00 00
	00		 push	 DWORD PTR _wrk+36
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DLBNIJHN@Cannot?5create?5output?5file?5?$CC?$CFs?$CC?$CB?6@

; 240  : 		return 0;

  00175	eb cf		 jmp	 SHORT $LN40@do_files
$LN8@do_files:

; 241  : 	}
; 242  : 
; 243  : 
; 244  : 	// get length of input file
; 245  : 	if( fseek(wrk.file_in,0,SEEK_END) )

  00177	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fseek
  0017d	6a 02		 push	 2
  0017f	53		 push	 ebx
  00180	ff 35 28 00 00
	00		 push	 DWORD PTR _wrk+40
  00186	ff d6		 call	 esi
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018b	85 c0		 test	 eax, eax
  0018d	74 0d		 je	 SHORT $LN7@do_files
$LN41@do_files:

; 246  : 	{
; 247  : 		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);

  0018f	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JLBCONCO@Cannot?5fseek?$CI?$CJ?5input?5file?5?$CC?$CFs?$CC?$CB?6@

; 248  : 		return 0;

  0019a	eb aa		 jmp	 SHORT $LN40@do_files
$LN7@do_files:

; 249  : 	}
; 250  : 	wrk.inlen=(ULONG)ftell(wrk.file_in);

  0019c	ff 35 28 00 00
	00		 push	 DWORD PTR _wrk+40
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  001a8	59		 pop	 ecx
  001a9	a3 34 00 00 00	 mov	 DWORD PTR _wrk+52, eax

; 251  : 	if( wrk.inlen==(ULONG)(-1L)  )

  001ae	83 f8 ff	 cmp	 eax, -1
  001b1	75 1d		 jne	 SHORT $LN6@do_files

; 252  : 	{
; 253  : 		printf("Cannot ftell() length of input file \"%s\"!\n",wrk.fname_in);

  001b3	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PLDGCDKA@Cannot?5ftell?$CI?$CJ?5length?5of?5input?5f@
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001c4	59		 pop	 ecx

; 254  : 		wrk.inlen=0;

  001c5	89 1d 34 00 00
	00		 mov	 DWORD PTR _wrk+52, ebx

; 255  : 		return 0;

  001cb	e9 a0 fe ff ff	 jmp	 $LN38@do_files
$LN6@do_files:

; 256  : 	}
; 257  : 	else if( wrk.inlen<16 )

  001d0	83 f8 10	 cmp	 eax, 16			; 00000010H
  001d3	73 10		 jae	 SHORT $LN4@do_files

; 258  : 	{
; 259  : 		printf("Input file \"%s\" is smaller than 16 bytes - I won't process it!\n",wrk.fname_in);

  001d5	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@BEKICNPF@Input?5file?5?$CC?$CFs?$CC?5is?5smaller?5than?5@

; 260  : 		return 0;

  001e0	e9 61 ff ff ff	 jmp	 $LN40@do_files
$LN4@do_files:

; 261  : 	}
; 262  : 	if( fseek(wrk.file_in,0,SEEK_SET) )

  001e5	53		 push	 ebx
  001e6	53		 push	 ebx
  001e7	ff 35 28 00 00
	00		 push	 DWORD PTR _wrk+40
  001ed	ff d6		 call	 esi
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f2	85 c0		 test	 eax, eax

; 263  : 	{
; 264  : 		printf("Cannot fseek() input file \"%s\"!\n",wrk.fname_in);
; 265  : 		return 0;

  001f4	75 99		 jne	 SHORT $LN41@do_files

; 266  : 	}
; 267  : 
; 268  : 
; 269  : 	// load input file in mem
; 270  : 	wrk.indata=(UBYTE *)malloc(wrk.inlen);

  001f6	8b 35 34 00 00
	00		 mov	 esi, DWORD PTR _wrk+52
  001fc	56		 push	 esi
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00203	59		 pop	 ecx
  00204	a3 30 00 00 00	 mov	 DWORD PTR _wrk+48, eax

; 271  : 	if( !wrk.indata )

  00209	3b c3		 cmp	 eax, ebx
  0020b	75 1a		 jne	 SHORT $LN2@do_files

; 272  : 	{
; 273  : 		printf("Cannot allocate %d bytes of memory for loading input file \"%s\"!\n", wrk.inlen, wrk.fname_in);

  0020d	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  00213	56		 push	 esi
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DBFCELOO@Cannot?5allocate?5?$CFd?5bytes?5of?5memo@
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 		return 0;

  00222	e9 4a fe ff ff	 jmp	 $LN39@do_files
$LN2@do_files:

; 275  : 	}
; 276  : 
; 277  : 	if( wrk.inlen!=fread(wrk.indata,1,wrk.inlen,wrk.file_in) )

  00227	ff 35 28 00 00
	00		 push	 DWORD PTR _wrk+40
  0022d	56		 push	 esi
  0022e	6a 01		 push	 1
  00230	50		 push	 eax
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00237	83 c4 10	 add	 esp, 16			; 00000010H
  0023a	39 05 34 00 00
	00		 cmp	 DWORD PTR _wrk+52, eax
  00240	74 10		 je	 SHORT $LN1@do_files

; 278  : 	{
; 279  : 		printf("Cannot successfully load input file \"%s\" in memory!\n",wrk.fname_in);

  00242	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IABCAEBF@Cannot?5successfully?5load?5input?5f@

; 280  : 		return 0;

  0024d	e9 f4 fe ff ff	 jmp	 $LN40@do_files
$LN1@do_files:

; 281  : 	}
; 282  : 
; 283  : 
; 284  : 	return 1;// no errors

  00252	33 c0		 xor	 eax, eax
  00254	40		 inc	 eax
$LN22@do_files:
  00255	5e		 pop	 esi
  00256	5d		 pop	 ebp
  00257	5b		 pop	 ebx

; 285  : }

  00258	c3		 ret	 0
_do_files ENDP
_TEXT	ENDS
PUBLIC	_dump_config
; Function compile flags: /Ogspy
;	COMDAT _dump_config
_TEXT	SEGMENT
_dump_config PROC					; COMDAT

; 103  : {

  00000	56		 push	 esi

; 104  : 	printf("Configuration review:\n");

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  00007	57		 push	 edi
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EGBADFM@Configuration?5review?3?6?$AA@
  0000d	ff d6		 call	 esi

; 105  : 	printf("\n");

  0000f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00016	ff d6		 call	 esi

; 106  : 
; 107  : 	printf("Pack format: ");

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0O@KMBGFIEH@Pack?5format?3?5?$AA@
  0001f	ff d6		 call	 esi

; 108  : 	if( wrk.packtype==PK_MLZ )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  00026	59		 pop	 ecx
  00027	83 f8 01	 cmp	 eax, 1
  0002a	75 07		 jne	 SHORT $LN24@dump_confi

; 109  : 		printf("MegaLZ.\n");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_08NCBGNGKE@MegaLZ?4?6?$AA@
  00031	eb 1d		 jmp	 SHORT $LN27@dump_confi
$LN24@dump_confi:

; 110  : 	else if( wrk.packtype==PK_HRM )

  00033	83 f8 02	 cmp	 eax, 2
  00036	75 07		 jne	 SHORT $LN22@dump_confi

; 111  : 		printf("Hrum3.5\n");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_08OGNAOKAB@Hrum3?45?6?$AA@
  0003d	eb 11		 jmp	 SHORT $LN27@dump_confi
$LN22@dump_confi:

; 112  : 	else if( wrk.packtype==PK_HST )

  0003f	83 f8 03	 cmp	 eax, 3
  00042	75 07		 jne	 SHORT $LN20@dump_confi

; 113  : 		printf("Hrust1.x\n");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_09JKGPLJEC@Hrust1?4x?6?$AA@

; 114  : 	else

  00049	eb 05		 jmp	 SHORT $LN27@dump_confi
$LN20@dump_confi:

; 115  : 		printf("unknown.\n"); // this should be actually never displayed

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_09GPCJIKDG@unknown?4?6?$AA@
$LN27@dump_confi:
  00050	ff d6		 call	 esi
  00052	59		 pop	 ecx

; 116  : 
; 117  : 	printf("Mode:        ");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PLCOEPCC@Mode?3?5?5?5?5?5?5?5?5?$AA@
  00058	ff d6		 call	 esi

; 118  : 	if( wrk.mode )

  0005a	33 ff		 xor	 edi, edi
  0005c	59		 pop	 ecx
  0005d	39 3d 08 00 00
	00		 cmp	 DWORD PTR _wrk+8, edi
  00063	74 07		 je	 SHORT $LN18@dump_confi

; 119  : 		printf("depacking.\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IDENCAMB@depacking?4?6?$AA@

; 120  : 	else

  0006a	eb 05		 jmp	 SHORT $LN28@dump_confi
$LN18@dump_confi:

; 121  : 		printf("packing.\n");

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_09BBMFODNF@packing?4?6?$AA@
$LN28@dump_confi:
  00071	ff d6		 call	 esi
  00073	59		 pop	 ecx

; 122  : 
; 123  : 	if( !wrk.mode )

  00074	39 3d 08 00 00
	00		 cmp	 DWORD PTR _wrk+8, edi
  0007a	75 1f		 jne	 SHORT $LN14@dump_confi

; 124  : 	{
; 125  : 		printf("Pack coding: ");

  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LJOCJJEK@Pack?5coding?3?5?$AA@
  00081	ff d6		 call	 esi
  00083	59		 pop	 ecx

; 126  : 		if( wrk.greedy )

  00084	39 3d 04 00 00
	00		 cmp	 DWORD PTR _wrk+4, edi
  0008a	74 07		 je	 SHORT $LN15@dump_confi

; 127  : 			printf("greedy (sub-optimal but faster).\n");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DCNALCGB@greedy?5?$CIsub?9optimal?5but?5faster?$CJ?4@

; 128  : 		else

  00091	eb 05		 jmp	 SHORT $LN29@dump_confi
$LN15@dump_confi:

; 129  : 			printf("optimal (slower).\n");

  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GBMPBFLL@optimal?5?$CIslower?$CJ?4?6?$AA@
$LN29@dump_confi:
  00098	ff d6		 call	 esi
  0009a	59		 pop	 ecx
$LN14@dump_confi:

; 130  : 	}
; 131  : 
; 132  : 	if( wrk.zxheader )

  0009b	39 3d 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, edi
  000a1	74 2e		 je	 SHORT $LN13@dump_confi

; 133  : 	{
; 134  : 		printf("Header for old ZX ");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICHGMKAA@Header?5for?5old?5ZX?5?$AA@
  000a8	ff d6		 call	 esi

; 135  : 		if( wrk.packtype==PK_HRM )

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  000af	59		 pop	 ecx
  000b0	83 f8 02	 cmp	 eax, 2
  000b3	75 07		 jne	 SHORT $LN12@dump_confi

; 136  : 			printf("hrum3.5 ");

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_08LEKKEIK@hrum3?45?5?$AA@
  000ba	eb 0a		 jmp	 SHORT $LN30@dump_confi
$LN12@dump_confi:

; 137  : 		else if( wrk.packtype==PK_HST )

  000bc	83 f8 03	 cmp	 eax, 3
  000bf	75 08		 jne	 SHORT $LN10@dump_confi

; 138  : 			printf("hrust1.x ");

  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_09LKFJHGLK@hrust1?4x?5?$AA@
$LN30@dump_confi:
  000c6	ff d6		 call	 esi
  000c8	59		 pop	 ecx
$LN10@dump_confi:

; 139  : 
; 140  : 		printf("depackers is on.\n");

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FKPGKNLF@depackers?5is?5on?4?6?$AA@
  000ce	ff d6		 call	 esi
  000d0	59		 pop	 ecx
$LN13@dump_confi:

; 141  : 	}
; 142  : 
; 143  : 	if( wrk.wordbit )

  000d1	39 3d 10 00 00
	00		 cmp	 DWORD PTR _wrk+16, edi
  000d7	74 44		 je	 SHORT $LN9@dump_confi

; 144  : 	{
; 145  : 		printf("Bitstream is grouped in words -\n");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DHHMLDIC@Bitstream?5is?5grouped?5in?5words?5?9?6@
  000de	ff d6		 call	 esi
  000e0	59		 pop	 ecx

; 146  : 		if( wrk.bigend )

  000e1	39 3d 14 00 00
	00		 cmp	 DWORD PTR _wrk+20, edi
  000e7	74 0f		 je	 SHORT $LN8@dump_confi

; 147  : 		{
; 148  : 			printf(" words are big-endian, %s","INCOMPATIBLE with old ZX depackers!\n");

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LJKMBCBJ@?5words?5are?5big?9endian?0?5?$CFs?$AA@
  000f3	ff d6		 call	 esi
  000f5	59		 pop	 ecx

; 149  : 		}
; 150  : 		else

  000f6	eb 44		 jmp	 SHORT $LN31@dump_confi
$LN8@dump_confi:

; 151  : 		{
; 152  : 			printf(" words are little-endian, ");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BDKIIBCL@?5words?5are?5little?9endian?0?5?$AA@
  000fd	ff d6		 call	 esi

; 153  : 			if( (wrk.packtype==PK_HRM) || (wrk.packtype==PK_HST) )

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  00104	59		 pop	 ecx
  00105	83 f8 02	 cmp	 eax, 2
  00108	74 0c		 je	 SHORT $LN5@dump_confi
  0010a	83 f8 03	 cmp	 eax, 3
  0010d	74 07		 je	 SHORT $LN5@dump_confi

; 155  : 			else
; 156  : 				printf("INCOMPATIBLE with old ZX depackers!\n");

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PKEFMG@INCOMPATIBLE?5with?5old?5ZX?5depacke@
  00114	eb 24		 jmp	 SHORT $LN32@dump_confi
$LN5@dump_confi:

; 154  : 				printf("compatible with old ZX depackers.\n");

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BACEHNOO@compatible?5with?5old?5ZX?5depackers@

; 157  : 		}
; 158  : 	}
; 159  : 	else

  0011b	eb 1d		 jmp	 SHORT $LN32@dump_confi
$LN9@dump_confi:

; 160  : 	{
; 161  : 		printf("Bitstream is grouped in bytes -\n");

  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MDHDGKIP@Bitstream?5is?5grouped?5in?5bytes?5?9?6@
  00122	ff d6		 call	 esi

; 162  : 		if( wrk.packtype==PK_MLZ )

  00124	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _wrk, 1
  0012b	59		 pop	 ecx
  0012c	75 07		 jne	 SHORT $LN2@dump_confi

; 163  : 			printf(" compatible with old ZX depackers.\n");

  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GKJJFKPF@?5compatible?5with?5old?5ZX?5depacker@

; 164  : 		else

  00133	eb 05		 jmp	 SHORT $LN32@dump_confi
$LN2@dump_confi:

; 165  : 			printf(" INCOMPATIBLE with old ZX depackers!\n");

  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MMGEBIK@?5INCOMPATIBLE?5with?5old?5ZX?5depack@
$LN32@dump_confi:
  0013a	ff d6		 call	 esi
$LN31@dump_confi:
  0013c	59		 pop	 ecx

; 166  : 	}
; 167  : 
; 168  : 	printf("Maximum lookback window size is %d bytes.\n\n",wrk.maxwin);

  0013d	ff 35 1c 00 00
	00		 push	 DWORD PTR _wrk+28
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IOMBMFCC@Maximum?5lookback?5window?5size?5is?5@
  00148	ff d6		 call	 esi

; 169  : 
; 170  : 
; 171  : 	// files
; 172  : 	printf("Input file \"%s\" (%d bytes) successfully loaded.\n", wrk.fname_in, wrk.inlen);

  0014a	ff 35 34 00 00
	00		 push	 DWORD PTR _wrk+52
  00150	ff 35 20 00 00
	00		 push	 DWORD PTR _wrk+32
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CKMCOPOC@Input?5file?5?$CC?$CFs?$CC?5?$CI?$CFd?5bytes?$CJ?5succe@
  0015b	ff d6		 call	 esi

; 173  : 	printf("Output file \"%s\" created.\n", wrk.fname_out );

  0015d	ff 35 24 00 00
	00		 push	 DWORD PTR _wrk+36
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@EMIEMNDG@Output?5file?5?$CC?$CFs?$CC?5created?4?6?$AA@
  00168	ff d6		 call	 esi
  0016a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi

; 174  : 
; 175  : //	...more info...?
; 176  : }

  0016f	c3		 ret	 0
_dump_config ENDP
_TEXT	ENDS
PUBLIC	_show_help
; Function compile flags: /Ogspy
;	COMDAT _show_help
_TEXT	SEGMENT
_show_help PROC						; COMDAT

; 72   : {

  00000	56		 push	 esi

; 73   : 	printf("======== mhmt help ========\n");

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  00007	57		 push	 edi
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IKJILILF@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
  0000d	ff d6		 call	 esi

; 74   : 	printf("parameters:\n");

  0000f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0N@DNFBPHAO@parameters?3?6?$AA@
  00016	ff d6		 call	 esi

; 75   : 	printf("-mlz, -hrm, -hst - use MegaLZ, hrum3.5 or hrust1.x format (default is MegaLZ)\n");

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0EP@EOFJONAG@?9mlz?0?5?9hrm?0?5?9hst?5?9?5use?5MegaLZ?0?5h@
  0001f	ff d6		 call	 esi

; 76   : 	printf("-g - greedy coding (default is optimal coding)\n");

  00021	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0DA@DNLEHDLO@?9g?5?9?5greedy?5coding?5?$CIdefault?5is?5o@
  00028	ff d6		 call	 esi

; 77   : 	printf("-d - depacking instead of packing (default is packing)\n");

  0002a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0DI@NFACNIGL@?9d?5?9?5depacking?5instead?5of?5packin@
  00031	ff d6		 call	 esi

; 78   : 	printf("\n");

  00033	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00038	57		 push	 edi
  00039	ff d6		 call	 esi

; 79   : 	printf("-zxh - use zx-specific header for hrum or hrust. DEFAULT is NO HEADER!\n");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@GKEJLPPN@?9zxh?5?9?5use?5zx?9specific?5header?5fo@
  00040	ff d6		 call	 esi

; 80   : 	printf("       Not applicable for MegaLZ. If -zxh is specified, -16, NO -bend and\n");

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KLCIKDKP@?5?5?5?5?5?5?5Not?5applicable?5for?5MegaLZ@
  00047	ff d6		 call	 esi

; 81   : 	printf("       NO -mlz is forced.\n");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BJDAHFLC@?5?5?5?5?5?5?5NO?5?9mlz?5is?5forced?4?6?$AA@
  0004e	ff d6		 call	 esi

; 82   : 	printf("\n");

  00050	57		 push	 edi
  00051	ff d6		 call	 esi

; 83   : 	printf("-8, -16 - bitstream is in bytes or words in packed file.\n");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@MOHBNMPA@?98?0?5?916?5?9?5bitstream?5is?5in?5bytes?5@
  00058	ff d6		 call	 esi

; 84   : 	printf("          Default for MegaLZ is -8, for hrum and hrust is -16.\n");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@JJFNEBNC@?5?5?5?5?5?5?5?5?5?5Default?5for?5MegaLZ?5is?5@
  0005f	ff d6		 call	 esi

; 85   : 	printf("\n");

  00061	57		 push	 edi
  00062	ff d6		 call	 esi

; 86   : 	printf("-bend - if -16 specified, this makes words big-endian. Default is little-endian.\n");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@KDKBLDKN@?9bend?5?9?5if?5?916?5specified?0?5this?5m@
  00069	ff d6		 call	 esi

; 87   : 	printf("\n");

  0006b	57		 push	 edi
  0006c	ff d6		 call	 esi

; 88   : 	printf("-maxwinN - maximum lookback window. N is decimal number, which can only be\n");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@MBNFBDCK@?9maxwinN?5?9?5maximum?5lookback?5wind@
  00073	ff d6		 call	 esi

; 89   : 	printf("           256,512,1024,2048,4096,8192,16384,32768. Default is format-specific\n");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BJDLAAMC@?5?5?5?5?5?5?5?5?5?5?5256?0512?01024?02048?0409@
  0007a	ff d6		 call	 esi

; 90   : 	printf("           maximum window: MegaLZ is 4352, hrum is 4096, hrust is 65536.\n");

  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@NOKIKEAM@?5?5?5?5?5?5?5?5?5?5?5maximum?5window?3?5MegaL@
  00081	ff d6		 call	 esi

; 91   : 	printf("           For given format, window can't be greater than default value\n");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@KGEBBION@?5?5?5?5?5?5?5?5?5?5?5For?5given?5format?0?5win@
  00088	ff d6		 call	 esi

; 92   : 	printf("\n");

  0008a	57		 push	 edi
  0008b	ff d6		 call	 esi
  0008d	83 c4 40	 add	 esp, 64			; 00000040H

; 93   : 	printf("usage:\n");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_07JELMINIL@usage?3?6?$AA@
  00095	ff d6		 call	 esi

; 94   : 	printf("mhmt [parameter list] <input filename> [<output filename>]\n");

  00097	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET ??_C@_0DM@GINDLNFB@mhmt?5?$FLparameter?5list?$FN?5?$DMinput?5fil@
  0009e	ff d6		 call	 esi

; 95   : 	printf("\n");

  000a0	57		 push	 edi
  000a1	ff d6		 call	 esi

; 96   : 	printf("if no output filename given, filename is appended with \".mlz\", \".hrm\" or \".hst\"\n");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@OKFADLH@if?5no?5output?5filename?5given?0?5fil@
  000a8	ff d6		 call	 esi

; 97   : 	printf("in accordance with format chosen; for depacking \".dpk\" is appended\n");

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@LGHAKDJG@in?5accordance?5with?5format?5chosen@
  000af	ff d6		 call	 esi

; 98   : 	printf("====== mhmt help end ======\n");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IJEEOKCM@?$DN?$DN?$DN?$DN?$DN?$DN?5mhmt?5help?5end?5?$DN?$DN?$DN?$DN?$DN?$DN?6?$AA@
  000b6	ff d6		 call	 esi

; 99   : 	printf("\n");

  000b8	57		 push	 edi
  000b9	ff d6		 call	 esi
  000bb	83 c4 18	 add	 esp, 24			; 00000018H
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 100  : }

  000c0	c3		 ret	 0
_show_help ENDP
PUBLIC	_main
; Function compile flags: /Ogspy
;	COMDAT _main
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 17   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 18   : 	int error=0;
; 19   : 	ULONG parse_result;
; 20   : 
; 21   : 
; 22   : 	init_globals();
; 23   : 
; 24   : 
; 25   : 	// printf short info
; 26   : 	printf("mhmt - MeHruMsT - MEgalz, HRUM and hruST (c) 2009 lvd^nedopc\n\n");

  00002	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__printf
  00008	56		 push	 esi
  00009	33 f6		 xor	 esi, esi
  0000b	57		 push	 edi
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@PNLAAOGH@mhmt?5?9?5MeHruMsT?5?9?5MEgalz?0?5HRUM?5a@
  00011	33 ff		 xor	 edi, edi
  00013	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _wrk, 1
  0001d	89 35 04 00 00
	00		 mov	 DWORD PTR _wrk+4, esi
  00023	89 35 08 00 00
	00		 mov	 DWORD PTR _wrk+8, esi
  00029	89 35 0c 00 00
	00		 mov	 DWORD PTR _wrk+12, esi
  0002f	89 35 10 00 00
	00		 mov	 DWORD PTR _wrk+16, esi
  00035	89 35 14 00 00
	00		 mov	 DWORD PTR _wrk+20, esi
  0003b	89 35 18 00 00
	00		 mov	 DWORD PTR _wrk+24, esi
  00041	c7 05 1c 00 00
	00 00 11 00 00	 mov	 DWORD PTR _wrk+28, 4352	; 00001100H
  0004b	89 35 20 00 00
	00		 mov	 DWORD PTR _wrk+32, esi
  00051	89 35 24 00 00
	00		 mov	 DWORD PTR _wrk+36, esi
  00057	89 35 28 00 00
	00		 mov	 DWORD PTR _wrk+40, esi
  0005d	89 35 2c 00 00
	00		 mov	 DWORD PTR _wrk+44, esi
  00063	89 35 30 00 00
	00		 mov	 DWORD PTR _wrk+48, esi
  00069	89 35 34 00 00
	00		 mov	 DWORD PTR _wrk+52, esi
  0006f	ff d5		 call	 ebp

; 27   : 
; 28   : 	// parse arguments
; 29   : 	parse_result = parse_args(argc, argv);

  00071	ff 74 24 1c	 push	 DWORD PTR _argv$[esp+16]
  00075	ff 74 24 1c	 push	 DWORD PTR _argc$[esp+20]
  00079	e8 00 00 00 00	 call	 _parse_args
  0007e	8b d8		 mov	 ebx, eax
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30   : 
; 31   : 	if( parse_result&ARG_PARSER_SHOWHELP )

  00083	f6 c3 01	 test	 bl, 1
  00086	74 15		 je	 SHORT $LN9@main

; 32   : 	{
; 33   : 		if( parse_result&ARG_PARSER_ERROR )

  00088	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0008e	74 08		 je	 SHORT $LN8@main

; 34   : 			printf("\n");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00095	ff d5		 call	 ebp
  00097	59		 pop	 ecx
$LN8@main:

; 35   : 
; 36   : 		show_help();

  00098	e8 00 00 00 00	 call	 _show_help
$LN9@main:

; 37   : 	}
; 38   : 
; 39   : 	if( parse_result&ARG_PARSER_ERROR )

  0009d	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  000a3	74 5f		 je	 SHORT $LN7@main

; 40   : 	{
; 41   : 		printf("There were errors in arguments.\n");

  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DEFIMKDI@There?5were?5errors?5in?5arguments?4?6@
  000aa	ff d5		 call	 ebp
  000ac	59		 pop	 ecx
$LN4@main:

; 59   : 		{
; 60   : 			error++;

  000ad	33 ff		 xor	 edi, edi
  000af	47		 inc	 edi
$LN1@main:

; 61   : 		}
; 62   : 	}
; 63   : 
; 64   : 
; 65   : 
; 66   : 	free_globals();

  000b0	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000b5	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__free
  000bb	3b c6		 cmp	 eax, esi
  000bd	74 04		 je	 SHORT $LN18@main
  000bf	50		 push	 eax
  000c0	ff d5		 call	 ebp
  000c2	59		 pop	 ecx
$LN18@main:
  000c3	a1 2c 00 00 00	 mov	 eax, DWORD PTR _wrk+44
  000c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fclose
  000ce	3b c6		 cmp	 eax, esi
  000d0	74 04		 je	 SHORT $LN17@main
  000d2	50		 push	 eax
  000d3	ff d3		 call	 ebx
  000d5	59		 pop	 ecx
$LN17@main:
  000d6	a1 28 00 00 00	 mov	 eax, DWORD PTR _wrk+40
  000db	3b c6		 cmp	 eax, esi
  000dd	74 04		 je	 SHORT $LN16@main
  000df	50		 push	 eax
  000e0	ff d3		 call	 ebx
  000e2	59		 pop	 ecx
$LN16@main:
  000e3	a1 24 00 00 00	 mov	 eax, DWORD PTR _wrk+36
  000e8	3b c6		 cmp	 eax, esi
  000ea	74 04		 je	 SHORT $LN15@main
  000ec	50		 push	 eax
  000ed	ff d5		 call	 ebp
  000ef	59		 pop	 ecx
$LN15@main:
  000f0	a1 20 00 00 00	 mov	 eax, DWORD PTR _wrk+32
  000f5	3b c6		 cmp	 eax, esi
  000f7	74 04		 je	 SHORT $LN14@main
  000f9	50		 push	 eax
  000fa	ff d5		 call	 ebp
  000fc	59		 pop	 ecx
$LN14@main:

; 67   : 
; 68   : 	return error;

  000fd	8b c7		 mov	 eax, edi
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx

; 69   : }

  00103	c3		 ret	 0
$LN7@main:

; 42   : 		error++;
; 43   : 	}
; 44   : 	else if( parse_result&ARG_PARSER_GO )

  00104	f6 c3 02	 test	 bl, 2
  00107	74 a7		 je	 SHORT $LN1@main

; 45   : 	{
; 46   : 		if( do_files() )

  00109	e8 00 00 00 00	 call	 _do_files
  0010e	85 c0		 test	 eax, eax
  00110	74 9b		 je	 SHORT $LN4@main

; 47   : 		{
; 48   : 			dump_config();

  00112	e8 00 00 00 00	 call	 _dump_config

; 49   : 			if( wrk.mode )

  00117	39 35 08 00 00
	00		 cmp	 DWORD PTR _wrk+8, esi
  0011d	74 07		 je	 SHORT $LN3@main

; 50   : 			{
; 51   : 				error += depack() ? 0 : 1;

  0011f	e8 00 00 00 00	 call	 _depack

; 52   : 			}
; 53   : 			else

  00124	eb 05		 jmp	 SHORT $LN21@main
$LN3@main:

; 54   : 			{
; 55   : 				error += pack() ? 0 : 1;

  00126	e8 00 00 00 00	 call	 _pack
$LN21@main:
  0012b	8b f8		 mov	 edi, eax
  0012d	f7 df		 neg	 edi
  0012f	1b ff		 sbb	 edi, edi
  00131	47		 inc	 edi

; 56   : 			}
; 57   : 		}
; 58   : 		else

  00132	e9 79 ff ff ff	 jmp	 $LN1@main
_main	ENDP
_TEXT	ENDS
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-optimal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@ ; `string'
;	COMDAT ??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@
CONST	SEGMENT
??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@ DB 'mhmt-'
	DB	'optimal.c: update_optch() found zero bitlength of lz code. Fa'
	DB	'tal error.', 0aH, 00H			; `string'
PUBLIC	_reverse_optch
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-optimal.c
;	COMDAT _reverse_optch
_TEXT	SEGMENT
_position$ = -4						; size = 4
_reverse_optch PROC					; COMDAT
; _optch$ = ecx
; _actual_len$ = eax

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b f0		 mov	 esi, eax

; 78   : 	struct lzcode curr, temp;
; 79   : 	ULONG position;
; 80   : 	LONG len;
; 81   : 
; 82   : 	position = actual_len;
; 83   : 
; 84   : 	temp = optch[position].code;

  0000b	c1 e0 04	 shl	 eax, 4
  0000e	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00011	8b 5c 08 04	 mov	 ebx, DWORD PTR [eax+ecx+4]
  00015	57		 push	 edi
  00016	89 74 24 0c	 mov	 DWORD PTR _position$[esp+16], esi

; 85   : 
; 86   : 	while(position>1)

  0001a	83 fe 01	 cmp	 esi, 1
  0001d	76 2a		 jbe	 SHORT $LN2@reverse_op
$LN3@reverse_op:

; 87   : 	{
; 88   : 		len = temp.length;

  0001f	8b c2		 mov	 eax, edx

; 89   : 		if( len<0 ) len=(-len);

  00021	85 d2		 test	 edx, edx
  00023	7d 02		 jge	 SHORT $LN1@reverse_op
  00025	f7 d8		 neg	 eax
$LN1@reverse_op:

; 90   : 
; 91   : 		position -= len;

  00027	29 44 24 0c	 sub	 DWORD PTR _position$[esp+16], eax

; 92   : 
; 93   : 		curr = temp;
; 94   : 
; 95   : 		temp = optch[position].code;

  0002b	8b 44 24 0c	 mov	 eax, DWORD PTR _position$[esp+16]
  0002f	c1 e0 04	 shl	 eax, 4
  00032	03 c1		 add	 eax, ecx
  00034	83 7c 24 0c 01	 cmp	 DWORD PTR _position$[esp+16], 1
  00039	8b f2		 mov	 esi, edx
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	8b fb		 mov	 edi, ebx
  0003f	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 96   : 		optch[position].code = curr;

  00042	89 30		 mov	 DWORD PTR [eax], esi
  00044	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00047	77 d6		 ja	 SHORT $LN3@reverse_op
$LN2@reverse_op:

; 97   : 	}
; 98   : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_reverse_optch ENDP
_TEXT	ENDS
PUBLIC	_update_optch
; Function compile flags: /Ogspy
;	COMDAT _update_optch
_TEXT	SEGMENT
_codepos$ = -4						; size = 4
_position$ = 8						; size = 4
_get_lz_price$ = 12					; size = 4
_optch$ = 16						; size = 4
_update_optch PROC					; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 45   : 	ULONG codepos;
; 46   : 	ULONG bitlen;
; 47   : 	ULONG newpos;
; 48   : 	LONG len;
; 49   : 
; 50   : 	for( codepos = 0; len=codes[codepos].length; codepos++ ) // loop through all existing lz codes

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?codes@?1??pack@@9@9
  00009	83 65 fc 00	 and	 DWORD PTR _codepos$[ebp], 0
  0000d	53		 push	 ebx
  0000e	8b 5d 10	 mov	 ebx, DWORD PTR _optch$[ebp]
  00011	56		 push	 esi
  00012	8b f0		 mov	 esi, eax
  00014	85 c0		 test	 eax, eax
  00016	74 54		 je	 SHORT $LN5@update_opt
  00018	57		 push	 edi
  00019	bf 00 00 00 00	 mov	 edi, OFFSET ?codes@?1??pack@@9@9
$LL7@update_opt:

; 51   : 	{
; 52   : 		bitlen = (*get_lz_price)(position, &codes[codepos]); // get bit length of given lz code

  0001e	57		 push	 edi
  0001f	ff 75 08	 push	 DWORD PTR _position$[ebp]
  00022	ff 55 0c	 call	 DWORD PTR _get_lz_price$[ebp]
  00025	59		 pop	 ecx
  00026	59		 pop	 ecx

; 53   : 		if( !bitlen )

  00027	85 c0		 test	 eax, eax
  00029	74 45		 je	 SHORT $LN11@update_opt

; 57   : 		}
; 58   : 		else
; 59   : 		{
; 60   : 			if( len<0 ) len=(-len); // deal with negative lengths (special markers)

  0002b	85 f6		 test	 esi, esi
  0002d	7d 02		 jge	 SHORT $LN2@update_opt
  0002f	f7 de		 neg	 esi
$LN2@update_opt:

; 61   : 
; 62   : 			newpos = position + len; // look where current lz code points to and take from there old price reaching that location

  00031	8b 55 08	 mov	 edx, DWORD PTR _position$[ebp]
  00034	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]

; 63   : 
; 64   : 			if( optch[newpos].price > bitlen + optch[position].price ) // if oldprice is worse than with current lz code

  00037	c1 e2 04	 shl	 edx, 4
  0003a	8b 54 1a 08	 mov	 edx, DWORD PTR [edx+ebx+8]
  0003e	c1 e1 04	 shl	 ecx, 4
  00041	03 d0		 add	 edx, eax
  00043	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00046	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  00049	76 0d		 jbe	 SHORT $LN6@update_opt

; 65   : 			{
; 66   : 				optch[newpos].price = bitlen + optch[position].price;

  0004b	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 67   : 				optch[newpos].code  = codes[codepos];

  0004e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00050	89 08		 mov	 DWORD PTR [eax], ecx
  00052	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN6@update_opt:
  00058	ff 45 fc	 inc	 DWORD PTR _codepos$[ebp]
  0005b	8b 7d fc	 mov	 edi, DWORD PTR _codepos$[ebp]
  0005e	8d 3c fd 00 00
	00 00		 lea	 edi, DWORD PTR ?codes@?1??pack@@9@9[edi*8]
  00065	8b 37		 mov	 esi, DWORD PTR [edi]
  00067	85 f6		 test	 esi, esi
  00069	75 b3		 jne	 SHORT $LL7@update_opt
  0006b	5f		 pop	 edi
$LN5@update_opt:
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx

; 68   : 			}
; 69   : 		}
; 70   : 	}
; 71   : }

  0006e	c9		 leave
  0006f	c3		 ret	 0
$LN11@update_opt:

; 54   : 		{
; 55   : 			printf("mhmt-optimal.c: update_optch() found zero bitlength of lz code. Fatal error.\n");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@LOGMPBLH@mhmt?9optimal?4c?3?5update_optch?$CI?$CJ?5f@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0007b	59		 pop	 ecx

; 56   : 			exit(1);

  0007c	6a 01		 push	 1
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN13@update_opt:
  00084	cc		 int	 3
_update_optch ENDP
_TEXT	ENDS
PUBLIC	_free_optch
; Function compile flags: /Ogspy
;	COMDAT _free_optch
_TEXT	SEGMENT
_optch$ = 8						; size = 4
_free_optch PROC					; COMDAT

; 37   : 	if( optch )

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _optch$[esp-4], 0
  00005	74 06		 je	 SHORT $LN1@free_optch

; 38   : 		free( optch );

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__free
$LN1@free_optch:

; 39   : }

  0000d	c3		 ret	 0
_free_optch ENDP
_TEXT	ENDS
PUBLIC	_make_optch
; Function compile flags: /Ogspy
;	COMDAT _make_optch
_TEXT	SEGMENT
_make_optch PROC					; COMDAT
; _actual_len$ = esi

; 11   : 	struct optchain * optch;
; 12   : 
; 13   : 	ULONG i;
; 14   : 
; 15   : 	// we allocate length+1 because all codes at the end of input stream will point
; 16   : 	// to the length+1 place. Also we'll start reversing from length+1 position in optch array
; 17   : 	optch = (struct optchain *)malloc( (actual_len+1)*sizeof(struct optchain) );

  00000	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00003	c1 e0 04	 shl	 eax, 4
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000d	59		 pop	 ecx

; 18   : 
; 19   : 	if( optch )

  0000e	85 c0		 test	 eax, eax
  00010	74 2c		 je	 SHORT $LN1@make_optch

; 20   : 	{
; 21   : 		optch[0].code.length = 1; // 1st byte is always copied 'as-is', however, this is just filler,
; 22   : 		optch[0].code.disp   = 0; // not accounted elsewhere

  00012	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 23   : 
; 24   : 		// init prices to absolute maximum for optimal chain build-up
; 25   : 		optch[0].price = 0;

  00016	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 26   : 		optch[1].price = 8;
; 27   : 		for(i=2;i<(actual_len+1);i++)

  0001a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0001d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00023	c7 40 18 08 00
	00 00		 mov	 DWORD PTR [eax+24], 8
  0002a	83 f9 02	 cmp	 ecx, 2
  0002d	76 0f		 jbe	 SHORT $LN1@make_optch
  0002f	8d 50 28	 lea	 edx, DWORD PTR [eax+40]
  00032	83 c1 fe	 add	 ecx, -2			; fffffffeH
$LL3@make_optch:

; 28   : 			optch[i].price = 0xFFFFFFFF;

  00035	83 0a ff	 or	 DWORD PTR [edx], -1
  00038	83 c2 10	 add	 edx, 16			; 00000010H
  0003b	49		 dec	 ecx
  0003c	75 f7		 jne	 SHORT $LL3@make_optch
$LN1@make_optch:

; 29   : 	}
; 30   : 
; 31   : 	return optch;
; 32   : }

  0003e	c3		 ret	 0
_make_optch ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-pack.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@ ; `string'
PUBLIC	??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@ ; `string'
PUBLIC	??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@ ; `string'
PUBLIC	??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@ ; `string'
PUBLIC	??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@ ; `string'
PUBLIC	??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@ ; `string'
;	COMDAT ??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@
CONST	SEGMENT
??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@ DB 'mhm'
	DB	't-pack.c:pack() - greedy coding not supported!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@
CONST	SEGMENT
??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@ DB 'm'
	DB	'hmt-pack.c:pack() - add_tb() failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@
CONST	SEGMENT
??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@ DB 'm'
	DB	'hmt-pack.c:pack() - can''t make optchain array!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@
CONST	SEGMENT
??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@ DB 'm'
	DB	'hmt-pack.c:pack() - build_hash() failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@
CONST	SEGMENT
??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@ DB 'mh'
	DB	'mt-pack.c:pack() - there must be no zxheader for anything exc'
	DB	'ept hrust or hrum!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@
CONST	SEGMENT
??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@ DB 'mhm'
	DB	't-pack.c:pack() - format unsupported!', 0aH, 00H ; `string'
	ALIGN	8

?codes@?1??pack@@9@9 DQ 0f14H DUP (?)			; `pack'::`2'::codes
PUBLIC	_pack
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-pack.c
;	COMDAT _pack
_TEXT	SEGMENT
_get_lz_price$ = -12					; size = 4
_emit$ = -8						; size = 4
_hash$ = -4						; size = 4
_pack	PROC						; COMDAT

; 18   : 
; 19   : 
; 20   : 	ULONG (*get_lz_price)(ULONG position, struct lzcode * lzcode) = NULL; // generates correct bitlen (price) of code
; 21   : 
; 22   : 	ULONG (*emit)(struct optchain * optch, ULONG actual_len) = NULL; // emits lzcode to the output bit/byte stream
; 23   : 
; 24   : 
; 25   : 	ULONG success=1;
; 26   : 
; 27   : 
; 28   : 	ULONG actual_len; // actual length of packing (to account for ZX headers containing last unpacked bytes)
; 29   : 
; 30   : 	UBYTE * hash;
; 31   : 
; 32   : 	struct optchain * optch=NULL;
; 33   : 
; 34   : 	static struct lzcode codes[MAX_CODES_SIZE]; // generate codes here; static to ensure it's not on the stack
; 35   : 
; 36   : 
; 37   : 	UBYTE curr_byte, last_byte;
; 38   : 	UWORD index;
; 39   : 	ULONG position;
; 40   : 
; 41   : 
; 42   : 	// some preparations
; 43   : 	//
; 44   : 	if( wrk.packtype==PK_MLZ )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _wrk
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	75 12		 jne	 SHORT $LN21@pack

; 45   : 	{
; 46   : 		get_lz_price  = &get_lz_price_megalz;

  0000f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _get_lz_price$[esp+20], OFFSET _get_lz_price_megalz

; 47   : 		emit          = &emit_megalz;

  00017	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _emit$[esp+20], OFFSET _emit_megalz
  0001f	eb 30		 jmp	 SHORT $LN16@pack
$LN21@pack:

; 48   : 	}
; 49   : 	else if( wrk.packtype==PK_HRM )

  00021	83 f8 02	 cmp	 eax, 2
  00024	75 12		 jne	 SHORT $LN19@pack

; 50   : 	{
; 51   : 		get_lz_price  = &get_lz_price_hrum;

  00026	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _get_lz_price$[esp+20], OFFSET _get_lz_price_hrum

; 52   : 		emit          = &emit_hrum;

  0002e	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _emit$[esp+20], OFFSET _emit_hrum
  00036	eb 19		 jmp	 SHORT $LN16@pack
$LN19@pack:

; 53   : 	}
; 54   : 	else if( wrk.packtype==PK_HST )

  00038	83 f8 03	 cmp	 eax, 3
  0003b	0f 85 43 01 00
	00		 jne	 $LN17@pack

; 55   : 	{
; 56   : 		get_lz_price  = &get_lz_price_hrust;

  00041	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _get_lz_price$[esp+20], OFFSET _get_lz_price_hrust

; 57   : 		emit          = &emit_hrust;

  00049	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _emit$[esp+20], OFFSET _emit_hrust
$LN16@pack:

; 63   : 	}
; 64   : 
; 65   : 
; 66   : 	actual_len = wrk.inlen;

  00051	8b 35 34 00 00
	00		 mov	 esi, DWORD PTR _wrk+52

; 67   : 	if( wrk.zxheader )

  00057	33 db		 xor	 ebx, ebx
  00059	39 1d 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, ebx
  0005f	74 08		 je	 SHORT $LN11@pack

; 68   : 	{
; 69   : 		if( wrk.packtype==PK_HRM )

  00061	83 f8 02	 cmp	 eax, 2
  00064	75 47		 jne	 SHORT $LN14@pack

; 70   : 		{
; 71   : 			actual_len -= 5;

  00066	83 ee 05	 sub	 esi, 5
$LN11@pack:
  00069	57		 push	 edi

; 81   : 		}
; 82   : 	}
; 83   : 
; 84   : 
; 85   :         // initializations and preparations
; 86   : 	init_tb();
; 87   : 
; 88   : 	hash = build_hash(wrk.indata, actual_len);

  0006a	56		 push	 esi
  0006b	ff 35 30 00 00
	00		 push	 DWORD PTR _wrk+48
  00071	33 c0		 xor	 eax, eax
  00073	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00078	bf 00 00 00 00	 mov	 edi, OFFSET _tb_entry
  0007d	89 1d 00 00 00
	00		 mov	 DWORD PTR _tb_free, ebx
  00083	89 1d 00 00 00
	00		 mov	 DWORD PTR _tb_bunches, ebx
  00089	f3 ab		 rep stosd
  0008b	e8 00 00 00 00	 call	 _build_hash
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
  00092	89 44 24 14	 mov	 DWORD PTR _hash$[esp+24], eax

; 89   : 	if( !hash )

  00096	3b c3		 cmp	 eax, ebx
  00098	75 27		 jne	 SHORT $LN42@pack

; 90   : 	{
; 91   : 		printf("mhmt-pack.c:pack() - build_hash() failed!\n");

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DKNDDHOE@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5build_hash?$CI@
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000a5	59		 pop	 ecx

; 92   : 		success = 0;

  000a6	33 ff		 xor	 edi, edi

; 93   : 	}
; 94   : 
; 95   : 	if( success )

  000a8	e9 d2 00 00 00	 jmp	 $LN34@pack
$LN14@pack:

; 72   : 		}
; 73   : 		else if( wrk.packtype==PK_HST )

  000ad	83 f8 03	 cmp	 eax, 3
  000b0	75 05		 jne	 SHORT $LN12@pack

; 74   : 		{
; 75   : 			actual_len -= 6;

  000b2	83 ee 06	 sub	 esi, 6

; 76   : 		}
; 77   : 		else

  000b5	eb b2		 jmp	 SHORT $LN11@pack
$LN12@pack:

; 78   : 		{
; 79   : 			printf("mhmt-pack.c:pack() - there must be no zxheader for anything except hrust or hrum!\n");

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@JEAMPEIF@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5there?5must?5@

; 80   : 			return 0;

  000bc	e9 c8 00 00 00	 jmp	 $LN47@pack
$LN42@pack:
  000c1	55		 push	 ebp

; 96   : 	{
; 97   : 		optch = make_optch(actual_len);

  000c2	e8 00 00 00 00	 call	 _make_optch
  000c7	8b e8		 mov	 ebp, eax

; 98   : 		if( !optch )

  000c9	3b eb		 cmp	 ebp, ebx
  000cb	75 0a		 jne	 SHORT $LN43@pack

; 99   : 		{
; 100  : 			printf("mhmt-pack.c:pack() - can't make optchain array!\n");

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GJNLKKGO@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5can?8t?5make?5@

; 101  : 			success = 0;
; 102  : 		}
; 103  : 	}
; 104  : 
; 105  : 
; 106  : 	// go packing!
; 107  : 	if( success )

  000d2	e9 89 00 00 00	 jmp	 $LN48@pack
$LN43@pack:

; 108  : 	{
; 109  : 		if( !wrk.greedy ) // default optimal coding

  000d7	39 1d 04 00 00
	00		 cmp	 DWORD PTR _wrk+4, ebx
  000dd	75 7c		 jne	 SHORT $LN6@pack

; 110  : 		{
; 111  : 			// go generating lzcodes byte-by-byte
; 112  : 			//
; 113  : 			curr_byte = wrk.indata[0];

  000df	a1 30 00 00 00	 mov	 eax, DWORD PTR _wrk+48
  000e4	8a 18		 mov	 bl, BYTE PTR [eax]

; 114  : 			//
; 115  : 			for(position=1;position<actual_len;position++)

  000e6	33 ff		 xor	 edi, edi
  000e8	47		 inc	 edi
  000e9	3b f7		 cmp	 esi, edi
  000eb	76 4d		 jbe	 SHORT $LN3@pack
$LL45@pack:

; 116  : 			{
; 117  : 				last_byte = curr_byte;
; 118  : 				curr_byte = wrk.indata[position];

  000ed	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _wrk+48
  000f3	8a c3		 mov	 al, bl
  000f5	8a 1c 39	 mov	 bl, BYTE PTR [ecx+edi]

; 119  : 
; 120  : 				// add current two-byter to the chains
; 121  : 				index = (last_byte<<8) + curr_byte;
; 122  : 				if( !add_tb(index,position) )

  000f8	66 0f b6 c0	 movzx	 ax, al
  000fc	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00101	66 0f af c1	 imul	 ax, cx
  00105	66 0f b6 cb	 movzx	 cx, bl
  00109	66 03 c1	 add	 ax, cx
  0010c	0f b7 c0	 movzx	 eax, ax
  0010f	50		 push	 eax
  00110	8b c7		 mov	 eax, edi
  00112	e8 00 00 00 00	 call	 _add_tb
  00117	59		 pop	 ecx
  00118	85 c0		 test	 eax, eax
  0011a	74 38		 je	 SHORT $LN39@pack

; 127  : 				}
; 128  : 
; 129  : 				// search lzcodes for given position
; 130  : 				make_lz_codes(position, actual_len, hash, codes);

  0011c	ff 74 24 18	 push	 DWORD PTR _hash$[esp+28]
  00120	56		 push	 esi
  00121	57		 push	 edi
  00122	e8 00 00 00 00	 call	 _make_lz_codes

; 131  : 
; 132  : 				// update optimal chain with lzcodes
; 133  : 				update_optch(position, codes, get_lz_price, optch);

  00127	55		 push	 ebp
  00128	ff 74 24 20	 push	 DWORD PTR _get_lz_price$[esp+44]
  0012c	57		 push	 edi
  0012d	e8 00 00 00 00	 call	 _update_optch
  00132	83 c4 18	 add	 esp, 24			; 00000018H
  00135	47		 inc	 edi
  00136	3b fe		 cmp	 edi, esi
  00138	72 b3		 jb	 SHORT $LL45@pack
$LN3@pack:

; 134  : 			}
; 135  : 
; 136  : 
; 137  : 			// all input bytes scanned, chain built, so now reverse it (prepare for scanning in output generation part)
; 138  : 			reverse_optch(optch, actual_len);

  0013a	8b c6		 mov	 eax, esi
  0013c	8b cd		 mov	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 _reverse_optch

; 143  : 			success = 0;
; 144  : 		}
; 145  : 
; 146  : 		// data built, now emit packed file
; 147  : 		success = success && (*emit)(optch, actual_len);

  00143	56		 push	 esi
  00144	55		 push	 ebp
  00145	ff 54 24 1c	 call	 DWORD PTR _emit$[esp+36]
  00149	59		 pop	 ecx
  0014a	59		 pop	 ecx
  0014b	85 c0		 test	 eax, eax
  0014d	74 18		 je	 SHORT $LN46@pack
  0014f	33 ff		 xor	 edi, edi
  00151	47		 inc	 edi
  00152	eb 15		 jmp	 SHORT $ERROR$3957
$LN39@pack:

; 123  : 				{
; 124  : 					printf("mhmt-pack.c:pack() - add_tb() failed!\n");

  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LAFCLHBC@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5add_tb?$CI?$CJ?5fa@

; 125  : 					success = 0;
; 126  : 					goto ERROR;

  00159	eb 05		 jmp	 SHORT $LN48@pack
$LN6@pack:

; 139  : 		}
; 140  : 		else // greedy coding
; 141  : 		{
; 142  : 			printf("mhmt-pack.c:pack() - greedy coding not supported!\n");

  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@POENPHHB@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5greedy?5codi@
$LN48@pack:
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00166	59		 pop	 ecx
$LN46@pack:

; 143  : 			success = 0;
; 144  : 		}
; 145  : 
; 146  : 		// data built, now emit packed file
; 147  : 		success = success && (*emit)(optch, actual_len);

  00167	33 ff		 xor	 edi, edi
$ERROR$3957:

; 148  : 	}
; 149  : 
; 150  : 
; 151  : 
; 152  : 
; 153  : 
; 154  : ERROR:
; 155  : 	free_optch(optch);

  00169	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  0016f	85 ed		 test	 ebp, ebp
  00171	74 04		 je	 SHORT $LN31@pack
  00173	55		 push	 ebp
  00174	ff d6		 call	 esi
  00176	59		 pop	 ecx
$LN31@pack:

; 156  : 
; 157  : 	destroy_hash(hash);

  00177	ff 74 24 18	 push	 DWORD PTR _hash$[esp+28]
  0017b	ff d6		 call	 esi
  0017d	59		 pop	 ecx
  0017e	5d		 pop	 ebp
$LN34@pack:

; 158  : 
; 159  : 	return success;

  0017f	8b c7		 mov	 eax, edi
  00181	5f		 pop	 edi
  00182	eb 0e		 jmp	 SHORT $LN22@pack
$LN17@pack:

; 58   : 	}
; 59   : 	else
; 60   : 	{
; 61   : 		printf("mhmt-pack.c:pack() - format unsupported!\n");

  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PPDMKKDD@mhmt?9pack?4c?3pack?$CI?$CJ?5?9?5format?5unsu@
$LN47@pack:
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 62   : 		return 0;

  0018f	33 c0		 xor	 eax, eax
  00191	59		 pop	 ecx
$LN22@pack:
  00192	5e		 pop	 esi
  00193	5b		 pop	 ebx

; 160  : }

  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
  00197	c3		 ret	 0
_pack	ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-parsearg.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@BFNKOLLP@maxwin65536?$AA@		; `string'
PUBLIC	??_C@_0M@MFHGIBPC@maxwin32768?$AA@		; `string'
PUBLIC	??_C@_0M@FEHHHDGI@maxwin16384?$AA@		; `string'
PUBLIC	??_C@_0L@OPCPICNH@maxwin8192?$AA@		; `string'
PUBLIC	??_C@_0L@IJMMFODJ@maxwin4352?$AA@		; `string'
PUBLIC	??_C@_0L@PGAPMNLH@maxwin4096?$AA@		; `string'
PUBLIC	??_C@_0L@OPBEIGMK@maxwin2048?$AA@		; `string'
PUBLIC	??_C@_0L@IMMPKE@maxwin1024?$AA@			; `string'
PUBLIC	??_C@_09CDNLKNNF@maxwin512?$AA@			; `string'
PUBLIC	??_C@_09NNGJPILE@maxwin256?$AA@			; `string'
PUBLIC	??_C@_04JFAPGDHH@bend?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_03CNPPLIFM@zxh?$AA@			; `string'
PUBLIC	??_C@_03DNMNJFPE@hst?$AA@			; `string'
PUBLIC	??_C@_03KHAPFGNL@hrm?$AA@			; `string'
PUBLIC	??_C@_03IDOKKMAF@mlz?$AA@			; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	_default_arg_table
PUBLIC	??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@ ; `string'
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@ ; `string'
PUBLIC	??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@ ; `string'
PUBLIC	??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@ ; `string'
PUBLIC	??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@ ; `string'
PUBLIC	??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@ ; `string'
PUBLIC	??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@ ; `string'
PUBLIC	??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@ ; `string'
PUBLIC	??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@ ; `string'
;	COMDAT ??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #4! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@
CONST	SEGMENT
??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@ DB 'Maximum win'
	DB	'dow specified is too big for given packing type!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #3! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@
CONST	SEGMENT
??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@ DB 'There can '
	DB	'be only little-endian arrangement of bits when ZX-header is a'
	DB	'ctive!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #2! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@
CONST	SEGMENT
??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@ DB 'There can b'
	DB	'e only 16bit grouping of bits when ZX-header is active!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@
CONST	SEGMENT
??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@ DB 'There cou'
	DB	'ldn''t be zx-header in megalz mode!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@
CONST	SEGMENT
??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@ DB 'Impos'
	DB	'sible error #1! Press any key to continue or "SPACE" to exit.'
	DB	'.. :-)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@
CONST	SEGMENT
??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@ DB 'No greedy mo'
	DB	'de specification for DEpacking!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@ DB 'Redundant argument'
	DB	's!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@ DB 'No filenames s'
	DB	'pecified!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@
CONST	SEGMENT
??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@ DB 'Cannot alloc'
	DB	'ate memory for filename string!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@ DB 'Too man'
	DB	'y filenames specified!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@ DB 'Wrong arguments!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@ DB 'Too many arguments'
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@
CONST	SEGMENT
??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@ DB 'N'
	DB	'o arguments! Use "mhmt -h" or "mhmt -help" for help!', 0aH, 00H ; `string'
_default_arg_table DD FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	01H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	02H
	DD	FLAT:??_C@_03IDOKKMAF@mlz?$AA@
	DD	03H
	DD	FLAT:??_C@_03KHAPFGNL@hrm?$AA@
	DD	03H
	DD	FLAT:??_C@_03DNMNJFPE@hst?$AA@
	DD	03H
	DD	FLAT:??_C@_03CNPPLIFM@zxh?$AA@
	DD	04H
	DD	FLAT:??_C@_01KJLJFBPL@8?$AA@
	DD	05H
	DD	FLAT:??_C@_02KMALDIDP@16?$AA@
	DD	05H
	DD	FLAT:??_C@_04JFAPGDHH@bend?$AA@
	DD	06H
	DD	FLAT:??_C@_09NNGJPILE@maxwin256?$AA@
	DD	07H
	DD	FLAT:??_C@_09CDNLKNNF@maxwin512?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@IMMPKE@maxwin1024?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@OPBEIGMK@maxwin2048?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@PGAPMNLH@maxwin4096?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@IJMMFODJ@maxwin4352?$AA@
	DD	07H
	DD	FLAT:??_C@_0L@OPCPICNH@maxwin8192?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@FEHHHDGI@maxwin16384?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@MFHGIBPC@maxwin32768?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@BFNKOLLP@maxwin65536?$AA@
	DD	07H
	DD	00H
	DD	00H
?strings@?1??get_maxwin@@9@9 DD FLAT:??_C@_09NNGJPILE@maxwin256?$AA@ ; `get_maxwin'::`2'::strings
	DD	FLAT:??_C@_09CDNLKNNF@maxwin512?$AA@
	DD	FLAT:??_C@_0L@IMMPKE@maxwin1024?$AA@
	DD	FLAT:??_C@_0L@OPBEIGMK@maxwin2048?$AA@
	DD	FLAT:??_C@_0L@PGAPMNLH@maxwin4096?$AA@
	DD	FLAT:??_C@_0L@IJMMFODJ@maxwin4352?$AA@
	DD	FLAT:??_C@_0L@OPCPICNH@maxwin8192?$AA@
	DD	FLAT:??_C@_0M@FEHHHDGI@maxwin16384?$AA@
	DD	FLAT:??_C@_0M@MFHGIBPC@maxwin32768?$AA@
	DD	FLAT:??_C@_0M@BFNKOLLP@maxwin65536?$AA@
	DD	00H
?sizes@?1??get_maxwin@@9@9 DD 0100H			; `get_maxwin'::`2'::sizes
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	01100H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
	DD	00H
;	COMDAT ??_C@_0M@BFNKOLLP@maxwin65536?$AA@
CONST	SEGMENT
??_C@_0M@BFNKOLLP@maxwin65536?$AA@ DB 'maxwin65536', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MFHGIBPC@maxwin32768?$AA@
CONST	SEGMENT
??_C@_0M@MFHGIBPC@maxwin32768?$AA@ DB 'maxwin32768', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEHHHDGI@maxwin16384?$AA@
CONST	SEGMENT
??_C@_0M@FEHHHDGI@maxwin16384?$AA@ DB 'maxwin16384', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPCPICNH@maxwin8192?$AA@
CONST	SEGMENT
??_C@_0L@OPCPICNH@maxwin8192?$AA@ DB 'maxwin8192', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IJMMFODJ@maxwin4352?$AA@
CONST	SEGMENT
??_C@_0L@IJMMFODJ@maxwin4352?$AA@ DB 'maxwin4352', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGAPMNLH@maxwin4096?$AA@
CONST	SEGMENT
??_C@_0L@PGAPMNLH@maxwin4096?$AA@ DB 'maxwin4096', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPBEIGMK@maxwin2048?$AA@
CONST	SEGMENT
??_C@_0L@OPBEIGMK@maxwin2048?$AA@ DB 'maxwin2048', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IMMPKE@maxwin1024?$AA@
CONST	SEGMENT
??_C@_0L@IMMPKE@maxwin1024?$AA@ DB 'maxwin1024', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CDNLKNNF@maxwin512?$AA@
CONST	SEGMENT
??_C@_09CDNLKNNF@maxwin512?$AA@ DB 'maxwin512', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNGJPILE@maxwin256?$AA@
CONST	SEGMENT
??_C@_09NNGJPILE@maxwin256?$AA@ DB 'maxwin256', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFAPGDHH@bend?$AA@
CONST	SEGMENT
??_C@_04JFAPGDHH@bend?$AA@ DB 'bend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNPPLIFM@zxh?$AA@
CONST	SEGMENT
??_C@_03CNPPLIFM@zxh?$AA@ DB 'zxh', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNMNJFPE@hst?$AA@
CONST	SEGMENT
??_C@_03DNMNJFPE@hst?$AA@ DB 'hst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHAPFGNL@hrm?$AA@
CONST	SEGMENT
??_C@_03KHAPFGNL@hrm?$AA@ DB 'hrm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDOKKMAF@mlz?$AA@
CONST	SEGMENT
??_C@_03IDOKKMAF@mlz?$AA@ DB 'mlz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
PUBLIC	_cmp_str_nocase
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-parsearg.c
;	COMDAT _cmp_str_nocase
_TEXT	SEGMENT
_order$ = -4						; size = 4
_cmp_str_nocase PROC					; COMDAT
; _left$ = ecx
; _right$ = eax

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 382  : 
; 383  : 	LONG order=0;

  00004	83 65 fc 00	 and	 DWORD PTR _order$[ebp], 0
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	8b f1		 mov	 esi, ecx
$LL10@cmp_str_no:

; 384  : 
; 385  : 	UBYTE leftchar,rightchar;
; 386  : 	UBYTE leftadd,rightadd;
; 387  : 
; 388  : 	do
; 389  : 	{
; 390  : 		leftchar  = (UBYTE)*left;

  0000f	8a 0e		 mov	 cl, BYTE PTR [esi]

; 391  : 		rightchar = (UBYTE)*right;

  00011	8a 17		 mov	 dl, BYTE PTR [edi]

; 392  : 
; 393  : 		leftadd  = 0;

  00013	32 db		 xor	 bl, bl

; 394  : 		rightadd = 0;

  00015	32 c0		 xor	 al, al

; 395  : 
; 396  : 		left++;

  00017	46		 inc	 esi

; 397  : 		right++;

  00018	47		 inc	 edi

; 398  : 
; 399  : 		if( leftchar  >= (UBYTE)'a' ) leftadd  = (UBYTE)('A'-'a');

  00019	80 f9 61	 cmp	 cl, 97			; 00000061H
  0001c	72 02		 jb	 SHORT $LN7@cmp_str_no
  0001e	b3 e0		 mov	 bl, 224			; 000000e0H
$LN7@cmp_str_no:

; 400  : 		if( rightchar >= (UBYTE)'a' ) rightadd = (UBYTE)('A'-'a');

  00020	80 fa 61	 cmp	 dl, 97			; 00000061H
  00023	72 02		 jb	 SHORT $LN6@cmp_str_no
  00025	b0 e0		 mov	 al, 224			; 000000e0H
$LN6@cmp_str_no:

; 401  : 
; 402  : 		if( leftchar  > (UBYTE)'z' ) leftadd  = 0;

  00027	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  0002a	76 02		 jbe	 SHORT $LN5@cmp_str_no
  0002c	32 db		 xor	 bl, bl
$LN5@cmp_str_no:

; 403  : 		if( rightchar > (UBYTE)'z' ) rightadd = 0;

  0002e	80 fa 7a	 cmp	 dl, 122			; 0000007aH
  00031	76 02		 jbe	 SHORT $LN4@cmp_str_no
  00033	32 c0		 xor	 al, al
$LN4@cmp_str_no:

; 404  : 
; 405  : 		leftchar  += leftadd;

  00035	02 cb		 add	 cl, bl

; 406  : 		rightchar += rightadd;

  00037	02 d0		 add	 dl, al

; 407  : 
; 408  : 		if( leftchar<rightchar ) order = (-1);

  00039	3a ca		 cmp	 cl, dl
  0003b	73 06		 jae	 SHORT $LN17@cmp_str_no
  0003d	83 4d fc ff	 or	 DWORD PTR _order$[ebp], -1

; 409  : 		if( leftchar>rightchar ) order = (+1);

  00041	3a ca		 cmp	 cl, dl
$LN17@cmp_str_no:
  00043	76 07		 jbe	 SHORT $LN9@cmp_str_no
  00045	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _order$[ebp], 1
$LN9@cmp_str_no:

; 410  : 
; 411  : 	} while( (!order) && leftchar && rightchar );

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _order$[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	75 08		 jne	 SHORT $LN1@cmp_str_no
  00053	84 c9		 test	 cl, cl
  00055	74 04		 je	 SHORT $LN1@cmp_str_no
  00057	84 d2		 test	 dl, dl
  00059	75 b4		 jne	 SHORT $LL10@cmp_str_no
$LN1@cmp_str_no:
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 412  : 
; 413  : 	return order;
; 414  : }

  0005e	c9		 leave
  0005f	c3		 ret	 0
_cmp_str_nocase ENDP
_TEXT	ENDS
PUBLIC	_match_arg
; Function compile flags: /Ogspy
;	COMDAT _match_arg
_TEXT	SEGMENT
_argument$ = 8						; size = 4
_match_arg PROC						; COMDAT

; 368  : 	struct argtbl * test_arg = default_arg_table;
; 369  : 
; 370  : 
; 371  : 	while( test_arg->name && cmp_str_nocase(test_arg->name,argument) )

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _default_arg_table
  00006	56		 push	 esi
  00007	be 00 00 00 00	 mov	 esi, OFFSET _default_arg_table
  0000c	eb 12		 jmp	 SHORT $LN7@match_arg
$LL2@match_arg:
  0000e	8b 44 24 08	 mov	 eax, DWORD PTR _argument$[esp]
  00012	e8 00 00 00 00	 call	 _cmp_str_nocase
  00017	85 c0		 test	 eax, eax
  00019	74 09		 je	 SHORT $LN1@match_arg

; 372  : 		test_arg++;

  0001b	83 c6 08	 add	 esi, 8
  0001e	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN7@match_arg:

; 368  : 	struct argtbl * test_arg = default_arg_table;
; 369  : 
; 370  : 
; 371  : 	while( test_arg->name && cmp_str_nocase(test_arg->name,argument) )

  00020	85 c9		 test	 ecx, ecx
  00022	75 ea		 jne	 SHORT $LL2@match_arg
$LN1@match_arg:

; 373  : 
; 374  : 	return (test_arg->name)?test_arg:NULL;

  00024	8b 06		 mov	 eax, DWORD PTR [esi]
  00026	f7 d8		 neg	 eax
  00028	1b c0		 sbb	 eax, eax
  0002a	23 c6		 and	 eax, esi
  0002c	5e		 pop	 esi

; 375  : }

  0002d	c3		 ret	 0
_match_arg ENDP
_TEXT	ENDS
PUBLIC	_get_maxwin
; Function compile flags: /Ogspy
;	COMDAT _get_maxwin
_TEXT	SEGMENT
_txtmaxwin$ = 8						; size = 4
_get_maxwin PROC					; COMDAT

; 313  : 	static char * strings[] =
; 314  : 	{
; 315  : 		ARGSTR_MW256,
; 316  : 		ARGSTR_MW512,
; 317  : 		ARGSTR_MW1024,
; 318  : 		ARGSTR_MW2048,
; 319  : 		ARGSTR_MW4096,
; 320  : 		ARGSTR_MW4352,
; 321  : 		ARGSTR_MW8192,
; 322  : 		ARGSTR_MW16384,
; 323  : 		ARGSTR_MW32768,
; 324  : 		ARGSTR_MW65536,
; 325  : 		NULL
; 326  : 	};
; 327  : 
; 328  : 	static LONG sizes[] =
; 329  : 	{
; 330  : 		256,
; 331  : 		512,
; 332  : 		1024,
; 333  : 		2048,
; 334  : 		4096,
; 335  : 		4352,
; 336  : 		8192,
; 337  : 		16384,
; 338  : 		32768,
; 339  : 		65536,
; 340  : 		0
; 341  : 	};
; 342  : 
; 343  : 	ULONG i;
; 344  : 
; 345  : 
; 346  : 	i=0;
; 347  : 	while( strings[i] )

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?strings@?1??get_maxwin@@9@9
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	eb 15		 jmp	 SHORT $LN9@get_maxwin
$LL3@get_maxwin:

; 348  : 	{
; 349  : 		if( !cmp_str_nocase( strings[i], txtmaxwin ) )

  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _txtmaxwin$[esp]
  0000f	e8 00 00 00 00	 call	 _cmp_str_nocase
  00014	85 c0		 test	 eax, eax
  00016	74 10		 je	 SHORT $LN7@get_maxwin
  00018	8b 0c b5 04 00
	00 00		 mov	 ecx, DWORD PTR ?strings@?1??get_maxwin@@9@9[esi*4+4]

; 352  : 		}
; 353  : 
; 354  : 		i++;

  0001f	46		 inc	 esi
$LN9@get_maxwin:

; 313  : 	static char * strings[] =
; 314  : 	{
; 315  : 		ARGSTR_MW256,
; 316  : 		ARGSTR_MW512,
; 317  : 		ARGSTR_MW1024,
; 318  : 		ARGSTR_MW2048,
; 319  : 		ARGSTR_MW4096,
; 320  : 		ARGSTR_MW4352,
; 321  : 		ARGSTR_MW8192,
; 322  : 		ARGSTR_MW16384,
; 323  : 		ARGSTR_MW32768,
; 324  : 		ARGSTR_MW65536,
; 325  : 		NULL
; 326  : 	};
; 327  : 
; 328  : 	static LONG sizes[] =
; 329  : 	{
; 330  : 		256,
; 331  : 		512,
; 332  : 		1024,
; 333  : 		2048,
; 334  : 		4096,
; 335  : 		4352,
; 336  : 		8192,
; 337  : 		16384,
; 338  : 		32768,
; 339  : 		65536,
; 340  : 		0
; 341  : 	};
; 342  : 
; 343  : 	ULONG i;
; 344  : 
; 345  : 
; 346  : 	i=0;
; 347  : 	while( strings[i] )

  00020	85 c9		 test	 ecx, ecx
  00022	75 e7		 jne	 SHORT $LL3@get_maxwin

; 355  : 	}
; 356  : 
; 357  : 	return 0;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 358  : }

  00027	c3		 ret	 0
$LN7@get_maxwin:

; 350  : 		{
; 351  : 			return sizes[i];

  00028	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?sizes@?1??get_maxwin@@9@9[esi*4]
  0002f	5e		 pop	 esi

; 358  : }

  00030	c3		 ret	 0
_get_maxwin ENDP
_TEXT	ENDS
PUBLIC	_sort_args
; Function compile flags: /Ogspy
;	COMDAT _sort_args
_TEXT	SEGMENT
_args$ = 8						; size = 4
_sort_args PROC						; COMDAT

; 290  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 291  : 	struct argtbl temp;
; 292  : 	LONG i,j;
; 293  : 
; 294  : 	// simple bubble sort since there are not too many arguments
; 295  : 	for( i=(argsize-2); i>=0; i-- )

  00003	6a 0e		 push	 14			; 0000000eH
  00005	5e		 pop	 esi
$LL7@sort_args:

; 296  : 	{
; 297  : 		for( j=0; j<=i; j++ )

  00006	85 f6		 test	 esi, esi
  00008	7c 2e		 jl	 SHORT $LN6@sort_args
  0000a	8b 44 24 10	 mov	 eax, DWORD PTR _args$[esp+8]
  0000e	83 c0 08	 add	 eax, 8
  00011	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$LL4@sort_args:

; 298  : 		{
; 299  : 			if( args[j].type > args[j+1].type )

  00014	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00017	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0001a	76 16		 jbe	 SHORT $LN3@sort_args

; 300  : 			{
; 301  : 				temp      = args[j];
; 302  : 				args[j]   = args[j+1];

  0001c	8b 18		 mov	 ebx, DWORD PTR [eax]
  0001e	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00021	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00024	89 58 f8	 mov	 DWORD PTR [eax-8], ebx
  00027	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0002a	89 58 fc	 mov	 DWORD PTR [eax-4], ebx

; 303  : 				args[j+1] = temp;

  0002d	89 08		 mov	 DWORD PTR [eax], ecx
  0002f	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN3@sort_args:
  00032	83 c0 08	 add	 eax, 8
  00035	4f		 dec	 edi
  00036	75 dc		 jne	 SHORT $LL4@sort_args
$LN6@sort_args:

; 291  : 	struct argtbl temp;
; 292  : 	LONG i,j;
; 293  : 
; 294  : 	// simple bubble sort since there are not too many arguments
; 295  : 	for( i=(argsize-2); i>=0; i-- )

  00038	4e		 dec	 esi
  00039	79 cb		 jns	 SHORT $LL7@sort_args

; 304  : 			}
; 305  : 		}
; 306  : 	}
; 307  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	c3		 ret	 0
_sort_args ENDP
_TEXT	ENDS
PUBLIC	_parse_args
; Function compile flags: /Ogspy
;	COMDAT _parse_args
_TEXT	SEGMENT
_inarg_pos$ = -148					; size = 4
_files_num$ = -144					; size = 4
_storearg_pos$ = -144					; size = 4
tv438 = -140						; size = 4
tv410 = -140						; size = 4
_argstore$ = -136					; size = 136
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_parse_args PROC					; COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 47   : 	struct argtbl argstore[ARG_STORE_SIZE+1]; // last element is always stop-value
; 48   : 
; 49   : 
; 50   : 
; 51   : 	struct argtbl * arg;
; 52   : 
; 53   : 	ULONG inarg_pos; // position in argv[] array
; 54   : 	ULONG storearg_pos; // position in argstore[] array
; 55   : 
; 56   : 	ULONG files_num; // number of filenames specified
; 57   : 
; 58   : 	char * temp_filename;
; 59   : 
; 60   : 	ULONG last_arg_type;
; 61   : 
; 62   : 	ULONG maxwin;
; 63   : 
; 64   : 
; 65   : 	ULONG i;
; 66   : 	for(i=0;i<ARG_STORE_SIZE+1;i++)

  0000f	33 c0		 xor	 eax, eax
$LL47@parse_args:

; 67   : 	{
; 68   : 		argstore[i].name = NULL;

  00011	83 64 c4 18 00	 and	 DWORD PTR _argstore$[esp+eax*8+160], 0

; 69   : 		argstore[i].type = ARG_NOARG;

  00016	c7 44 c4 1c ff
	00 00 00	 mov	 DWORD PTR _argstore$[esp+eax*8+164], 255 ; 000000ffH
  0001e	40		 inc	 eax
  0001f	83 f8 11	 cmp	 eax, 17			; 00000011H
  00022	72 ed		 jb	 SHORT $LL47@parse_args

; 70   : 	}
; 71   : 
; 72   : 
; 73   : 	if( argc<2 )

  00024	83 7d 08 02	 cmp	 DWORD PTR _argc$[ebp], 2
  00028	7d 13		 jge	 SHORT $LN44@parse_args

; 74   : 	{
; 75   : 		printf("No arguments! Use \"mhmt -h\" or \"mhmt -help\" for help!\n");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FFJLACD@No?5arguments?$CB?5Use?5?$CCmhmt?5?9h?$CC?5or?5?$CC@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00035	59		 pop	 ecx

; 76   : 		return 0L;

  00036	33 c0		 xor	 eax, eax
  00038	e9 01 04 00 00	 jmp	 $LN48@parse_args
$LN44@parse_args:

; 77   : 	}
; 78   : 
; 79   : 	// shortcut for help request
; 80   : 	if( !cmp_str_nocase( argv[1]+1, "h" ) || !cmp_str_nocase( argv[1]+1, "help" ) )

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00046	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01BDACAMKP@h?$AA@
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 _cmp_str_nocase
  00052	85 c0		 test	 eax, eax
  00054	0f 84 e1 03 00
	00		 je	 $LN42@parse_args
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04PCJFHION@help?$AA@
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 _cmp_str_nocase
  00066	85 c0		 test	 eax, eax
  00068	0f 84 cd 03 00
	00		 je	 $LN42@parse_args

; 82   : 
; 83   : 
; 84   : 	inarg_pos = 1;
; 85   : 	storearg_pos = 0;
; 86   : 	files_num = 0;

  0006e	83 64 24 10 00	 and	 DWORD PTR _files_num$[esp+160], 0
  00073	33 c0		 xor	 eax, eax
  00075	40		 inc	 eax
  00076	89 44 24 0c	 mov	 DWORD PTR _inarg_pos$[esp+160], eax

; 87   : 
; 88   : 	// first find all arguments beginning with "-"
; 89   : 	while( inarg_pos<(ULONG)argc && *(argv[inarg_pos])=='-' )

  0007a	39 45 08	 cmp	 DWORD PTR _argc$[ebp], eax
  0007d	0f 86 05 01 00
	00		 jbe	 $LN84@parse_args
  00083	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _default_arg_table
  00089	8d 7c 24 18	 lea	 edi, DWORD PTR _argstore$[esp+160]
$LL41@parse_args:
  0008d	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00090	8b 4c 24 0c	 mov	 ecx, DWORD PTR _inarg_pos$[esp+160]
  00094	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00097	80 38 2d	 cmp	 BYTE PTR [eax], 45	; 0000002dH
  0009a	75 58		 jne	 SHORT $LN63@parse_args

; 90   : 	{
; 91   : 		arg=match_arg(argv[inarg_pos]+1); // search match...

  0009c	be 00 00 00 00	 mov	 esi, OFFSET _default_arg_table
  000a1	85 db		 test	 ebx, ebx
  000a3	74 1d		 je	 SHORT $LN51@parse_args
  000a5	40		 inc	 eax
  000a6	89 44 24 14	 mov	 DWORD PTR tv410[esp+160], eax
  000aa	8b cb		 mov	 ecx, ebx
$LL52@parse_args:
  000ac	8b 44 24 14	 mov	 eax, DWORD PTR tv410[esp+160]
  000b0	e8 00 00 00 00	 call	 _cmp_str_nocase
  000b5	85 c0		 test	 eax, eax
  000b7	74 09		 je	 SHORT $LN51@parse_args
  000b9	83 c6 08	 add	 esi, 8
  000bc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000be	85 c9		 test	 ecx, ecx
  000c0	75 ea		 jne	 SHORT $LL52@parse_args
$LN51@parse_args:
  000c2	8b 06		 mov	 eax, DWORD PTR [esi]
  000c4	f7 d8		 neg	 eax
  000c6	1b c0		 sbb	 eax, eax
  000c8	23 c6		 and	 eax, esi

; 92   : 		if( arg ) // match!

  000ca	0f 84 93 00 00
	00		 je	 $LN39@parse_args

; 93   : 		{
; 94   : 			if( storearg_pos>=ARG_STORE_SIZE )

  000d0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _inarg_pos$[esp+160]
  000d4	49		 dec	 ecx
  000d5	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000d8	73 73		 jae	 SHORT $LN67@parse_args

; 98   : 			}
; 99   : 
; 100  : 			argstore[storearg_pos++] = *arg;

  000da	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 106  : 		}
; 107  : 
; 108  : 		inarg_pos++;

  000df	ff 44 24 0c	 inc	 DWORD PTR _inarg_pos$[esp+160]
  000e3	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000e6	8b 44 24 0c	 mov	 eax, DWORD PTR _inarg_pos$[esp+160]
  000ea	89 0f		 mov	 DWORD PTR [edi], ecx
  000ec	83 c7 08	 add	 edi, 8
  000ef	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  000f2	72 99		 jb	 SHORT $LL41@parse_args
$LN63@parse_args:

; 109  : 	}
; 110  : 
; 111  : 	// parse filenames then
; 112  : 	while( inarg_pos<(ULONG)argc )

  000f4	8b 45 08	 mov	 eax, DWORD PTR _argc$[ebp]
  000f7	39 44 24 0c	 cmp	 DWORD PTR _inarg_pos$[esp+160], eax
  000fb	0f 83 87 00 00
	00		 jae	 $LN84@parse_args
$LL36@parse_args:

; 113  : 	{
; 114  : 		if( files_num>=2 ) // there should be no more than two filenames

  00101	83 7c 24 10 02	 cmp	 DWORD PTR _files_num$[esp+160], 2
  00106	0f 83 83 00 00
	00		 jae	 $LN68@parse_args
  0010c	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0010f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _inarg_pos$[esp+160]
  00113	8d 34 88	 lea	 esi, DWORD PTR [eax+ecx*4]

; 118  : 		}
; 119  : 
; 120  : 		temp_filename = (char *)malloc( 1+strlen(argv[inarg_pos]) );

  00116	8b 06		 mov	 eax, DWORD PTR [esi]
  00118	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL85@parse_args:
  0011b	8a 10		 mov	 dl, BYTE PTR [eax]
  0011d	40		 inc	 eax
  0011e	84 d2		 test	 dl, dl
  00120	75 f9		 jne	 SHORT $LL85@parse_args
  00122	2b c1		 sub	 eax, ecx
  00124	40		 inc	 eax
  00125	50		 push	 eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0012c	59		 pop	 ecx

; 121  : 		if( !temp_filename )

  0012d	85 c0		 test	 eax, eax
  0012f	74 65		 je	 SHORT $LN69@parse_args
  00131	8b 16		 mov	 edx, DWORD PTR [esi]

; 125  : 		}
; 126  : 
; 127  : 		strcpy( temp_filename, argv[inarg_pos] );

  00133	8b f0		 mov	 esi, eax
$LL50@parse_args:
  00135	8a 0a		 mov	 cl, BYTE PTR [edx]
  00137	42		 inc	 edx
  00138	88 0e		 mov	 BYTE PTR [esi], cl
  0013a	46		 inc	 esi
  0013b	84 c9		 test	 cl, cl
  0013d	75 f6		 jne	 SHORT $LL50@parse_args

; 128  : 
; 129  : 		if( files_num==0 )

  0013f	83 7c 24 10 00	 cmp	 DWORD PTR _files_num$[esp+160], 0
  00144	75 24		 jne	 SHORT $LN32@parse_args

; 130  : 			wrk.fname_in = temp_filename;

  00146	a3 20 00 00 00	 mov	 DWORD PTR _wrk+32, eax

; 131  : 		else // only files_num==1, because of condition in the beginning of current "while" cycle

  0014b	eb 22		 jmp	 SHORT $LN31@parse_args
$LN67@parse_args:

; 95   : 			{
; 96   : 				printf("Too many arguments!\n");

  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BBCBIAKE@Too?5many?5arguments?$CB?6?$AA@
$LN91@parse_args:
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00158	59		 pop	 ecx

; 97   : 				return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  00159	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  0015e	e9 db 02 00 00	 jmp	 $LN48@parse_args
$LN39@parse_args:

; 101  : 		}
; 102  : 		else // argument does not match predefined set
; 103  : 		{
; 104  : 			printf("Wrong arguments!\n");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JFHEPGMJ@Wrong?5arguments?$CB?6?$AA@

; 105  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  00168	eb e8		 jmp	 SHORT $LN91@parse_args
$LN32@parse_args:

; 132  : 			wrk.fname_out = temp_filename;

  0016a	a3 24 00 00 00	 mov	 DWORD PTR _wrk+36, eax
$LN31@parse_args:

; 133  : 
; 134  : 		files_num++;

  0016f	ff 44 24 10	 inc	 DWORD PTR _files_num$[esp+160]

; 135  : 		inarg_pos++;

  00173	ff 44 24 0c	 inc	 DWORD PTR _inarg_pos$[esp+160]
  00177	8b 44 24 0c	 mov	 eax, DWORD PTR _inarg_pos$[esp+160]
  0017b	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  0017e	72 81		 jb	 SHORT $LL36@parse_args

; 136  : 	}
; 137  : 
; 138  : 	if( !files_num ) // there must be at least 1 filename specified

  00180	33 f6		 xor	 esi, esi
  00182	39 74 24 10	 cmp	 DWORD PTR _files_num$[esp+160], esi
  00186	75 24		 jne	 SHORT $LN30@parse_args
$LN84@parse_args:

; 139  : 	{
; 140  : 		printf("No filenames specified!\n");

  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CMFMFJDB@No?5filenames?5specified?$CB?6?$AA@

; 141  : 		return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  0018d	eb c3		 jmp	 SHORT $LN91@parse_args
$LN68@parse_args:

; 115  : 		{
; 116  : 			printf("Too many filenames specified!\n");

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MIBFNAEK@Too?5many?5filenames?5specified?$CB?6?$AA@

; 117  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  00194	eb bc		 jmp	 SHORT $LN91@parse_args
$LN69@parse_args:

; 122  : 		{
; 123  : 			printf("Cannot allocate memory for filename string!\n");

  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OPFKPBNC@Cannot?5allocate?5memory?5for?5filen@
$LN92@parse_args:
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001a1	59		 pop	 ecx

; 124  : 			return ARG_PARSER_ERROR;

  001a2	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001a7	e9 92 02 00 00	 jmp	 $LN48@parse_args
$LN30@parse_args:

; 142  : 	}
; 143  : 
; 144  : 
; 145  : 	// now optional arguments (starting with "-") are stored in argstore[],
; 146  : 	// all needed filenames are also copied, go proceed configuring with
; 147  : 	// optional arguments
; 148  : 
; 149  : 	// sort argument array (in increasing .type order) to ensure correct parsing
; 150  : 	sort_args( argstore, ARG_STORE_SIZE );

  001ac	8d 44 24 18	 lea	 eax, DWORD PTR _argstore$[esp+160]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 _sort_args

; 151  : 
; 152  : 	storearg_pos = 0;
; 153  : 	last_arg_type = ARG_INIT; // there is no such value in argstore[].type

  001b6	33 d2		 xor	 edx, edx

; 154  : 	while( argstore[storearg_pos].type != ARG_NOARG )

  001b8	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR _argstore$[esp+168], 255 ; 000000ffH
  001c0	59		 pop	 ecx
  001c1	89 74 24 10	 mov	 DWORD PTR _storearg_pos$[esp+160], esi
  001c5	0f 84 07 02 00
	00		 je	 $LN28@parse_args
  001cb	33 db		 xor	 ebx, ebx
  001cd	33 c9		 xor	 ecx, ecx
  001cf	8d 44 24 1c	 lea	 eax, DWORD PTR _argstore$[esp+164]
  001d3	43		 inc	 ebx
$LL29@parse_args:

; 155  : 	{
; 156  : 		if( last_arg_type == argstore[storearg_pos].type )

  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 44 24 14	 mov	 DWORD PTR tv438[esp+160], eax
  001da	3b d0		 cmp	 edx, eax
  001dc	0f 84 f5 01 00
	00		 je	 $LN71@parse_args

; 160  : 		}
; 161  : 
; 162  : 		switch( argstore[storearg_pos].type )

  001e2	48		 dec	 eax
  001e3	0f 84 c4 01 00
	00		 je	 $LN24@parse_args
  001e9	48		 dec	 eax
  001ea	0f 84 a9 01 00
	00		 je	 $LN23@parse_args
  001f0	48		 dec	 eax
  001f1	0f 84 e1 00 00
	00		 je	 $LN21@parse_args
  001f7	48		 dec	 eax
  001f8	0f 84 c3 00 00
	00		 je	 $LN14@parse_args
  001fe	48		 dec	 eax
  001ff	74 76		 je	 SHORT $LN12@parse_args
  00201	48		 dec	 eax
  00202	74 5c		 je	 SHORT $LN6@parse_args
  00204	48		 dec	 eax
  00205	0f 85 d6 01 00
	00		 jne	 $LN1@parse_args

; 254  : 
; 255  : 		case ARG_MAXWIN:
; 256  : 			maxwin = get_maxwin( argstore[storearg_pos].name );

  0020b	39 35 00 00 00
	00		 cmp	 DWORD PTR ?strings@?1??get_maxwin@@9@9, esi
  00211	74 2c		 je	 SHORT $LN56@parse_args
  00213	8b 7c 0c 18	 mov	 edi, DWORD PTR _argstore$[esp+ecx+160]
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?strings@?1??get_maxwin@@9@9
$LL57@parse_args:
  0021d	8b c7		 mov	 eax, edi
  0021f	e8 00 00 00 00	 call	 _cmp_str_nocase
  00224	85 c0		 test	 eax, eax
  00226	74 10		 je	 SHORT $LN70@parse_args
  00228	8b 0c b5 04 00
	00 00		 mov	 ecx, DWORD PTR ?strings@?1??get_maxwin@@9@9[esi*4+4]
  0022f	46		 inc	 esi
  00230	85 c9		 test	 ecx, ecx
  00232	75 e9		 jne	 SHORT $LL57@parse_args

; 166  : 			break;
; 167  : 
; 168  : 		case ARG_GREEDY:
; 169  : 			if( wrk.mode ) // since sorted, argument list causes parsing go from up to down in this "case" list

  00234	33 f6		 xor	 esi, esi
  00236	eb 07		 jmp	 SHORT $LN56@parse_args
$LN70@parse_args:

; 254  : 
; 255  : 		case ARG_MAXWIN:
; 256  : 			maxwin = get_maxwin( argstore[storearg_pos].name );

  00238	8b 34 b5 00 00
	00 00		 mov	 esi, DWORD PTR ?sizes@?1??get_maxwin@@9@9[esi*4]
$LN56@parse_args:

; 257  : 			if( !maxwin ) // there shouldn't be this case, but nevertheless...

  0023f	85 f6		 test	 esi, esi
  00241	0f 84 a4 01 00
	00		 je	 $LN72@parse_args

; 261  : 			}
; 262  : 
; 263  :                         // wrk.maxwin is already initialized to the maximum value suitable for given packing type, so check new setting
; 264  : 			if( maxwin > wrk.maxwin )

  00247	3b 35 1c 00 00
	00		 cmp	 esi, DWORD PTR _wrk+28
  0024d	0f 87 a2 01 00
	00		 ja	 $LN73@parse_args

; 268  : 			}
; 269  : 			wrk.maxwin = maxwin;

  00253	89 35 1c 00 00
	00		 mov	 DWORD PTR _wrk+28, esi

; 270  : 			break;

  00259	33 f6		 xor	 esi, esi
  0025b	e9 53 01 00 00	 jmp	 $LN25@parse_args
$LN6@parse_args:

; 244  : 
; 245  : 		case ARG_BIGEND:
; 246  : 			// whether word-grouped bits must be big- or little-endian arranged
; 247  : 			if( wrk.zxheader )

  00260	39 35 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, esi
  00266	0f 85 93 01 00
	00		 jne	 $LN74@parse_args

; 251  : 			}
; 252  : 			wrk.bigend = 1;

  0026c	89 1d 14 00 00
	00		 mov	 DWORD PTR _wrk+20, ebx

; 253  : 			break;

  00272	e9 3c 01 00 00	 jmp	 $LN25@parse_args
$LN12@parse_args:

; 222  : 
; 223  : 		case ARG_WORD:
; 224  : 			// whether bits must be grouped in words or in bytes
; 225  : 			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_8 ) )

  00277	8b 7c 0c 18	 mov	 edi, DWORD PTR _argstore$[esp+ecx+160]
  0027b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01KJLJFBPL@8?$AA@
  00280	8b cf		 mov	 ecx, edi
  00282	e8 00 00 00 00	 call	 _cmp_str_nocase
  00287	85 c0		 test	 eax, eax
  00289	75 17		 jne	 SHORT $LN11@parse_args

; 226  : 			{
; 227  : 				if( wrk.zxheader ) // won't force byte-wise bits when there is a zx-header

  0028b	39 35 0c 00 00
	00		 cmp	 DWORD PTR _wrk+12, esi
  00291	0f 85 72 01 00
	00		 jne	 $LN75@parse_args

; 231  : 				}
; 232  : 				wrk.wordbit = 0;

  00297	89 35 10 00 00
	00		 mov	 DWORD PTR _wrk+16, esi
  0029d	e9 11 01 00 00	 jmp	 $LN25@parse_args
$LN11@parse_args:

; 233  : 			}
; 234  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_16 ) )

  002a2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02KMALDIDP@16?$AA@
  002a7	8b cf		 mov	 ecx, edi
  002a9	e8 00 00 00 00	 call	 _cmp_str_nocase
  002ae	85 c0		 test	 eax, eax
  002b0	0f 85 5d 01 00
	00		 jne	 $LN8@parse_args

; 235  : 			{
; 236  : 				wrk.wordbit = 1;

  002b6	89 1d 10 00 00
	00		 mov	 DWORD PTR _wrk+16, ebx

; 242  : 			}
; 243  : 			break;

  002bc	e9 f2 00 00 00	 jmp	 $LN25@parse_args
$LN14@parse_args:

; 211  : 
; 212  : 		case ARG_ZXHEAD:
; 213  : 			// ZX-header is not applicable for PK_MLZ type...
; 214  : 			// also wrk.packtype has been already set before...
; 215  : 			if( PK_MLZ==wrk.packtype )

  002c1	39 1d 00 00 00
	00		 cmp	 DWORD PTR _wrk, ebx
  002c7	0f 84 50 01 00
	00		 je	 $LN76@parse_args

; 219  : 			}
; 220  : 			wrk.zxheader = 1;

  002cd	89 1d 0c 00 00
	00		 mov	 DWORD PTR _wrk+12, ebx

; 221  : 			break;

  002d3	e9 db 00 00 00	 jmp	 $LN25@parse_args
$LN21@parse_args:

; 176  : 
; 177  : 		case ARG_PTYPE:
; 178  : 			if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_MEGALZ ) )

  002d8	8b 7c 0c 18	 mov	 edi, DWORD PTR _argstore$[esp+ecx+160]
  002dc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03IDOKKMAF@mlz?$AA@
  002e1	8b cf		 mov	 ecx, edi
  002e3	e8 00 00 00 00	 call	 _cmp_str_nocase
  002e8	85 c0		 test	 eax, eax
  002ea	75 2d		 jne	 SHORT $LN20@parse_args

; 179  : 			{
; 180  : 				wrk.packtype = PK_MLZ;

  002ec	89 1d 00 00 00
	00		 mov	 DWORD PTR _wrk, ebx

; 181  : 				wrk.zxheader = 0;

  002f2	89 35 0c 00 00
	00		 mov	 DWORD PTR _wrk+12, esi

; 182  : 				wrk.wordbit  = 0;

  002f8	89 35 10 00 00
	00		 mov	 DWORD PTR _wrk+16, esi

; 183  : 				wrk.bigend   = 0;

  002fe	89 35 14 00 00
	00		 mov	 DWORD PTR _wrk+20, esi

; 184  : 				wrk.fullbits = 0;

  00304	89 35 18 00 00
	00		 mov	 DWORD PTR _wrk+24, esi

; 185  : 				wrk.maxwin   = 4352;

  0030a	c7 05 1c 00 00
	00 00 11 00 00	 mov	 DWORD PTR _wrk+28, 4352	; 00001100H
  00314	e9 9a 00 00 00	 jmp	 $LN25@parse_args
$LN20@parse_args:

; 186  : 			}
; 187  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUM ) )

  00319	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03KHAPFGNL@hrm?$AA@
  0031e	8b cf		 mov	 ecx, edi
  00320	e8 00 00 00 00	 call	 _cmp_str_nocase
  00325	85 c0		 test	 eax, eax
  00327	75 2e		 jne	 SHORT $LN18@parse_args

; 188  : 			{
; 189  : 				wrk.packtype = PK_HRM;

  00329	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _wrk, 2

; 190  : 				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified

  00333	89 35 0c 00 00
	00		 mov	 DWORD PTR _wrk+12, esi

; 191  : 				wrk.wordbit  = 1;

  00339	89 1d 10 00 00
	00		 mov	 DWORD PTR _wrk+16, ebx

; 192  : 				wrk.bigend   = 0;

  0033f	89 35 14 00 00
	00		 mov	 DWORD PTR _wrk+20, esi

; 193  : 				wrk.fullbits = 1;

  00345	89 1d 18 00 00
	00		 mov	 DWORD PTR _wrk+24, ebx

; 194  : 				wrk.maxwin   = 4096;

  0034b	c7 05 1c 00 00
	00 00 10 00 00	 mov	 DWORD PTR _wrk+28, 4096	; 00001000H
  00355	eb 5c		 jmp	 SHORT $LN25@parse_args
$LN18@parse_args:

; 195  : 			}
; 196  : 			else if( !cmp_str_nocase( argstore[storearg_pos].name, ARGSTR_HRUST ) )

  00357	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03DNMNJFPE@hst?$AA@
  0035c	8b cf		 mov	 ecx, edi
  0035e	e8 00 00 00 00	 call	 _cmp_str_nocase
  00363	85 c0		 test	 eax, eax
  00365	0f 85 bc 00 00
	00		 jne	 $LN16@parse_args

; 197  : 			{
; 198  : 				wrk.packtype = PK_HST;

  0036b	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _wrk, 3

; 199  : 				wrk.zxheader = 0; // by default, there is NO ZX-HEADER if only -hrm or -hst specified

  00375	89 35 0c 00 00
	00		 mov	 DWORD PTR _wrk+12, esi

; 200  : 				wrk.wordbit  = 1;

  0037b	89 1d 10 00 00
	00		 mov	 DWORD PTR _wrk+16, ebx

; 201  : 				wrk.bigend   = 0;

  00381	89 35 14 00 00
	00		 mov	 DWORD PTR _wrk+20, esi

; 202  : 				wrk.fullbits = 1;

  00387	89 1d 18 00 00
	00		 mov	 DWORD PTR _wrk+24, ebx

; 203  : 				wrk.maxwin   = 65536;

  0038d	c7 05 1c 00 00
	00 00 00 01 00	 mov	 DWORD PTR _wrk+28, 65536 ; 00010000H

; 209  : 			}
; 210  : 			break;

  00397	eb 1a		 jmp	 SHORT $LN25@parse_args
$LN23@parse_args:

; 166  : 			break;
; 167  : 
; 168  : 		case ARG_GREEDY:
; 169  : 			if( wrk.mode ) // since sorted, argument list causes parsing go from up to down in this "case" list

  00399	39 35 08 00 00
	00		 cmp	 DWORD PTR _wrk+8, esi
  0039f	0f 85 8c 00 00
	00		 jne	 $LN77@parse_args

; 173  : 			}
; 174  : 			wrk.greedy = 1; // set greedy packing mode

  003a5	89 1d 04 00 00
	00		 mov	 DWORD PTR _wrk+4, ebx

; 175  : 			break;

  003ab	eb 06		 jmp	 SHORT $LN25@parse_args
$LN24@parse_args:

; 163  : 		{
; 164  : 		case ARG_MODE:
; 165  : 			wrk.mode = 1; // set depack mode

  003ad	89 1d 08 00 00
	00		 mov	 DWORD PTR _wrk+8, ebx
$LN25@parse_args:

; 276  : 			break;
; 277  : 		}
; 278  : 
; 279  : 
; 280  : 		last_arg_type = argstore[storearg_pos++].type;

  003b3	ff 44 24 10	 inc	 DWORD PTR _storearg_pos$[esp+160]
  003b7	8b 4c 24 10	 mov	 ecx, DWORD PTR _storearg_pos$[esp+160]
  003bb	8b 54 24 14	 mov	 edx, DWORD PTR tv438[esp+160]
  003bf	c1 e1 03	 shl	 ecx, 3
  003c2	8d 44 0c 1c	 lea	 eax, DWORD PTR _argstore$[esp+ecx+164]
  003c6	81 38 ff 00 00
	00		 cmp	 DWORD PTR [eax], 255	; 000000ffH
  003cc	0f 85 02 fe ff
	ff		 jne	 $LL29@parse_args
$LN28@parse_args:

; 281  : 	}
; 282  : 
; 283  : 
; 284  : 	return ARG_PARSER_GO;

  003d2	6a 02		 push	 2
  003d4	58		 pop	 eax
  003d5	eb 67		 jmp	 SHORT $LN48@parse_args
$LN71@parse_args:

; 157  : 		{
; 158  : 			printf("Redundant arguments!\n");

  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NPNKMNAK@Redundant?5arguments?$CB?6?$AA@

; 159  : 			return ARG_PARSER_ERROR|ARG_PARSER_SHOWHELP;

  003dc	e9 71 fd ff ff	 jmp	 $LN91@parse_args
$LN1@parse_args:

; 271  : 
; 272  : 		default:
; 273  : 			// once again impossible error: we shouldn't be here since "while" loop condition...
; 274  : 			printf("Impossible error #4! Press any key to continue or \"SPACE\" to exit... :-)\n");

  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@HMDMCFKA@Impossible?5error?5?$CD4?$CB?5Press?5any?5k@

; 275  : 			return ARG_PARSER_ERROR;

  003e6	e9 b0 fd ff ff	 jmp	 $LN92@parse_args
$LN72@parse_args:

; 258  : 			{
; 259  : 				printf("Impossible error #3! Press any key to continue or \"SPACE\" to exit... :-)\n");

  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@CMNHFOIF@Impossible?5error?5?$CD3?$CB?5Press?5any?5k@

; 260  : 				return ARG_PARSER_ERROR;

  003f0	e9 a6 fd ff ff	 jmp	 $LN92@parse_args
$LN73@parse_args:

; 265  : 			{
; 266  : 				printf("Maximum window specified is too big for given packing type!\n");

  003f5	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MHMOIMDE@Maximum?5window?5specified?5is?5too?5@

; 267  : 				return ARG_PARSER_ERROR;

  003fa	e9 9c fd ff ff	 jmp	 $LN92@parse_args
$LN74@parse_args:

; 248  : 			{
; 249  : 				printf("There can be only little-endian arrangement of bits when ZX-header is active!\n");

  003ff	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@BNJBLHKO@There?5can?5be?5only?5little?9endian?5@

; 250  : 				return ARG_PARSER_ERROR;

  00404	e9 92 fd ff ff	 jmp	 $LN92@parse_args
$LN75@parse_args:

; 228  : 				{
; 229  : 					printf("There can be only 16bit grouping of bits when ZX-header is active!\n");

  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MBNKLAMC@There?5can?5be?5only?516bit?5grouping@

; 230  : 					return ARG_PARSER_ERROR;

  0040e	e9 88 fd ff ff	 jmp	 $LN92@parse_args
$LN8@parse_args:

; 237  : 			}
; 238  : 			else // there shouldn't be this case, but nevertheless...
; 239  : 			{
; 240  : 				printf("Impossible error #2! Press any key to continue or \"SPACE\" to exit... :-)\n");

  00413	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@DBECENFC@Impossible?5error?5?$CD2?$CB?5Press?5any?5k@

; 241  : 				return ARG_PARSER_ERROR;

  00418	e9 7e fd ff ff	 jmp	 $LN92@parse_args
$LN76@parse_args:

; 216  : 			{
; 217  : 				printf("There couldn't be zx-header in megalz mode!\n");

  0041d	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@KBGDMFLH@There?5couldn?8t?5be?5zx?9header?5in?5m@

; 218  : 				return ARG_PARSER_ERROR;

  00422	e9 74 fd ff ff	 jmp	 $LN92@parse_args
$LN16@parse_args:

; 204  : 			}
; 205  : 			else // there shouldn't be this case, but nevertheless...
; 206  : 			{
; 207  : 				printf("Impossible error #1! Press any key to continue or \"SPACE\" to exit... :-)\n");

  00427	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BHPNHJCL@Impossible?5error?5?$CD1?$CB?5Press?5any?5k@

; 208  : 				return ARG_PARSER_ERROR;

  0042c	e9 6a fd ff ff	 jmp	 $LN92@parse_args
$LN77@parse_args:

; 170  : 			{
; 171  : 				printf("No greedy mode specification for DEpacking!\n");

  00431	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GOBMBPGD@No?5greedy?5mode?5specification?5for@

; 172  : 				return ARG_PARSER_ERROR;

  00436	e9 60 fd ff ff	 jmp	 $LN92@parse_args
$LN42@parse_args:

; 81   : 		return ARG_PARSER_SHOWHELP;

  0043b	33 c0		 xor	 eax, eax
  0043d	40		 inc	 eax
$LN48@parse_args:

; 285  : }

  0043e	5f		 pop	 edi
  0043f	5e		 pop	 esi
  00440	5b		 pop	 ebx
  00441	8b e5		 mov	 esp, ebp
  00443	5d		 pop	 ebp
  00444	c3		 ret	 0
_parse_args ENDP
END
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\d\mhmt\src\mhmt-tb.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

COMM	_tb_entry:DWORD:010000H
COMM	_tb_free:DWORD
COMM	_tb_bunches:DWORD
PUBLIC	_get_free_tb
; Function compile flags: /Ogspy
; File d:\d\mhmt\src\mhmt-tb.c
;	COMDAT _get_free_tb
_TEXT	SEGMENT
_get_free_tb PROC					; COMDAT

; 171  : 	struct tb_chain * newtb;
; 172  : 
; 173  : 	if( tb_free )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _tb_free
  00005	85 c0		 test	 eax, eax
  00007	74 0a		 je	 SHORT $LN2@get_free_t

; 174  : 	{
; 175  : 		newtb=tb_free;
; 176  : 		tb_free=tb_free->next;

  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	89 0d 00 00 00
	00		 mov	 DWORD PTR _tb_free, ecx

; 183  : 	}
; 184  : }

  00012	c3		 ret	 0
$LN2@get_free_t:

; 177  : 
; 178  : 		return newtb;
; 179  : 	}
; 180  : 	else
; 181  : 	{
; 182  : 		return NULL;

  00013	33 c0		 xor	 eax, eax

; 183  : 	}
; 184  : }

  00015	c3		 ret	 0
_get_free_tb ENDP
_TEXT	ENDS
PUBLIC	_add_bunch_of_tb
; Function compile flags: /Ogspy
;	COMDAT _add_bunch_of_tb
_TEXT	SEGMENT
_add_bunch_of_tb PROC					; COMDAT

; 143  : 	ULONG i;
; 144  : 	struct tb_bunch * newbunch;
; 145  : 
; 146  : 	// alloc new bunch
; 147  : 	newbunch=(struct tb_bunch *)malloc( sizeof(struct tb_bunch) );

  00000	68 04 80 00 00	 push	 32772			; 00008004H
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000b	59		 pop	 ecx

; 148  : 	if( !newbunch ) return 0;

  0000c	85 c0		 test	 eax, eax
  0000e	75 01		 jne	 SHORT $LN4@add_bunch_

; 165  : }

  00010	c3		 ret	 0
$LN4@add_bunch_:

; 149  : 
; 150  : 	// link every twobyter into one list
; 151  : 	for(i=0;i<(BUNCHSIZE-1);i++)

  00011	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00014	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00019	56		 push	 esi
$LL3@add_bunch_:

; 152  : 	{
; 153  : 		newbunch->bunch[i].next=&(newbunch->bunch[i+1]);

  0001a	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0001d	89 31		 mov	 DWORD PTR [ecx], esi
  0001f	83 c1 08	 add	 ecx, 8
  00022	4a		 dec	 edx
  00023	75 f5		 jne	 SHORT $LL3@add_bunch_

; 154  : 	}
; 155  : 
; 156  : 	// add this list to the free list
; 157  : 	newbunch->bunch[BUNCHSIZE-1].next=tb_free;

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_free
  0002b	89 88 00 80 00
	00		 mov	 DWORD PTR [eax+32768], ecx

; 158  : 	tb_free=&(newbunch->bunch[0]);

  00031	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00034	89 0d 00 00 00
	00		 mov	 DWORD PTR _tb_free, ecx

; 159  : 
; 160  : 	// add bunch to bunches list
; 161  : 	newbunch->next=tb_bunches;

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_bunches
  00040	89 08		 mov	 DWORD PTR [eax], ecx

; 162  : 	tb_bunches=newbunch;

  00042	a3 00 00 00 00	 mov	 DWORD PTR _tb_bunches, eax

; 163  : 
; 164  : 	return 1;

  00047	33 c0		 xor	 eax, eax
  00049	40		 inc	 eax
  0004a	5e		 pop	 esi

; 165  : }

  0004b	c3		 ret	 0
_add_bunch_of_tb ENDP
_TEXT	ENDS
PUBLIC	_cutoff_tb_chain
; Function compile flags: /Ogspy
;	COMDAT _cutoff_tb_chain
_TEXT	SEGMENT
_cutoff_tb_chain PROC					; COMDAT
; _index$ = ecx
; _position$ = eax

; 90   : 	struct tb_chain * curr, * prev;
; 91   : 
; 92   : 
; 93   : 	curr=tb_entry[index];

  00000	0f b7 c9	 movzx	 ecx, cx
  00003	57		 push	 edi
  00004	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR _tb_entry[ecx*4]
  0000b	8b f8		 mov	 edi, eax
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 	if( !curr ) return; // if nothing to remove

  0000f	85 c0		 test	 eax, eax
  00011	74 5d		 je	 SHORT $LN1@cutoff_tb_

; 95   : 
; 96   : 
; 97   : 	// see if we should delete some elements after first element in the given chain
; 98   : 	prev=curr;

  00013	8b d0		 mov	 edx, eax

; 99   : 	curr=curr->next;

  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	56		 push	 esi

; 100  : 
; 101  : 	while( curr )

  00019	8b 35 1c 00 00
	00		 mov	 esi, DWORD PTR _wrk+28
  0001f	85 c0		 test	 eax, eax
  00021	74 33		 je	 SHORT $LN14@cutoff_tb_
  00023	53		 push	 ebx
$LL7@cutoff_tb_:

; 102  : 	{
; 103  : 		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it

  00024	8b df		 mov	 ebx, edi
  00026	2b 18		 sub	 ebx, DWORD PTR [eax]
  00028	3b de		 cmp	 ebx, esi
  0002a	77 0e		 ja	 SHORT $LN16@cutoff_tb_

; 117  : 
; 118  : 			break;
; 119  : 		}
; 120  : 		else
; 121  : 		{
; 122  : 			prev=curr;

  0002c	8b d0		 mov	 edx, eax

; 123  : 			curr=curr->next;

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	85 c0		 test	 eax, eax
  00033	75 ef		 jne	 SHORT $LL7@cutoff_tb_

; 102  : 	{
; 103  : 		if( (position-(curr->pos)) > wrk.maxwin ) // found some old element: delete rest of chain along with it

  00035	eb 1e		 jmp	 SHORT $LN15@cutoff_tb_
$LL4@cutoff_tb_:

; 107  : 			{
; 108  : 				curr = curr->next;

  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN16@cutoff_tb_:

; 104  : 		{
; 105  : 			// find end of chain
; 106  : 			while( curr->next )

  0003a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003e	75 f7		 jne	 SHORT $LL4@cutoff_tb_

; 109  : 			}
; 110  : 
; 111  : 			// now curr - last chain element, prev->next - beginning of orphaned chain
; 112  : 			// add orphaned chain to free list
; 113  : 			curr->next = tb_free;

  00040	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _tb_free
  00046	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 114  : 			tb_free = prev->next;

  00049	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 115  : 
; 116  : 			prev->next = NULL; // cut off chain

  0004c	83 62 04 00	 and	 DWORD PTR [edx+4], 0
  00050	a3 00 00 00 00	 mov	 DWORD PTR _tb_free, eax
$LN15@cutoff_tb_:
  00055	5b		 pop	 ebx
$LN14@cutoff_tb_:

; 124  : 		}
; 125  : 	}
; 126  : 
; 127  : 	// delete first (entry) element in chain if needed (in this case, all subsequent els are already deleted)
; 128  : 	curr=tb_entry[index];

  00056	8b 01		 mov	 eax, DWORD PTR [ecx]

; 129  : 	if( (position-(curr->pos)) > wrk.maxwin )

  00058	2b 38		 sub	 edi, DWORD PTR [eax]
  0005a	3b fe		 cmp	 edi, esi
  0005c	5e		 pop	 esi
  0005d	76 11		 jbe	 SHORT $LN1@cutoff_tb_

; 130  : 	{
; 131  : 		tb_entry[index] = NULL;

  0005f	83 21 00	 and	 DWORD PTR [ecx], 0

; 132  : 
; 133  : 		curr->next=tb_free; // element goes to free list

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tb_free
  00068	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 134  : 		tb_free=curr;

  0006b	a3 00 00 00 00	 mov	 DWORD PTR _tb_free, eax
$LN1@cutoff_tb_:
  00070	5f		 pop	 edi

; 135  : 	}
; 136  : }

  00071	c3		 ret	 0
_cutoff_tb_chain ENDP
_TEXT	ENDS
PUBLIC	_add_tb
; Function compile flags: /Ogspy
;	COMDAT _add_tb
_TEXT	SEGMENT
_index$ = 8						; size = 2
_add_tb	PROC						; COMDAT
; _position$ = eax

; 51   : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 52   : 	struct tb_chain * newtb;
; 53   : 
; 54   : 	newtb=get_free_tb();

  00003	e8 00 00 00 00	 call	 _get_free_tb

; 55   : 	if( !newtb )

  00008	85 c0		 test	 eax, eax
  0000a	75 2c		 jne	 SHORT $LN2@add_tb

; 56   : 	{ // no free elements
; 57   : 
; 58   : 		if( position > wrk.maxwin ) // if there could be enough tbs to try to flush

  0000c	3b 35 1c 00 00
	00		 cmp	 esi, DWORD PTR _wrk+28
  00012	76 0b		 jbe	 SHORT $LN3@add_tb

; 59   : 		{
; 60   : 			// try to flush current chain
; 61   : 			cutoff_tb_chain(index,position);

  00014	8b 4c 24 08	 mov	 ecx, DWORD PTR _index$[esp]
  00018	8b c6		 mov	 eax, esi
  0001a	e8 00 00 00 00	 call	 _cutoff_tb_chain
$LN3@add_tb:

; 62   : 		}
; 63   : 
; 64   : 		newtb=get_free_tb();

  0001f	e8 00 00 00 00	 call	 _get_free_tb

; 65   : 		if( !newtb )

  00024	85 c0		 test	 eax, eax
  00026	75 10		 jne	 SHORT $LN2@add_tb

; 66   : 		{ // nothing free - allocate new bunch
; 67   : 			if( !add_bunch_of_tb() )

  00028	e8 00 00 00 00	 call	 _add_bunch_of_tb
  0002d	85 c0		 test	 eax, eax
  0002f	75 02		 jne	 SHORT $LN1@add_tb
  00031	5e		 pop	 esi

; 84   : }

  00032	c3		 ret	 0
$LN1@add_tb:

; 68   : 			{
; 69   : 				return 0;
; 70   : 			}
; 71   : 
; 72   : 			newtb=get_free_tb(); // here is no chance to fail!... hopefully...

  00033	e8 00 00 00 00	 call	 _get_free_tb
$LN2@add_tb:

; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : 
; 77   : 
; 78   : 	newtb->pos=position-1; // points to the first byte of given two bytes
; 79   : 	newtb->next=tb_entry[index];

  00038	0f b7 4c 24 08	 movzx	 ecx, WORD PTR _index$[esp]
  0003d	4e		 dec	 esi
  0003e	89 30		 mov	 DWORD PTR [eax], esi
  00040	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR _tb_entry[ecx*4]
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 80   : 	tb_entry[index]=newtb;

  0004c	89 01		 mov	 DWORD PTR [ecx], eax

; 81   : 
; 82   : 
; 83   : 	return 1;

  0004e	33 c0		 xor	 eax, eax
  00050	40		 inc	 eax
  00051	5e		 pop	 esi

; 84   : }

  00052	c3		 ret	 0
_add_tb	ENDP
_TEXT	ENDS
PUBLIC	_init_tb
; Function compile flags: /Ogspy
;	COMDAT _init_tb
_TEXT	SEGMENT
_init_tb PROC						; COMDAT

; 20   : 	ULONG i;
; 21   : 
; 22   : 	tb_free=NULL;    // init linked list of free tb_chain elements

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR _tb_free, 0

; 23   : 	tb_bunches=NULL; // no bunches already allocated

  00007	83 25 00 00 00
	00 00		 and	 DWORD PTR _tb_bunches, 0
  0000e	57		 push	 edi

; 24   : 
; 25   : 	for(i=0;i<65536;i++) // init array of 2-byte match pointers
; 26   : 	{
; 27   : 		tb_entry[i]=NULL;

  0000f	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00014	33 c0		 xor	 eax, eax
  00016	bf 00 00 00 00	 mov	 edi, OFFSET _tb_entry
  0001b	f3 ab		 rep stosd
  0001d	5f		 pop	 edi

; 28   : 	}
; 29   : }

  0001e	c3		 ret	 0
_init_tb ENDP
END
